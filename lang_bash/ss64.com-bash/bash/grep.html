<!doctype html><html>
<head><meta charset="UTF-8">
<link rel="STYLESHEET" href="../main.css" type="text/css">
<title>grep Man Page | Bash | SS64.com</title>
</head><!-- #BeginLibraryItem "/Library/head_bash.lbi" --><div id="tnav"><ul>
<li class="tbtn"><a href="http://ss64.com/"> ( &nbsp;SS64 &nbsp;)</a></li>
<li class="tbtn"><a href="http://ss64.com/bash">Bash</a></li>
<li class="tbtn"><a href="syntax.html">Syntax</a></li>
<li><div id="search"><form action="http://www.google.com/search" method="get">
<button tabindex="-1" type="submit" id="q-img"></button>
<input type="text" name="q" id="q" size="27" maxlength="255" onblur="if(this.value=='')this.value='Search…';" onclick="if(this.value=='Search…')this.value='';" value="Search…">
<input type="hidden" name="sitesearch" value="ss64.com/bash/"></form></div></li>
</ul></div><!-- #EndLibraryItem --><h1>grep</h1> 
<p>Search file(s) for specific text. </p>
<pre>Syntax
      grep [<i>options</i>] <i>PATTERN</i> [<i>FILE</i>...]
<br>      grep [<i>options</i>] [-e <i>PATTERN</i> | -f <i>FILE</i>] [<i>FILE</i>...]

A simple example:
$ grep "Needle in a Haystack" /etc/*

Options
   -A <i>NUM</i>
   --after-context=<i>NUM</i>
       Print <i>NUM</i> lines of trailing context after matching lines.
       Places a line containing -- between contiguous groups of matches. 
   -a
   --text
       Process a binary file as if it were text; this is equivalent
       to the --binary-files=text option.

   -B <i>NUM
  </i> --before-context=<i>NUM</i>
       Print <i>NUM</i> lines of leading context before matching lines.
       Places a line containing -- between contiguous groups of matches.

   -C NUM
   --context=<i>NUM</i>
       Print NUM lines of output context.
       Places a line containing -- between contiguous groups of matches. 
   -b
   --byte-offset
       Print the byte offset within the input file before each line of output. 
   --binary-files=<i>TYPE</i>
       If the first few bytes of a file indicate that the file contains binary data, assume 
       that the file is of type <i>TYPE</i>. By default, <i>TYPE</i> is binary, and grep normally outputs
       either a one-line message saying that a binary file matches, or no message if there
       is no match. If <i>TYPE</i> is without-match, grep assumes that a binary file does not match;
       this is equivalent to the -I option. If <i>TYPE</i> is text, grep processes a binary file as
       if it were text; this is equivalent to the -a option.
       Warning: grep --binary-files=text might output binary garbage, which can have nasty
       side effects if the output is a terminal and if the terminal driver interprets some
       of it as commands. 
   --colour[=<i>WHEN</i>]
   --color[=<i>WHEN</i>]
       Surround the matching string with the marker find in GREP_COLOR environment variable.
       WHEN may be 'never', 'always', or 'auto' 
   -c
   --count
       Suppress normal output; instead print a count of matching lines for each input file.
       With the -v, --invert-match option (see below), count non-matching lines.

   -D <i>ACTION</i>
   --devices=<i>ACTION</i>
       If an input file is a device, FIFO or socket, use <i>ACTION</i> to process it.
       By default, <i>ACTION</i> is read, which means that devices are read just as if they were
       ordinary files. If <i>ACTION</i> is skip, devices are silently skipped. 
   -d <i>ACTION</i>
   --directories=<i>ACTION</i>
       If an input file is a directory, use <i>ACTION</i> to process it.
       By default, <i>ACTION</i> is read, which means that directories are read just as if they
       were ordinary files. If <i>ACTION</i> is skip, directories are silently skipped.
       If <i>ACTION</i> is recurse, grep reads all files under each directory, recursively; this
       is equivalent to the -r option.

   -E
   --extended-regexp
       Interpret <i>PATTERN</i> as an <a href="grep-regex.html">extended regular expression</a>. 
   -e <i>PATTERN</i>
   --regexp=<i>PATTERN</i>
       Use <i>PATTERN</i> as the pattern; useful to protect patterns beginning with -.

   -F
   --fixed-strings
       Interpret <i>PATTERN</i> as a list of fixed strings, separated by newlines,
       any of which is to be matched.

   -P
   --perl-regexp
       Interpret <i>PATTERN</i> as a Perl regular expression.

   -f <i>FILE</i>
   --file=<i>FILE</i>
       Obtain patterns from <i>FILE</i>, one per line. The empty file contains zero
       patterns, and therefore matches nothing.

   -G
   --basic-regexp
       Interpret <i>PATTERN</i> as a <a href="grep-regex.html">basic regular expression</a> This is the default.
 
   -H
   --with-filename
       Print the filename for each match. 
   -h
   --no-filename
       Suppress the prefixing of filenames on output when multiple files are searched. 
   --help
      Output a brief help message.

   -I
      Process a binary file as if it did not contain matching data; this is
      equivalent to the --binary-files=without-match option.
   -i
   --ignore-case
      Ignore case distinctions in both the <i>PATTERN</i> and the input files.

   -L
   --files-without-match
      Suppress normal output; instead print the name of each input file from which
      no output would normally have been printed. The scanning will stop on the first match. 
   -l
   --files-with-matches
      Suppress normal output; instead print the name of each input file from which
      output would normally have been printed. The scanning will stop on the first match.

   -m <i>NUM</i>
   --max-count=<i>NUM</i>
      Stop reading a file after NUM matching lines.
      If the input is standard input from a regular file, and NUM matching lines are
      output, grep ensures that the standard input is positioned to just after the last
      matching line before exiting, regardless of the presence of trailing context lines.
      This enables a calling process to resume a search. When grep stops after <i>NUM</i> matching
      lines, it outputs any trailing context lines.
      When the -c or --count option is also used, grep does not output a count greater
      than <i>NUM</i>. When the -v or --invert-match option is also used, grep stops after
      outputting <i>NUM</i> non-matching lines. 
   --mmap
      If possible, use the mmap(2) system call to read input, instead of the default
      read(2) system call. In some situations, --mmap yields better performance.
      However, --mmap can cause undefined behavior (including core dumps) if an input
      file shrinks while grep is operating, or if an I/O error occurs.

   -n
   --line-number
      Prefix each line of output with the line number within its input file. 

   -o
   --only-matching
       Show only the part of a matching line that matches <i>PATTERN</i>.

   --label=<i>LABEL</i>
       Display input actually coming from standard input as input coming from file <i>LABEL</i>.
       This is especially useful for tools like zgrep, e.g. gzip -cd foo.gz |grep --label=foo something 
   --line-buffered
       Use line buffering, it can be a performance penality.

   -q
   --quiet, --silent
       Quiet; do not write anything to standard output.
       Exit immediately with zero status if any match is found, even if an error
       was detected. Also see the -s or --no-messages option.

   -R
   -r
   --recursive
       Read all files under each directory, recursively; this is equivalent to the -d recurse option. 
   --include=<i>PATTERN</i>
       Recurse in directories only searching file matching <i>PATTERN</i>. 
   --exclude=<i>PATTERN</i>
       Recurse in directories skip file matching <i>PATTERN</i>.
 
   -s
   --no-messages
       Suppress error messages about nonexistent or unreadable files.
       Portability note: unlike GNU grep, traditional grep did not conform to POSIX.2 ,
       because traditional grep lacked a -q option and its -s option behaved like
       GNU grep's -q option. Shell scripts intended to be portable to traditional grep
       should avoid both -q and -s and should redirect output to /dev/null instead.

   -U, --binary
       Treat the file(s) as binary. 
       By default, under MS-DOS and MS-Windows, grep guesses the file type by looking at
       the contents of the first 32KB read from the file. If grep decides the file is a
       text file, it strips the CR characters from the original file contents
       (to make regular expressions with ^ and $ work correctly).
       Specifying -U overrules this guesswork, causing all files to be read and passed
       to the matching mechanism verbatim; if the file is a text file with CR/LF pairs
       at the end of each line, this will cause some regular expressions to fail.
       This option has no effect on platforms other than MS-DOS and MS-Windows.
 
   -u
   --unix-byte-offsets
       Report Unix-style byte offsets.
       This switch causes grep to report byte offsets as if the file were a Unix-style text
       file, i.e. with CR characters stripped off. This will produce results identical to
       running grep on a Unix machine.
       This option has no effect unless -b option is also used; it has no effect on
       platforms other than MS-DOS and MS-Windows.

   -V
   --version
       Print the version number of grep to standard error.
       This version number should be included in all bug reports (see below). 
   -v
   --invert-match
       Invert the sense of matching, to select non-matching lines. 
   -w
   --word-regexp
       Select only those lines containing matches that form whole words.
       The test is that the matching substring must either be at the beginning of
       the line, or preceded by a non-word constituent character. Similarly, it
       must be either at the end of the line or followed by a non-word constituent
       character. Word-constituent characters are letters, digits, and the underscore.

   -x
   --line-regexp
       Select only those matches that exactly match the whole line. 
   -y
       Obsolete synonym for -i.
   -Z
   --null
       Output a zero byte (the ASCII NUL character) instead of the character that
       normally follows a file name. For example, grep -lZ outputs a zero byte after
       each file name instead of the usual newline.
       This option makes the output unambiguous, even in the presence of file names
       containing unusual characters like newlines.
       This option can be used with commands like find -print0, perl -0, sort -z, and
       xargs -0 to process arbitrary file names, even those that contain newline characters. 

<b>Environment variables</b>

Grep's behavior can be affected by setting the following environment variables

GREP_OPTIONS                 - default options
GREP_COLOR                   - The marker for highlighting
LC_ALL, LC_COLLATE, LANG<br>    These variables specify the LC_COLLATE locale, which determines the collating
    sequence used to interpret range expressions like [a-z]. <br>LC_ALL, LC_CTYPE, LANG<br>    These variables specify the LC_CTYPE locale, which determines the type of
    characters, e.g., which characters are whitespace. <br>LC_ALL, LC_MESSAGES, LANG<br>    These variables specify the LC_MESSAGES locale, which determines the
    language that grep uses for messages. The default C locale uses American English messages. <br>POSIXLY_CORRECT<br>    If set, grep behaves as POSIX.2 requires; otherwise, grep behaves more like other GNU programs.
_<i>N</i>_GNU_nonoption_argv_flags_
   If the ith character of this environment variable's value is 1, do not consider
   the ith operand of grep to be an option, ( <i>N</i> is grep's numeric process ID)

see `info' for more on these
</pre>
<p><span class="body">Grep stands for:  Global Regular Expression Print.</span></p>
<p>  <b>Diagnostics</b><br>
    <br>
  Normally, exit status is 0 if matches were found, and 1 if no matches
  were found (the `-v' option inverts the sense of the exit status).<br> Exit status is 2 if there were syntax errors in the pattern,
inaccessible input files, or other system errors.</p>
<p><b>Examples</b></p>
<p>Search the file example.txt, including binary data (-a) for the string 'hunting the snark':</p>
<p>$ <span class="code">sudo grep -a 'hunting the snark' example.txt</span></p>
<p>Search the whole partition (/sda1), including binary data(-a) for the string 'hunting the snark' return all the lines starting 25 <b>B</b>efore the text found and 50 lines <b>A</b>fter the matching text found, this can be a way to discover fragments of deleted files but is very slow:</p>
<p>$ <span class="code">grep -a -B 25 -A 50 'hunting the snark' /dev/sda1</span> &gt; results.txt</p>
<p>Search the file wordlist.txt  for any lines that <b>don't </b>include at least one vowel:</p>
<p>$ <span class="code">grep -v [aeiou] wordlist.txt</span></p>
<p>Remove lines from <span class="code">invoices.txt</span> if they appear in <span class="code">paid.txt</span>:</p>
<p>$ <span class="code">grep -F -x -v -f paid.txt invoices.txt &gt;paidinvoices.txt</span></p>
<p><i class="quote">&quot;I understand that change is frightening for people, especially if there's nothing to go to. It's best to stay where you are.
I understand that&quot; ~ <a href="http://www.bbc.co.uk/politics97/diana/panorama.html">Princess Diana</a> </i><br>
<br>
<b> Related:</b><br>
<br>
<a href="egrep.html">egrep</a> - Search file(s) for lines that match an extended 
expression<br>
<a href="fgrep.html">fgrep</a> - Search file(s) for lines that match a fixed 
string<br>
pgrep - find  signal processes by name
<br>
<a href="find.html">find</a> - Search for files that meet a desired criteria<br>
<a href="awk.html">gawk</a> - Find and Replace text within file(s)<br>
<a href="locate.html">locate</a> - Find files<br>
<a href="sed.html">sed</a> - Stream Editor - Find and Replace text within file(s)  <br>
<a href="tr.html">tr</a> - Translate, squeeze, and/or delete characters <br>
<a href="whereis.html">whereis</a> - Search the user's <span class="code">$path</span>, man pages and source files for a program<br>
<a href="http://beyondgrep.com/">BeyondGrep : ack</a> - A tool like grep, optimized for programmers <br>
Equivalent Windows commands: <a href="http://ss64.com/nt/qgrep.html">QGREP</a> / <a href="http://ss64.com/nt/findstr.html">FINDSTR</a> - Search for strings in files </p><!-- #BeginLibraryItem "/Library/foot_bash.lbi" --><p><script type="text/javascript"><!--
google_ad_client = "ca-pub-6140977852749469";
/* bash336Rect */
google_ad_slot = "3362592300";
google_ad_width = 336;
google_ad_height = 280;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script></p>
<hr>
<div id=bl class="footer"><a href="grep.html#"><img src="../images/top.png" width="30" height="22" alt="Back to the Top"></a></div>
<div id=br class="footer, tagline">&copy; Copyright <a href="http://ss64.com/">SS64.com</a> 1999-2014<br>
Some rights reserved</div><!-- #EndLibraryItem --></body>
</html>
