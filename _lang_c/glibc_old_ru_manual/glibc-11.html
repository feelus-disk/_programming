<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> Библиотека языка C GNU glibc: Гнезда</TITLE>
 <LINK HREF="glibc-12.html" REL=next>
 <LINK HREF="glibc-10.html" REL=previous>
 <LINK HREF="glibc.html#toc11" REL=contents>
</HEAD>
<body bgcolor="#DDE1C2">
<LINK REL="stylesheet" href="http://www.opennet.ru/opennet4.css" type="text/css">
<!--htdig_noindex-->
<FORM method="get" action="http://www.opennet.ru/search.shtml">
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%">
<TR>
<TD VALIGN="BOTTOM" BGCOLOR="#E9EAD6" style="background: #E9EAD6 url('http://www.opennet.ru/back.gif') repeat-x bottom left">
<A HREF="http://www.opennet.ru/"><IMG SRC="http://www.opennet.ru/opennet2.gif" HEIGHT=60 WIDTH=249 ALT="The OpenNET Project" BORDER="0"></A><br>
</TD>

<TD BGCOLOR="#B0B190" WIDTH="1"><IMG SRC="http://www.opennet.ru/p.gif" HEIGHT=1 WIDTH=1 ALT=""></TD>

<TD VALIGN=TOP ALIGN=RIGHT WIDTH="470" HEIGHT="70" BGCOLOR="#D9DAC6">
<TABLE BORDER=0 CELLPADDING=1 WIDTH="470">
<TR>
<TD HEIGHT=60 BGCOLOR="#D9DAC6">

<script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
 style="display:inline-block;width:468px;height:60px"
 data-ad-client="ca-pub-2075278885744463"
 data-ad-slot="4070171090"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</TD>
</TR>
</TABLE>
</TD>

<TD BGCOLOR="#B0B190" WIDTH="1"><IMG SRC="http://www.opennet.ru/p.gif" HEIGHT=1 WIDTH=1 ALT=""></TD>
<TD WIDTH="40" BGCOLOR="#E9EAD6" style="background: #E9EAD6 url('http://www.opennet.ru/back.gif') repeat-x bottom left">&nbsp;</TD>
<TD BGCOLOR="#B0B190" WIDTH="1"><IMG SRC="http://www.opennet.ru/p.gif" HEIGHT=1 WIDTH=1 ALT=""></TD>

<TD VALIGN=TOP ALIGN=RIGHT WIDTH="130" BGCOLOR="#E9EAD6" ROWSPAN=3>
<a              
href="http://click.opennet.ru/cgi-bin/opennet/hjump.cgi?lanbilling8" target=_blank><img              
src="http://www.opennet.ru/img/lanbilling8.gif" width=130 height=125 border=0 alt=""></a>

</TD>

</TR>

<TR BGCOLOR="#B0B190"><TD COLSPAN=6><IMG SRC="http://www.opennet.ru/p.gif" HEIGHT=1 WIDTH=1 ALT=""></TD></TR>


<TR BGCOLOR="#E9EAD6">
<TD ALIGN=CENTER COLSPAN=5>
<table width="100%">
<tr>
<td rowspan=2 width=300 nowrap class="h">
<INPUT type=hidden name=exclude value="index|/man.shtml"><A HREF="http://www.opennet.ru/search.shtml" class="h"><u>Поиск</u></A>&nbsp;(<A HREF="http://www.opennet.ru/keywords/" class="h">теги</A>):&nbsp;<INPUT type="text" size="20" name="words" value="" title='для поиска в google наберите "g фраза"'>
</td><td width="20%">
&nbsp;   <A HREF="http://www.opennet.ru/opennews/" class="h"><b><u>НОВОСТИ</u></b></A> (<a href="http://www.opennet.ru/news/opennet.shtml" class="h">+</a>)
</td><td width="20%">
  <A HREF="http://www.opennet.ru/mp/" class="h"><b><u>КОНТЕНТ</u></b></A>
</td><td width="20%">
  <A HREF="http://wiki.opennet.ru" class="h"><b><u>WIKI</u></b></A>
</td><td width="20%">
   <A HREF="http://www.opennet.ru/man.shtml" class="h"><b><u>MAN'ы</u></b></A>
</td><td width="20%">
   <A HREF="http://www.opennet.ru/forum/" class="h"><b><u>ФОРУМ</u></b></A>
</td></tr>
</table>
</TD>
<TD BGCOLOR="#B0B190" WIDTH="1"><IMG SRC="http://www.opennet.ru/p.gif" HEIGHT=1 WIDTH=1 ALT=""></TD>
</TR>
<TR BGCOLOR="#B0B190"><TD COLSPAN=7><IMG SRC="http://www.opennet.ru/p.gif" HEIGHT=2 WIDTH=1 ALT=""></TD></TR>
</TABLE>

<div style="float: left; width: 279; text-align: left;padding-right: 60px;" id=adv><A HREF="http://www.ip-as.ru" target=_blank><IMG SRC="http://www.opennet.ru/img/ipas3.gif" BORDER="0" width="279" height="40"></A></div>
<div style="padding-top: 0px;position:absolute;left:50%;margin-left:-235px;width:470px;" id=adv2>
<script language=JavaScript src="http://www.opennet.ru/cgi-bin/opennet/hints.cgi?itsoft"></script> 
</div>
<div style="width: 279;float: right;" id=adv3>
</div>
<div style="clear: both;"></div>
<br>

<script language="JavaScript"><!--
d=document;a='';r=escape(d.referrer);a+=';r='+r;
js=10; d.write('<img src="http://top.list.ru/counter'+
'?id=77689;js='+js+a+';rand='+Math.random()+
'" alt="" height=1 width=1>');
if(js>11)d.write('<'+'!-- ')//--></script><noscript><img
src="http://top.list.ru/counter?js=na;id=77689"
height=1 width=1 alt="">
</noscript>

</FORM>
<!--/htdig_noindex-->


<table  BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" style="margin-bottom: 5px;margin-top: 5px;">
<tr><td>
<TABLE  BORDER=0 CELLSPACING=0 CELLPADDING=4 BGCOLOR="#E9EAD6" WIDTH="100%">
<TR BGCOLOR="#C7CBB1"><TD><FONT COLOR="#000090">
<b><a href="http://www.opennet.ru/docs/">Каталог документации</a> / 
<a href="http://www.opennet.ru/docs/124.shtml">Раздел "Программирование, языки"</a> /
<a href="index.html">Оглавление документа</a>
</b>
</TD></TR>
</TABLE>
</TD></TR>
<TR BGCOLOR="#B0B190"><TD><IMG SRC="http://www.opennet.ru/p.gif" HEIGHT=3 WIDTH=1 ALT=""></TD></TR>
</TABLE>

<A HREF="glibc-12.html">Вперед</A>
<A HREF="glibc-10.html">Назад</A>
<A HREF="glibc.html#toc11">Содержание</A>
<HR>
<H2><A NAME="s11">11. Гнезда</A></H2>

<P>
<P>Эта глава описывает средства GNU для межпроцессорной связи,
используя гнезда.
<P>Гнездо - обобщенный межпроцессорный канал связи. Подобно
каналу, гнездо представляется как дескриптор файла. Но, в
отличие от каналов, гнезда поддерживает ссылка между
несвязанными процессами, и даже между процессами, выполняющимися на
различных машинах, которые связываются по сети. Гнезда - первичный
способ связи с другими машинами; telnet, rlogin, ftp, переговоры, и
другие сетевые программы используют гнезда.
<P>Не все операционные системы поддерживают гнезда. В библиотеке
GNU, заглавный файл 'sys/socket.h' существует независимо от
операционной системы, и функции гнезд всегда существуют, но если
система действительно не поддерживает гнезда, эти функции всегда
терпят неудачу.
<P>Незавершенность: Мы в настоящее время не описали средства для
передачи сообщений или для конфигурирования интерфейса Internet.
<P>
<H2><A NAME="ss11.1">11.1 Понятие Гнезда</A>
</H2>

<P>
<P>Когда Вы создаете гнездо, Вы должны определить стиль связи,
который Вы хотите использовать и тип протокола, который должен
поддерживать ее. Стиль связи гнезда определяет семантику
пользовательского уровня посылки и получения данных через гнезда.
Выбор стиля связи определяет ответы на вопросы типа:
<UL>
<LI>        Каковы модули передачи данных? Некоторые стили связи
расценивают данные как последовательность байтов, без большей
структуры; другие группируют байты в записи (которые известны в
этом контексте как пакеты).</LI>
<LI>        Могут данные быть потеряны в течение нормальной операции?
Некоторые стили связи гарантируют, что все посланные данные
прибывают в порядке, как они были посланы (страховка системы или
сетевых сбоев); другие стили иногда теряют данные как нормальная
часть операции, и могут иногда поставлять пакеты больше чем один
раз или в неправильном порядке.</LI>
<LI>        Является ли ссылка полностью с одним партнером? Некоторые стили
связи - подобно телефонному звонку, Вы делаете соединение с одним
отдаленным гнездом, и тогда свободно обмениваетесь данными. Другие
стили - подобно отправке по почте символов, Вы определяете адрес
адресата для каждого сообщения, которое Вы посылаете.</LI>
</UL>

Вы должны также выбрать именное пространство для наименования
гнезда. Имя гнезда ('адрес') значимо только в контексте частного
namespace. Фактически, даже тип данных, используемый для имени
гнезда может зависеть от именного. Именные пространства также
называются 'областями', но мы избегаем этого слова, поскольку оно
может быть спутано с другим использованием того же самого термина.
Каждое именное пространство имеет символическое имя, которое
начинается с 'PF_'. Соответствующее символическое имя, начинающееся
с 'AF_' обозначает формат адреса для этого namespace.
<P>В заключение Вы должны выбрать протокол, чтобы установить связь.
Протокол определяет  какой механизм низкого уровня используется,
чтобы передавать и получить данные. Каждый протокол допустим для
определенного именного пространства и стиля связи; именное пространство
иногда называется совокупностью протоколов из-за этого имена
именных пространств начинаются с 'PF_'.
<P>Правила протокола относятся к данным, передающимся между двумя
программами, возможно на различных компьютерах; большинство этих
правил обработано операционной системой, и Вы не нужно знать о
них. Вот что Вы должны знать относительно протоколов:
<UL>
<LI>        Чтобы иметь связь между двумя гнездами, они должны определить
тот же самый протокол.</LI>
<LI>        Каждый протокол значим со специфическим стилем/именным
пространством и не может использоваться с несоответствующими
комбинациями. Например, TCP протокол удовлетворяет только стилю
связи потока байтов и именному пространству Internet.</LI>
<LI>        Для каждой комбинации стиля и именного пространства, имеется
заданный по умолчанию протокол, который Вы можете запрашивать,
определяя 0 как номер протокола. И это - то, что Вы должны обычно
делать - использовать значение по умолчанию.</LI>
</UL>
<P>
<P>
<P>
<H2><A NAME="ss11.2">11.2 Стили Связи</A>
</H2>

<P>
<P>Библиотека GNU поддерживает различные виды сокетов. В этом разделе
описываются различные типы сокетов предоставляемые в бибилотекой  GNU.
Упомянутые в данном разделе символические константы определены в
"sys/socket.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int SOCK_STREAM (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Тип сокета SOCK_STREAM  предназначен для передачи потоков байтов. Такой
стиль передачи схож со стилем передачи данных через каналы (pipe)
(см. Главу 10 [Трубопроводы и FIFO]). Он используется для передачи данных
с отдаленным соединением. При таком стиле передачи данных обеспечивается
высокая надежность.
<P>Более подробное описание работы с использованием этого типа Вы найдете в
Разделе 11.8 [Соединения].
<P>
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int SOCK_DGRAM (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Тип сокета SOCK_DGRAM  используется для посылки индивидуально
адресованных пакетов (ненадежен). Этот тип принципиально отличается от типа
SOCK_STREAM.
<P>Каждый раз когда Вы пишите данные в сокет этого типа,
данные становятся одним пакетом. Вы должны определить адрес
получателя для каждого пакета.
<P>Единственной гарантией, которую предоставляет Вам система относительно
запросов передачи данных, является то, что она пробует наилучшим образом
посылать каждый пакет. У нее может получится посылка шестого пакета после
неудачи с четвертыми и пятыми пакетами; седьмой пакет может прибыть перед
шестым, также второй может прибыть как раз после шестого.
<P>Типичное использование типа SOCK_DGRAM в ситуациях, где есть возможность
повторной посылки пакетов, если ответ не был получен в приемлемое время.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int SOCK_RAW  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Этот тип  обеспечивает доступ к сетевым протоколам и
интерфейсам низкого уровня. Обычные пользовательские  программы,
обычно не имеют потребности использовать этот стиль.
<P>
<H2><A NAME="ss11.3">11.3 Адреса сокетов</A>
</H2>

<P>
<P>Имя сокета обычно называется адресом. Функции и символы для
имеющихся адресов сокетов могли называться как с использованием термина,
так и использованием термина "адрес". Вы можете расценивать эти термины как
синонимичные в контексте обсуждения сокетов.
<P>Сокет, созданный при помощи функции socket, не имеет никакого
адреса. Другие процессы могут использовать его для связи только после того
как Вы дадите ему адрес. Мы называем это - связывание  адреса с
сокетом. Связывание происходит при помощи  функции bind.
<P>
<P>В первый раз, когда Вы посылаете данные из сокета, или
используете его, чтобы инициализировать соединение, система
назначает адрес автоматически.
<P>Подробности адресации сокетов изменяются, в зависимости от
именного пространства, которое Вы используете. См. Раздел 11.4
[Именное пространство Файла], или Раздел 11.5 [Именное пространство
Internet].
<P>Независимо от именного пространства, Вы используете те же самые
функции bind и getsockname, чтобы установить и исследовать адрес
гнезда.
<P>
<H3>Форматы Адреса</H3>

<P>
<P>Функции bind и getsockname используют обобщенный тип данных
struct sockaddr *, чтобы представить указатель на адрес гнезда. Вы
не можете использовать этот тип данных действительно, чтобы
интерпретировать адрес или создавать его; для этого, Вы должны
использовать соответствующий тип данных для именного пространства
гнезда.
<P>Таким образом, обычная нужно создать адрес в соответствующем
именном пространстве специфического типа, и приводить указатель на
struct sockaddr *, когда Вы вызываете bind или getsockname.
<P>Единственная информация, которую Вы можете получить из структуры
sockaddr - указатель формата адреса, который сообщает Вам какой
тип данных использовать, чтобы понять адрес полностью.
<P>Символы в этом разделе определены в заголовочном файле
"sys/socket.h".
<P>
<P>
<P>
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct sockaddr  (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Тип структуры sockaddr непосредственно имеет следующие поля:
<P>
<BLOCKQUOTE><CODE>
<PRE>
      short int sa_family
</PRE>
</CODE></BLOCKQUOTE>

Это код для формата адреса. Он идентифицирует формат данных.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    сhar sa_data [14]
</PRE>
</CODE></BLOCKQUOTE>

Это фактические данные адреса сокета, которые являются
формато-зависимыми. Длина также зависит от формата, и может  быть
больше чем 14. Длина 14 из sa_data по существу произвольна.
<P>Каждый формат адреса имеет символическое имя, которое начинается
с "AF_ ". Каждый из них соответствует "PF_ " символу, который
обозначает соответствующее именное пространство. Вот список
названий форматов адресов:
<DL>
<DT><B>AF_FILE </B><DD><P>Обозначает формат адреса, который идет с именным
пространством файла. (PF_FILE - имя этого именного пространства.)
См. Раздел 11.4.2 [Подробности Именного пространства Файла], для
уточнения информации относительно этого формата адреса.
<P>
<DT><B>AF_UNIX </B><DD><P>Это синоним AF_FILE, для совместимости. (PF_UNIX &shy;
аналогично синоним для PF_FILE.)
<P>
<DT><B>AF_INET </B><DD><P>Обозначает формат адреса, который идет в именном
пространстве Internet. (PF_INET - имя этого именного пространства.)
См. Раздел 11.5.1 [Формат Адреса Internet].
<P>
<DT><B>AF_UNSPEC </B><DD><P>
<P>Не обозначает никакой специфический формат адреса. Он
используется только в редких случаях, когда необходимо очистить снаружи
заданный по умолчанию адрес адресата от "соединенного" датаграмного
сокета. См. Раздел 11.9.1 [Посылка Датаграмм].
</DL>

Соответствующий символ указателя именного пространства PF_UNSPEC
существует для законченности, но нет никакой причины
использовать его в программе.
<P>"Sys/socket.h" определяет символы, начинающиеся с " AF_ " для
различных видов сетей, большинство из которых фактически не встречается.
Мы будем документировать только то, что действительно используется на практике.
<P>
<H3>Установка Адреса сокета</H3>

<P>
<P>Используйте функцию bind, чтобы для связывания адреса сокета. Прототип
для bind находится в заголовочном файле "sys/socket.h". Для примеров
использования см. Раздел 11.4 [Именное пространство Файла].
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int bind (int socket, struct sockaddr *addr, size_t length) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция bind назначает адрес сокет socket. Аргументы Addr и length
определяют адрес; детализированный формат адреса зависит
от именного пространства. Первая часть адреса - всегда указатель
формата, который определяет именное пространство, и говорит, что
адрес находится в формате для этого именного пространства.
<P>Возвращаемое значение - 0 при успехе и -1 при отказе. Для этой функции
в переменной errno определены следующие виды ошибок:
<DL>
<DT><B>EBADF </B><DD><P>аргумент - не допустимый описатель файла.
<DT><B>ENOTSOCK </B><DD><P>дескриптор socket - сокет.
<DT><B>EADDRNOTAVAIL </B><DD><P>заданный адрес не доступен на этой машине.
<DT><B>EADDRINUSE </B><DD><P>Существует другой сокет использующий заданный адрес.
<P>
<DT><B>EINVAL </B><DD><P>сокет уже имеет адрес.
<DT><B>EACCESS </B><DD><P>Вам не достаточно прав для обращения к запрошенному
адресу. (В области Internet, только супер-пользователю позволяют
определить номер порта в диапазоне от 0 до IPPORT_RESERVED минус
один; см. Раздел 11.5.3 [Порты].) Дополнительные условия могут быть
возможны в зависимости от специфического именного пространства
сокета.
</DL>
<H3>Чтение Адреса сокета</H3>

<P>
<P>Используйте функцию getsockname, чтобы исследовать адрес гнезда
Internet. Прототип для этой функции находится в заголовочном файле
"sys/socket.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int getsockname (int socket, struct sockaddr *addr, size_t *length_ptr) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция getsockname возвращает информацию относительно адреса
сокета в заданного аргументами addr и length_ptr. Обратите
внимание, что length_ptr - указатель; Вы должны инициализировать
его, как размер резервирования addr, и по возвращении он содержит
фактический размер данных адреса.
<P>Формат данных адреса зависит от именного пространства сокета.
Длина информации обычно устанавливается для данного именного
пространства, так что обычно Вы можете знать точно, сколько места
необходимо. Обычно нужно зарезервировать место для значения,
используя соответствующий тип данных для именного пространства
сокета, и тогда привести адрес к struct sockaddr *, чтобы передать
его getsockname.
<P>Возвращаемое значение - 0 при успехе и -1 при ошибке. Для этой функции
в переменной errno определены следующие виды ошибок:
<DL>
<DT><B>EBADF </B><DD><P>аргумент socket - не допустимый описатель файла.
<DT><B>ENOTSOCK </B><DD><P>дескриптор socket - не сокет.
<DT><B>ENOBUFS </B><DD><P>не имеется достаточных внутренних буферов, доступных для
операции.
</DL>
<P>Вы не можете читать адрес сокета в именном пространстве файла.
Это непротиворечиво с остальной частью системы; вообще, не существует
способа найти имя файла из описателя для этого файла.
<P>
<P>
<H2><A NAME="ss11.4">11.4 Именное пространство Файла</A>
</H2>

<P>
<P>Этот раздел описывает подробности именного пространства файла,
чье символическое имя (требуется, когда Вы создаете сокет) &shy;
PF_FILE.
<P>
<H3>Понятия Именного пространства Файла</H3>

<P>
<P>В именном пространстве файла, адреса сокетов - имена файлов. Вы
можете определять любое желаемое имя файла для адреса сокета, но Вы должны
иметь право записи в каталоге, содержащем его. Для чтобы соединяться с
сокетом, Вы должны иметь право чтения для него.
Обычно эти файлы помещаются в каталог `/tmp'.
<P>Одна особенность именного пространства файла -- имя
используется только при открытии соединения; если только оно было
законченно, адрес не значим и может не существовать.
<P>Другая особенность заключается в том, что Вы не можете соединяться с
таким сокетом на другой машине, даже если другая машина совместно
использует файловую систему, которая содержит имя это имя сокета. Вы можете
видеть сокет в распечатке каталога, но соединение с ним никогда не произойдет.
<P>После того, как Вы закрываете сокет в именном пространстве
файла, Вы должны удалить имя файла из файловой системы. Используйте
unlink или remove, чтобы делать это; см. Раздел 9.5 [Удаление
Файлов].
<P>Именное пространство файла поддерживает только один протокол для
любого типа связи; 0 - номер протокола.
<P>
<H3>Подробности Именного пространства Файла</H3>

<P>
<P>Чтобы создавать сокет в именном пространстве файла, используйте
константу PF_FILE как аргумент именного пространства для socket или
socketpair. Эта константа определена в "sys/socket.h".
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int PF_FILE  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Он обозначает именное пространство файла, в котором адреса
сокетов являются именами файлов, и связываются совокупностью
протоколов.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int PF_UNIX  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Это - синоним PF_FILE используемый для совместимости.
<P>Структура для определения имен сокетов в именном пространстве
файла определена в заголовочном файле "sys/un.h":
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct sockaddr_un  (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Эта структура используется, чтобы определить адреса сокета
именного пространства файла. Она имеет следующие поля:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    short int sun_family
</PRE>
</CODE></BLOCKQUOTE>

Это поле идентифицирует совокупность адреса или формат адреса
сокета. Вы должны сохранить значение AF_FILE, чтобы обозначить
именное пространство файла. См. Раздел 11.3 [Адреса Гнезда].
<P>
<BLOCKQUOTE><CODE>
<PRE>
    char sun_path[108]
</PRE>
</CODE></BLOCKQUOTE>

Это имя используемого файла.
<P>Незавершенность: Почему - 108? RMS предлагает делать его
массивом нулевой длины и использовать alloc, чтобы зарезервировать
соответствующее количество памяти, основываясь на длине filename.
<P>Вы должны вычислить параметр длины для адреса сокета в именном
пространстве файла как сумму размера компоненты sun_family  и
длины (не размера резервирования!) строки имени файла.
<P>
<P>
<P>
<H3>Пример файлового-именного пространства сокетов</H3>

<P>
<P>Вот пример, показывающий, как создавать и связывать сокет в
именном пространстве файла.
<P>
<BLOCKQUOTE><CODE>
<PRE>
                #include &lt;stddef.h&gt;
                #include &lt;stdio.h&gt;
                #include &lt;errno.h&gt;
                #include &lt;stdlib.h&gt;
                #include &lt;sys/socket.h&gt;
                #include &lt;sys/un.h&gt;
                int
                make_named_socket (const char *filename)
                {
                        struct sockaddr_un name;
                        int sock;
                        size_t size;
                        sock = socket (PF_UNIX, SOCK_DGRAM, 0);
                        if (sock &lt; 0)
                                        {
                                                perror ("socket");
                                                exit (EXIT_FAILURE);
                                        }
                        name.sun_family = AF_FILE;
                        strcpy (name.sun_path, filename);
                        size=(offsetof(struct sockaddr_un, sun_path)
                                + strlen (name.sun_path) + 1);
                        if (bind (sock, (struct sockaddr *) &amp;name,
                                        size) &lt; 0) {
                                        perror ("bind");
                                        exit (EXIT_FAILURE);
                                }
                        return sock;
       }
</PRE>
</CODE></BLOCKQUOTE>
      
<P>
<P>
<P>
<H2><A NAME="ss11.5">11.5 Именное пространство Internet</A>
</H2>

<P>
<P>Этот раздел описывает подробности протокола и соглашений
именования сокетов, используемые в именном пространстве Internet.
<P>Чтобы создать сокет в именном пространстве Internet,
используйте символическое имя PF_INET этого именного пространства
как аргумент именного пространства socket или socketpair. Эта
макрокоманда определена в "sys/socket.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
       int PF_INET        (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Обозначает именное пространство Internet и связанную
совокупность протоколов.
<P>Адрес сокета для именного пространства Internet включает
следующие компоненты:
<UL>
<LI>     Адрес машины с которой Вы хотите соединяться. Адреса в Internet
могут быть определены разными способами; эти способы обсуждаются в Разделе
11.5.1 [Формат Адреса Internet] Разделе 11.5.2 [Главные Адреса], и
Разделе 11.5.2.4 [Главные Имена].
</LI>
<LI>     Номер порта для машины. См. Раздел 11.5.3 [Порты].</LI>
</UL>

Вы должны гарантировать, что адрес и номер порта представляется
в каноническиом формате, называемом сетевым байтовым порядком. См.
Раздел 11.5.5 [Порядок Байов], для уточнения информации относительно
этого.
<P>
<H3>Формат Адреса сокета Internet</H3>

<P>
<P>В именном пространстве Internet, адрес состоит из главного
адреса и порта на этой главной ЭВМ. Кроме того, протокол, который
Вы выбираете, служит как бы частью адреса, потому что местные числа
порта значимы только внутри специфического протокола.
<P>
<P>Тип данных для представления адресов в именном пространстве
Internet определен в заголовочном файле "netinet/in.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct sockaddr_in  (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Это тип данных, используемый, чтобы представить адреса в
именном пространстве Internet. Он имеет следующие поля:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    short int sin_family
</PRE>
</CODE></BLOCKQUOTE>

Это поле идентифицирует совокупность адресов или формат адреса
сокета. Вы должны сохранить значение AF_INET в этом элементе. См.
Раздел 11.3 [Адреса Гнезда].
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct in_addr sin_addr
</PRE>
</CODE></BLOCKQUOTE>

Это Internet адрес  главной машины. См. Раздел 11.5.2 [Главные
Адреса], и Раздел 11.5.2.4 [Главные Имена].
<P>
<BLOCKQUOTE><CODE>
<PRE>
    unsigned short int sin_port
</PRE>
</CODE></BLOCKQUOTE>

Это номер порта. См. Раздел 11.5.3 [Порты].
<P>Когда Вы вызываете bind или getsockname, Вы должны определить
sizeof (struct sockaddr_in) как параметр длины при использовании
адреса в именном пространстве Internet.
<P>
<H3>Главные Адреса</H3>

<P>
<P>Каждый компьютер в Internet имеет один, или большое количество
Internet адресов, т. е. числа, которые идентифицируют этот
компьютер среди остальных на Internet. Пользователи обычно записывают
число-адрес главной ЭВМ как последовательность из четырех чисел,
отделяемых точками, например "128.52.46.32".
<P>Каждый компьютер также имеет одно или большое количество главных
имен, которые являются строками слов, отделяемых точками, например
"churchy.gnu.ai.mit.edu".
<P>Программы, которые допускают пользователю определять главную ЭВМ
обычно принимают и числовые адреса и главные имена. Но для открытия соединения
программе необходим числовой адрес, так что для использования главного имени,
Вам нужно преобразовать его в числовой адрес.
<P>
<H3>Адреса Главной ЭВМ Internet</H3>

<P>
<P>Адрес главной ЭВМ в Internet - это номер, содержащий четыре байта
данных. Они разделены на две части, сетевой номер и местный номер
внутри этой сети. Сетевой номер состоит из первых одного, двух или трех байт;
остальная часть байтов - местный адрес.
<P>Сетевые числа зарегистрированы в Сетевом Информационном Центре
(NIC), и разделены на три класса A, B, и C. Местные числа сетевого
адреса индивидуальных машин зарегистрированы  администратором
в локальной сети.
<P>Сеть класса А имеет одиночно-байтовые числа в диапазоне от 0 до
127. Сетей класса A не так уж много, но каждая из них может
поддерживать очень большое количество главных ЭВМ. Сети класса В
размера имеет Двух-байтовые сетевые числа, с первым байтом в
диапазоне от 128 до 191. Класс C самый маленький; адреса в нем они имеют
Трех-байтовые сетевые числа, с первым байтом в диапазоне 192-255. Таким
образом, первый 1, 2, или 3 байты адреса Internet определяют сеть.
Оставшиеся байты адреса Internet определяют адрес внутри этой сети.
<P>Нулевая сеть класса A зарезервирована для передачи по всем сетям.
Кроме того, главный номер 0 внутри каждой сети зарезервирован для
передачи на все главные ЭВМ в этой сети.
<P>127-ая сеть класса A зарезервирована для возврата цикла; Вы можете
всегда использовать адрес Internet "127.0.0.1", чтобы обратиться к
главной машине.
<P>Так как одиночная машина может быть элементом нескольких сетей,
она может иметь много адресов главной ЭВМ Internet. Однако,
предполагается,  что существует не более одной машины с тем же самым
главным адресом.
<P>Имеются четыре формы стандартного расположения чисел и точек для
Internet адреса:
<OL>
<LI>    а.b.c.d  определяет все четыре байта адреса индивидуально.
</LI>
<LI>    а.b.c последняя часть адреса, интерпретируется как 2-байтовое
число. Это полезно для определения главных адресов в сети класса B
с сетевым адресом a.
</LI>
<LI>    а если дана только одна часть, то она соответствует непосредственно
числу главного адреса.
</LI>
<LI>    "0x" или "0X" подразумевает шестнадцатеричную систему
счисления; "0" подразумевает восьмеричную; в противном случае десятичная
система счисления.</LI>
</OL>
<H3>Тип Данных Главного Адреса</H3>

<P>
<P>Адреса главной ЭВМ Internet представляются в некоторых
контекстах как integers (long unsigned int). В других контекстах,
integer упакован внутри структуры типа struct in_addr. Было бы
лучше, если бы использование было сделано непротиворечивым.
<P>Следующие базисные определения для Internet адреса, появляются в
файле "netinet/in.h":
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct in_addr      (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Этот тип данных используется в некоторых контекстах, чтобы
содержать адрес главной ЭВМ Internet. Он имеет только одно поле,
именованное s_addr, в которое записывается адрес как long unsigned
int.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    unsigned long int INADDR_LOOPBACK  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Вы можете использовать эту константу, в качестве адреса вашей машины
вместо того, чтобы искать настоящий адрес. В Internet это адрес "127.0.0.1",
который обычно называется "localhost". Эта специальная константа сохраняет
Вас от проблемы поиска адреса вашей собственной машины. Используя этот адрес
можно имитировать передачу пакетов Internet в пределах одной машины.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    unsigned long int INADDR_ANY  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Вы можете использовать эту константу вместо "любого входящего адреса".
См. Раздел 11.3.2 [Установка Адреса]. Это обычный адрес, для указания в
поле sin_addr структуры  sockaddr_in, если Вы хотите установить соединение
Internet.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    unsigned long int INADDR_BROADCAST  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Эта константа - адрес, который Вы используете для посылки
широковещательных сообщений.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    unsigned long int INADDR_NONE (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Эта константа используется некоторыми функциями для отображения ошибок.
<P>
<H3>Функции Главного Адреса</H3>

<P>
<P>Это дополнительные функции для управления Internet адресацией,
объявленые в "arpa/inet.h". Они представляют Internet адреса в
сетевом порядке байтов; это сетевые числа и числа локальных сетевых адресов
в главном порядке байтов. См. Раздел 11.5.5 [Порядок Байтов], для объяснения
сетевого и главного порядка байтов.
<P>
<BLOCKQUOTE><CODE>
<PRE>
       int inet_aton (const char *name, struct in_addr *addr) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция преобразовывает имя адреса главной ЭВМ Internet из
стандарта числа-и-точки в двоичные данные. Inet_aton возвращает отличное от
нуля чило, если адрес допустим, и нуль если нет.
<P>
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    unsigned long int inet_addr (const char *name)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция преобразовывает имя адреса главной ЭВМ Internet из
стандарта числа-и-точки в двоичные данные. Если ввод не допустим,
inet_addr, возвращает INADDR_NONE. Это - устаревший интерфейс для
inet_aton; устаревший, потому что INADDR_NONE - допустимый адрес
(255.255.255.255), и inet_aton обеспечивает более чистый способ указать
ошибку.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    unsigned long int inet_network (const char *name)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция извлекает сетевой номер из имени адреса, данного в
стандарте числа-и-точки. Если ввод не допустим, inet_network,
возвращает -1.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    char * inet_ntoa (struct in_addr addr)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция преобразовывает addr Internet адреса главной ЭВМ  в
строку в стандарте числа-и-точки. Возвращаемое значение &shy;
указатель на статически размещенный буфер. Последующие обращения
запишут поверх в тот же самый буфер, так что Вы должны копировать
строку, если Вы должны сохранить ее.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct in_addr inet_makeaddr (int net, int local)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция создает Internet адрес главной ЭВМ ,  объединяя
номер сети с местным номером.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int inet_lnaof (struct in_addr addr)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает локальную часть адреса, если Internet адрес
главной ЭВМ - addr.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int inet_netof (struct in_addr addr)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает сетевую часть addr Internet адреса главной ЭВМ.
<P>
<P>
<H3>Главные Имена</H3>

<P>
<P>Кроме стандарта числа-и-точки для Internet адреса, Вы можете
также обратиться к главной ЭВМ символическим именем. Преимущество
символического имени - то, что его обычно проще запомнить.
Например, машина с адресом  "128.52.46.32" также может иметь адрес
"churchy.gnu.ai.mit.edu"; и другие машины в этом домене могут обратиться к
ней просто как "churchy".
<P>Система использует базу данных, чтобы следить за
отображением между главными именами и главными числами. Эта база
данных - файл, обычно "/etc/hosts" или эквивалент, обеспеченный
блоком преобразования имен. Функции и другие символы для доступа к
этой базе данных объявлены в "netdb.h". Возможности BSD могут использоваться
при подключении файла "netdb.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct hostent  (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Этот тип данных используется для представления доступа к базе
данных главных ЭВМ. Он имеет следующие элементы:
<P>
<BLOCKQUOTE><CODE>
<PRE>
                char *h_name
</PRE>
</CODE></BLOCKQUOTE>

Это "официальное" имя главной ЭВМ.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    char **h_aliases
</PRE>
</CODE></BLOCKQUOTE>

Это альтернативные имена для главной ЭВМ, представляемые как
вектор с нулевым символом в конце строк.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int h_addrtype
</PRE>
</CODE></BLOCKQUOTE>

Это тип главного адреса; практически, значение - всегда
AF_INET. В принципе другие виды адресов могли бы представляться в
базе данных, также как Internet адреса; если это было выполнено, Вы
могли бы найти значение в этом поле отличным от AF_INET. См. Раздел
11.3 [Адреса Гнезда].
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int h_length
</PRE>
</CODE></BLOCKQUOTE>

Это длина, в байтах, каждого адреса.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    char **h_addr_list
</PRE>
</CODE></BLOCKQUOTE>

Это вектор адресов для главной ЭВМ. (Заметим, что главная ЭВМ
могла бы быть соединенной с несколькими сетями и иметь различные
адреса в каждой.) вектор завершен нулевым указателем.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    char *h_addr
</PRE>
</CODE></BLOCKQUOTE>

Это синоним для h_addr_list [0]; другими словами, это первый
главный адрес.
<P>В главной базе данных каждый адрес только блок памяти h_length
байт длиной. Но в других контекстах имеется неявное предположение,
что Вы можете преобразовывать его в struct addr_in или long
unsigned int. Главные адреса в структуре struct hostent всегда даны
в сетевом порядке байтов; см. Раздел 11.5.5 [Порядок Байт].
<P>Вы можете использовать gethostbyname или gethostbyaddr, для
уточнения инфрмации базы данных главных ЭВМ относительно
специфической главной ЭВМ. Информация возвращена в статически
размещенной структуре.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct hostent * gethostbyname (const char *name)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция Gethostbyname  возвращает информацию относительно главной
ЭВМ, именованной name. Если происходит ошибка поиска, она
возвращает пустой указатель.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct hostent * gethostbyaddr (const char *addr, int length, (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция Gethostbyaddr возвращает информацию относительно главной
ЭВМ с адресом addr в Internet. Аргумент length - размер (в байтах)
адреса addr. format определяет формат адреса; для адреса Internet,
определите значение AF_INET.
<P>Если происходит сбой поиска, gethostbyaddr возвращает пустой
указатель.
<P>Если поиск имени gethostbyname или gethostbyaddr окончился неудачно, Вы
можете выяснить причину,  рассматривая значение переменной h_errno.
(Было бы правильнее установить errno, но использование h_errno
совместимо с другими системами.) Перед использованием h_errno, Вы
должны объявить его примерно так:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    extern int h_errno;
</PRE>
</CODE></BLOCKQUOTE>

Имеются коды ошибок, которые Вы можете находить в h_errno:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    HOST_NOT_FOUND
</PRE>
</CODE></BLOCKQUOTE>

Нет такой главной ЭВМ в базе данных.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    TRY_AGAIN
</PRE>
</CODE></BLOCKQUOTE>

Это происходит, когда с  блоком преобразования имен
нельзя было бы входить в контакт. Если Вы попробуете сделать это позже, то
возможно Вам повезет больше.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    NO_RECOVERY
</PRE>
</CODE></BLOCKQUOTE>

Произошла невосстанавливаемая ошибка .
<P>
<BLOCKQUOTE><CODE>
<PRE>
    NO_ADDRESS
</PRE>
</CODE></BLOCKQUOTE>

Главная база данных содержит вход для имени, но он не имеет
связанного Internet адреса .
<P>Вы можете также просматривать всю базу данных главных ЭВМ
используя sethostent, gethostent, и endhostent. Будьте внимательны
при использовании этих функций, потому что они не допускают повторного
использования.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    void sethostent (int stayopen)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция открывает базу данных главных ЭВМ для просмотра.
Затем Вы можете вызывать gethostent для ее чтения.
<P>Если аргумент stayopen  является отличным от нуля, она
устанавливает флаг так, чтобы последующие обращения к gethostbyname
или gethostbyaddr не закрыли базу данных (что они обычно сделали бы).
<P>Это делается для эффективности, если Вы вызываете эти функции
несколько раз, то избегаете повторного открытия базы данных для каждого
обращения.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct hostent * gethostent ()  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает следующий вход в базе данных главных ЭВМ.
Она возвращает пустой указатель, если не имеется больше входов.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    void endhostent ()  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция закрывает базу данных главных ЭВМ.
<P>
<H3>Порты Internet</H3>

<P>
<P>Адрес сокета в именном пространстве Internet состоит из адреса
Internet машины плюс номер порта, который отличает гнездо на данной
машине (для данного протокола). Номера портов располагаются от 0 до
65535.
<P>Номера портов меньше, зарезервированых IPPORT_RESERVED  для
стандартных серверов, типа finger и telnet. Имеется база данных,
которая следит за ними, и Вы можете использовать функцию getservbyname
для отображения сервисного номера порта; см. Раздел
11.5.4 [База данных Услуг].
<P>Если Вы собираетесь устанавливать сервер, который не является стандартно
определенным в базе данных, то Вам необходимо выбрать для него номер порта.
Используйте номера большие чем IPPORT_USERRESERVED; такие числа
зарезервированы для серверов и никогда не будут генерироваться системой.
<P>Когда Вы используете сокет без определения адреса, система
генерирует номер порта для него. Этот номер попадает в интервал  между
IPPORT_RESERVED и IPPORT_USERRESERVED.
<P>На Internet, фактически, законно иметь два различных сокета с одинаковыми
номерами портов, пока они оба не попытаются связаться с тем этим адресом
сокета (главный адрес плюс номер порта). Вы не должны дублировать номер порта
за исключением специальных обстоятельств, где протокол с более высоким уровнем
требует этого. Обычно, система не будет разрешать Вам делать это; bind требует
различные номера портов. Чтобы многократно использовать номер порта, Вы должны
установить опцию сокета SO_REUSEADDR. См. Раздел 11.11.2 [Опции Сокетов].
<P>Эти макрокоманды определены в заголовочном файле "netinet/in.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int IPPORT_RESERVED  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Номера портов меньшие IPPORT_RESERVED зарезервированы для
использования суперпользователем.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int IPPORT_USERRESERVED  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Номера портов большие или равные IPPORT_USERRESERVED зарезервированы для
явного использования; они никогда не будут размещены автоматически.
<P>
<H3>База данных Услуг</H3>

<P>
<P>База данных, которая следит за "общеизвестными" услугами -  это обычно или
файл "/etc/services" или эквивалент из блока преобразования имен. Вы можете
использовать эти утилиты, объявленные в "netdb.h" для обращения к базе данных
услуг.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct servent  (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Этот тип данных содержит информацию относительно входов в базе
данных услуг, он имеет следующие элементы:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    char *s_name
</PRE>
</CODE></BLOCKQUOTE>

Это "официальное" имя обслуживания.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    char **s_aliases
</PRE>
</CODE></BLOCKQUOTE>

Это альтернативные имена обслуживания, представляемые массивом строк.
<P>Пустой указатель завершает массив.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int s_port
</PRE>
</CODE></BLOCKQUOTE>

Это номер порта для обслуживания. Номера портов даны в сетевом
порядке байтов; см. Раздел 11.5.5 [Порядок Байтов].
<P>
<BLOCKQUOTE><CODE>
<PRE>
    char *s_proto
</PRE>
</CODE></BLOCKQUOTE>

Это имя протокола, для использования с этим обслуживанием. См.
Раздел 11.5.6 [База данных Протоколов].
<P>Чтобы получать информацию относительно специфического
обслуживания, используйте функции getservbyname или getservbyport функции.
Информация возвращается в статически размещенной структуре.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct servent * getservbyname (const char *name, const char *proto) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Getservbyname функция возвращает информацию относительно
обслуживания, именованного name, используя протокол proto. Если она
не может найти такое обслуживание, она возвращает пустой указатель.
<P>Эта функция полезна как для серверов так и для клиентов;
серверы используют ее, чтобы определить, на каком порту они
должны принимать пакеты (см. Раздел 11.8.2 [Прием]).
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct servent * getservbyport (int port, const char *proto) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция Getservbyport возвращает информацию относительно
обслуживания на порте port, используя протокол proto. Если она не
может найти такое обслуживание, она возвращает пустой указатель.
<P>Вы можете также просматривать базу данных услуг, используя
setservent, getservent, и endservent. Будьте внимательным в
использовании этих функций, потому что они не предназначены для повторного
использования.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    void setservent (int stayopen)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция открывает базу данных услуг для просмотра.
<P>Если аргумент stayopen  является отличным от нуля, она
устанавливает флаг так, чтобы последующие обращения к getservbyname
или getservbyport не закрыли базу данных (поскольку они обычно
закрыли бы). Это делается для большей эффективности, если Вы
вызываете эти функции несколько раз, избегая повторного открытия
базы данных для каждого обращения.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct servent * getservent (void)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает следующий вход базы данных услуг. Если
там нет больше входов, она возвращает пустой указатель.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    void endservent (void)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция закрывает базу данных услуг.
<P>
<H3>Преобразование Порядка Байтов</H3>

<P>
<P>Различные виды компьютеров используют различные соглашения для
упорядочения байтов внутри слова. Некоторые компьютеры помещают
старший байт сначала (это называется "big-endian" порядком), а
другие помещают его последним ("little-endian" порядок).
<P>Так, чтобы машины с различными соглашениями порядка байтов могли
связываться, протоколы Internet определяют каноническое соглашение
порядка байтов для данных, переданных по сети. Оно известно как
сетевой порядок байта.
<P>При установлении соединения в Internet, Вы должны
удостовериться, что данные в sin_port и sin_addr элементах
структуры sockaddr_in представляются в сетевом порядке байта. Если
Вы кодируете данные integer в сообщениях, посланных через сокет,
Вы должны преобразовать их в сетевой порядок байта. Если Вы не
делаете этого, ваша программа может работать не правильно при сообщении с
другими типами машин.
<P>Если Вы используете getservbyname и gethostbyname или inet_addr,
для  получения номера порта и главного адреса, то эти значения уже в
сетевом порядке байта, и Вы можете копировать их непосредственно в
структуру sockaddr_in.
<P>Иначе, Вы должны преобразовать значения явно. Используйте htons
и ntohs, чтобы преобразовать значения для sin_port элемента.
Используйте htonl и ntohl, чтобы преобразовать значения для
sin_addr элемента. (Помните, struct in_addr эквивалентен long
unsigned int.) Эти функции описаны в "netinet/in.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    unsigned short int htons (unsigned short int hostshort) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция преобразовывает short integer hostshort из главного
порядка байтов в сетевой порядок байта.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    unsigned short int ntohs (unsigned short int netshort) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция преобразовывает short integer netshort из сетевого
порядка байта в главный порядок байта.
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    unsigned long int htonl (unsigned long int hostlong)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция преобразовывает long integer hostlong из главного
порядка байтов в сетевой порядок байт.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    unsigned long int ntohl (unsigned long int netlong)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция преобразовывает long integer netlong из сетевого
порядка байт в главный порядок байт.
<P>
<H3>База данных Протоколов</H3>

<P>
<P>Протокол связи используется для управления низкого уровня
обмена данными. Например, протокол осуществляет вещи подобно
контрольным суммам, чтобы обнаружить ошибки в передачах, и команды
маршрутизации для сообщений.
<P>Заданный по умолчанию протокол связи для именного пространства
Internet зависит от стиля связи. Для потокового взаимодействия,
значение по умолчанию - TCP ("протокол управления передачей").
Для датаграмной связи, значение по умолчанию - UDP ("протокол
датаграммы пользователя"). Для надежной датаграмной связи
значение по умолчанию - RDP ("надежный датаграмный протокол"). Вы
должны почти всегда использовать это значение по умолчанию.
<P>Протоколы Internet вообще определены именем вместо номера.
Сетевые протоколы, которые знает главная ЭВМ, сохранены в базе
данных. Она обычно происходит от файла "/etc/protocols", или  может
быть эквивалент, обеспеченный блоком преобразования имен. Вы можете
искать номер протокола, связанный с именованным протоколом в базе
данных, используя getprotobyname функцию.
<P>Имеются детализированные описания утилит для доступа к базе
данных протоколов. Они объявлены в "netdb.h".
<P>
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct protoent  (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Этот тип данных используется, чтобы представить входы в базе
данных сетевых протоколов. Он имеет следующие элементы:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    char *p_name
</PRE>
</CODE></BLOCKQUOTE>

Это официальное имя протокола.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    char **p_aliases
</PRE>
</CODE></BLOCKQUOTE>

Это альтернативные имена для протокола, заданные как массив
строк.
<P>Последний элемент массива - пустой указатель.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int p_proto
</PRE>
</CODE></BLOCKQUOTE>

Это номер протокола (в главном порядке байт); используйте этот
элемент как аргумент protocol для socket.
<P>Вы можете использовать getprotobyname и getprotobynumber, чтобы
искать в базе данных протоколов специфический протокол. Информация
возвращается в статически размещенной структуре; Вы должны
копировать информацию, если Вы хотите сохранить ее для следующих
обращений.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct protoent * getprotobyname (const char *name)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция Getprotobyname  возвращает информацию относительно
сетевого протокола, именованного name. Если там нет такого
протокола, она возвращает пустой указатель.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct protoent * getprotobynumber (int protocol)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Getprotobynumber функция возвращает информацию относительно
сетевого протокола с указанным номером. Если там нет такого
протокола, она возвращает пустой указатель.
<P>Вы можете также просматривать целую базу данных протоколов (по
одному протоколу одновременно), используя setprotoent, getprotoent,
и endprotoent. Будьте внимательным в использовании этих функций,
потому что они не предназначены для повторного использования.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    void setprotoent (int stayopen)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция открывает для просмотра базу данных протоколов.
<P>Если аргумент stayopen  является отличным от нуля, она
устанавливает флаг так, чтобы последующие обращения к
getprotobyname или getprotobynumber не закрыли базу данных. Это
делается для большей эффективности, если Вы вызываете эти функции
несколько раз, избегая повторного открытия базы данных для каждого
обращения.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct protoent * getprotoent (void)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает следующий вход в базе данных протоколов.
Она возвращает пустой указатель, если не имеется больше входов.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    void endprotoent (void)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция закрывает базу данных протоколов.
<P>
<H3>Пример Internet сокета.</H3>

<P>
<P>Вот пример, показывающий, как создавать и называть сокет в
именном пространстве Internet. Созданный сокет существует
на машине, на которой выполняется программа. Вместо поиска и
использования адреса Internet машины, этот пример определяет
INADDR_ANY как главный адрес.
<P>
<P>
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
                #include &lt;stdio.h&gt;
                #include &lt;stdlib.h&gt;
                #include &lt;sys/socket.h&gt;
                #include &lt;netinet/in.h&gt;
                int
                make_socket (unsigned short int port)
                {
                        int sock;
                        struct sockaddr_in name;
                        sock = socket (PF_INET, SOCK_STREAM, 0);
                        if (sock &lt; 0)
                                {
                                        perror ("socket");
                                        exit (EXIT_FAILURE);
                                }
                        name.sin_family = AF_INET;
                        name.sin_port = htons (port);
                        name.sin_addr.s_addr = htonl (INADDR_ANY);
                        if (bind (sock, (struct sockaddr *) &amp;name,
                                                sizeof (name)) &lt; 0)
                                {
                                        perror ("bind");
                                        exit (EXIT_FAILURE);
                                }
                        return sock;
                }
</PRE>
</CODE></BLOCKQUOTE>

Вот другой пример, показывающий как Вы можете вносить в
структуре sockaddr_in, данную строку главного имени и номер порта:
<P>
<BLOCKQUOTE><CODE>
<PRE>
                #include &lt;stdio.h&gt;
                #include &lt;stdlib.h&gt;
                #include &lt;sys/socket.h&gt;
                #include &lt;netinet/in.h&gt;
                #include &lt;netdb.h&gt;
                void
                init_sockaddr (struct sockaddr_in *name, const
        char *hostname, unsigned short int port)
                {
                        struct hostent *hostinfo;
                        name-&gt;sin_family = AF_INET;
                        name-&gt;sin_port = htons (port);
                        hostinfo = gethostbyname (hostname);
                        if (hostinfo == NULL)
                                {
                                        fprintf (stderr, "Unknown host
                                                %s.\n", hostname);
                                        exit (EXIT_FAILURE);
                                }
                        name-&gt;sin_addr = *(struct in_addr *)
                        hostinfo-&gt;h_addr;
                }
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="ss11.6">11.6 Другие именные пространства</A>
</H2>

<P>
<P>Конечно другие именные пространства и связанные семейства
протоколов также реализованы, но не описаны здесь, потому что они редко
используются. PF_NS обращается к протоколам Программного
обеспечения Сети Ксерокса (Xerox Network Software). PF_ISO замещает
Открытые системы Связи (Open Systems Interconnect). PF_CCITT
обращается к протоколам из МККТТ (CCITT). "Socket.h" определяет
эти символы и другие протоколы.
<P>PF_IMPLINK используется для связи между главными ЭВМ и
Процессорами Сообщений Internet.
<P>
<H2><A NAME="ss11.7">11.7 Открытие и Закрытие сокетов</A>
</H2>

<P>
<P>Этот раздел описывает фактические библиотечные функции для
открытия и закрытия сокетов. Те же самые функции работают для всех
именных пространств и стилей соединения.
<P>
<P>
<P>
<P>
<P>
<H3>Создание сокета.</H3>

<P>
<P>Примитив для создания сокета - функция socket, объявлена в "sys/socket.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int socket (int namespace, int style, int protocol)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция создает сокет и определяет style стиль связи,
который должен быть одним из стилей сокетов, перечисленных в Разделе
11.2 [Стили Связи]. Аргумент namespace определяет именное
пространство; это должно быть PF_FILE (см. Раздел 11.4 [Именное
пространство Файла]) или PF_INET (см. Раздел 11.5 [Именное
пространство Internet]). protocol обозначает специфический протокол
(см. Раздел 11.1 [Понятия Гнезда] ).
<P>Возвращаемое значение из socket - описатель файла для нового
сокета, или -1 в случае ошибки. Следующие errno условия ошибки
определены для этой функции:
<DL>
<DT><B>EPROTONOSUPPORT </B><DD><P>
<P>Протокол или стиль не обеспечивается заданным именным
пространством.
<P>
<DT><B>EMFILE процесс имеет слишком много открытых описателей файла. </B><DD><P>
<P>
<DT><B>ENFILE </B><DD><P>система имеет слишком много открытыми описателей файла
<P>
<DT><B>EACCESS </B><DD><P>процесс не имеет привилегии, чтобы создать сокет
заданного стиля или протокола.
<P>
<DT><B>ENOBUFS </B><DD><P>в системе закончилось внутреннее пространство буфера.
</DL>

Описатель файла, возвращенный функцией socket поддерживает и
чтение и запись. Но, подобно трубопроводам, сокеты не поддерживают
операции позиционирования файла.
<P>Пример вызова функции socket см. Раздел 11.4 [Именное пространство Файла].
<P>
<H3>Закрытие сокета.</H3>

<P>
<P>Когда Вы закончили использование сокета, Вы можете просто
закрыть описатель файла примитивом close;
см. Раздел 8.1 [Открытие и Закрытие Файлов].
<P>Вы можете также выключать только прием или только передачу на
соединении, вызывая shutdown, которая объявлена в "sys/socket.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int shutdown (int socket, int how)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция shutdown выключает соединение с сокетом socket. Аргумент
how определяет какое действие выполнить:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    0 Остановка при получения данных для этого сокета.
    1 Остановка при передаче данных с этого сокета.
    2 Остановка и приема и передачи.
</PRE>
</CODE></BLOCKQUOTE>

Возвращаемое значение - 0 при успехе и -1 в случае неудачи. В переменной
errno определяются следующие коды ошибок для этой функции:
<DL>
<DT><B>EBADF </B><DD><P>socket - не допустимый описатель файла.
<DT><B>ENOTSOCK </B><DD><P>socket - не сокет.
<DT><B>ENOTCONN </B><DD><P>socket не соединен.
</DL>
<H3>Пары сокетов</H3>

<P>
<P>Пара socket состоит из пары соединенных (но неименованных)
сокетов. Это очень похоже на трубопровод и используется аналогичным
способом. Пары сокетов создаются функцией socketpair, описание в файле
"sys/socket.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int socketpair (int namespace, int style, int protocol, int fields[Function2])
</PRE>
</CODE></BLOCKQUOTE>

Эта функция создает пару сокетов, возвращая описатели файла в
fields [0] и fields [1]. Пара сокетов - дуплексный канал связи,
то есть и чтение и запись могут выполняться в любую сторону.
<P>Аргументы namespace, style и protocol интерпретируется как в
функции socket. style должен быть один из стилей связи,
перечисленных в Разделе 11.2 [Стили связb]. Аргумент именного
пространства определяет именное пространство, которое должно быть
AF_FILE (см. Раздел 11.4 [Именное пространство Файла]); protocol
определяет протокол связи.
<P>Если style определяет стиль связи без установки логического
соединения, то два сокета, которые Вы получаете, не соединены,
строго говоря, но каждое из них знает другое как заданный по
умолчанию адрес адресата, так что они могут посылать пакеты друг
другу.
<P>Функция Socketpair возвращает 0 при успехе и -1 при отказе.
В переменной errno определяются следующие коды ошибок для этой функции:
<DL>
<DT><B>EMFILE </B><DD><P>Процесс имеет слишком много открытых описателей файла.
<DT><B>EAFNOSUPPORT </B><DD><P>Не обеспечивается заданное именное пространство.
<DT><B>EPROTONOSUPPORT </B><DD><P>Не обеспечивается заданный протокол.
<DT><B>EOPNOTSUPP </B><DD><P>Заданный протокол не поддерживает создание пар сокетов.
</DL>
<H2><A NAME="ss11.8">11.8 Использование сокетов с соединениями.</A>
</H2>

<P>
<P>Наиболее общие стили связи включают создание соединения с
другим сокетом, и многократным обменом данными между этими сокетами.
Создание соединения асимметрично; одна сторона (клиент) действует,
чтобы запросить соединение, в то время как другая сторона (сервер)
создает сокет и ждет запрос на соединение.
<UL>
<LI>     Раздел 11.8.1 [Соединение], описывает то, что клиентская
программа должна делать, чтобы инициализировать соединение с
сервером.
</LI>
<LI>     Раздел 11.8.2 [Прием], и Раздел 11.8.3 [Принятие Соединений],
описывает то, что программа сервера должна делать, чтобы ждать и
делать после запросов соединения от клиентов.
</LI>
<LI>     Раздел 11.8.5 [Пересылка Данных], описывает, как данные
перемещаются через соединенные сокеты.</LI>
</UL>
<H3>Создание Соединения</H3>

<P>
<P>В создании соединения, клиент делает соединение, в то время как
сервер ждет и принимает соединение. Здесь мы обсуждаем то, что
клиентская программа должна делать, используя функцию connect,
которая объявлена в "sys/socket.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int connect (int socket, struct sockaddr *addr, size_t length) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция connect инициализирует соединение из сокета socket, чей адрес
определен аргументами length и addr. (Этот сокет обычно находится на другой
машине, и он должен быть установлен как сервер.)
См. Раздел 11.3 [Адреса Сокетов], для уточнения инфрмации относительно того,
как эти аргументы интерпретируются.
<P>Обычно, connect ждет, пока сервер не отвечает на запрос прежде. Вы можете
устанавливать режим неблокирования на сокете socket, чтобы заставить connect
возвратиться немедленно без ожидания ответа. См. Раздел 8.10 [Флаги Состояния
Файла], для уточнения инфрмации относительно неблокирования.
<P>Нормальное возвращаемое значение connect - 0. Если происходит
ошибка, connect возвращает -1. В переменной errno определяются следующие
коды ошибок для этой функции:
<DL>
<DT><B>EBADF </B><DD><P>сокет socket - не допустимый описатель файла.
<P>
<DT><B>ENOTSOCK </B><DD><P>указанный сокет - не сокет.
<P>
<DT><B>EADDRNOTAVAIL  </B><DD><P>заданный адрес не доступен на отдаленной машине.
<P>
<DT><B>EAFNOSUPPORT </B><DD><P>именное пространство addr не обеспечивается этим сокетом.
<P>
<DT><B>EISCONN </B><DD><P>указанный сокет уже соединен.
<P>
<DT><B>ETIMEDOUT </B><DD><P>попытка установить соединение не состоялась.
<P>
<DT><B>ECONNREFUSED </B><DD><P>сервер активно отказался устанавливать соединение.
<P>
<DT><B>ENETUNREACH </B><DD><P>сеть данного addr не доступна с этой главной ЭВМ.
<P>
<DT><B>EADDRINUSE </B><DD><P>адрес сокета для данного addr уже используется.
<P>
<DT><B>EINPROGRESS </B><DD><P>указанный сокет не-блокируемый, и соединение не могло бы быть
установлено немедленно.
<P>
<DT><B>EALREADY </B><DD><P>указанный сокет не-блокируемый и уже имеет отложенное
соединение.
</DL>
<H3>Ожидание Соединений</H3>

<P>
<P>Теперь рассмотрим то, что процесс сервера должен делать, чтобы
принять соединение из сокета. Это включает использование функции
listen, чтобы дать возможность запросам на соединения через сокет, и
позже использование функции accept (см. Раздел 11.8.3 [Принятие
Соединений] ) чтобы действовать по запросу. Функция listen используется
только для уже установленного логического соединения.
<P>В именном пространстве Internet, не сущестует специальных
механизмов защиты управления доступом к порту; любой процесс на
любой машине может установить соединение с вашим сервером. Если Вы
хотите ограничивать доступ к вашему серверу, заставьте его
исследовать адреса, связанные с запросами соединения или выполнять
некоторое другое подтверждение связи или протокол идентификации.
<P>В именном пространстве Файла, обычные биты защиты файла
управляют доступом к сокету.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int listen (int socket, unsigned int n)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция listen дает возможность указанному сокету воспринимать
соединения, таким образом создается сокет сервера.
<P>Аргумент n определяет длину очереди для отложенных соединений.
<P>Функция listen возвращает 0 при успехе и -1 в случае неудачи.
В переменной errno определяются следующие коды ошибок для этой функции:
<DL>
<DT><B>EBADF </B><DD><P>аргумент socket - не допустимый описатель файла.
<P>
<DT><B>ENOTSOCK </B><DD><P>аргумент socket - не сокет.
<P>
<DT><B>EOPNOTSUPP </B><DD><P>указанный сокет не поддерживает эту операцию.
</DL>
<P>
<H3>Принятие Соединений</H3>

<P>
<P>Когда сервер получает запрос соединения, он может создать
соединение, принимая запрос. Для этих целей следует использовать функцию
accept.
<P>Сокет, который был установлен как сервер, может принимать
запросы соединения от многих клиентов. Этот сокет сервера не станет
частью соединения; взамен, accept делает новый сокет, который
разделяет соединения. Accept возвращает описатель для этого сокета.
<P>Исходный сокет сервера остается доступным для ожидания
дальнейших запросов соединения.
<P>Число отложенных запросов соединения на сокете сервера конечно.
Если запросы соединения прибывают быстрее, чем сервер может
их обработать, очередь может заполниться, и дополнительные
запросы получат отказ с ошибкой ECONNREFUSED. Вы можете определять
максимальную длину этой очереди как аргумент функции listen, хотя
система может также наложить собственное внутреннее ограничение
длины этой очереди.
<P>
<P>
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int accept (int socket, struct sockaddr *addr, size_t *length_ptr)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция используется для принятия запроса на соединения в
указанном сокете сервера.
<P>Функция accept находится в состоянии ожидания, когда нет возможности
принять соединение, если, конечно, указанный сокет не имеет набор режимов
неблокирования. (Вы можете использовать select, чтобы ждать отложенное
соединение на неблокируемом сокете.) См. Раздел 8.10 [Флаги Состояния Файла],
для уточнения информации относительно режима неблокирования.
<P>Аргументы Addr и length_ptr используется, чтобы возвратить
информацию относительно имени клиентского сокета, которое
инициализировало соединение. См. Раздел 11.3 [Адреса сокетов], для
уточнения информации относительно формата.
<P>Сокет, который был установлен как сервер не станет частью
соединения; взамен, accept сделает новый сокет. Accept возвращает описатель
для этого сокета. Нормальное возвращаемое значение accept - описатель файла
для нового сокета.
<P>После accept, первоначально указанный сокет остается открытым и
не связанным, и продолжает ожидать, пока Вы не закрываете его. Вы
можете принимать дальнейшие соединения с этим сокетом, вызывая accept
снова.
<P>Если происходит ошибка, и accept возвращает -1.
В переменной errno определяются следующие коды ошибок для этой функции:
<DL>
<DT><B>EBADF </B><DD><P>аргумент socket - не допустимый описатель файла.
<P>
<DT><B>ENOTSOCK </B><DD><P>дескрипторный аргумент socket - не сокет.
<P>
<DT><B>EOPNOTSUPP </B><DD><P>описанный сокет не поддерживает эту операцию.
<P>
<DT><B>EWOULDBLOCK </B><DD><P>сокет имеет набор режимов неблокирования, и нет никаких
отложенных соединений.
</DL>

Функцию accept не позволяется применять для сокета без установления
логического соединения.
<P>
<H3>Кто соединен со Мной?</H3>

<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int getpeername (int socket, struct sockaddr *addr, size_t *length_ptr)  (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция Getpeername  возвращает адрес сокета, с которым сокет
соединен; она сохраняет адрес в пространстве памяти, заданном addr
и length_ptr. Она сохраняет также длину адреса в *length_ptr.
<P>См. Раздел 11.3 [Адреса Сокетов] , для уточнения информации
относительно формата адреса. В некоторых операционных системах,
getpeername работает только для сокетов в области Internet.
<P>Возвращаемое значение - 0 при успехе и -1 в случае неудачи.
В переменной errno определяются следующие коды ошибок для этой функции:
<DL>
<DT><B>EBADF </B><DD><P>аргумент socket - не допустимый описатель файла.
<P>
<DT><B>ENOTSOCK </B><DD><P>указанный сокет - не сокет.
<P>
<DT><B>ENOTCONN </B><DD><P>указанный сокет не соединен.
<P>
<DT><B>ENOBUFS </B><DD><P>нет внутренних доступных буферов.
</DL>
<P>
<H3>Пересылка Данных</H3>

<P>
<P>Если сокет был соединен с равным, Вы можете использовать обычные примитивы
read и write  (см. Раздел 8.2[Примитивы ввода - вывода]), чтобы передать
данные. Сокет - канал двусторонней связеи, так что чтение и запись может
выполняться в оба конца.
<P>Имеются также некоторые режимы ввода - вывода, которые являются
специфическими для операций с сокетами. Чтобы определять эти режимы, Вы
должны использовать функции recv и send  вместо более обобщенного
чтения и записи. Функции recv и send берут дополнительный
аргумент, который Вы можете использовать, чтобы определить
различные флаги, для управления специальными режимами ввода - вывода.
Например, Вы можете определить флаг MSG_OOB, чтобы читать
или писать внепоточные данные, а также  флаги MSG_PEEK или MSG_DONTROUTE.
<P>
<H3>Посылка Данных</H3>

<P>
<P>Функция send объявлена в файле "sys/socket.h". Если ваш аргумент flags
нуль, Вы можете точно также использовать write вместо send. Если сокет был
соединен, но соединение прервано, Вы получаете сигнал SIGPIPE для каждого
использования send или write (см. Раздел 21.2.6 [Разнообразные
Сигналы]).
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int send (int socket, void *buffer, size_t size, int flags) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция send - подобна write, но с дополнительными флагами Flags. Возможные
значения flags описаны в Разделе 11.8.5.3 [Опции Данных сокетов].
<P>Эта функция возвращает число переданных байтов, или -1 в противном случае.
Если сокет неблокируемый, то send (подобно write) может
возвращать после посылки только часть данных. См. Раздел 8.10 [Флаги Состояния
Файла], для уточнения информации относительно режима неблокирования.
<P>Обратите внимание, что успешное возвращаемое значение просто указывает, что
сообщение было послано без ошибки, и не обязательно, что оно было получено без
ошибки. В переменной errno определяются следующие коды ошибок для этой
функции:
<DL>
<DT><B>EBADF </B><DD><P>аргумент socket - не допустимый описатель файла.
<P>
<DT><B>EINTR </B><DD><P>операция был прервана сигналом прежде, чем любые данные
были посланы. См. Раздел 21.5 [Прерванные Примитивы].
<P>
<DT><B>ENOTSOCK </B><DD><P>указанный сокет - не сокет.
<P>
<DT><B>EMSGSIZE </B><DD><P>тип сокетаа требует, чтобы сообщение было послано
быстро, но сообщение слишком большое для этого.
<P>
<DT><B>EWOULDBLOCK </B><DD><P>на сокете был установле режим неблокирования, а операция
записи блокирует. (Обычно send блокирует, пока операция не может быть
завершена.)
<P>
<DT><B>ENOBUFS </B><DD><P>не имеется достаточного внутреннего доступного
пространства буфера.
<P>
<DT><B>ENOTCONN </B><DD><P>Вы не соединили этот сокет.
<P>
<DT><B>EPIPE </B><DD><P>Этот сокет был соединен, но соединение теперь разбито. В
этом случае send генерирует SIGPIPE сначала; если этот сигнал
игнорируется или блокируется, или если обработчик возвращается, то
происходит сбой send с EPIPE.
</DL>
<H3>Получение Данных</H3>

<P>
<P>Функция recv  объявлена в файле "sys/socket.h". Если ваш аргумент flags
является нулем, Вы можете точно также использовать read вместо recv;
см. Раздел 8.2 [Примитивы ввода-вывода].
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int recv (int socket, void *buffer, size_t size, int flags) (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция recv подобна read, но с дополнительными флагами flags.
Возможные значения flags описаны В Разделе 11.8.5.3 [Опции Данных
сокетов].
<P>Если режим неблокирования установлен для сокета, и никакие
данные не доступны для чтения, recv не ожидает, а сразу возвращает код ошибки.
См. Раздел 8.10 [Флаги Состояния Файла], для уточнения информации
относительно режима неблокирования.
<P>Эта функция возвращает число полученных байтов, или -1 в противном случае.
В переменной errno определяются следующие коды ошибок для этой функции:
<DL>
<DT><B>EBADF </B><DD><P>аргумент socket - не допустимый описатель файла.
<P>
<DT><B>ENOTSOCK </B><DD><P>дескриптор socket - не сокет.
<P>
<DT><B>EWOULDBLOCK </B><DD><P>Режим неблокирования был установлен на сокете.
(Обычно, recv блокирует пока не имеется входа, доступного для чтения.)
<P>
<DT><B>EINTR </B><DD><P>операция была прервана сигналом прежде, чем любые данные
прочитались. См. Раздел 21.5 [Прерванные Примитивы].
<P>
<DT><B>ENOTCONN </B><DD><P>Вы не соединили этот сокет.
</DL>
<P>
<H3>Опции Данных сокета.</H3>

<P>
<P>Аргумент flags для send и recv - битовая маска. Вы можете
объединить значения следующих макрокоманд вместе (через OR), чтобы
получить значение для этого аргумента. Все они определены в файле
"sys/socket.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int MSG_OOB   (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Посылка или получение данных вне потока. См. Раздел 11.8.8
[Данные вне потока].
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int MSG_PEEK  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Рассмотрение данных, но не удаление их из входной очереди.
Это применимо только для функций типа recv (для send не подходят).
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int MSG_DONTROUTE  (макрос)
</PRE>
</CODE></BLOCKQUOTE>

Не включать информацию о маршрутизации в сообщении. Это имеет смысл
только с операциями вывода, и обычно представляет интерес только
для диагностики программы.
<P>
<P>
<P>
<H3>Пример сокета с потоком байтов.</H3>

<P>
<P>Вот пример программы клиента, которая устанавливает соединение для
сокета в пространстве Internet с поточным типом передачи данных. Она не
делает ни чего особенно интересного; если она соединилась с
сервером, она посылает текстовую строку серверу и выходит.
<P>
<BLOCKQUOTE><CODE>
<PRE>
                #include &lt;stdio.h&gt;
                #include &lt;errno.h&gt;
                #include &lt;stdlib.h&gt;
        #include &lt;unistd.h&gt;
                #include &lt;sys/types.h&gt;
        #include &lt;sys/socket.h&gt;
        #include &lt;netinet/in.h&gt;
        #include &lt;netdb.h&gt;
        #define PORT    5555
        #define MESSAGE "Yow!!! Are we having fun yet?!?"
        #define SERVERHOST              "churchy.gnu.ai.mit.edu"
        void
        write_to_server (int filedes)
        {
                int nbytes;
                nbytes=write(filedes,MESSAGE,strlen(MESSAGE)+1);
                if (nbytes &lt; 0)
                        {
                                perror ("write");
                                exit (EXIT_FAILURE);
                        }
        }
        int
        main (void)
        {
                extern void init_sockaddr(struct sockaddr_in*name,
                                                const char *hostname,
                                                unsigned short int port);
                int sock;
                struct sockaddr_in servername;
                sock = socket (PF_INET, SOCK_STREAM, 0);
                if (sock &lt; 0)
                        {
                                perror ("socket (client)");
                                exit (EXIT_FAILURE);
                        }
                init_sockaddr (&amp;servername, SERVERHOST, PORT);
                if (0 &gt; connect (sock,
                                        (struct sockaddr *) &amp;servername,
                                        sizeof (servername)))
                        {
                                perror ("connect (client)");
                                exit (EXIT_FAILURE);
                        }
                write_to_server (sock);
                close (sock);
                exit (EXIT_SUCCESS);
        }
</PRE>
</CODE></BLOCKQUOTE>
<H3>Пример соединения сервера (Тип соединения - поток байтов)</H3>

<P>
<P>Текст программы сервера намного более сложен. Так как мы хотим
предоставлять многим клиентам быть соединенными с сервером, но в то же самое
время, было бы неправильно ждать ввод от одиночного клиента,  просто
вызывая read или recv. Взамен, нужно использовать select (см.
Раздел 8.6 [Ждущий ввод - вывод] ), чтобы ждать ввод на всех
открытых сокетах. Это также позволяет серверу иметь дело с
дополнительными запросами соединения.
<P>Этот специфический сервер не делает хоть что-нибудь интересное,
если он получил сообщение от клиента, то он закрывает сокет клиента
по получению признака конца файла.
<P>Эта программа использует make_socket и init_sockaddr для устанавления
адреса сокета; см. раздел 11.5.7 [Inet Пример].
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        #include &lt;stdio.h&gt;
        #include &lt;errno.h&gt;
        #include &lt;stdlib.h&gt;
        #include &lt;unistd.h&gt;
        #include &lt;sys/types.h&gt;
        #include &lt;sys/socket.h&gt;
        #include &lt;netinet/in.h&gt;
        #include &lt;netdb.h&gt;
        #define PORT   5555
        #define MAXMSG  512
        int
        read_from_client (int filedes)
        {
                char buffer[MAXMSG];
                int nbytes;
                nbytes = read (filedes,buffer,MAXMSG); 
                if (nbytes &lt; 0)
                        {
                                perror ("read");
                                exit (EXIT_FAILURE);
                        }
                else if (nbytes == 0)
                        return -1;
                else
                        {
                                fprintf (stderr, "Server: got message:  
                                        `%s'\n", buffer);
                                        return 0;
                        }
        }
        int
        main (void)
        {
                extern int make_socket (unsigned short int port);
                int sock;
                int status;
                fd_set active_fd_set, read_fd_set;
                int i;
                struct sockaddr_in clientname;
                size_t size;
                sock = make_socket (PORT);
                if (listen (sock, 1) &lt; 0)
                {
                        perror ("listen");
                        exit (EXIT_FAILURE);
                }
                FD_ZERO (&amp;active_fd_set);
                FD_SET (sock, &amp;active_fd_set);
                while (1)
                        {
                                if (select (FD_SETSIZE,
                                        &amp;read_fd_set, NULL,
                                        NULL, NULL) &lt; 0)
                                {
                                        perror ("select");
                                        exit (EXIT_FAILURE);
                                }
                        if (FD_ISSET (i, &amp;read_fd_set))
                        {
                                if (i == sock)
                                {
                                        if (accept (sock,
                        (struct sockaddr *) &amp;clientname, &amp;size) &lt; 0)
                                                                                        
                                {
                                                perror ("accept");
                                                exit (EXIT_FAILURE);
                                        }
                                        fprintf (stderr,
                "Server: connect from host %s, port %hd.\n",
                                        inet_ntoa (clientname.sin_addr),
                                        ntohs (clientname.sin_port));
                                        FD_SET (status, &amp;active_fd_set);
                                }
                                else
                                {
                                        if (read_from_client (i)&lt;0)
                                        {
                                                close (i);
                                                FD_CLR (i, &amp;active_fd_set);
                                        }
                                }
                        }
                }
        }
</PRE>
</CODE></BLOCKQUOTE>
<H3>Данные Вне потока</H3>

<P>
<P>Потоки с соединениями разрешающими данные вне потока  имеют
приоритет выше, чем обычные данные. Обычно причина для посылки
данных вне потока - исключительные условия. Способ послать
данные вне потока использует send с флагом MSG_OOB (см. Раздел
11.8.5.1 [Посылка Данных]).
<P>Данные вне потока посылаются с высшим приоритетом, плюс процесс получения
не обрабатывает их в обыкновенное очереди, но чтобы читать доступные данные
вне потока следует использовать recv с флагом MSG_OOB (см. Раздел 11.8.5.2
[Получение Данных]). Обычные операции чтения не воспринимают данные вне
потока; они читают только обычные данные.
<P>Когда сокет находит, что данные вне потока продвигаются, он
посылает сигнал SIGURG процессу владельца или группе процессов
сокета. Вы можете определять владельца, используя команду F_SETOWN
для функции fcntl; см. Раздел 8.12 [Ввод Прерывания]. Вы должны
также установить обработчик для этого сигнала, как описано в Главе
21 [Обработка Сигналов], для соответствующего действия типа чтения
данных вне потока.
<P>В качестве альтернативы, Вы можете проверять задержать данные
вне потока, или ждать данные вне потока, при использовании функции
select; она может ждать исключительное условие на гнезде. См.
Раздел 8.6 [Ждущий ввод - вывод].
<P>
<P>Уведомление о данных вне потока (с SIGURG или с select)
обозначает, что данные вне потока находятся в пути; данные не могут
фактически прибывать позже. Если Вы пробуете читать данные
вне потока прежде, чем они ппребывают, то  recv генерирует ошибку с
кодом EWOULDBLOCK.
<P>Посылка таких данных автоматически помещает "метку" в потоке
обычных данных, показывающую, где в последовательности данных "
были бы "данные вне потока. Это полезно, когда значение данных вне
потока - " отменяет все посланное до ". Вот, как Вы можете в
процессе получения проверять, были ли любые обычные данные посланы
перед меткой:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    success = ioctl (socket, SIOCATMARK, &amp;result);
</PRE>
</CODE></BLOCKQUOTE>

Имеется функция, чтобы отбросить любые обычные данные,
предшествующие данным вне потока:
<BLOCKQUOTE><CODE>
<PRE>
                int
                discard_until_mark (int socket)
                {
                        while (1)
                        {
                                char buffer[1024];
                                int result, success;
                                success = ioctl (socket, SIOCATMARK,
                                &amp;result); if (success &lt; 0)
                                perror ("ioctl");
                                if (result)
                                        return;
                                success = read (socket, buffer, sizeof
                                                buffer);
                                if (success &lt; 0)
                                perror ("read");
                        }
                }
</PRE>
</CODE></BLOCKQUOTE>

Если Вы не хотите отбрасывать обычные данные, предшествующие
метке, Вам необходимо создать место во внутренних буферах систем для данных
вне потока. Если Вы пробуете читать данные вне потока и получаете ошибку
EWOULDBLOCK, попробуйте читать некоторые обычные данные (сохраняя их
так, чтобы Вы могли использовать их позже) и смотрите появится ли
необходимое место. Вот пример:
<BLOCKQUOTE><CODE>
<PRE>
                struct buffer
                {
                        char *buffer;
                        int size;
                        struct buffer *next;
                };
        struct buffer *
        read_oob (int socket)
        {
                struct buffer *tail = 0;
                struct buffer *list = 0;
                while (1)
                {
                        char *buffer = (char *) xmalloc (1024);
                        struct buffer *link;
                        int success;
                        int result;
                        success = recv (socket, buffer, sizeof
                buffer, MSG_OOB);
                        if (success &gt;= 0)
                        {
                                link-&gt;size = success;
                                link-&gt;next = list;
                                return link;
                        }
                        success = ioctl (socket, SIOCATMARK,
                &amp;result);
                         if (success &lt; 0)
                                perror ("ioctl");
                        if (result)
                        {
                                sleep (1);
                                continue;
                        }
                        success = read (socket, buffer, sizeof
                        buffer);
                        if (success &lt; 0)
                        perror ("read");
                        {
                                link-&gt;size = success;
                                if (tail)
                                        tail-&gt;next = link;
                                else
                                        list = link;
                                tail = link;
                        }
                }
        }
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="ss11.9">11.9 Датаграмные операции сокета</A>
</H2>

<P>
<P>Этот раздел описывает, как использовать стили связи, которые не
используют соединения (стили SOCK DGRAM и SOCK_RDM). При
использовании этих стилей, Вы группируете данные в пакеты, и каждый
пакет - независимая связь. Вы определяете адресата для каждого
пакета индивидуально.
<P>Датаграмные пакеты подобны письмам: Вы посылаете каждый
независимо, с собственным адресом адресата, и они могут прибывать в
неправильном порядке или вообще не прибывать.
<P>Функции listen и accept не предназначены для сокетов, использующих
стили связи без установки логического соединения.
<P>
<P>
<P>
<P>
<P>
<P>
<H3>Посылка Датаграмм</H3>

<P>
<P>Нормальный способ посылки данных относительно датаграмного
сокета использует функцию sendto, объявленную в "sys/socket.h".
<P>!!! Вы можете вызывать connect  на  датаграмном  сокете,  но  эта
функция  определяет заданного по умолчанию адресата для дальнейшей пе&shy;
редачи данных на сокете.  Когда сокет имеет по умолчанию заданного ад&shy;
ресата, Вы можете использовать send (см. Раздел 11.8.5.1 [Посылка Дан&shy;
ных] ) или write (см.  Раздел 8.2 [Примитивы ввода - вывода] ) для по&shy;
сылки пакетов. Вы можете отменять заданного по умолчанию адресата, вы&shy;
зывая connect,  и используя формат адреса AF_UNSPEC в аргументе  addr.
См. Раздел 11.8.1 [Соединение].
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int sendto (int socket, void *buffer. size_t size, int flags, sockaddr *addr, size_t length)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция пересылает данные из buffer через сокет socket по
заданному адресу. size задает число пересылаемых байт.
<P>Flags интерпретируется также как и в send; см. Раздел 11.8.5.3 [Опции
данных сокетов].
<P>Возвращаемое значение и условия ошибок такие же как и для send,
но Вы не можете полагаться на систему для обнаружения ошибок и
сообщения о них; наиболее общая ошибка состоит в том, что пакет
потеряется или не имеется никого в заданном адресе, чтобы получить
его, и операционная система на вашей машине обычно не знает этого.
<P>Также возможно, что для одного обращения к sendto она сообщит
ошибку из-за проблемы  связанной  с предыдущим обращением.
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<H3>Получение Датаграмм</H3>

<P>
<P>Функция recvfrom читает пакет из датаграмного сокета и также
сообщает Вам, откуда он был послан. Эта функция объявлена в "sys/socket.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int recvfrom (int socket, void *buffer, size_t size, int flags, struct sockaddr *addr, size_t *length_ptr)
</PRE>
</CODE></BLOCKQUOTE>

Функция recvfrom читает один пакет из указанного сокета в указанный буфер.
<P>Аргумент size определяет максимальное число байтов, которые
нужно читать.
<P>Если пакет является больше чем size байт, то, Вы получаете
первые size байт пакета, а остальная часть пакета потеряна. Не
существует способа прочитать остальную часть пакета. Таким
образом, когда Вы используете протокол пакетов, Вы должны всегда
знать длину ожидаемого пакета.
<P>Аргументы addr и length_ptr  используются для  возвращения
адреса источника пакета. См. Раздел 11.3 [Адреса сокетов]. Для
сокета в области файла, информация адреса не будет значима, так как
Вы не можете читать адрес такого сокета (см. Раздел 11.4 [Именное
пространство Файла] ). Вы можете определять пустой указатель как
аргумент addr, если Вы не заинтересованы в этой информации.
<P>Flags интерпретируется тем же самым способом как recv (см.
Раздел 11.8.5.3 [Опции Данных сокета]). Возвращаемое значение и
условия ошибки - такие же как для recv.
<P>Вы можете использовать recv (см. Раздел 11.8.5.2 [Получение
Данных]) вместо recvfrom, если знаете, что не должны выяснить,
кто послал пакет. Даже read, может использоваться, если Вы не
хотите определять flags (см. Раздел 8.2 [Примитивы ввода &shy;
вывода]).
<P>
<P>
<P>
<H3>Датаграмный Пример сокета.</H3>

<P>
<P>Вот набор примеров программ, которые посылают сообщения используя
датаграмный стиль. И клиент и сервер используют функцию make_named_socket,
которая была предоставлена в Разделе 11.4 [Именное пространство Файла], для
создания и  связывания сокетов.
<P>Сначала программа сервера. Очевидно, это не особенно полезная
программа, но она показывает общие идеи.
<BLOCKQUOTE><CODE>
<PRE>
                #include &lt;stdio.h&gt;
                #include &lt;errno.h&gt;
                #include &lt;stdlib.h&gt;
                #include &lt;sys/socket.h&gt;
                #include &lt;sys/un.h&gt;
                #define SERVER  "/tmp/serversocket"
                #define MAXMSG  512
                int
                main (void)
                {
                        int sock;
                        char message[MAXMSG];
                        struct sockaddr_un name;
                        size_t size;
                        int nbytes;
                        sock = make_named_socket (SERVER);
                        while (1)
                        {
                                size = sizeof (name);
                                nbytes=recvfrom(sock,message,MAXMSG,0,
                                        (struct sockaddr*) &amp; name,&amp;size);
                                if (nbytes &lt; 0)
                                {
                                        perror ("recfrom (server)");
                                        exit (EXIT_FAILURE);
                                }
                                fprintf (stderr, "Server: got message:
                                %s\n", message);
                                nbytes=sendto(sock,message,nbytes,0,
                                        (struct sockaddr*) &amp; name,size);
                                if (nbytes &lt; 0)
                                {
                                        perror ("sendto (server)");
                                        exit (EXIT_FAILURE);
                                }
                        }
                        }
</PRE>
</CODE></BLOCKQUOTE>
<H3>Пример Чтения Датаграмм</H3>

<P>
<P>Вот программа клиента, соответствующая серверу выше.
<P>Она посылает датаграмму серверу и ждет ответ. Обратите внимание,
что сокету клиента (также как для сервера) в этом примере должно
быть дано имя. Так, чтобы сервер мог направлять сообщение обратно
клиенту. Так как сокет не имеет никакого связанного состояния
соединения, единственый способ, которым сервер может сделать это
ссылаясь на имя клиента.
<BLOCKQUOTE><CODE>
<PRE>
                #include &lt;stdio.h&gt;
                #include &lt;errno.h&gt;
                #include &lt;unistd.h&gt;
                #include &lt;stdlib.h&gt;
                #include &lt;sys/socket.h&gt;
                #include &lt;sys/un.h&gt;
                #define SERVER  "/tmp/serversocket"
                #define CLIENT  "/tmp/mysocket"
                #define MAXMSG  512
                #define MESSAGE "Yow!!! Are we having fun yet?!?"
                int
                main (void)
                {
                        extern int make_named_socket (const
                char *name);
                        int sock;
                        char message[MAXMSG];
                        struct sockaddr_un name;
                        size_t size;
                        int nbytes;
                        sock = make_named_socket (CLIENT);
                        name.sun_family = AF_UNIX;
                        strcpy (name.sun_path, SERVER);
                        size = strlen (name.sun_path) + sizeof (name.sun_family);
                        nbytes = sendto (sock, MESSAGE,
        strlen (MESSAGE) + 1, 0, (struct sockaddr *) &amp; name, size);
                        if (nbytes &lt; 0)
                        {
                                perror ("sendto (client)");
                                exit (EXIT_FAILURE);
                        }
                nbytes =recvfrom(sock,message,MAXMSG,0,NULL,0);
                if (nbytes &lt; 0)
                {
                        perror ("recfrom (client)");
                        exit (EXIT_FAILURE);
                }
                fprintf (stderr,"Client: got message: %s\n",message);
                        remove (CLIENT);
                        close (sock);
                }
</PRE>
</CODE></BLOCKQUOTE>

Имейте в виду, что датаграмная связь сокетов ненадежна. В этом
примере программа клиента ждет неопределенное время, если сообщение
никогда не достигает сервера, или, если ответ сервера никогда не
возвращается. Более автоматическое решение могло бы  использовать
select (см. Раздел 8.6 [Ждущий ввод - вывод]), чтобы установить
период блокировки по времени для ответа, и в этом случае или снова послать
сообщение, или выключить сокет и выйти.
<P>
<P>
<P>
<H2><A NAME="ss11.10">11.10 Демон Inetd</A>
</H2>

<P>
<P>Мы объяснили выше, как написать программу сервера, которая
реализует собственное ожидание. Такой сервер должен уже выполниться
для любого соединения с ним.
<P>Другой способ обеспечивать обслуживание портов для Internet
состоит в том, чтобы использовать в программе для ожидания демона inetd.
Inetd - программа, которая выполняется все время и ждет (используя
select) сообщения на заданном наборе портов. Когда она получает
сообщение, она принимает соединение (если стиль сокета запрашивает
соединение), и тогда запускает дочерний процесс, чтобы выполнить
соответствующую программу сервера. Вы определяете порты и их
программы в файле "/etc/inetd.conf".
<P>
<H3>Inetd Серверы</H3>

<P>
<P>Написание программы сервера, которая будет выполнена inetd очень
просто. Каждый раз когда кто-то запрашивает соединение с
соответствующим портом, стартует новый процесс сервера. Соединение
уже существует в это время; гнездо доступно как описатель
стандартного ввода и как описатель стандартного вывода (описатели 0
и 1) в процессе сервера. Так что программа сервера может начинать
читать и писать данные сразу же. Часто программа нуждается только в
обычных средствах ввода-вывода; фактически, универсальная
программа-фильтр, которая не знает ничего относительно сокетов, может
работать как сервер потока байтов, запускаемая inetd.
<P>Вы можете также использовать inetd для серверов, которые
используют стили связи без установления логического соединения. Для
этих серверов, inetd не пробует принять соединение, так как никакое
соединение не возможно. Она только начинает программу сервера,
которая может читать входящий датаграмный пакет из описателя 0.
Программа сервера может обрабатывать один запрос и выходить,
или читать большое количество запросов. Вы должны определить, который из этих
двух методов использования сервера удобен Вам при конфигурации inetd.
<P>
<P>
<H3>Конфигурирование inetd</H3>

<P>
<P>Файл "/etc/inetd.conf " сообщает inetd, какие порты ожидает какой
сервер для обработки пакетов. Обычно каждый вход в файле - это строка, но Вы
можете разбивать его на много строк, если все, кроме первой строки входа,
начинаются с пропуска. Строки, которые начинаются с "*" являются
комментариями.
<P>Имеются два стандартных входа в "/etc/inetd.conf":
<P>
<BLOCKQUOTE><CODE>
<PRE>
    ftp stream tcp nowait root /libexec/ftpd ftpd
    talk dgram udp wait root /libexec/talkd talkd
</PRE>
</CODE></BLOCKQUOTE>

Вход имеет формат:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    service style protocol wait username program arguments
</PRE>
</CODE></BLOCKQUOTE>

Поле service говорит, какое обслуживание обеспечивает эта программа.
Это должно быть имя обслуживания, определенного в "/etc/services". Inetd
использует обслуживание, чтобы решить какой порт слушать для этого входа.
<P>style и protocol определяют стиль связи и протокол для
использования ожидающего сокета. Стиль должен иметь имя стиля
связи, преобразованного в строчные буквы и с удаленным "SOCK_",
например, "stream" или "dgram". Протокол должен быть один из
протоколов, перечисленных в "/etc/protocols". Типичные имена
протокола - "tcp" для соединений потока байтов и "udp" для
ненадежных датаграмм.
<P>Поле wait должно быть, или "wait" или "nowait". "wait" используется, если
стиль не требует установления логического соединения и обрабатывает
многократные запросы. "nowait" используется, когда необходимо,чтобы inetd
начинал новый процесс для каждого сообщения, или запроса, который приходит.
Если используется соединение, то wait должен быть "nowait".
<P>user - имя пользователя, под которым сервер должен выполняться.
Inetd выполняется под пользователя root, так что она может устанавливать ID
пользователей дочерних процессов произвольно. Лучше избегать
использования "root" для пользователя; но некоторые серверы, типа Telnet и
FTP, читают username и пароль самостоятельно. Эти серверы должны быть
запущены под пользователя root изначально, так как они могут регистрировать
потоки данных передаваемых по сети.
<P>program вместе с аргументами определяет команду, для запуска
сервера. Это должно быть абсолютное имя файла, определяющее
исполняемый файл для выполнения. Аргументы состоят из любого числа
отделенных пробелами слов, которые станут аргументами командной
строки программы.
<P>Первое слово в аргументах - нуль, который должен быть
именем программы непосредственно (каталоги sans).
<P>Если Вы редактируете "/etc/inetd.conf", то Вы можете указывать
необходимость повторного чтения файла для inetd и сообщения нового
содержимого, посылая inetd сигнал SIGHUP. Вы будете должны использовать ps,
чтобы определить ID процесса inetd, поскольку оно не фиксировано.
<P>
<H2><A NAME="ss11.11">11.11 Опции сокетов.</A>
</H2>

<P>
<P>Этот раздел описывает, как читать или установить различные
опции, которые изменяют поведение сокетов и их основных протоколов
связи.
<P>Когда Вы манипулируете опциями сокета, Вы должны определить, к
какому уровню они относятся, то есть применяется ли опция
к интерфейсу сокета, или к интерфейсу протокола связи низшего
уровня.
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<H3>Функции Опций сокета.</H3>

<P>
<P>Имеются функции для исследования и изменения опций сокета. Они
объявлены в "sys/socket.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
       int getsockopt (int socket, int level, int optname, void *optval, size_t *optlen_ptr)
</PRE>
</CODE></BLOCKQUOTE>

Функция getsockopt получает информацию относительно значения
опции optname заданного уровня для указанного сокета.
<P>Значение опции сохранено в буфере, на который указывает optval.
Перед обращением, Вы должны обеспечить в * optlen_ptr размер этого
буфера; по возвращении, он содержит число байтов информации,
фактически сохраненной в буфере.
<P>Большинство опций интерпретирует буфер optval как одиночное
значение int.
<P>Фактически возвращаемое значение getsockopt - 0 при успехе и -1
в случае неудачи. В переменной errno отражены следующие возможные
причины:
<DL>
<DT><B>EBADF </B><DD><P>аргумент socket - не допустимый описатель файла.
<P>
<DT><B>ENOTSOCK </B><DD><P>дескриптор socket - не сокет.
<P>
<DT><B>ENOPROTOOPT  </B><DD><P>Optname не имеет смысла для данного уровня.
</DL>

<BLOCKQUOTE><CODE>
<PRE>
    int setsockopt (int socket, int level, int optname, void *optval, size_t optlen)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция используется, чтобы установить опцию сокета optname
заданного уровня для указанное сокета. Значение опции передано в
буфере optval, который имеет размер optlen.
<P>
<P>Возвращаемое значение и коды ошибки для setsockopt такие же
как для getsockopt.
<P>
<H3>Опции уровня сокета.</H3>

<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int SOL_SOCKET  (константа)
</PRE>
</CODE></BLOCKQUOTE>

Используйте эту константу, как аргумент level для getsockopt или
setsockopt, чтобы манипулировать опциями уровня сокета, описанными
в этом разделе.
<P>Вот таблица имен опций уровня сокета; все они определены в файле
"sys/socket.h".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    SO_DEBUG
</PRE>
</CODE></BLOCKQUOTE>

Эта опция переключает запись информации об отладке в основных
модулях протокола. Значение имеет тип int; значение отличное от
нуля означает "да".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    SO_REUSEADDR
</PRE>
</CODE></BLOCKQUOTE>

Эта опция говорит bind (см. Раздел 11.3.2 [Установка Адреса])
разрешить многократное использование местных адресов для этого
сокета. Если Вы пользуетесь этой опцией, Вы можете фактически
иметь два сокета с тем же самым номером порта Internet. Необходимость в
этой опции возникает, потому что что некоторые протоколы Internet с более
высоким уровнем, такие FTP, требуют, чтобы Вы многократно использовали
тот же самый номер сокета.
<P>Значение имеет тип int; значение отличное от нуля означает "да".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    SO_KEEPALIVE
</PRE>
</CODE></BLOCKQUOTE>

Эта опция указывает, должен ли основной протокол периодически
передавать сообщения на соединенный сокет. Если адресат будет не
в состоянии отвечать на эти сообщения, соединение  рассматривается
разорваным. Значение имеет тип int; значение отличное от нуля
означает "да".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    SO_DONTROUTE
</PRE>
</CODE></BLOCKQUOTE>

Эта опция контролирует при посылке сообщения обход нормальных
средств посылки сообщений. Если она установлена, сообщения
посылаются непосредственно сетевому интерфейсу. Значение имеет тип
int; значение отличное от нуля означает "да".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    SO_LINGER
</PRE>
</CODE></BLOCKQUOTE>

Эта опция определяет то, что должно случиться, в случае, когда сокет
предоставляющий надежную выдачу все еще не передал сообщения, до закрытия;
см. Раздел 11.7.2 [Закрытие сокета]. Значение имеет тип struct linger.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct linger  (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Эта структура имеет следующие элементы:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int l_onoff
</PRE>
</CODE></BLOCKQUOTE>

Это поле интерпретируется как булевское. Оно отлично от нуля, если
блокировка закрыта, пока данные не переданы, или период блокировки
по времени не истек.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int l_linger
</PRE>
</CODE></BLOCKQUOTE>

Определяет период блокировки по времени, в секундах.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    SO_BROADCAST
</PRE>
</CODE></BLOCKQUOTE>

Эта опция определяет могут ли датаграммы быть широковещательно переданы из
сокета. Значение имеет тип int; значение отличное от нуля означает
"да".
<P>
<P>
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    SO_OOBINLINE
</PRE>
</CODE></BLOCKQUOTE>

Если эта опция установлена, данные вне потока получаемые в
сокет помещаются в нормальную входную очередь. Она разрешает
читать их, используя read или recv без того, чтобы определить
флаг MSG_OOB. См. Раздел 11.8.8 [Данные вне потока]. Значение имеет
тип int; значение отличное от нуля означает "да".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    SO_SNDBUF
</PRE>
</CODE></BLOCKQUOTE>

Эта опция получает или устанавливает размер буфера вывода.
Значение size_t является его размером в байтах.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    SO_RCVBUF
</PRE>
</CODE></BLOCKQUOTE>

Эта опция получает или устанавливает размер буфера ввода.
Значение size_t является его размером в байтах.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    SO_STYLE
</PRE>
</CODE></BLOCKQUOTE>

<BLOCKQUOTE><CODE>
<PRE>
    SO_TYPE
</PRE>
</CODE></BLOCKQUOTE>

Эта опция может использоваться только с getsockopt. Она используется,
чтобы получить стиль связи сокета. SO_TYPE - историческое имя, а
SO_STYLE - привилегированное имя в GNU. Значение имеет тип int, и обозначает
стиль связи; см. Раздел 11.2 [Стили Связи].
<P>
<BLOCKQUOTE><CODE>
<PRE>
    SO_ERROR
</PRE>
</CODE></BLOCKQUOTE>

Эта опция может использоваться только с getsockopt. Она
используется, чтобы сбросить состояние ошибки сокета. Значение
int представляет собой предыдущее состояние ошибки.
<P>
<P>
<P>
<P>
<P>
<P>
<H2><A NAME="ss11.12">11.12 База данных Сетей</A>
</H2>

<P>
<P>Много систем приходят с базой данных, которая записывает список
сетей, известных разработчику системы. Она обычно сохраняется или в
файле "/etc/networks" или в блоке преобразования имен. Эта база данных полезна
для маршрутизации программ типа route, но бесполезна для программ, которые
просто связываются по сети. Функции предназначенные для обращения
к этой базе данных описаны  в "netdb.h ".
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct netent                 (тип данных)
</PRE>
</CODE></BLOCKQUOTE>

Этот тип данных используется, чтобы представить информацию
относительно входов в базе данных сетей.
<P>Он имеет следующие элементы:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    char *n_name
</PRE>
</CODE></BLOCKQUOTE>

Это - "официальное" имя сети.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    char **n_aliases
</PRE>
</CODE></BLOCKQUOTE>

Это альтернативные имена для сети, представляемые как вектор
строк. Пустой указатель завершает массив.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    int n_addrtype
</PRE>
</CODE></BLOCKQUOTE>

Это - тип сетевого номера; он всегда равно AF_INET для сетей
Internet.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    unsigned long int n_net
</PRE>
</CODE></BLOCKQUOTE>

Это сетевой номер. Сетевые числа представлены в главном порядке
байтов; см. Раздел 11.5.5 [Порядок Байтов].
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct netent * getnetbyname (const char *name)     (функция)
</PRE>
</CODE></BLOCKQUOTE>

Getnetbyname функция возвращает информацию относительно сети
именованной name. Она возвращает пустой указатель, если нет
никакой сети.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct netent * getnetbyaddr (long net, int type)   (функция)
</PRE>
</CODE></BLOCKQUOTE>

Функция getnetbyaddr  возвращает информацию относительно сети
указанного типа с номером net. Вы должны определить значение
AF_INET для аргумента type для сети Internet.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    getnetbyaddr возвращает пустой указатель в случае отсутствия такой сети.
</PRE>
</CODE></BLOCKQUOTE>

Вы можете также просматривать базу данных сетей, используя
setnetent, getnetent, и endnetent. Будьте внимательным в
использовании этих функций, потому что они не предназначены для повторного
использования.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    void setnetent (int stayopen)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция открывает базу данных сетей.
<P>Если аргумент stayopen  является отличным от нуля, то она
устанавливает флаг так, чтобы последующие обращения к getnetbyname
или getnetbyaddr не закрыли базу данных. Это делается для большей
эффективности, если Вы вызываете эти функции несколько раз, избегая
повторного открытия базы данных для каждого обращения.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    struct netent * getnetent (void)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция возвращает следующий вход в базе данных сетей. Она
возвращает пустой указатель, если не имеется больше входов.
<P>
<BLOCKQUOTE><CODE>
<PRE>
    void endnetent (void)
</PRE>
</CODE></BLOCKQUOTE>

Эта функция закрывает базу данных сетей.
<P>
<P>
<P>
<P>
<HR>
<A HREF="glibc-12.html">Вперед</A>
<A HREF="glibc-10.html">Назад</A>
<A HREF="glibc.html#toc11">Содержание</A>

<!--htdig_noindex-->
<noindex>
<br>

<table id=ibm_adv align=center><tr valign=top><td width="605">
<iframe src="http://www.opennet.ru/adv_lc.html" height="240" width="605" scrolling="no" name="ibm" border="0" frameborder="0" target="_blank" marginheight="0" marginwidth="0"></iframe>
</td></tr></table>
</noindex>
<!--/htdig_noindex-->


<!-- footer -->
<!--htdig_noindex-->
<br>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=1 WIDTH="100%" BGCOLOR="#B0B190">
<TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%" VALIGN="MIDDLE">
<TR>
<TD WIDTH="35%" BGCOLOR="#E9EAD6" ALIGN=LEFT>
<FONT SIZE="-1">
&nbsp;&nbsp;<A HREF="http://www.opennet.ru/cgi-bin/opennet/bookmark.cgi">Закладки&nbsp;на&nbsp;сайте</A><BR>
&nbsp;&nbsp;<A HREF="http://www.opennet.ru/cgi-bin/opennet/bookmark.cgi?submit=add" target="blank_">Проследить&nbsp;за&nbsp;страницей</A>
</FONT>
</TD>
<TD WIDTH="65%" ALIGN=RIGHT BGCOLOR="#E9EAD6">
<FONT SIZE="-1">Created&nbsp;1996-2014&nbsp;by&nbsp;<B><A HREF="http://www.opennet.ru/contact.shtml" title="email mc@tyumen.ru">Maxim&nbsp;Chirkov</A></B></FONT>&nbsp;&nbsp;<BR>
<FONT SIZE="-1"><A HREF="http://www.opennet.ru/add.shtml">Добавить</A>,&nbsp;<A HREF="http://www.opennet.ru/reklama.shtml">Реклама</A>,&nbsp;<A HREF="http://www.opennet.ru/banners2.shtml">Вебмастеру</A>,&nbsp;<A HREF="http://www.opennet.ru/guide.shtml">ГИД</A></FONT>&nbsp;&nbsp;
</TD>
</TR>
</TABLE>
</TD></TR>
</TABLE>


<div align=right><table><tr><td>
<a target=_blank href="http://www.runnet.ru"><img src="http://www.opennet.ru/img/runnet.gif" border=0 height=31 width=88 alt="RUNNet"></a>
<a target=_blank href="http://top.list.ru/jump?from=77689"><img src="http://top.list.ru/counter?id=77689;t=75;l=1" border=0 height=31 width=38 alt="TopList"></a>
<script type="text/javascript"><!--
document.write("<a href='http://www.liveinternet.ru/click' "+
"target=_blank><img src='//counter.yadro.ru/hit?t45.6;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+
"' alt='' title='LiveInternet' "+
"border='0' width='31' height='31'><\/a>")
//--></script>
<a target=_blank href="http://counter.rambler.ru/top100/"><img src="http://counter.rambler.ru/top100.cnt?10566" width=1 height=1 border=0><img src="http://www.opennet.ru/banner.gif" width=88 height=31 border=0></a>
</td></tr></table>
</div>
</form>
<!--/htdig_noindex-->
<!-- end of footer -->

</BODY>
</HTML>
