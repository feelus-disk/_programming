<html>
<head>
<title>Программа Ping</title>
</head>

<body>
<div>


<p><small><a HREF="index.html"><img SRC="contents.jpg" BORDER="0" WIDTH="94" HEIGHT="20"></a><a HREF="../home.htm"><img SRC="begin.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava8.html"><img SRC="forward.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava6.html"><img SRC="back_b.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a href="index.html"><img SRC="index.jpg" border="0" WIDTH="68" HEIGHT="20"></a></small></p>

<font FACE="Arial" SIZE="4">



<p><a NAME="t070000"></a>Глава 7 Программа Ping</p>

</font><font FACE="Arial"><font size="3"><u>



<p><b><a NAME="t071000"></a>Введение</p>

</b></u></font>



<p><small><a NAME="t071001"></a>Программа Ping предназначена для

проверки доступности удаленного хоста.

Программа посылает <a NAME="t071002"></a>ICMP эхо запрос на

хост и ожидает возврата ICMP эхо отклика. (На

рисунке 6.3 приведен список типов ICMP сообщений.) </small></p>



<p><small>Обычно, если Вы не можете послать Ping на хост,

то не сможете получить доступ к этому хосту,

используя Telnet или FTP. С другой стороны, если Вы не

можете зайти на хост с помощью Telnet, Ping, как

правило, начальная точка, с которой начинается

идентификация проблемы. Помимо этого, с помощью

Ping можно оценить время возврата пакета от хоста,

что дает представление о том, &quot;насколько

далеко&quot; находится хост. </small></p>



<p><small>В этой главе мы воспользуемся программой Ping

в качестве диагностического средства, а также

для дальнейшего рассмотрения ICMP. Кроме

упомянутого выше, Ping имеет опции записи маршрута

и временной марки. Раздел 11 [Stevens 1990] содержит

исходные тексты программы Ping.</small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">Раньше можно было

считать верным утверждение, что если мы не можем

послать Ping на хост, то не сможем работать с хостом

и с использованием Telnet или FTP. В настоящее время

это утверждение не является верным. Связано это с

тем, что в сети Internet появились повышенные

требования к секретности. Маршрутизаторы

поддерживают списки доступа, появились <a NAME="t071003"></a>шлюзы,

использующие технологию firewall. В настоящее время

доступность хоста основывается не только на

доступности IP уровня, а также от того, какой

используется протокол и какой при этом работает

порт. Ping может показывать хост как недоступный,

однако мы можем получить доступ через Telnet на порт

25 (почтовый сервер).</font></p>

</font>



<p><small><a NAME="t072000"></a>&nbsp;</small></p>

<font size="3"><u><b>



<p>Программа Ping</p>

</b></u></font>



<p><small>Мы будем называть программу ping, которая

посылает эхо запросы - клиент, а хост, на который

посылаются эхо запросы - сервер. Большинство

реализаций TCP/IP поддерживают Ping сервер

непосредственно в ядре - сервер не является

пользовательским процессом. (Два сервиса,

работающие с ICMP запросами, которые мы описали в <a HREF="glava6.html">главе 6</a>, маска адреса и запросы

временной марки, также обрабатываются

непосредственно в ядре.) На рисунке 7.1 показаны ICMP

эхо запрос и эхо отклик.<a NAME="t072001"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t7_1.jpg" WIDTH="513" HEIGHT="167"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 7.1 Формат ICMP сообщения для

эхо запроса и эхо отклика.</small></p>



<p>&nbsp;</p>



<p><small>Так же, как в случае других ICMP запросов, в

отклике сервера должены содержаться поля

идентификатора (identifier) и номера

последовательности (sequence number). Кроме того, любые

дополнительные данные, посланные клиентам,

должны быть отражены эхом. </small></p>



<p><small>Реализации ping, присутствующие в Unix,

устанавливают в поле идентификатора ICMP

сообщения идентификатор процесса, отправляющего

запрос. Это позволяет программе ping

идентифицировать вернувшийся ответ, если на

одном и том же хосте в одно и то же время запущено

несколько программ ping. </small></p>



<p><small>Номер последовательности начинается с 0 и

увеличивается на единицу каждый раз когда

посылается следующий эхо запрос. ping печатает

номер последовательности каждого возвращенного

пакета, позволяя нам увидеть, потерялся ли пакет,

поменялась ли последовательность движения

пакетов и был ли пакет продублирован. Так как IP

является ненадежным сервисом доставки

датаграмм, любое из трех вышеперечисленных

условий может появиться при работе программы ping. </small></p>



<p><small>Исторически сложилось так, что программа ping

посылает эхо запрос один раз в секунду, печатая

каждый эхо отклик в момент его возвращения.

Однако новые разработки требуют указания опции <a NAME="t072002"></a>-s, чтобы программа работала подобным

образом. По умолчанию новые реализации посылают

только один эхо запрос и выдают сообщение &quot;host is

alive&quot; (хост доступен), если эхо отклик получен,

или &quot;no answer&quot; (не отвечает), если отклик не

получен в течение 20 секунд.</small></p>

<font size="3"><i><b>



<p>Работа программы в локальных сетях</p>

</b></i></font>



<p><small>Вывод программы ping при работе в локальных

сетях обычно выглядит следующим образом:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>bsdi % <b>ping svr4</b><br>

PING svr4 (140.252.13.34): 56 data bytes<br>

64 bytes from 140.252.13.34: icmp_seq=0 ttl=255 time=0 ms<br>

64 bytes from 140.252.13.34: icmp_seq=1 ttl=255 time=0 ms<br>

64 bytes from 140.252.13.34: icmp_seq=2 ttl=255 time=0 ms<br>

64 bytes from 140.252.13.34: icmp_seq=3 ttl=255 time=0 ms<br>

64 bytes from 140.252.13.34: icmp_seq=4 ttl=255 time=0 ms<br>

64 bytes from 140.252.13.34: icmp_seq=5 ttl=255 time=0 ms<br>

64 bytes from 140.252.13.34: icmp_seq=6 ttl=255 time=0 ms<br>

64 bytes from 140.252.13.34: icmp_seq=7 ttl=255 time=0 ms<br>

^<b>?</b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; чтобы

остановить ping, вводим символ прерывания<br>

--- svr4 ping statistics ---<br>

8 packets transmitted, 8 packets received, 0% packet loss<br>

round-trip min/avg/max = 0/0/0 ms<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Когда принимается ICMP эхо отклик, печатается

номер последовательности, затем параметр время

жизни (TTL) и рассчитанное время возврата. (<a NAME="t072003"></a>TTL это поле времени жизни в IP заголовке.

В настоящее время программа ping в BSD печатает

полученное TTL каждый раз, когда принимается эхо

отклик - некоторые реализации этого не делают. Мы

рассмотрим использование TTL в <a HREF="glava8.html">главе 8</a>

с программой <a NAME="t072004"></a>traceroute.) </small></p>



<p><small>Как видно из примера, приведенного выше, эхо

отклики возвращаются в том же порядке, в котором

были отправлены (0, 1, 2 и так далее). </small></p>



<p><small>ping может рассчитать время возврата, так как

он сохраняет время, когда был отправлен эхо

запрос, в разделе данных ICMP сообщения. Когда

отклик возвращается, эти данные извлекаются и

сравниваются с текущим временем. Обратите

внимание на то, что посылающая система, bsdi, во

всех случаях рассчитала время возврата равное 0

мс. Это объясняется тем, что программе доступен

таймер с низким разрешением. Система <a NAME="t072005"></a>BSD/386

может использовать только таймер с дискретом 10

мс. (Мы обсудим это более подробно в <a HREF="glavaB.html">приложении

В</a>.) Позже, с использованием вывода команды <a NAME="t072006"></a>tcpdump, мы увидим, что в системах с часами

с более высоким разрешением (Sun) разница во

времени между ICMP эхо запросом и эхо откликом

составляет примерно 4 мс. </small></p>



<p><small>Первая строка вывода содержит IP адрес хоста

назначения, даже если было указано имя (svr4). Это

означает, что имя было преобразовано в IP адрес. Мы

рассмотрим процедуру преобразования и DNS в <a HREF="glava14.html">главе 14</a>. После запуска программы ping

проходит несколько секунд, перед тем как

появляется первая строка вывода с напечатанным IP

адресом, это время необходимо DNS, чтобы

определить IP адрес, соответствующий имени хоста. </small></p>



<p><small>На рисунке 7.2 показан вывод tcpdump для этого

примера.<a NAME="t072007"></a></small></p>




<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p> 1 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi

&gt; svr4: icmp: echo request<br>

2 0.003733 (0.0037)&nbsp;&nbsp;&nbsp; svr4 &gt; bsdi: icmp: echo reply<br>

<br>

3 0.998045 (0.9943)&nbsp;&nbsp;&nbsp; bsdi &gt; svr4: icmp: echo request<br>

4 1.001747 (0.0037)&nbsp;&nbsp;&nbsp; svr4 &gt; bsdi: icmp: echo reply<br>

<br>

5 1.997818 (0.9961)&nbsp;&nbsp;&nbsp; bsdi &gt; svr4: icmp: echo request<br>

6 2.001542 (0.0037)&nbsp;&nbsp;&nbsp; svr4 &gt; bsdi: icmp: echo reply<br>

<br>

7 2.997610 (0.9961)&nbsp;&nbsp;&nbsp; bsdi &gt; svr4: icmp: echo request<br>

8 3.001311 (0.0037)&nbsp;&nbsp;&nbsp; svr4 &gt; bsdi: icmp: echo reply<br>

<br>

9 3.997390 (0.9961)&nbsp;&nbsp;&nbsp; bsdi &gt; svr4: icmp: echo request<br>

10 4.001115 (0.0037)&nbsp;&nbsp;&nbsp; svr4 &gt; bsdi: icmp: echo reply<br>

<br>

11 4.997201 (0.9961)&nbsp;&nbsp;&nbsp; bsdi &gt; svr4: icmp: echo request<br>

12 5.000904 (0.0037)&nbsp;&nbsp;&nbsp; svr4 &gt; bsdi: icmp: echo reply<br>

<br>

13 5.996977 (0.9961)&nbsp;&nbsp;&nbsp; bsdi &gt; svr4: icmp: echo request<br>

14 6.000708 (0.0037)&nbsp;&nbsp;&nbsp; svr4 &gt; bsdi: icmp: echo reply<br>

<br>

15 6.996764 (0.9961)&nbsp;&nbsp;&nbsp; bsdi &gt; svr4: icmp: echo request<br>

16 7.000479 (0.0037)&nbsp;&nbsp;&nbsp; svr4 &gt; bsdi: icmp: echo reply<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Рисунок 7.2 Вывод ping при работе в локальной

сети.</small></p>



<p>&nbsp;</p>



<p><small>Время между отправкой эхо запроса и приемом

эхо отклика составляет 3,7 мс. Также мы видим, что

эхо запросы посылаются с интервалом примерно в 1

секунду. </small></p>



<p><small>Часто бывает, что первое время возврата

больше чем все остальные. Это происходит в том

случае, если аппаратный адрес назначения

отсутствует в ARP кэше отправителя. Как мы помним

из <a HREF="glava4.html">главы 4</a>, отправка ARP запроса и

получение ARP отклика может занять несколько

миллисекунд, только после этого отправляется

первый эхо запрос. Это проиллюстрировано в

следующем примере:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>sun % <b>arp -a</b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; убедимся,

что ARP кэш пуст<br>

<br>

sun % <b>ping svr4</b><br>

PING svr4: 56 data bytes<br>

64 bytes from svr4 (140.252.13.34): icmp_seq=0. time=7. ms<br>

64 bytes from svr4 (140.252.13.34): icmp_seq=1. time=4. ms<br>

64 bytes from svr4 (140.252.13.34): icmp_seq=2. time=4. ms<br>

64 bytes from svr4 (140.252.13.34): icmp_seq=3. time=4. ms<br>

^<b>? </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим

символ прерывания<br>

---- svr4 PING Statistics ----<br>

4 packet transmitted, 4 packets received, 0% packets loss<br>

round-trip (ms) min/avg/max = 4/4/7<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Дополнительные 3 миллисекунды в первом RTT

скорее всего потрачены на отправку ARP запроса и

получение отклика. </small></p>



<p><small>Этот пример был запущен на хосте sun, который

имеет таймер с разрешением в одну микросекунду,

но не смотря на это, программа ping печатает время

возврата только с разрешением в одну

миллисекунду. В предыдущем примере, запущенном

под <a NAME="t072008"></a>BSD/386 Version 0.9.4, время возврата равно

0 миллисекунд, так как таймер имеет разрешение в 10

миллисекунд. Следующий вывод получен с

использованием BSD/386 Version 1.0, где есть таймер с

разрешением в одну микросекунду. Существует

версия программы ping, которая имеет более высокое

временное разрешение.</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>bsdi % <b>ping svr4</b><br>

PING svr4 (140.252.13.34): 56 data bytes<br>

64 bytes from 140.252.13.34: icmp_seq=0 ttl=255 time=9.304 ms<br>

64 bytes from 140.252.13.34: icmp_seq=1 ttl=255 time=6.089 ms<br>

64 bytes from 140.252.13.34: icmp_seq=2 ttl=255 time=6.079 ms<br>

64 bytes from 140.252.13.34: icmp_seq=3 ttl=255 time=6.096 ms<br>

^<b>?</b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим

символ прерывания<br>

--- svr4 ping statistics ---<br>


4 packets transmitted, 4 packets received, 0% packet loss<br>

round-trip min/avg/max = 6.079/6.880/9.304 ms<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>

<font size="3"><i><b>



<p>Работа программы в глобальных сетях</p>

</b></i></font>



<p><small>При работе в глобальных сетях результат

может значительно отличаться. Следующий пример

был получен в рабочий день после полудня, время,

когда Internet обычно довольно загружен:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>gemini % <b>ping vangogh.cs.berkeley.edu</b><br>

PING vangogh.cs.berkeley.edu: 56 data bytes<br>

64 bytes from (128.32.130.2): icmp_seq=0. time=660. ms<br>

64 bytes from (128.32.130.2): icmp_seq=5. time=1780. ms<br>

64 bytes from (128.32.130.2): icmp_seq=7. time=380. ms<br>

64 bytes from (128.32.130.2): icmp_seq=8. time=420. ms<br>

64 bytes from (128.32.130.2): icmp_seq=9. time=390. ms<br>

64 bytes from (128.32.130.2): icmp_seq=14. time=110. ms<br>

64 bytes from (128.32.130.2): icmp_seq=15. time=170. ms<br>

64 bytes from (128.32.130.2): icmp_seq=16. time=100. ms<br>

^<b>?</b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим

символ прерывания<br>

---- vangogh.CS.Berkeley.EDU PING Statistics ----<br>

17 packets transmitted, 8 packets received, 52% packet loss<br>

round-trip (ms) min/avg/max = 100/501/1780<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Эхо запросы и эхо отклики с номерами

последовательности 1, 2, 3, 4, 6, 10, 11, 12 и 13 были

потеряны. Также обратите внимание на

значительную разницу между величинами времен

возврата. (Количество потерянных пакетов, а

именно 52%, является ненормальным. Это неприемлимо

для Internet даже в рабочие дни после полудня.) </small></p>



<p><small>При работе в глобальных сетях можно

встретиться с дублированием пакетов (один и тот

же номер последовательности появляется дважды

или несколько раз), также может возникнуть

перемешивание номеров последовательности (номер

последовательности N+1 появляется перед номером

последовательности N). </small></p>

<font size="3"><i><b>



<p><a NAME="t072009"></a>Выделенные SLIP каналы</p>

</b></i></font>



<p><small>Давайте рассмотрим время возврата при

работе по SLIP каналам, так как они обычно работают

в асинхронном режиме с низкими скоростями,

например 9600 бит/сек или меньше. Обратимся к

расчету <a NAME="t072010"></a>пропускной способности

последовательной линии, приведенному в разделе <a HREF="glava2.html#t02A000">&quot;Вычисление загруженности

последовательной линии&quot;</a> главы 2.

Предположим, скорость SLIP канала между хостами bsdi

и slip составляет 1200 бит/сек. </small></p>



<p><small>Оценить время возврата можно следующим

образом. Во-первых, обратимся к примеру вывода Ping,

показанному ранее. По умолчанию, ICMP сообщение

содержит 56 байт данных. А также, 20 байт IP

заголовка и 8 байт ICMP заголовка, что в сумме дает

размер IP датаграммы - 84 байта. (Мы можем проверить

это, запустив tcpdump <a NAME="t072017"></a>-e, с помощью этой

опции можно посмотреть размеры Ethernet фреймов.) Из

раздела <a HREF="glava2.html#t024000">&quot;SLIP: IP по

последовательной линии&quot;</a> главы 2 мы знаем, что

в начало и в конец датаграммы добавляется по

меньшей мере два дополнительных байта, а именно -

байт END. Не исключено, что при создании фреймов SLIP

будут добавлены дополнительные байты, однако это

зависит от величины каждого байта в датаграмме.

Предположим, что скорость составляет 1200 бит/сек,

в байте 8 бит, один старт-бит и один стоп-бит, при

этом скорость будет 120 байт/сек или 8,33 мс на один

байт. Время возврата составит (86 x 8,33 x 2) или 1433 мс.

(Здесь умножается на 2 потому, что мы рассчитываем

время возврата - то есть время, за которое пакет

ушел и вернулся.) </small></p>



<p><small>Следующий вывод должен подтвердить

правильность наших вычислений: </small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>svr4 % <b>ping -s slip</b><br>

PING slip: 56 data bytes<br>

64 bytes from (192.42.62.1): icmp_seq=0. time=1480. ms<br>

64 bytes from (192.42.62.1): icmp_seq=1. time=1480. ms<br>

64 bytes from (192.42.62.1): icmp_seq=2. time=1480. ms<br>

64 bytes from (192.42.62.1): icmp_seq=3. time=1480. ms<br>

^<b>?</b><br>

---- slip PING Statistics ----<br>

5 packets transmitted, 4 packets received, 20% packet loss<br>

round-trip (ms) min/avg/max = 1480/1480/1480<br>

</p>



<p>&nbsp;</p>

</font><font FACE="Arial">



<p><small>(Опция <a NAME="t072011"></a>-s необходима для <a NAME="t072012"></a>SVR4, чтобы посылать один запрос каждую

секунду.) Время возврата составляет почти 1,5

секунды, однако программа все еще посылает ICMP эхо

запросы с интервалом в 1 секунду. Это означает,

что будет выдано два эхо запроса (в момент

времени 0 и в момент времени 1), перед тем как

вернется первый отклик (момент времени 1,480).

Именно поэтому программа считает, что один пакет

потерян. В действительности он не был потерян,

скорее всего он еще просто не вернулся. </small></p>



<p><small>Мы снова обратимся к медленному SLIP каналу в <a HREF="glava8.html">главе 8</a>, когда будем рассматривать

работу программы <a NAME="t072013"></a>traceroute. </small></p>

<font size="3"><i><b>



<p><a NAME="t072014"></a>SLIP каналы с дозвоном (Dialup) </p>

</b></i></font>



<p><small>При использовании SLIP каналов с дозвоном

существуют некоторые отличия, так как на каждом

конце канала присутствуют модемы. Модемы,

которые используются между системами netb и sun,

предоставляют то, что называется модуляцией V.32

(9600 бит/сек), контроль ошибок V.42 (также иногда

называемый LAP-M) и сжатие данных V.42bis. Это означает,

что наши простые вычисления, которые были

достаточно точны для выделенного канала, где

известны все параметры, в таких условиях

практически неверны. </small></p>



<p><small>В данном случае играют роль несколько

фактов. <a NAME="t072015"></a>Модемы вносят некоторую

задержку. Размер пакета может быть уменьшен

благодаря сжатию данных, однако размер может

быть и увеличен, так как используется протокол

контроля ошибок. В дополнение, принимающий модем

не может выдать полученные байты данных до тех

пор, пока не будет проверена <a NAME="t072016"></a>контрольная

сумма. И в завершение, на каждом конце

используется последовательный асинхронный

интерфейс компьютера, а большинство

операционных систем читают эти интерфейсы через

определенный интервал времени или после того,

как было получено определенное количество

символов. </small></p>



<p><small>В следующем примере мы послали ping на хост

gemini с хоста sun.</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>sun % <b>ping gemini</b><br>

PING gemini: 56 data bytes<br>

64 bytes from gemini (140.252.1.11): icmp_seq=0. time=373. ms<br>

64 bytes from gemini (140.252.1.11): icmp_seq=1. time=360. ms<br>

64 bytes from gemini (140.252.1.11): icmp_seq=2. time=340. ms<br>

64 bytes from gemini (140.252.1.11): icmp_seq=3. time=320. ms<br>

64 bytes from gemini (140.252.1.11): icmp_seq=4. time=330. ms<br>

64 bytes from gemini (140.252.1.11): icmp_seq=5. time=310. ms<br>

64 bytes from gemini (140.252.1.11): icmp_seq=6. time=290. ms<br>

64 bytes from gemini (140.252.1.11): icmp_seq=7. time=300. ms<br>

64 bytes from gemini (140.252.1.11): icmp_seq=8. time=280. ms<br>

64 bytes from gemini (140.252.1.11): icmp_seq=9. time=290. ms<br>

64 bytes from gemini (140.252.1.11): icmp_seq=10. time=300. ms<br>

64 bytes from gemini (140.252.1.11): icmp_seq=11. time=280. ms<br>

----gemini PING Statistics----<br>

12 packets transmitted, 12 packets received, 0% packet loss<br>

round-trip (ms) min/avg/max = 280/314/373<br>

</p>




<p>&nbsp;</p>

</font><font FACE="Arial">



<p><small>Обратите внимание на то, что в первой строке

RTT не кратен 10 миллисекундам, однако в остальных

строках значение RTT кратно 10 миллисекундам. Если

запустить этот пример несколько раз, то можно

заметить, что подобное поведение сохранится. (Это

вызвано точностью часов хоста sun - они

предоставляют разрешение в одну миллисекунду.

Это было проверено тестами, которые приведены в <a HREF="glavaB.htm">приложении В</a>.) </small></p>



<p><small>Также обратите внимание на то, что первый RTT

больше чем следующие, а остальные уменьшаются в

процессе работы команды и их диапазон находится

между 280 и 300 мс. Если не останавливать программу

примерно минуту или две, RTT останутся в этом

диапазоне, никогда не уменьшаясь меньше чем 260 мс.

Если рассчитать ожидаемый RTT для скорости 9600

бит/сек (<a HREF="#t075001">упражнение 2</a> главы 7),

величина составит 180 миллисекунд, таким образом

мы ошиблись в расчете примерно в 1,5 раза от

реального значения. </small></p>



<p><small>Если программа ping будет работать в течение

60 секунд, то среднее RTT при использовании V.42 и V.42bis

составит 277 миллисекунд. (Это лучше, чем значение,

полученное в предыдущем примере, так как

программа работала долше, при этом значение RTT

застабилизировались в определенном диапазоне.)

Если выключить сжатие данных V.42bis, то среднее

значение составит 330 миллисекунд. Если выключить

контроль ошибок V.42 (который также выключается

при выключении сжатия данных V.42bis), среднее

значение составит 300 миллисекунд. Эти параметры

модемов влияют на RTT, однако все же лучше

использовать контроль ошибкок и сжатие данных. </small></p>

<font size="3"><u><b>



<p><a NAME="t073000"></a>Опция записи IP маршрута</p>

</b></u></font>



<p><small>Программа ping предоставляет возможность

просмотреть IP опцию записи маршрута (RR). В

большинстве версий программы ping присутствует

опция <a NAME="t073001"></a>-R, которая включает

характеристику записи маршрута. При

использовании этой опции ping устанавливает опцию

IP записи маршрута (RR) в исходящих датаграммах

(которые содержат ICMP эхо запрос). При этом каждый

маршрутизатор, который обрабатывает датаграмму,

добавляет свой IP адрес в список, находящийся в

дополнительном поле. Когда датаграмма достигает

конечного пункта назначения, список IP адресов

копируется в исходящий ICMP эхо отклик, а все

маршрутизаторы на обратном пути также добавляют

свои IP адреса в список. Когда ping принимает эхо

отклик, печатает список IP адресов. </small></p>



<p><small>Как бы просто это не звучало, в

действительности, запись маршрута - достаточно

сложный процесс. Генерация IP опции RR хостом

источником, обработка опции RR промежуточными

маршрутизаторами и отражение входящего списка RR

из ICMP эхо запроса в исходящий ICMP эхо отклик все

это дополнительные и необязательные

характеристики. Большинство систем в настоящее

время поддерживают эти дополнительные

характеристики, однако некоторые системы не

отображают список IP адресов. </small></p>



<p><small>Самая большая проблема, однако, заключается

в ограниченном размере IP заголовка, в который

должен поместиться список IP адресов. Из рисунка

3.1 видно, что <a NAME="t073002"></a>поле длины заголовка

(header length) в IP заголовке составляет 4 бита, что

ограничивает размер IP заголовка в пределах

пятнадцати 32-битных слов (60 байт). Так как

фиксированный размер IP заголовка составляет 20

байт, а RR опция использует 3 байта для своей

установки (что мы опишем ниже), то остается 37 байт

(60-20-3) на список адресов, а это, в свою очередь,

позволяет поместить туда до 9 IP адресов. На заре

развития <a NAME="t073003"></a>ARPANET 9 IP адресов - было очень

много, однако, в настоящее время, подобный размер

существенно ограничивает работу команды ping с

опцией -R. (В <a HREF="glava8.html">главе 8</a> мы рассмотрим

программу Traceroute, которая используется для

отслеживания маршрута, по которому двигается

датаграмма.) Несмотря на все ограничения, опция

записи маршрута работает и предоставляет

возможность пронаблюдать, как обрабатываются

опции IP. На рисунке 7.3 показан общий формат опции

записи маршрута в IP датаграмме.<a NAME="t073004"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t7_3.jpg" WIDTH="515" HEIGHT="154"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 7.3 Общий формат опции

маршрута в IP заголовке.</small></p>



<p>&nbsp;</p>



<p><small>Код (code) - однобайтовое поле, содержащее тип

IP опции. Для опции RR установлено значение 7. <a NAME="t073005"></a>Длина (len) - это полный размер в байтах

опции RR, в данном случае 39. (Несмотря на то, что

существует возможность указать опцию RR с

размером меньше максимального, ping всегда

предоставляет поле опции размером 39 байт, что

позволяет записать до 9 IP адресов. Несмотря на то,

что существует ограничение в размере опций в IP

заголовке, оно, тем не менее, позволяет указать

размер меньше максимального.) </small></p>



<p><small>Указатель (ptr) - это индекс в 39-байтной опции,

который указывает на то, где хранится следующий IP

адрес. Его минимальное значение 4, что указывает

на первый IP адрес. Когда следующий IP адрес

записывается в список, значение ptr меняется

следующим образом: 8, 12, 16 и так до 36. После того как

записан девятый адрес, ptr устанавливается в

значение 40, указывая на то, что список полон. А

теперь давайте зададим себе такой вопрос. </small></p>



<p><small>Когда маршрутизатор (который по

определению имеет <a NAME="t073006"></a>несколько

интерфейсов) записывает свой IP адрес в список,

какой IP адрес он записывает? Это должен быть

адрес либо входящего интерфейса, либо

исходящего. RFC 791 [<a NAME="t073007"></a>Postel 1981a] указывает,

что маршрутизатор записывает IP адрес исходящего

интерфейса. Однако, мы увидим, что когда исходный

хост (хост, запустивший ping) получает ICMP эхо отклик

с включенной опцией RR, он вносит в список IP адрес

своего входящего интерфейса.</small></p>

<font size="3"><i><b>



<p>Обычный пример</p>

</b></i></font>



<p><small>Давайте попробуем запустить программу ping с

опцией RR. Мы запустили ping с хоста svr4 на хост slip.

Промежуточный роутер (bsdi) обрабатывает

датаграмму, следующий вывод будет получен от svr4:</small></p>




<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>svr4 % <b>ping -R slip</b><br>

PING slip (140.252.13.65): 56 data bytes<br>

64 bytes from 140.252.13.65: icmp_seq=0 ttl=254 time=280 ms<br>

RR: bsdi (140.252.13.66)<br>

slip (140.252.13.65)<br>

bsdi (140.252.13.35)<br>

svr4 (140.252.13.34)<br>

64 bytes from 140.252.13.65: icmp_seq=1 ttl=254 time=280 ms (same route)<br>

64 bytes from 140.252.13.65: icmp_seq=2 ttl=254 time=280 ms (same route)<br>

^<b>?</b><br>

--- slip ping statistics ---<br>

3 packets transmitted, 3 packets received, 0% packet loss<br>

round-trip min/avg/max = 270/276/280 ms<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>На рисунке 7.4 показаны 4 пересылки, через

которые проходит пакет (по две в каждом

направлении), а также IP адреса добавляемые к

списку RR при каждой пересылке.<a NAME="t073008"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t7_4.jpg" WIDTH="527" HEIGHT="144"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 7.4 Программа ping с опцией

записи маршрутизации.</small></p>



<p>&nbsp;</p>



<p><small>Маршрутизатор bsdi добавляет в список разные

IP адреса в зависимости от направления движения

датаграммы. Он всегда добавляет IP адрес

исходящего интерфейса. Однако, когда ICMP эхо

отклик достигает системы, которая инициировала

запрос (svr4), она добавляет в список IP адрес

входящего интерфейса. </small></p>



<p><small>Мы можем наблюдать за обменом пакетами с

хоста sun, на котором запущена программа <a NAME="t073009"></a>tcpdump

с опцией <a NAME="t073010"></a>-v (просмотр IP опций). На

рисунке&nbsp;7.5 показан вывод.<a NAME="t073011"></a></small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>1&nbsp; 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4&gt;slip:


icmp: echo request (ttl 32, id 35835, <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; optlen=40

RR{39}=RR{#0.0.0.0/0.0.0.0/0.0.0.0/ <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.0.0.0/0.0.0.0/0.0.0.0/0.0.0.0/0.0.0.0/0.0.0.0}

EOL)<br>

<br>

2&nbsp; 0.267746 (0.2677)&nbsp;&nbsp;&nbsp; slip&gt;svr4: icmp: echo reply (ttl 254, id

1976, <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; optlen=40

RR{39}=RR{140.252.13.66/140.252.13.65/ <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 140.252.13.35/#0.0.0.0/0.0.0.0/0.0.0.0/0.0.0.0/

0.0.0.0/0.0.0.0} EOL)<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Рисунок 7.5 Вывод программы tcpdump c записью

опций маршрутизации. </small></p>



<p>&nbsp;</p>



<p><small>Вывод optlen=40 указывает на то, что

пространство опций в IP заголовке, используемое в

данном случае, равно 40 байтам. (Обратите внимание,

длина IP заголовка должна быть кратна 4 байтам.) RR

{39} означает, что включена опция записи маршрута,

а длина ее поля составляет 39. Затем приводится

список из 9 IP адресов, знак (#) показывает на

который из IP адресов указывает поле ptr в

заголовке опции RR. Так как мы наблюдали за

пакетами с хоста sun (см. рисунок 7.4), то видели

только ICMP эхо запросы с пустым списком и ICMP эхо

отклики, в списке которых содержится 3 адреса. Мы

удалили оставшиеся строки в выводе tcpdump, так как

они практически идентичны тем, которые показаны

на рисунке 7.5. </small></p>



<p><small>Комбинация <a NAME="t073012"></a>EOL в конце записи

маршрута указывает на IP опцию &quot;конец списка&quot;

(end of list). Опция EOL имеет значение 0. В поле опций IP

заголовка, состоящего из 40 байт присутствует 39

байт данных RR. Так как пространство опций

устанавливается в 0, перед тем как датаграмма

отсылается, последний байт 0 следующий за 39-ю

байтами данных RR интерпретируется как EOL. Если в

поле опций IP заголовка присутствует несколько

опций и появляется необходимость использовать

байты заполнения перед началом следующей опции,

используется специальный символ &quot;нет

операции&quot; (<a NAME="t073013"></a>NOP - no operation), значение

которого равно единице.</small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">На рисунке 7.5 <a NAME="t073014"></a>SVR4

устанавливает в поле <a NAME="t073015"></a>TTL в эхо запросе

значение 32, а <a NAME="t073016"></a>BSD/386 устанавливает

значение 255. (Это значение печатается как 254,

потому что маршрутизатор bsdi уже успел уменьшить

это значение на единицу.) Все новые системы

устанавливают TTL ICMP сообщений по максимуму (255). </font></p>



<p><font color="#0000A0">Необходимо отметить, что две

системы, BSD/386 и SVR4, из трех TCP/IP реализаций,

описываемых в качестве примера в этой книге,

поддерживают опцию записи маршрута. Таким

образом, они корректно обновляют RR список при

перенаправлении датаграммы. Также они корректно

отражают RR список из входящих ICMP эхо запросов в

исходящий ICMP эхо отклик. <a NAME="t073017"></a>SunOS 4.1.3,

однако, обновляет RR список, когда перенаправляет


датаграмму, но не отображает RR список. <a NAME="t073018"></a>Solaris

2.x исправляет эту проблему.</font></p>

</font>



<p>&nbsp;</p>

<font size="3"><i><b>



<p>Ненормальный вывод</p>

</b></i></font>



<p><small>Следующий пример был рассмотрен автором и

является исходной точкой для дальнейшего

описания <a NAME="t073019"></a>ICMP сообщений о

перенаправлении в <a HREF="glava9.html">главе 9</a>. Мы

посылаем ping на хост aix, находящийся в подсети

140.252.1, с хоста slip (доступ осуществляется через SLIP

соединение с дозвоном на компьютере sun) с опцией

записи маршрута. При этом получаем следующий

вывод:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>slip % <b>ping -R aix</b><br>

PING aix (140.252.1.92): 56 data bytes<br>

64 bytes from 140.252.1.92: icmp_seq=0 ttl=251 time=650 ms<br>

RR:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi (140.252.13.35)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun (140.252.1.29)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; netb (140.252.1.183)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aix (140.252.1.92)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gateway (140.252.1.4)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; почему используется

этот маршрутизатор?<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; netb (140.252.1.183)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun (140.252.13.33)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi (140.252.13.66)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slip (140.252.13.65)<br>

64 bytes from aix: icmp_seq=1 ttl=251 time=610 ms (same route)<br>

64 bytes from aix: icmp_seq=2 ttl=251 time=600 ms (same route)<br>

^<b>?</b><br>

--- aix ping statistics ---<br>

4 packets transmitted, 3 packets recieved, 25% packet loss<br>

round-trip min/avg/max = 600/620/650 ms<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Мы могли бы запустить этот пример с хоста

bsdi, но выбрали хост slip, чтобы увидеть все 9 IP

адресов, которые появятся в списке RR. </small></p>



<p><small>Странность этого вывода заключается в том,

что исходящая датаграмма (ICMP эхо запрос)

направляется непосредственно от netb к aix, а

возвращается (ICMP эхо отклик) от aix через

маршрутизатор gateway, перед тем как попасть в netb. То

что мы видим здесь, является характеристикой IP

маршрутизации, которую мы опишем ниже. На рисунке

7.6 показан путь датаграммы.<a NAME="t073020"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t7_6.jpg" WIDTH="533" HEIGHT="298"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 7.6 Работа программы ping с

записью маршрута, показывающая характеристику IP

маршрутизации.</small></p>



<p>&nbsp;</p>



<p><small>Проблема заключается в том, что aix не знает

как послать IP датаграмму, направляющуюся в

подсеть 140.252.13 к netb. Однако, aix имеет в своей

таблице маршрутизации пункт по умолчанию,

который сообщает о необходимости посылать все

датаграммы на маршрутизатор gateway, если не

существует конкретного маршрута к пункту

назначения. Маршрутизатор gateway знает значительно

больше о существующих маршрутах, чем любой

другой хост в подсети 140.252.1. (В этой сети Ethernet

присутствует более чем 150 хостов, и вместо того

чтобы каждому иметь запущенный демон

маршрутизации, они используют пункт &quot;по

умолчанию&quot; (default), который указывает на

маршрутизатор gateway.) </small></p>



<p><small>Вопрос, на который пока нет ответа,

заключается в том, почему gateway не послал

сообщение ICMP о перенаправлении (глава 9, раздел <a HREF="glava9.html#t095000">&quot;ICMP ошибки перенаправления&quot;</a>)

на aix, чтобы обновить его таблицу маршрутизации?

По некоторым причинам (возможно потому, что

датаграмма, генерирующая перенаправление,

является ICMP эхо запросом) перенаправление не

произошло. Однако, если мы используем Telnet и

подключимся к серверу дневного времени на aix, <a NAME="t073021"></a>ICMP перенаправление произойдет, и

таблица маршрутизации aix будет обновлена. Если мы

затем запустим ping со включенной опцией записи

маршрута, маршрут покажет, что датаграммы идут от

netb к aix и назад к netb без дополнительной пересылки

через маршрутизатор gateway. Мы рассмотрим

сообщения ICMP о перенаправлении более подробно в

разделе <a HREF="glava9.html#t095000">&quot;ICMP ошибки

перенаправления&quot;</a> главы 9. </small></p>

<font size="3"><u><b>



<p><a NAME="t074000"></a>IP опция временной марки</p>

</b></u></font>



<p><small>Опция IP временной марки во многом

напоминает опцию записи маршрута. На рисунке 7.7

показан формат IP опции временной марки (сравните

с рисунком 7.3).<a NAME="t074001"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t7_7.jpg" WIDTH="519" HEIGHT="165"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 7.7 Общий формат опции

временной марки в IP заголовке.</small></p>



<p>&nbsp;</p>



<p><small>Для опции временной марки поле кода (code)

устанавливается в 0x44. Два поля длина (len) и

указатель (ptr) такие же как в опции записи

маршрута: полная длина опции (обычно 36 или 40) и

указатель на следующий доступный пункт (5, 9, 13 и

так далее). </small></p>



<p><small>Размер двух следующих полей составляет 4

бита: OF - поле переполнения (overflow) и FL - поле флагов

(flags). Функционирование опции временной марки

определяется полем флагов (flags), как показано на

рисунке 7.8.<a NAME="t074002"></a></small></p>



<p>&nbsp;</p>

</font>



<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="673">

  <tr>

    <td WIDTH="14%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small><font FACE="Arial">флаги

    (flags)</font></small></td>

    <td WIDTH="86%" VALIGN="TOP" BGCOLOR="#ffffff"><font FACE="Arial"><p ALIGN="CENTER"><small>Описание</small></font></td>

  </tr>

  <tr>

    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>0</small></font></td>

    <td WIDTH="86%" VALIGN="TOP"><font FACE="Arial"><small>Запись только

    временных марок. Это как раз то, что мы показали

    на рисунке 7.7.</small></font></td>

  </tr>

  <tr>

    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>1</small></font></td>

    <td WIDTH="86%" VALIGN="TOP"><font FACE="Arial"><small>Каждый

    маршрутизатор записывает свой IP адрес и

    временную марку. Места в списке опций хватает

    только на четыре такие пары.</small></font></td>

  </tr>

  <tr>

    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>3</small></font></td>

    <td WIDTH="86%" VALIGN="TOP"><font FACE="Arial"><small>Отправитель

    устанавливает список опций, который должен

    состоять из 4-х пар IP адресов 0 (ноль) временных

    марок. Маршрутизатор записывает свою временную

    марку только в том случае, если следующий IP адрес

    из списка совпадает с IP адресом маршрутизатора.</small></font></td>

  </tr>

</table>

<font FACE="Arial">



<p><small>Рисунок 7.8 Значение флагов в опции

временной марки.</small></p>



<p>&nbsp;</p>



<p><small>В случае если маршрутизатор не может

добавить временную марку, из-за того что не

хватает места, он увеличивает на единицу поле

переполнения (overflow). </small></p>



<p><small>Обычное значение для временной марки это

количество миллисекунд после полуночи, UTC, что

напоминает <a NAME="t074003"></a>запрос и отклик временной

марки ICMP (глава 6, раздел <a HREF="glava6.html#t064000">&quot;ICMP

запрос и отклик временной марки&quot;</a>). Если

маршрутизатор не поддерживает подобный

стандарт, он может вставить то представление

времени, которое он использует, однако затем он

должен установить в единицу старшие биты

временной марки, чтобы указать на нестандартный

формат. </small></p>



<p><small>Заданные ограничения, которые мы

рассматривали с опцией записи маршрута, с опцией

временной марки становятся еще более жесткими.

Если осуществляется запись и IP адресов и

временных марок (флаги установлены в единицу), то

можно сохранить только 4 подобные пары.

Сохранение только временной марки практически

бесполезно, потому что мы не имеем представления,

какому маршрутизатору соответствует

определенная временная марка (если только мы не

имеет фиксированную топологию, которая никогда

не изменяется). Если установить флаги в значение

3, то появится возможность выбрать, каким

маршрутизаторам необходимо вставлять их

временные марки. Более глобальная проблема

заключается в том, что мы не можем контролировать

то, насколько точно маршрутизаторы

устанавливают временные марки. Поэтому довольно

сложно оценить время пересылки между

маршрутизаторами с использованием этой IP опции.

Вскоре мы увидим, что программа traceroute (см. <a HREF="glava8.html">главу 8</a>) предоставляет более

совершенный способ оценки времени пересылки

между маршрутизаторами.</small></p>

<font size="3"><u><b>



<p><a NAME="t075000"></a>Краткие выводы</p>

</b></u></font>



<p><small>Программа ping является основным тестирующим

средством, которое позволяет определить наличие

соединения между системами, использующими TCP/IP.

Она использует ICMP эхо запрос и эхо отклик и не

использует транспортные уровни (TCP или UDP). Ping

сервер обычно является частью реализации ядра

ICMP. </small></p>



<p><small>Мы рассмотрели стандартный вывод команды


ping для локальных, глобальных сетей и каналов SLIP (с

дозвоном и выделенных), и рассчитали пропускную

способность последовательных линий выделенных

SLIP каналов. ping также позволяет использовать IP

опцию записи маршрута. Мы использовали эту IP

опцию, чтобы посмотреть как используется маршрут

по умолчанию. Мы вернемся к этой теме в <a HREF="glava9.html">главе 9</a>. Также мы рассмотрели IP опцию

временной марки, однако она имеет ограниченную

практическую ценность. </small></p>

<font size="3"><i><b>



<p><a NAME="t075001"></a>Упражнения</b></i></font><font size="1"> 



<ol>

  <li></font><font size="2">Нарисуйте временной график вывода

    программы ping для SLIP канала из раздела <a HREF="#t072000">&quot;Программа

    Ping&quot;</a>.</li>

  <li>Рассчитайте RTT, если SLIP канал между bsdi и slip имеет

    скорость 9600 бит/сек. Считайте, что по умолчанию

    передается 56 байт данных.</li>

  <li>Текущая программа ping в BSD позволяет нам указать

    шаблон для раздела данных ICMP сообщения. (Первые 8

    байт раздела данных не заполняются шаблоном, а в

    тот момент, когда пакет отправляется, они

    хранятся здесь.) Если мы укажем шаблон 0xc0,

    повторно рассчитайте ответ на предыдущее

    упражнение. (Подсказка: просмотрите раздел <a HREF="glava2.html#t024000">&quot;SLIP: IP по последовательной

    линии&quot;</a> главы 2.)</li>

  <li>Влияет ли использование SLIP со сжатием (<a NAME="t075002"></a>CSLIP,

    глава 2, раздел <a HREF="glava2.html#t025000">&quot;SLIP с

    компрессией (CSLIP)&quot;</a>) на временные интервалы,

    которые мы рассматривали в разделе <a HREF="#t072000">&quot;Программа

    Ping&quot;</a>, при работе команды ping?</li>

  <li>Рассмотрите <a HREF="glava2.html#t027001">рисунок 2.4</a>.

    Замечаете ли Вы разницу между pingом на <a NAME="t075003"></a>loopback

    адрес и pingом на Ethernet адрес?</font><font size="1"></li>

</ol>

</font></font>



<p><small><a HREF="index.html"><img SRC="contents.jpg" BORDER="0" WIDTH="94" HEIGHT="20"></a><a HREF="../home.htm"><img SRC="begin.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava8.html"><img SRC="forward.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava6.html"><img SRC="back_b.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a href="index.html"><img SRC="index.jpg" border="0" WIDTH="68" HEIGHT="20"></a></small></p>

<font size="1">



<p>&nbsp;</p>

</font>
</div>
</body>

</html>

