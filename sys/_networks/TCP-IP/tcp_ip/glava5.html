<html>



<head>
<title>RARP: Обратный протокол определения адреса</title>

</head>



<body>
<div>


<p><small><a HREF="index.html"><img SRC="contents.jpg" BORDER="0" WIDTH="94" HEIGHT="20"></a><a HREF="../home.htm"><img SRC="begin.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava6.html"><img SRC="forward.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava4.html"><img SRC="back_b.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a href="index.html"><img SRC="index.jpg" border="0" WIDTH="68" HEIGHT="20"></a></small></p>

<font FACE="Arial" SIZE="4">



<p><a NAME="t050000"></a>Глава 5 RARP: обратный протокол

определения адреса</p>

</font><font FACE="Arial"><font size="3"><u>



<p><b><a NAME="t051000"></a>Введение</p>

</b></u></font>



<p><small>Когда загружается система с локальным

диском, она обычно получает свой IP адрес из

конфигурационного файла, который считывается с

диска. Однако для систем, не имеющих диска, таких

как X терминалы или бездисковые рабочие станции,

требуются другой способ определения

собственного IP адреса. </small></p>



<p><small>Каждая система в сети имеет уникальный

аппаратный адрес, который назначается

производителем сетевого интерфейса (сетевой

платы). Принцип работы RARP заключается в том, что

бездисковая система может считать свой

уникальный аппаратный адрес с интерфейсной

платы и послать RARP запрос (широковещательный

фрейм в сеть), где потребует кого-нибудь

откликнуться и сообщить IP адрес (с помощью RARP

отклика). </small></p>



<p><small>Несмотря на то что концепция довольно

проста, ее реализация как правило значительно

сложнее чем ARP, который был описан в <a HREF="glava4.html">предыдущей</a>

главе. Официальная спецификация RARP находится в RFC

903 [<a NAME="t051001"></a>Finlayson et al. 1984].</small></p>

<font size="3"><u><b>



<p><a NAME="t052000"></a>Формат пакета RARP</p>

</b></u></font>



<p><small><a NAME="t052001"></a>Формат пакета RARP практически

идентичен пакету ARP (см. рисунок 4.3). Единственное

отличие заключается в том, что поле <a NAME="t052002"></a>тип

фрейма (frame type) для запроса или отклика RARP

установлено в 0x8035, а поле op имеет значение 3 для RARP

запроса и значение 4 для RARP отклика. </small></p>



<p><small>RARP запрос является широковещательным, а RARP

отклик обычно персональный.</small></p>

<font size="3"><u><b>



<p><a NAME="t053000"></a>Примеры RARP</p>

</b></u></font>



<p><small>В нашей сети мы можем заставить хост sun

загружаться из сети, вместо того чтобы

загружаться с локального диска. Если мы

запустили RARP сервер и <a NAME="t053001"></a>tcpdump на хосте

bsdi, то получим вывод, показанный на рисунке 5.1. Мы

используем флаг <a NAME="t053002"></a>-e, чтобы команда tcpdump


показывала аппаратные адреса:<a NAME="t053003"></a> </small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>1&nbsp; 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42

ff:ff:ff:ff:ff:ff rarp 60: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp

who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>

2&nbsp; 0.13 (0.13)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0:0:c0:6f:2d:40 8:0:20:3:f6:42 rarp 42: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp

reply 8:0:20:3:f6:42 at sun<br>

3&nbsp; 0.14 (0.01)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 0:0:c0:6f:2d:40 ip 65: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.26999&gt;bsdi.tftp:

23 RRQ &quot;8CFC0D21.SUN4C&quot;<br>

</p>

</font><font FACE="Arial">



<p><small>Рисунок 5.1 Запрос и отклик RARP.</small></p>



<p>&nbsp;</p>



<p><small>Запрос RARP широковещательный (строка 1), а

отклик RARP (строка 2) персональный. Вывод в строке 2,

at sun, означает, что RARP отклик содержит IP адрес

хоста sun (140.252.13.33). </small></p>



<p><small>В строке 3 мы видим, что как только sun получил

свой IP адрес, он выдал TFTP запрос на чтение (RRQ)

файла 8CFC0D21.SUN4C. (<a NAME="t053004"></a>TFTP это простой

протокол передачи файлов - Trivial File Transfer Protocol. Мы

рассмотрим его более подробно в <a HREF="glava15.html">главе

15</a>.) Восемь шестнадцатиричных цифр в имени файла

это шестнадцатиричное представление IP адреса

140.252.13.33 хоста sun. Это IP адрес, который мы получили

в отклике RARP. Оставшаяся часть имени файла, SUN4C,

указывает на тип системы, которая загружается. </small></p>



<p><small>В строке 3 <a NAME="t053005"></a>tcpdump сообщает, что это

IP датаграмма длиной 65, а не UDP датаграмма (которая

в действительности является ей), так как мы

запустили tcpdump с флаго -e, чтобы получить в выводе

аппаратные адреса. Еще один момент на, который

необходимо обратить внимание на рисунке 5.1,

заключается в том, что длина Ethernet фрейма в строке

2 меньше чем установленный минимум (который, как

мы упоминали в разделе <a HREF="glava4.html#t045000">&quot;Примеры

ARP&quot;</a> главы 4, должен быть равен 60 байтам).

Причина этого заключается в том, что мы запустили

tcpdump на системе, которая посылает этот Ethernet фрейм

(bsdi). Приложение, <a NAME="t053006"></a>rarpd, пишет 42 байта в

устройство пакетного фильтра BSD (BSD Packet Filter) (14

байт - Ethernet заголовок и 28 байт - отклик RARP), именно

это и видит tcpdump. Однако драйвер устройства Ethernet

дополняет этот короткий фрейм до минимального

размера, необходимого для передачи (60 байт). Если

бы мы запустили tcpdump на другом компьютере, длина

составила бы 60 байт. </small></p>



<p><small>Также мы видим, что когда бездисковая

система получает свой IP адрес в отклике RARP, она

осуществляет TFTP запрос, чтобы прочитать

загрузочный имидж. Сейчас мы не будем подробно

рассматривать, как загружаются бездисковые

системы. (В <a HREF="glava16.html">главе 16</a> описывается

последовательность загрузки бездисковых X

терминалов с использованием RARP, BOOTP и TFTP.) </small></p>



<p><small>На рисунке 5.2 показаны пакеты, которые

появляются в том случае, если в сети нет RARP

сервера. Адрес назначения каждого пакета -

широковещательный адрес Ethernet. Адрес Ethernet,

следующий за who-is, это аппаратный адрес хоста

которому требуется информация, а адрес Ethernet,

следующий за tell, это аппаратный адрес

отправителя. </small></p>



<p><small><a NAME="t053007"></a>Обратите внимание на частоту

повторных передач. Первая повторная передача

происходит через 6,55 секунд, затем интервал

увеличивается до 42,80 секунд, затем через 5,34

секунды, затем через 6,55 секунд и снова через 42,79

секунды. Если мы рассчитаем разницу между каждым

тайм-аутом, мы заметим эффект удвоения: между 5,34 и

6,55 - 1,21 секунды, между 6,55 и 8,97 - 2,42 секунды, между 8,97

и 13,80 - 4,83 секунды и так далее.<a NAME="t053008"></a></small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p> 1&nbsp;&nbsp;&nbsp; 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42

ff:ff:ff:ff:ff:ff rarp 60: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp

who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>

2&nbsp;&nbsp;&nbsp; 6.55 ( 6.55)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp

60: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp

who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>

3&nbsp;&nbsp; 15.52 ( 8.97)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp

who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>

4&nbsp;&nbsp; 29.32 (13.80)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp

who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>

5&nbsp;&nbsp; 52.78 (23.46)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp

who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>

6&nbsp;&nbsp; 95.58 (42.80)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp

who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>

7&nbsp; 100.92 ( 5.34)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp

who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>

8&nbsp; 107.47 ( 6.55)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp

who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>

9&nbsp; 116.44 ( 8.97)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp

who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>

10&nbsp; 130.24 (13.80)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp

who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>

11&nbsp; 153.70 (23.46)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp

who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>

12&nbsp; 196.49 (42.79)&nbsp;&nbsp;&nbsp; 8:0:20:3:f6:42 ff:ff:ff:ff:ff:ff rarp 60: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rarp

who-is 8:0:20:3:f6:42 tell 8:0:20:3:f6:42<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Рисунок 5.2 RARP запрос при отсутствии в сети

RARP сервера.</small></p>



<p>&nbsp;</p>



<p><small>Когда тайм-аут достигает определенного

предела (больше чем 42,80 секунды), он сбрасывается

вновь в 5,34 секунды. </small></p>



<p><small>Подобное увеличение значения тайм-аута -

это наилучший подход, так как каждый раз

используется одно и то же значение. На рисунке 6.8

мы увидим неверный подход, с помощью которого

осуществляются тайм-ауты и повторные передачи, а

в <a HREF="glava21.html">главе 21</a> мы рассмотрим метод

используемый в TCP.</small></p>

<font size="3"><u><b>



<p><a NAME="t054000"></a>Реализация RARP сервера</p>

</b></u></font>



<p><small>Тогда как концепция RARP довольно проста,

реализация RARP сервера сильно зависит от системы

и довольно сложна. Напротив, реализация ARP

сервера проста и является, как правило, частью

реализации ядра TCP/IP. Так как ядро знает

собственные IP адреса и аппаратные адреса, при

получении ARP запроса для одного из IP адресов оно

просто формирует отклик с соответствующим

аппаратным адресом.</small></p>

<font size="3"><i><b>



<p>RARP серверы как пользовательские процессы</p>

</b></i></font>



<p><small>Основная задача RARP сервера заключается в

том, чтобы предоставить соответствие между

аппаратными адресами и IP адресами для множества

хостов (все бездисковые системы в сети).

Необходимая информация содержится в дисковом

файле (обычно <a NAME="t054001"></a>/etc/ethers в UNIX системах).

Так как ядро обычно не читает дисковые файлы,

функция RARP сервера реализуется с использованием

пользовательского процесса, который не является

частью ядра TCP/IP. </small></p>



<p><small>Далее, можно отметить, что RARP запросы

передаются в качестве Ethernet фреймов со

специфическим <a NAME="t054002"></a>полем типа фрейма Ethernet

(0x8035 на рисунке 2.1). Это означает, что RARP сервер

должен обладать способностью отправлять и

принимать Ethernet фреймы подобного типа. В <a HREF="glavaA.htm">приложении А</a> мы опишем как для приема

подобных фреймов используются BSD Packet Filter, Sun Network

Interface Tap и SVR4 Data Link Provider Interface. Так как посылка и

прием подобных фреймов зависит от системы,

реализация RARP сервера также зависит от системы.</small></p>

<font size="3"><i><b>



<p>Несколько RARP серверов в сети</p>

</b></i></font>



<p><small>Еще одна особенность заключается в том, что

RARP запросы посылаются в виде широковещательных

запросов аппаратного уровня, как показано на

рисунке 5.2. Это означает, что они не

перенаправляются маршрутизаторами. Чтобы

позволить бездисковым системам загружаться,

даже если RARP сервер выключен, в сети обычно

существуют несколько RARP серверов (на одном и том

же кабеле). </small></p>



<p><small>По мере того как количество серверов растет

(чтобы повысить надежность), увеличивается

сетевой траффик, так как каждый сервер посылает

RARP отклик на каждый RARP запрос. Бездисковые

системы, которые посылают RARP запросы, обычно

используют первый полученный ими RARP отклик. (Мы

никогда не имели подобных проблем с ARP, потому что

только один хост посылает ARP отклик.) Более того,

существует вероятность, что несколько RARP

серверов отправят отклики одновременно,

увеличивая тем самым количество коллизий в Ethernet.</small></p>

<font size="3"><u><b>



<p><a NAME="t055000"></a>Краткие выводы</p>

</b></u></font>



<p><small>RARP используется большинством бездисковых

систем при загрузке, для получения свох IP

адресов. Формат пакета RARP практически идентичен

пакету ARP. Запрос RARP широковещательный, в нем

содержится аппаратный адрес отправителя, при

этом он спрашивает кого-либо послать ему его IP

адрес. Отклик обычно персональный. </small></p>



<p><small>Проблемы с RARP заключаются в том, что он

использует широковещательные запросы на

канальном уровне, поэтому большинство

маршрутизаторов не могут перенаправлять RARP

запросы; а также в том, что передается минимум

необходимой информации: только IP адрес системы. В

<a HREF="glava16.html">главе 16</a> мы увидим, что BOOTP сообщает

значительно больше информации необходимой при

загрузке бездисковых систем: IP адрес, имя хоста, с

которого происходит загрузка, и так далее. </small></p>



<p><small>Несмотря на то что концепция RARP довольно

проста, реализация RARP сервера зависит от системы.

Также надо отметить, что не все TCP/IP реализации

предоставляют RARP сервер.</small></p>



<p>&nbsp;</p>

<font size="3"><i><b>



<p>Упражнения</b></i></font><font size="1"> 



<ol>

  <li></font><font size="2">Требуется ли для RARP отдельное <a NAME="t055001"></a>поле типа фрейма (frame type)? Может ли быть

    использовано одно и то же значение 0x0806 для ARP и RARP?</li>

  <li>Если в сети находится несколько RARP серверов, как


    они могут сделать так, чтобы предотвратить

    коллизии своих ответов?</font><font size="1"></li>

</ol>

</font></font>



<p><small><a HREF="index.html"><img SRC="contents.jpg" BORDER="0" WIDTH="94" HEIGHT="20"></a><a HREF="../home.htm"><img SRC="begin.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava6.html"><img SRC="forward.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava4.html"><img SRC="back_b.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a href="index.html"><img SRC="index.jpg" border="0" WIDTH="68" HEIGHT="20"></a></small></p>

<font size="1">



<p>&nbsp;</p>

</font>
</div>
</body>

</html>

