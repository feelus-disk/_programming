
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>Chapter&nbsp;2.&nbsp;The Structure of the Java Virtual Machine</title>
      <link rel="stylesheet" type="text/css" href="../../../javaspec.css">
      <meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1">
      <link rel="home" href="index.html" title="The Java&reg; Virtual Machine Specification">
      <link rel="up" href="index.html" title="The Java&reg; Virtual Machine Specification">
      <link rel="prev" href="jvms-1.html" title="Chapter&nbsp;1.&nbsp;Introduction">
      <link rel="next" href="jvms-3.html" title="Chapter&nbsp;3.&nbsp;Compiling for the Java Virtual Machine">
      <link rel="copyright" href="jvms-0-front.html" title="Legal Notice">
   </head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" id="logo"><img src="../../../../webdesign/other/im/oralogo_small.gif" alt="Oracle Logo"><br><p><a href="http://docs.oracle.com/javase/8/docs/">Java SE</a> &gt; <a href="http://docs.oracle.com/javase/specs/index.html">Java SE Specifications</a> &gt; <a href="index.html">Java Virtual Machine Specification</a></p>
      </div>
      <div class="navheader">
         <table width="100%" summary="Navigation header">
            <tr>
               <th colspan="3" align="center">Chapter&nbsp;2.&nbsp;The Structure of the Java Virtual Machine</th>
            </tr>
            <tr>
               <td width="20%" align="left"><a accesskey="p" href="jvms-1.html">Prev</a>&nbsp;
               </td>
               <th width="60%" align="center">&nbsp;</th>
               <td width="20%" align="right">&nbsp;<a accesskey="n" href="jvms-3.html">Next</a></td>
            </tr>
         </table>
         <hr>
      </div>
      <div lang="en" class="chapter" title="Chapter&nbsp;2.&nbsp;The Structure of the Java Virtual Machine">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title"><a name="jvms-2"></a>Chapter&nbsp;2.&nbsp;The Structure of the Java Virtual Machine
                  </h2>
               </div>
            </div>
         </div>
         <div class="toc">
            <p><b>Table of Contents</b></p>
            <dl>
               <dt><span class="section"><a href="jvms-2.html#jvms-2.1">2.1. The <code class="literal">class</code> File Format</a></span></dt>
               <dt><span class="section"><a href="jvms-2.html#jvms-2.2">2.2. Data Types</a></span></dt>
               <dt><span class="section"><a href="jvms-2.html#jvms-2.3">2.3. Primitive Types and Values</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.3.1">2.3.1. Integral Types and Values</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.3.2">2.3.2. Floating-Point Types, Value Sets, and Values</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.3.3">2.3.3. The <code class="literal">returnAddress</code> Type and Values</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.3.4">2.3.4. The <code class="literal">boolean</code> Type</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jvms-2.html#jvms-2.4">2.4. Reference Types and Values</a></span></dt>
               <dt><span class="section"><a href="jvms-2.html#jvms-2.5">2.5. Run-Time Data Areas</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.5.1">2.5.1. The <code class="literal">pc</code> Register</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.5.2">2.5.2. Java Virtual Machine Stacks</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.5.3">2.5.3. Heap</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.5.4">2.5.4. Method Area</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.5.5">2.5.5. Run-Time Constant Pool</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.5.6">2.5.6. Native Method Stacks</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jvms-2.html#jvms-2.6">2.6. Frames</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.6.1">2.6.1. Local Variables</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.6.2">2.6.2. Operand Stacks</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.6.3">2.6.3. Dynamic Linking</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.6.4">2.6.4. Normal Method Invocation Completion</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.6.5">2.6.5. Abrupt Method Invocation Completion</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jvms-2.html#jvms-2.7">2.7. Representation of Objects</a></span></dt>
               <dt><span class="section"><a href="jvms-2.html#jvms-2.8">2.8. Floating-Point Arithmetic</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.8.1">2.8.1. Java Virtual Machine Floating-Point Arithmetic and IEEE 754</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.8.2">2.8.2. Floating-Point Modes</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.8.3">2.8.3. Value Set Conversion</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jvms-2.html#jvms-2.9">2.9. Special Methods</a></span></dt>
               <dt><span class="section"><a href="jvms-2.html#jvms-2.10">2.10. Exceptions</a></span></dt>
               <dt><span class="section"><a href="jvms-2.html#jvms-2.11">2.11. Instruction Set Summary</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.11.1">2.11.1. Types and the Java Virtual Machine</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.11.2">2.11.2. Load and Store Instructions</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.11.3">2.11.3. Arithmetic Instructions</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.11.4">2.11.4. Type Conversion Instructions</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.11.5">2.11.5. Object Creation and Manipulation</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.11.6">2.11.6. Operand Stack Management Instructions</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.11.7">2.11.7. Control Transfer Instructions</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.11.8">2.11.8. Method Invocation and Return Instructions</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.11.9">2.11.9. Throwing Exceptions</a></span></dt>
                     <dt><span class="section"><a href="jvms-2.html#jvms-2.11.10">2.11.10. Synchronization</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="jvms-2.html#jvms-2.12">2.12. Class Libraries</a></span></dt>
               <dt><span class="section"><a href="jvms-2.html#jvms-2.13">2.13. Public Design, Private Implementation</a></span></dt>
            </dl>
         </div>
         <p class="norm"><a name="jvms-2-100"></a>This document specifies an
            abstract machine. It does not describe any particular implementation
            of the Java Virtual Machine.
         </p>
         <p class="norm"><a name="jvms-2-110"></a>To implement the Java Virtual Machine
            correctly, you need only be able to read the <code class="literal">class</code> file format and
            correctly perform the operations specified therein. Implementation
            details that are not part of the Java Virtual Machine's specification would
            unnecessarily constrain the creativity of implementors. For example,
            the memory layout of run-time data areas, the garbage-collection
            algorithm used, and any internal optimization of the Java Virtual Machine
            instructions (for example, translating them into machine code) are
            left to the discretion of the implementor.
         </p>
         <p class="norm"><a name="jvms-2-120"></a>All references to Unicode in
            this specification are given with respect to <em class="citetitle">The Unicode
               Standard, Version 6.0.0</em>, available at
            <code class="uri">http://www.unicode.org/</code>.
         </p>
         <div class="section" title="2.1.&nbsp;The class File Format">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jvms-2.1"></a>2.1.&nbsp;The <code class="literal">class</code> File Format
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jvms-2.1-100"></a>Compiled code to be executed
               by the Java Virtual Machine is represented using a hardware- and operating
               system-independent binary format, typically (but not necessarily)
               stored in a file, known as the <code class="literal">class</code> file format. The <code class="literal">class</code> file
               format precisely defines the representation of a class or interface,
               including details such as byte ordering that might be taken for
               granted in a platform-specific object file format.
            </p>
            <p class="norm"><a name="jvms-2.1-110"></a>Chapter 4, "The <code class="literal">class</code> File
               Format", covers the <code class="literal">class</code> file format in detail.
            </p>
         </div>
         <div class="section" title="2.2.&nbsp;Data Types">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jvms-2.2"></a>2.2.&nbsp;Data Types
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jvms-2.2-100"></a>Like the Java programming language, the Java Virtual Machine
               operates on two kinds of types: <span class="emphasis"><em>primitive types</em></span>
               and <span class="emphasis"><em>reference types</em></span>. There are, correspondingly,
               two kinds of values that can be stored in variables, passed as
               arguments, returned by methods, and operated upon: <span class="emphasis"><em>primitive
                     values</em></span> and <span class="emphasis"><em>reference values</em></span>.
            </p>
            <p class="norm"><a name="jvms-2.2-110"></a>The Java Virtual Machine expects that nearly
               all type checking is done prior to run time, typically by a compiler,
               and does not have to be done by the Java Virtual Machine itself. Values of primitive
               types need not be tagged or otherwise be inspectable to determine
               their types at run time, or to be distinguished from values of
               reference types. Instead, the instruction set of the Java Virtual Machine
               distinguishes its operand types using instructions intended to operate
               on values of specific types. For instance, <span class="emphasis"><em>iadd</em></span>, <span class="emphasis"><em>ladd</em></span>, <span class="emphasis"><em>fadd</em></span>, and
               <span class="emphasis"><em>dadd</em></span> are all Java Virtual Machine instructions that add two numeric values and
               produce numeric results, but each is specialized for its operand type:
               <code class="literal">int</code>, <code class="literal">long</code>, <code class="literal">float</code>, and <code class="literal">double</code>, respectively. For a summary of
               type support in the Java Virtual Machine instruction set, see
               <a class="xref" href="jvms-2.html#jvms-2.11.1" title="2.11.1.&nbsp;Types and the Java Virtual Machine">&sect;2.11.1</a>.
            </p>
            <p class="norm"><a name="jvms-2.2-120"></a>The Java Virtual Machine contains explicit
               support for objects. An object is either a dynamically allocated class
               instance or an array. A reference to an object is considered to have
               Java Virtual Machine type <code class="literal">reference</code>. Values of type <code class="literal">reference</code> can be thought of as pointers
               to objects. More than one reference to an object may exist. Objects
               are always operated on, passed, and tested via values of type
               <code class="literal">reference</code>.
            </p>
         </div>
         <div class="section" title="2.3.&nbsp;Primitive Types and Values">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jvms-2.3"></a>2.3.&nbsp;Primitive Types and Values
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jvms-2.3-100"></a>The primitive data types
               supported by the Java Virtual Machine are the <span class="emphasis"><em>numeric types</em></span>, the
               <code class="literal">boolean</code> type (<a class="xref" href="jvms-2.html#jvms-2.3.4" title="2.3.4.&nbsp;The boolean Type">&sect;2.3.4</a>), and the <code class="literal">returnAddress</code>
               type (<a class="xref" href="jvms-2.html#jvms-2.3.3" title="2.3.3.&nbsp;The returnAddress Type and Values">&sect;2.3.3</a>).
            </p>
            <p class="norm"><a name="jvms-2.3-110"></a>The numeric types consist of
               the <span class="emphasis"><em>integral types</em></span> (<a class="xref" href="jvms-2.html#jvms-2.3.1" title="2.3.1.&nbsp;Integral Types and Values">&sect;2.3.1</a>)
               and the <span class="emphasis"><em>floating-point types</em></span>
               (<a class="xref" href="jvms-2.html#jvms-2.3.2" title="2.3.2.&nbsp;Floating-Point Types, Value Sets, and Values">&sect;2.3.2</a>).
            </p>
            <p class="norm"><a name="jvms-2.3-120"></a>The integral types are:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.3-120-A"></a><code class="literal">byte</code>, whose values are
                            8-bit signed two's-complement integers, and whose default value is
                            zero
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.3-120-B"></a><code class="literal">short</code>, whose values
                            are 16-bit signed two's-complement integers, and whose default
                            value is zero
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.3-120-C"></a><code class="literal">int</code>, whose values are
                            32-bit signed two's-complement integers, and whose default value
                            is zero
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.3-120-D"></a><code class="literal">long</code>, whose values are
                            64-bit signed two's-complement integers, and whose default value
                            is zero
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.3-120-E"></a><code class="literal">char</code>, whose values are
                            16-bit unsigned integers representing Unicode code points in the
                            Basic Multilingual Plane, encoded with UTF-16, and whose default
                            value is the null code point (<code class="literal">'\u0000'</code>)
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jvms-2.3-130"></a>The floating-point types
               are:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.3-130-A"></a><code class="literal">float</code>, whose values
                            are elements of the float value set or, where supported, the
                            float-extended-exponent value set, and whose default value is
                            positive zero
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.3-130-B"></a><code class="literal">double</code>, whose values
                            are elements of the double value set or, where supported, the
                            double-extended-exponent value set, and whose default value is
                            positive zero
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jvms-2.3-200"></a>The values of the <code class="literal">boolean</code>
               type encode the truth values <code class="literal">true</code> and <code class="literal">false</code>, and the default value
               is <code class="literal">false</code>.
            </p>
            <p class="note">The First Edition of <em class="citetitle">The <span class="trademark">Java</span>&reg; Virtual Machine Specification</em> did not consider
               <code class="literal">boolean</code> to be a Java Virtual Machine type. However, <code class="literal">boolean</code> values do have
               limited support in the Java Virtual Machine. The Second Edition of <em class="citetitle">The <span class="trademark">Java</span>&reg; Virtual Machine Specification</em>
               clarified the issue by treating <code class="literal">boolean</code> as a type.
            </p>
            <p class="norm"><a name="jvms-2.3-300"></a>The values of the
               <code class="literal">returnAddress</code> type are pointers to the opcodes of Java Virtual Machine
               instructions. Of the primitive types, only the <code class="literal">returnAddress</code> type is
               not directly associated with a Java programming language type.
            </p>
            <div class="section" title="2.3.1.&nbsp;Integral Types and Values">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.3.1"></a>2.3.1.&nbsp;Integral Types and Values
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.3.1-100"></a>The values of the integral
                  types of the Java Virtual Machine are:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.3.1-100-A"></a>For <code class="literal">byte</code>, from -128
                               to 127 (-2<sup>7</sup> to
                               2<sup>7</sup> - 1), inclusive
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.3.1-100-B"></a>For <code class="literal">short</code>, from
                               -32768 to 32767 (-2<sup>15</sup> to
                               2<sup>15</sup> - 1), inclusive
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.3.1-100-C"></a>For <code class="literal">int</code>, from
                               -2147483648 to 2147483647 (-2<sup>31</sup> to
                               2<sup>31</sup> - 1), inclusive
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.3.1-100-D"></a>For <code class="literal">long</code>, from
                               -9223372036854775808 to 9223372036854775807
                               (-2<sup>63</sup> to 2<sup>63</sup>
                               - 1), inclusive
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.3.1-100-E"></a>For <code class="literal">char</code>, from 0 to
                               65535 inclusive
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="2.3.2.&nbsp;Floating-Point Types, Value Sets, and Values">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.3.2"></a>2.3.2.&nbsp;Floating-Point Types, Value Sets, and Values
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.3.2-100"></a>The floating-point types are
                  <code class="literal">float</code> and <code class="literal">double</code>, which are conceptually associated with the
                  32-bit single-precision and 64-bit double-precision format IEEE 754
                  values and operations as specified in <em class="citetitle">IEEE Standard for
                     Binary Floating-Point Arithmetic</em> (ANSI/IEEE Std. 754-1985,
                  New York).
               </p>
               <p class="norm"><a name="jvms-2.3.2-110"></a>The IEEE 754 standard
                  includes not only positive and negative sign-magnitude numbers, but
                  also positive and negative zeros, positive and
                  negative <span class="emphasis"><em>infinities</em></span>, and a special Not-a-Number
                  value (hereafter abbreviated as "NaN"). The NaN value is used to
                  represent the result of certain invalid operations such as dividing
                  zero by zero.
               </p>
               <p class="norm"><a name="jvms-2.3.2-120"></a>Every implementation of the
                  Java Virtual Machine is required to support two standard sets of floating-point
                  values, called the <span class="emphasis"><em>float value set</em></span> and
                  the <span class="emphasis"><em>double value set</em></span>. In addition, an
                  implementation of the Java Virtual Machine may, at its option, support either or both
                  of two extended-exponent floating-point value sets, called the
                  <span class="emphasis"><em>float-extended-exponent value set</em></span> and
                  the <span class="emphasis"><em>double-extended-exponent value set</em></span>. These
                  extended-exponent value sets may, under certain circumstances, be used
                  instead of the standard value sets to represent the values of type
                  <code class="literal">float</code> or <code class="literal">double</code>.
               </p>
               <p class="norm"><a name="jvms-2.3.2-130"></a>The finite nonzero values of
                  any floating-point value set can all be expressed in the form <span class="emphasis"><em>s</em></span>
                  <span class="symbol">&#8901;</span> <span class="emphasis"><em>m</em></span> <span class="symbol">&#8901;</span> 2<sup>(<span class="emphasis"><em>e</em></span> &#8722; <span class="emphasis"><em>N</em></span>
                     + 1)</sup>, where <span class="emphasis"><em>s</em></span> is +1 or &#8722;1, <span class="emphasis"><em>m</em></span> is a positive
                  integer less than 2<span class="emphasis"><em>N</em></span>, and <span class="emphasis"><em>e</em></span> is an integer
                  between <span class="emphasis"><em>E<sub>min</sub></em></span> =
                  &#8722;(2<sup><span class="emphasis"><em>K</em></span>&#8722;1</sup>&#8722;2)
                  and <span class="emphasis"><em>E<sub>max</sub></em></span> =
                  2<sup><span class="emphasis"><em>K</em></span>&#8722;1</sup>&#8722;1, inclusive, and
                  where <span class="emphasis"><em>N</em></span> and <span class="emphasis"><em>K</em></span> are parameters
                  that depend on the value set. Some values can be represented in this
                  form in more than one way; for example, supposing that a
                  value <span class="emphasis"><em>v</em></span> in a value set might be represented in
                  this form using certain values for <span class="emphasis"><em>s</em></span>, <span class="emphasis"><em>m</em></span>, and <span class="emphasis"><em>e</em></span>, then if
                  it happened that <span class="emphasis"><em>m</em></span> were even and <span class="emphasis"><em>e</em></span> were less than
                  2<sup><span class="emphasis"><em>K</em></span>-1</sup>, one could halve
                  <span class="emphasis"><em>m</em></span> and increase <span class="emphasis"><em>e</em></span> by 1 to produce a second representation for
                  the same value <span class="emphasis"><em>v</em></span>. A representation in this form
                  is called <span class="emphasis"><em>normalized</em></span> if <span class="emphasis"><em>m</em></span> <span class="symbol">&#8805;</span>
                  2<sup><span class="emphasis"><em>N</em></span>-1</sup>; otherwise the
                  representation is said to be <span class="emphasis"><em>denormalized</em></span>. If a
                  value in a value set cannot be represented in such a way that <span class="emphasis"><em>m</em></span>
                  <span class="symbol">&#8805;</span> 2<sup><span class="emphasis"><em>N</em></span>-1</sup>, then the
                  value is said to be a <span class="emphasis"><em>denormalized value</em></span>, because
                  it has no normalized representation.
               </p>
               <p class="norm"><a name="jvms-2.3.2-140"></a>The constraints on the
                  parameters <span class="emphasis"><em>N</em></span> and <span class="emphasis"><em>K</em></span> (and on
                  the derived parameters <span class="emphasis"><em>E<sub>min</sub></em></span>
                  and <span class="emphasis"><em>E<sub>max</sub></em></span>) for the two
                  required and two optional floating-point value sets are summarized in
                  <a class="xref" href="jvms-2.html#jvms-2.3.2-140-A" title="Table&nbsp;2.3.2-A.&nbsp;Floating-point value set parameters">Table&nbsp;2.3.2-A</a>.
               </p>
               <div class="table"><a name="jvms-2.3.2-140-A"></a><p class="title"><b>Table&nbsp;2.3.2-A.&nbsp;Floating-point value set parameters</b></p>
                  <div class="table-contents">
                     <table summary="Floating-point value set parameters" border="1">
                        <colgroup>
                           <col>
                           <col>
                           <col>
                           <col>
                           <col>
                        </colgroup>
                        <thead>
                           <tr>
                              <th>Parameter</th>
                              <th>float</th>
                              <th>float-extended-exponent</th>
                              <th>double</th>
                              <th>double-extended-exponent</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <td><span class="emphasis"><em>N</em></span></td>
                              <td>24</td>
                              <td>24</td>
                              <td>53</td>
                              <td>53</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>K</em></span></td>
                              <td>8</td>
                              <td><span class="symbol">&#8805;</span> 11
                              </td>
                              <td>11</td>
                              <td><span class="symbol">&#8805;</span> 15
                              </td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>E<sub>max</sub></em></span></td>
                              <td>+127</td>
                              <td><span class="symbol">&#8805;</span> +1023
                              </td>
                              <td>+1023</td>
                              <td><span class="symbol">&#8805;</span> +16383
                              </td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>E<sub>min</sub></em></span></td>
                              <td>-126</td>
                              <td><span class="symbol">&#8804;</span> -1022
                              </td>
                              <td>-1022</td>
                              <td><span class="symbol">&#8804;</span> -16382
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
               </div><br class="table-break"><p class="norm"><a name="jvms-2.3.2-150"></a>Where one or both
                  extended-exponent value sets are supported by an implementation, then
                  for each supported extended-exponent value set there is a specific
                  implementation-dependent constant <span class="emphasis"><em>K</em></span>, whose value
                  is constrained by <a class="xref" href="jvms-2.html#jvms-2.3.2-140-A" title="Table&nbsp;2.3.2-A.&nbsp;Floating-point value set parameters">Table&nbsp;2.3.2-A</a>; this
                  value <span class="emphasis"><em>K</em></span> in turn dictates the values
                  for <span class="emphasis"><em>E<sub>min</sub></em></span>
                  and <span class="emphasis"><em>E<sub>max</sub></em></span>.
               </p>
               <p class="norm"><a name="jvms-2.3.2-160"></a>Each of the four value sets
                  includes not only the finite nonzero values that are ascribed to it
                  above, but also the five values positive zero, negative zero, positive
                  infinity, negative infinity, and NaN.
               </p>
               <p class="norm"><a name="jvms-2.3.2-170"></a>Note that the constraints in
                  <a class="xref" href="jvms-2.html#jvms-2.3.2-140-A" title="Table&nbsp;2.3.2-A.&nbsp;Floating-point value set parameters">Table&nbsp;2.3.2-A</a> are designed so that every element
                  of the float value set is necessarily also an element of the
                  float-extended-exponent value set, the double value set, and the
                  double-extended-exponent value set. Likewise, each element of the
                  double value set is necessarily also an element of the
                  double-extended-exponent value set. Each extended-exponent value set
                  has a larger range of exponent values than the corresponding standard
                  value set, but does not have more precision.
               </p>
               <p class="norm"><a name="jvms-2.3.2-180"></a>The elements of the float
                  value set are exactly the values that can be represented using the
                  single floating-point format defined in the IEEE 754 standard, except
                  that there is only one NaN value (IEEE 754 specifies
                  2<sup>24</sup>-2 distinct NaN values). The elements of
                  the double value set are exactly the values that can be represented
                  using the double floating-point format defined in the IEEE 754
                  standard, except that there is only one NaN value (IEEE 754 specifies
                  2<sup>53</sup>-2 distinct NaN values). Note, however,
                  that the elements of the float-extended-exponent and
                  double-extended-exponent value sets defined here
                  do <span class="emphasis"><em>not</em></span> correspond to the values that can be
                  represented using IEEE 754 single extended and double extended
                  formats, respectively. This specification does not mandate a specific
                  representation for the values of the floating-point value sets except
                  where floating-point values must be represented in the <code class="literal">class</code> file
                  format (<a class="xref" href="jvms-4.html#jvms-4.4.4" title="4.4.4.&nbsp;The CONSTANT_Integer_info and CONSTANT_Float_info Structures">&sect;4.4.4</a>,
                  <a class="xref" href="jvms-4.html#jvms-4.4.5" title="4.4.5.&nbsp;The CONSTANT_Long_info and CONSTANT_Double_info Structures">&sect;4.4.5</a>).
               </p>
               <p class="norm"><a name="jvms-2.3.2-190"></a>The float,
                  float-extended-exponent, double, and double-extended-exponent value
                  sets are not types. It is always correct for an implementation of the
                  Java Virtual Machine to use an element of the float value set to represent a value of
                  type <code class="literal">float</code>; however, it may be permissible in certain contexts for
                  an implementation to use an element of the float-extended-exponent
                  value set instead. Similarly, it is always correct for an
                  implementation to use an element of the double value set to represent
                  a value of type <code class="literal">double</code>; however, it may be permissible in certain
                  contexts for an implementation to use an element of the
                  double-extended-exponent value set instead.
               </p>
               <p class="norm"><a name="jvms-2.3.2-200"></a>Except for NaNs, values of
                  the floating-point value sets are <span class="emphasis"><em>ordered</em></span>. When
                  arranged from smallest to largest, they are negative infinity,
                  negative finite values, positive and negative zero, positive finite
                  values, and positive infinity.
               </p>
               <p class="norm"><a name="jvms-2.3.2-210"></a>Floating-point positive zero
                  and floating-point negative zero compare as equal, but there are other
                  operations that can distinguish them; for example,
                  dividing <code class="literal">1.0</code> by <code class="literal">0.0</code> produces
                  positive infinity, but dividing <code class="literal">1.0</code>
                  by <code class="literal">-0.0</code> produces negative infinity.
               </p>
               <p class="norm"><a name="jvms-2.3.2-220"></a>NaNs
                  are <span class="emphasis"><em>unordered</em></span>, so numerical comparisons and tests
                  for numerical equality have the value <code class="literal">false</code> if either or both of
                  their operands are NaN. In particular, a test for numerical equality
                  of a value against itself has the value <code class="literal">false</code> if and only if the
                  value is NaN. A test for numerical inequality has the value <code class="literal">true</code> if
                  either operand is NaN.
               </p>
            </div>
            <div class="section" title="2.3.3.&nbsp;The returnAddress Type and Values">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.3.3"></a>2.3.3.&nbsp;The <code class="literal">returnAddress</code> Type and Values
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.3.3-100"></a>The <code class="literal">returnAddress</code> type is
                  used by the Java Virtual Machine's <span class="emphasis"><em>jsr</em></span>, <span class="emphasis"><em>ret</em></span>, and <span class="emphasis"><em>jsr_w</em></span> instructions
                  (<a class="xref" href="jvms-6.html#jvms-6.5.jsr" title="jsr">&sect;<span class="emphasis"><em>jsr</em></span></a>, <a class="xref" href="jvms-6.html#jvms-6.5.ret" title="ret">&sect;<span class="emphasis"><em>ret</em></span></a>,
                  <a class="xref" href="jvms-6.html#jvms-6.5.jsr_w" title="jsr_w">&sect;<span class="emphasis"><em>jsr_w</em></span></a>). The values of the <code class="literal">returnAddress</code>
                  type are pointers to the opcodes of Java Virtual Machine instructions. Unlike the
                  numeric primitive types, the <code class="literal">returnAddress</code> type does not correspond
                  to any Java programming language type and cannot be modified by the running
                  program.
               </p>
            </div>
            <div class="section" title="2.3.4.&nbsp;The boolean Type">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.3.4"></a>2.3.4.&nbsp;The <code class="literal">boolean</code> Type
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.3.4-100"></a>Although the Java Virtual Machine defines a
                  <code class="literal">boolean</code> type, it only provides very limited support for it. There
                  are no Java Virtual Machine instructions solely dedicated to operations on <code class="literal">boolean</code>
                  values. Instead, expressions in the Java programming language that operate on
                  <code class="literal">boolean</code> values are compiled to use values of the Java Virtual Machine <code class="literal">int</code> data
                  type.
               </p>
               <p class="norm"><a name="jvms-2.3.4-200"></a>The Java Virtual Machine does directly
                  support <code class="literal">boolean</code> arrays. Its <span class="emphasis"><em>newarray</em></span> instruction
                  (<a class="xref" href="jvms-6.html#jvms-6.5.newarray" title="newarray">&sect;<span class="emphasis"><em>newarray</em></span></a>) enables creation of <code class="literal">boolean</code>
                  arrays. Arrays of type <code class="literal">boolean</code> are accessed and modified using the
                  <code class="literal">byte</code> array instructions <span class="emphasis"><em>baload</em></span> and <span class="emphasis"><em>bastore</em></span>
                  (<a class="xref" href="jvms-6.html#jvms-6.5.baload" title="baload">&sect;<span class="emphasis"><em>baload</em></span></a>,
                  <a class="xref" href="jvms-6.html#jvms-6.5.bastore" title="bastore">&sect;<span class="emphasis"><em>bastore</em></span></a>).
               </p>
               <p class="note">In Oracle&#8217;s Java Virtual Machine implementation, <code class="literal">boolean</code> arrays
                  in the Java programming language are encoded as Java Virtual Machine <code class="literal">byte</code> arrays, using 8 bits per
                  <code class="literal">boolean</code> element.
               </p>
               <p class="norm"><a name="jvms-2.3.4-210"></a>The Java Virtual Machine encodes <code class="literal">boolean</code>
                  array components using <code class="literal">1</code> to represent <code class="literal">true</code> and <code class="literal">0</code> to
                  represent <code class="literal">false</code>. Where Java programming language <code class="literal">boolean</code> values are mapped by
                  compilers to values of Java Virtual Machine type <code class="literal">int</code>, the compilers must use the
                  same encoding.
               </p>
            </div>
         </div>
         <div class="section" title="2.4.&nbsp;Reference Types and Values">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jvms-2.4"></a>2.4.&nbsp;Reference Types and Values
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jvms-2.4-100"></a>There are three kinds of <code class="literal">reference</code>
               types: class types, array types, and interface types. Their values are
               references to dynamically created class instances, arrays, or class
               instances or arrays that implement interfaces, respectively.
            </p>
            <p class="norm"><a name="jvms-2.4-110"></a>An array type consists of a
               <span class="emphasis"><em>component type</em></span> with a single dimension (whose
               length is not given by the type). The component type of an array type
               may itself be an array type. If, starting from any array type, one
               considers its component type, and then (if that is also an array type)
               the component type of that type, and so on, eventually one must reach
               a component type that is not an array type; this is called
               the <span class="emphasis"><em>element type</em></span> of the array type. The element
               type of an array type is necessarily either a primitive type, or a
               class type, or an interface type.
            </p>
            <p class="norm"><a name="jvms-2.4-200"></a>A <code class="literal">reference</code> value may also be the
               special null reference, a reference to no object, which will be
               denoted here by <code class="literal">null</code>. The <code class="literal">null</code> reference initially has no run-time
               type, but may be cast to any type. The default value of a <code class="literal">reference</code> type
               is <code class="literal">null</code>.
            </p>
            <p class="norm"><a name="jvms-2.4-300"></a>This specification does not
               mandate a concrete value encoding <code class="literal">null</code>.
            </p>
         </div>
         <div class="section" title="2.5.&nbsp;Run-Time Data Areas">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jvms-2.5"></a>2.5.&nbsp;Run-Time Data Areas
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jvms-2.5-100"></a>The Java Virtual Machine defines various
               run-time data areas that are used during execution of a program. Some
               of these data areas are created on Java Virtual Machine start-up and are destroyed
               only when the Java Virtual Machine exits. Other data areas are per thread. Per-thread
               data areas are created when a thread is created and destroyed when the
               thread exits.
            </p>
            <div class="section" title="2.5.1.&nbsp;The pc Register">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.5.1"></a>2.5.1.&nbsp;The <code class="literal">pc</code> Register
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.5.1-100"></a>The Java Virtual Machine can support many
                  threads of execution at once (JLS &sect;17). Each Java Virtual Machine thread has its own
                  <code class="literal">pc</code> (program counter) register. At any point, each Java Virtual Machine thread is
                  executing the code of a single method, namely the current method
                  (<a class="xref" href="jvms-2.html#jvms-2.6" title="2.6.&nbsp;Frames">&sect;2.6</a>) for that thread. If that method is not
                  <code class="literal">native</code>, the <code class="literal">pc</code> register contains the address of the Java Virtual Machine
                  instruction currently being executed. If the method currently being
                  executed by the thread is <code class="literal">native</code>, the value of the Java Virtual Machine's <code class="literal">pc</code>
                  register is undefined. The Java Virtual Machine's <code class="literal">pc</code> register is wide enough to
                  hold a <code class="literal">returnAddress</code> or a native pointer on the specific
                  platform.
               </p>
            </div>
            <div class="section" title="2.5.2.&nbsp;Java Virtual Machine Stacks">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.5.2"></a>2.5.2.&nbsp;Java Virtual Machine Stacks
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.5.2-100"></a>Each Java Virtual Machine thread has a
                  private <span class="emphasis"><em>Java Virtual Machine stack</em></span>, created at the same time as
                  the thread. A Java Virtual Machine stack stores frames
                  (<a class="xref" href="jvms-2.html#jvms-2.6" title="2.6.&nbsp;Frames">&sect;2.6</a>). A Java Virtual Machine stack is analogous to the stack
                  of a conventional language such as C: it holds local variables and
                  partial results, and plays a part in method invocation and
                  return. Because the Java Virtual Machine stack is never manipulated directly except
                  to push and pop frames, frames may be heap allocated. The memory for a
                  Java Virtual Machine stack does not need to be contiguous.
               </p>
               <p class="note">In the First Edition of <em class="citetitle">The <span class="trademark">Java</span>&reg; Virtual Machine Specification</em>, the Java Virtual Machine stack
                  was known as the <span class="emphasis"><em>Java stack</em></span>.
               </p>
               <p class="norm"><a name="jvms-2.5.2-110"></a>This specification permits
                  Java Virtual Machine stacks either to be of a fixed size or to dynamically expand and
                  contract as required by the computation. If the Java Virtual Machine stacks are of a
                  fixed size, the size of each Java Virtual Machine stack may be chosen independently
                  when that stack is created.
               </p>
               <p class="note">A Java Virtual Machine implementation may provide the programmer or
                  the user control over the initial size of Java Virtual Machine stacks, as well as, in
                  the case of dynamically expanding or contracting Java Virtual Machine stacks, control
                  over the maximum and minimum sizes.
               </p>
               <p class="norm"><a name="jvms-2.5.2-200"></a>The following exceptional
                  conditions are associated with Java Virtual Machine stacks:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jvms-2.5.2-200-A"></a>If
                               the computation in a thread requires a larger Java Virtual Machine stack than is
                               permitted, the Java Virtual Machine throws a <code class="literal">StackOverflowError</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jvms-2.5.2-200-B"></a>If
                               Java Virtual Machine stacks can be dynamically expanded, and expansion is
                               attempted but insufficient memory can be made available to effect
                               the expansion, or if insufficient memory can be made available to
                               create the initial Java Virtual Machine stack for a new thread, the Java Virtual Machine throws
                               an <code class="literal">OutOfMemoryError</code>.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="2.5.3.&nbsp;Heap">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.5.3"></a>2.5.3.&nbsp;Heap
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.5.3-100"></a>The Java Virtual Machine has
                  a <span class="emphasis"><em>heap</em></span> that is shared among all Java Virtual Machine
                  threads. The heap is the run-time data area from which memory for all
                  class instances and arrays is allocated.
               </p>
               <p class="norm"><a name="jvms-2.5.3-110"></a>The heap is created on
                  virtual machine start-up. Heap storage for objects is reclaimed by an
                  automatic storage management system (known as a <span class="emphasis"><em>garbage
                        collector</em></span>); objects are never explicitly deallocated. The
                  Java Virtual Machine assumes no particular type of automatic storage management
                  system, and the storage management technique may be chosen according
                  to the implementor's system requirements. The heap may be of a fixed
                  size or may be expanded as required by the computation and may be
                  contracted if a larger heap becomes unnecessary. The memory for the
                  heap does not need to be contiguous.
               </p>
               <p class="note">A Java Virtual Machine implementation may provide the programmer or
                  the user control over the initial size of the heap, as well as, if the
                  heap can be dynamically expanded or contracted, control over the
                  maximum and minimum heap size.
               </p>
               <p class="norm"><a name="jvms-2.5.3-200"></a>The following exceptional
                  condition is associated with the heap:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jvms-2.5.3-200-A"></a>If a
                               computation requires more heap than can be made available by the
                               automatic storage management system, the Java Virtual Machine throws an
                               <code class="literal">OutOfMemoryError</code>.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="2.5.4.&nbsp;Method Area">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.5.4"></a>2.5.4.&nbsp;Method Area
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.5.4-100"></a>The Java Virtual Machine has
                  a <span class="emphasis"><em>method area</em></span> that is shared among all Java Virtual Machine
                  threads. The method area is analogous to the storage area for compiled
                  code of a conventional language or analogous to the "text" segment in
                  an operating system process. It stores per-class structures such as
                  the run-time constant pool, field and method data, and the code for
                  methods and constructors, including the special methods
                  (<a class="xref" href="jvms-2.html#jvms-2.9" title="2.9.&nbsp;Special Methods">&sect;2.9</a>) used in class and instance initialization
                  and interface initialization.
               </p>
               <p class="norm"><a name="jvms-2.5.4-110"></a>The method area is created
                  on virtual machine start-up. Although the method area is logically
                  part of the heap, simple implementations may choose not to either
                  garbage collect or compact it. This 
                  specification does not mandate the location of the method area or the
                  policies used to manage compiled code. The method area may be of a
                  fixed size or may be expanded as required by the computation and may
                  be contracted if a larger method area becomes unnecessary. The memory
                  for the method area does not need to be contiguous.
               </p>
               <p class="note">A Java Virtual Machine implementation may provide the programmer or
                  the user control over the initial size of the method area, as well as,
                  in the case of a varying-size method area, control over the maximum
                  and minimum method area size.
               </p>
               <p class="norm"><a name="jvms-2.5.4-200"></a>The following exceptional
                  condition is associated with the method area:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jvms-2.5.4-200-A"></a>If
                               memory in the method area cannot be made available to satisfy an
                               allocation request, the Java Virtual Machine throws an <code class="literal">OutOfMemoryError</code>.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="2.5.5.&nbsp;Run-Time Constant Pool">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.5.5"></a>2.5.5.&nbsp;Run-Time Constant Pool
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.5.5-100"></a>A <span class="emphasis"><em>run-time
                        constant pool</em></span> is a per-class or per-interface run-time
                  representation of the <code class="literal">constant_pool</code> table in a <code class="literal">class</code> file
                  (<a class="xref" href="jvms-4.html#jvms-4.4" title="4.4.&nbsp;The Constant Pool">&sect;4.4</a>). It contains several kinds of constants,
                  ranging from numeric literals known at compile-time to method and
                  field references that must be resolved at run-time. The run-time
                  constant pool serves a function similar to that of a symbol table for
                  a conventional programming language, although it contains a wider
                  range of data than a typical symbol table.
               </p>
               <p class="norm"><a name="jvms-2.5.5-110"></a>Each run-time constant pool
                  is allocated from the Java Virtual Machine's method area
                  (<a class="xref" href="jvms-2.html#jvms-2.5.4" title="2.5.4.&nbsp;Method Area">&sect;2.5.4</a>). The run-time constant pool for a class
                  or interface is constructed when the class or interface is created
                  (<a class="xref" href="jvms-5.html#jvms-5.3" title="5.3.&nbsp;Creation and Loading">&sect;5.3</a>) by the Java Virtual Machine.
               </p>
               <p class="norm"><a name="jvms-2.5.5-200"></a>The following exceptional
                  condition is associated with the construction of the run-time constant
                  pool for a class or interface:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jvms-2.5.5-200-A"></a>When
                               creating a class or interface, if the construction of the run-time
                               constant pool requires more memory than can be made available in
                               the method area of the Java Virtual Machine, the Java Virtual Machine throws an <code class="literal">OutOfMemoryError</code>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="note">See <a class="xref" href="jvms-5.html" title="Chapter&nbsp;5.&nbsp;Loading, Linking, and Initializing">&sect;5 (<i>Loading, Linking, and Initializing</i>)</a>  for information about the
                  construction of the run-time constant pool.
               </p>
            </div>
            <div class="section" title="2.5.6.&nbsp;Native Method Stacks">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.5.6"></a>2.5.6.&nbsp;Native Method Stacks
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.5.6-100"></a>An implementation of the
                  Java Virtual Machine may use conventional stacks, colloquially called "C stacks," to
                  support <code class="literal">native</code> methods (methods written in a language other than the
                  Java programming language). Native method stacks may also be used by the
                  implementation of an interpreter for the Java Virtual Machine's instruction set in a
                  language such as C. Java Virtual Machine implementations that cannot load <code class="literal">native</code>
                  methods and that do not themselves rely on conventional stacks need
                  not supply native method stacks. If supplied, native method stacks are
                  typically allocated per thread when each thread is created.
               </p>
               <p class="norm"><a name="jvms-2.5.6-110"></a>This specification permits
                  native method stacks either to be of a fixed size or to dynamically
                  expand and contract as required by the computation. If the native
                  method stacks are of a fixed size, the size of each native method
                  stack may be chosen independently when that stack is created.
               </p>
               <p class="note">A Java Virtual Machine implementation may provide the programmer or
                  the user control over the initial size of the native method stacks, as
                  well as, in the case of varying-size native method stacks, control
                  over the maximum and minimum method stack sizes.
               </p>
               <p class="norm"><a name="jvms-2.5.6-200"></a>The following exceptional
                  conditions are associated with native method stacks:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm-error"><a name="jvms-2.5.6-200-A"></a>If
                                 the computation in a thread requires a larger native method
                                 stack than is permitted, the Java Virtual Machine throws a <code class="literal">StackOverflowError</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm-error"><a name="jvms-2.5.6-200-B"></a>If
                               native method stacks can be dynamically expanded and native method
                               stack expansion is attempted but insufficient memory can be made
                               available, or if insufficient memory can be made available to
                               create the initial native method stack for a new thread, the Java Virtual Machine
                               throws an <code class="literal">OutOfMemoryError</code>.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
         </div>
         <div class="section" title="2.6.&nbsp;Frames">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jvms-2.6"></a>2.6.&nbsp;Frames
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jvms-2.6-100"></a>A <span class="emphasis"><em>frame</em></span>
               is used to store data and partial results, as well as to perform
               dynamic linking, return values for methods, and dispatch
               exceptions.
            </p>
            <p class="norm"><a name="jvms-2.6-110"></a>A new frame is created each
               time a method is invoked. A frame is destroyed when its method
               invocation completes, whether that completion is normal or abrupt (it
               throws an uncaught exception). Frames are allocated from the Java Virtual Machine
               stack (<a class="xref" href="jvms-2.html#jvms-2.5.2" title="2.5.2.&nbsp;Java Virtual Machine Stacks">&sect;2.5.2</a>) of the thread creating the
               frame. Each frame has its own array of local variables
               (<a class="xref" href="jvms-2.html#jvms-2.6.1" title="2.6.1.&nbsp;Local Variables">&sect;2.6.1</a>), its own operand stack
               (<a class="xref" href="jvms-2.html#jvms-2.6.2" title="2.6.2.&nbsp;Operand Stacks">&sect;2.6.2</a>), and a reference to the run-time
               constant pool (<a class="xref" href="jvms-2.html#jvms-2.5.5" title="2.5.5.&nbsp;Run-Time Constant Pool">&sect;2.5.5</a>) of the class of the
               current method.
            </p>
            <p class="note">A frame may be extended with additional
               implementation-specific information, such as debugging
               information.
            </p>
            <p class="norm"><a name="jvms-2.6-120"></a>The sizes of the local
               variable array and the operand stack are determined at compile-time
               and are supplied along with the code for the method associated with
               the frame (<a class="xref" href="jvms-4.html#jvms-4.7.3" title="4.7.3.&nbsp;The Code Attribute">&sect;4.7.3</a>). Thus the size of the frame
               data structure depends only on the implementation of the Java Virtual Machine, and
               the memory for these structures can be allocated simultaneously on
               method invocation.
            </p>
            <p class="norm"><a name="jvms-2.6-200"></a>Only one frame, the frame for
               the executing method, is active at any point in a given thread of
               control. This frame is referred to as the <span class="emphasis"><em>current
                     frame</em></span>, and its method is known as the <span class="emphasis"><em>current
                     method</em></span>. The class in which the current method is defined is
               the <span class="emphasis"><em>current class</em></span>. Operations on local variables
               and the operand stack are typically with reference to the current
               frame.
            </p>
            <p class="norm"><a name="jvms-2.6-210"></a>A frame ceases to be current
               if its method invokes another method or if its method completes. When
               a method is invoked, a new frame is created and becomes current when
               control transfers to the new method. On method return, the current
               frame passes back the result of its method invocation, if any, to the
               previous frame. The current frame is then discarded as the previous
               frame becomes the current one.
            </p>
            <p class="norm"><a name="jvms-2.6-300"></a>Note that a frame created by a
               thread is local to that thread and cannot be referenced by any other
               thread.
            </p>
            <div class="section" title="2.6.1.&nbsp;Local Variables">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.6.1"></a>2.6.1.&nbsp;Local Variables
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.6.1-100"></a>Each frame
                  (<a class="xref" href="jvms-2.html#jvms-2.6" title="2.6.&nbsp;Frames">&sect;2.6</a>) contains an array of variables known as
                  its <span class="emphasis"><em>local variables</em></span>. The length of the local
                  variable array of a frame is determined at compile-time and supplied
                  in the binary representation of a class or interface along with the
                  code for the method associated with the frame
                  (<a class="xref" href="jvms-4.html#jvms-4.7.3" title="4.7.3.&nbsp;The Code Attribute">&sect;4.7.3</a>).
               </p>
               <p class="norm"><a name="jvms-2.6.1-110"></a>A single local variable can
                  hold a value of type <code class="literal">boolean</code>, <code class="literal">byte</code>, <code class="literal">char</code>, <code class="literal">short</code>, <code class="literal">int</code>,
                  <code class="literal">float</code>, <code class="literal">reference</code>, or <code class="literal">returnAddress</code>. A pair of local variables can hold
                  a value of type <code class="literal">long</code> or <code class="literal">double</code>.
               </p>
               <p class="norm"><a name="jvms-2.6.1-200"></a>Local variables are
                  addressed by indexing. The index of the first local variable is
                  zero. An integer is considered to be an index into the local variable
                  array if and only if that integer is between zero and one less than
                  the size of the local variable array.
               </p>
               <p class="norm"><a name="jvms-2.6.1-210"></a>A value of type <code class="literal">long</code> or
                  type <code class="literal">double</code> occupies two consecutive local variables. Such a value
                  may only be addressed using the lesser index. For example, a value of
                  type <code class="literal">double</code> stored in the local variable array at index <span class="emphasis"><em>n</em></span>
                  actually occupies the local variables with indices <span class="emphasis"><em>n</em></span> and
                  <span class="emphasis"><em>n</em></span>+1; however, the local variable at index <span class="emphasis"><em>n</em></span>+1 cannot be
                  loaded from. It can be stored into. However, doing so invalidates the
                  contents of local variable <span class="emphasis"><em>n</em></span>.
               </p>
               <p class="norm"><a name="jvms-2.6.1-220"></a>The Java Virtual Machine does not require
                  <span class="emphasis"><em>n</em></span> to be even. In intuitive terms, values of types <code class="literal">long</code> and
                  <code class="literal">double</code> need not be 64-bit aligned in the local variables
                  array. Implementors are free to decide the appropriate way to
                  represent such values using the two local variables reserved for the
                  value.
               </p>
               <p class="norm"><a name="jvms-2.6.1-300"></a>The Java Virtual Machine uses local
                  variables to pass parameters on method invocation. On class method
                  invocation, any parameters are passed in consecutive local variables
                  starting from local variable <span class="emphasis"><em>0</em></span>. On instance
                  method invocation, local variable <span class="emphasis"><em>0</em></span> is always
                  used to pass a reference to the object on which the instance method is
                  being invoked (<code class="literal">this</code> in the Java programming language). Any parameters are
                  subsequently passed in consecutive local variables starting from local
                  variable <span class="emphasis"><em>1</em></span>.
               </p>
            </div>
            <div class="section" title="2.6.2.&nbsp;Operand Stacks">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.6.2"></a>2.6.2.&nbsp;Operand Stacks
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.6.2-100"></a>Each frame
                  (<a class="xref" href="jvms-2.html#jvms-2.6" title="2.6.&nbsp;Frames">&sect;2.6</a>) contains a last-in-first-out (LIFO) stack
                  known as its <span class="emphasis"><em>operand stack</em></span>. The maximum depth of
                  the operand stack of a frame is determined at compile-time and is
                  supplied along with the code for the method associated with the frame
                  (<a class="xref" href="jvms-4.html#jvms-4.7.3" title="4.7.3.&nbsp;The Code Attribute">&sect;4.7.3</a>).
               </p>
               <p class="norm"><a name="jvms-2.6.2-110"></a>Where it is clear by
                  context, we will sometimes refer to the operand stack of the current
                  frame as simply the operand stack.
               </p>
               <p class="norm"><a name="jvms-2.6.2-200"></a>The operand stack is empty
                  when the frame that contains it is created. The Java Virtual Machine supplies
                  instructions to load constants or values from local variables or
                  fields onto the operand stack. Other Java Virtual Machine instructions take operands
                  from the operand stack, operate on them, and push the result back onto
                  the operand stack. The operand stack is also used to prepare
                  parameters to be passed to methods and to receive method
                  results.
               </p>
               <p class="norm"><a name="jvms-2.6.2-210"></a>For example, the <span class="emphasis"><em>iadd</em></span>
                  instruction (<a class="xref" href="jvms-6.html#jvms-6.5.iadd" title="iadd">&sect;<span class="emphasis"><em>iadd</em></span></a>) adds two <code class="literal">int</code> values
                  together. It requires that the <code class="literal">int</code> values to be added be the top two
                  values of the operand stack, pushed there by previous
                  instructions. Both of the <code class="literal">int</code> values are popped from the operand
                  stack. They are added, and their sum is pushed back onto the operand
                  stack. Subcomputations may be nested on the operand stack, resulting
                  in values that can be used by the encompassing computation.
               </p>
               <p class="norm"><a name="jvms-2.6.2-300"></a>Each entry on the operand
                  stack can hold a value of any Java Virtual Machine type, including a value of type
                  <code class="literal">long</code> or type <code class="literal">double</code>.
               </p>
               <p class="norm"><a name="jvms-2.6.2-310"></a>Values from the operand
                  stack must be operated upon in ways appropriate to their types. It is
                  not possible, for example, to push two <code class="literal">int</code> values and subsequently
                  treat them as a <code class="literal">long</code> or to push two <code class="literal">float</code> values and subsequently
                  add them with an <span class="emphasis"><em>iadd</em></span> instruction. A small number of Java Virtual Machine
                  instructions (the <span class="emphasis"><em>dup</em></span> instructions (<a class="xref" href="jvms-6.html#jvms-6.5.dup" title="dup">&sect;<span class="emphasis"><em>dup</em></span></a>)
                  and <span class="emphasis"><em>swap</em></span> (<a class="xref" href="jvms-6.html#jvms-6.5.swap" title="swap">&sect;<span class="emphasis"><em>swap</em></span></a>)) operate on run-time data
                  areas as raw values without regard to their specific types; these
                  instructions are defined in such a way that they cannot be used to
                  modify or break up individual values. These restrictions on operand
                  stack manipulation are enforced through <code class="literal">class</code> file verification
                  (<a class="xref" href="jvms-4.html#jvms-4.10" title="4.10.&nbsp;Verification of class Files">&sect;4.10</a>).
               </p>
               <p class="norm"><a name="jvms-2.6.2-400"></a>At any point in time, an
                  operand stack has an associated depth, where a value of type <code class="literal">long</code> or
                  <code class="literal">double</code> contributes two units to the depth and a value of any other
                  type contributes one unit.
               </p>
            </div>
            <div class="section" title="2.6.3.&nbsp;Dynamic Linking">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.6.3"></a>2.6.3.&nbsp;Dynamic Linking
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.6.3-100"></a>Each frame
                  (<a class="xref" href="jvms-2.html#jvms-2.6" title="2.6.&nbsp;Frames">&sect;2.6</a>) contains a reference to the run-time
                  constant pool (<a class="xref" href="jvms-2.html#jvms-2.5.5" title="2.5.5.&nbsp;Run-Time Constant Pool">&sect;2.5.5</a>) for the type of the
                  current method to support <span class="emphasis"><em>dynamic linking</em></span> of the
                  method code. The <code class="literal">class</code> file code for a method refers to methods to
                  be invoked and variables to be accessed via symbolic
                  references. Dynamic linking translates these symbolic method
                  references into concrete method references, loading classes as
                  necessary to resolve as-yet-undefined symbols, and translates variable
                  accesses into appropriate offsets in storage structures associated
                  with the run-time location of these variables.
               </p>
               <p class="norm"><a name="jvms-2.6.3-110"></a>This late binding of the
                  methods and variables makes changes in other classes that a method
                  uses less likely to break this code.
               </p>
            </div>
            <div class="section" title="2.6.4.&nbsp;Normal Method Invocation Completion">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.6.4"></a>2.6.4.&nbsp;Normal Method Invocation Completion
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.6.4-100"></a>A method invocation
                  <span class="emphasis"><em>completes normally</em></span> if that invocation does not
                  cause an exception (<a class="xref" href="jvms-2.html#jvms-2.10" title="2.10.&nbsp;Exceptions">&sect;2.10</a>) to be thrown, either
                  directly from the Java Virtual Machine or as a result of executing an explicit
                  <code class="literal">throw</code> statement. If the invocation of the current method completes
                  normally, then a value may be returned to the invoking method. This
                  occurs when the invoked method executes one of the return instructions
                  (<a class="xref" href="jvms-2.html#jvms-2.11.8" title="2.11.8.&nbsp;Method Invocation and Return Instructions">&sect;2.11.8</a>), the choice of which must be
                  appropriate for the type of the value being returned (if any).
               </p>
               <p class="norm"><a name="jvms-2.6.4-110"></a>The current frame
                  (<a class="xref" href="jvms-2.html#jvms-2.6" title="2.6.&nbsp;Frames">&sect;2.6</a>) is used in this case to restore the state
                  of the invoker, including its local variables and operand stack, with
                  the program counter of the invoker appropriately incremented to skip
                  past the method invocation instruction. Execution then continues
                  normally in the invoking method's frame with the returned value (if
                  any) pushed onto the operand stack of that frame.
               </p>
            </div>
            <div class="section" title="2.6.5.&nbsp;Abrupt Method Invocation Completion">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.6.5"></a>2.6.5.&nbsp;Abrupt Method Invocation Completion
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.6.5-100"></a>A method invocation
                  <span class="emphasis"><em>completes abruptly</em></span> if execution of a Java Virtual Machine
                  instruction within the method causes the Java Virtual Machine to throw an exception
                  (<a class="xref" href="jvms-2.html#jvms-2.10" title="2.10.&nbsp;Exceptions">&sect;2.10</a>), and that exception is not handled
                  within the method. Execution of an <span class="emphasis"><em>athrow</em></span> instruction
                  (<a class="xref" href="jvms-6.html#jvms-6.5.athrow" title="athrow">&sect;<span class="emphasis"><em>athrow</em></span></a>) also causes an exception to be
                  explicitly thrown and, if the exception is not caught by the current
                  method, results in abrupt method invocation completion. A method
                  invocation that completes abruptly never returns a value to its
                  invoker.
               </p>
            </div>
         </div>
         <div class="section" title="2.7.&nbsp;Representation of Objects">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jvms-2.7"></a>2.7.&nbsp;Representation of Objects
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jvms-2.7-100"></a>The Java Virtual Machine does not mandate any
               particular internal structure for objects.
            </p>
            <p class="note">In some of Oracle&#8217;s implementations of the Java Virtual Machine, a
               reference to a class instance is a pointer to
               a <span class="emphasis"><em>handle</em></span> that is itself a pair of pointers: one
               to a table containing the methods of the object and a pointer to the
               <code class="literal">Class</code> object that represents the type of the object, and the other
               to the memory allocated from the heap for the object data.
            </p>
         </div>
         <div class="section" title="2.8.&nbsp;Floating-Point Arithmetic">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jvms-2.8"></a>2.8.&nbsp;Floating-Point Arithmetic
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jvms-2.8-100"></a>The Java Virtual Machine incorporates a
               subset of the floating-point arithmetic specified in <em class="citetitle">IEEE
                  Standard for Binary Floating-Point Arithmetic</em> (ANSI/IEEE
               Std. 754-1985, New York).
            </p>
            <div class="section" title="2.8.1.&nbsp;Java Virtual Machine Floating-Point Arithmetic and IEEE 754">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.8.1"></a>2.8.1.&nbsp;Java Virtual Machine Floating-Point Arithmetic and IEEE 754
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.8.1-100"></a>The key differences between
                  the floating-point arithmetic supported by the Java Virtual Machine and the IEEE 754
                  standard are:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.8.1-100-A"></a>The floating-point
                               operations of the Java Virtual Machine do not throw exceptions, trap, or
                               otherwise signal the IEEE 754 exceptional conditions of invalid
                               operation, division by zero, overflow, underflow, or inexact. The
                               Java Virtual Machine has no signaling NaN value.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.8.1-100-B"></a>The Java Virtual Machine does not
                               support IEEE 754 signaling floating-point comparisons.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.8.1-100-C"></a>The rounding
                               operations of the Java Virtual Machine always use IEEE 754 round to nearest
                               mode. Inexact results are rounded to the nearest representable
                               value, with ties going to the value with a zero least-significant
                               bit. This is the IEEE 754 default mode. But Java Virtual Machine instructions
                               that convert values of floating-point types to values of integral
                               types round toward zero. The Java Virtual Machine does not give any means to
                               change the floating-point rounding mode.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.8.1-100-D"></a>The Java Virtual Machine does not
                               support either the IEEE 754 single extended or double extended
                               format, except insofar as the double and double-extended-exponent
                               value sets may be said to support the single extended format. The
                               float-extended-exponent and double-extended-exponent value sets,
                               which may optionally be supported, do not correspond to the values
                               of the IEEE 754 extended formats: the IEEE 754 extended formats
                               require extended precision as well as extended exponent
                               range.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="2.8.2.&nbsp;Floating-Point Modes">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.8.2"></a>2.8.2.&nbsp;Floating-Point Modes
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.8.2-100"></a>Every method has a
                  <span class="emphasis"><em>floating-point mode</em></span>, which is
                  either <span class="emphasis"><em>FP-strict</em></span> or <span class="emphasis"><em>not
                        FP-strict</em></span>. The floating-point mode of a method is
                  determined by the setting of the <code class="literal">ACC_STRICT</code> flag of the
                  <code class="literal">access_flags</code> item of the <code class="literal">method_info</code> structure
                  (<a class="xref" href="jvms-4.html#jvms-4.6" title="4.6.&nbsp;Methods">&sect;4.6</a>) defining the method. A method for which
                  this flag is set is FP-strict; otherwise, the method is not
                  FP-strict.
               </p>
               <p class="note">Note that this mapping of the <code class="literal">ACC_STRICT</code> flag
                  implies that methods in classes compiled by a compiler in JDK release
                  1.1 or earlier are effectively not FP-strict.
               </p>
               <p class="norm"><a name="jvms-2.8.2-200"></a>We will refer to an operand
                  stack as having a given floating-point mode when the method whose
                  invocation created the frame containing the operand stack has that
                  floating-point mode. Similarly, we will refer to a Java Virtual Machine instruction
                  as having a given floating-point mode when the method containing that
                  instruction has that floating-point mode.
               </p>
               <p class="norm"><a name="jvms-2.8.2-300"></a>If a float-extended-exponent
                  value set is supported (<a class="xref" href="jvms-2.html#jvms-2.3.2" title="2.3.2.&nbsp;Floating-Point Types, Value Sets, and Values">&sect;2.3.2</a>), values of type
                  <code class="literal">float</code> on an operand stack that is not FP-strict may range over that
                  value set except where prohibited by value set conversion
                  (<a class="xref" href="jvms-2.html#jvms-2.8.3" title="2.8.3.&nbsp;Value Set Conversion">&sect;2.8.3</a>). If a double-extended-exponent value
                  set is supported (<a class="xref" href="jvms-2.html#jvms-2.3.2" title="2.3.2.&nbsp;Floating-Point Types, Value Sets, and Values">&sect;2.3.2</a>), values of type
                  <code class="literal">double</code> on an operand stack that is not FP-strict may range over that
                  value set except where prohibited by value set conversion.
               </p>
               <p class="norm"><a name="jvms-2.8.2-310"></a>In all other contexts,
                  whether on the operand stack or elsewhere, and regardless of
                  floating-point mode, floating-point values of type <code class="literal">float</code> and
                  <code class="literal">double</code> may only range over the float value set and double value set,
                  respectively. In particular, class and instance fields, array
                  elements, local variables, and method parameters may only contain
                  values drawn from the standard value sets.
               </p>
            </div>
            <div class="section" title="2.8.3.&nbsp;Value Set Conversion">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.8.3"></a>2.8.3.&nbsp;Value Set Conversion
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.8.3-100"></a>An implementation of the
                  Java Virtual Machine that supports an extended floating-point value set is permitted
                  or required, under specified circumstances, to map a value of the
                  associated floating-point type between the extended and the standard
                  value sets. Such a <span class="emphasis"><em>value set conversion</em></span> is not a
                  type conversion, but a mapping between the value sets associated with
                  the same type.
               </p>
               <p class="norm"><a name="jvms-2.8.3-110"></a>Where value set conversion
                  is indicated, an implementation is permitted to perform one of the
                  following operations on a value:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.8.3-110-A"></a>If the value is of
                               type <code class="literal">float</code> and is not an element of the float value set, it maps
                               the value to the nearest element of the float value set.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.8.3-110-B"></a>If the value is of
                               type <code class="literal">double</code> and is not an element of the double value set, it
                               maps the value to the nearest element of the double value
                               set.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jvms-2.8.3-120"></a>In addition, where value set
                  conversion is indicated, certain operations are required:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.8.3-120-A"></a>Suppose execution of a
                               Java Virtual Machine instruction that is not FP-strict causes a value of type
                               <code class="literal">float</code> to be pushed onto an operand stack that is FP-strict,
                               passed as a parameter, or stored into a local variable, a field,
                               or an element of an array. If the value is not an element of the
                               float value set, it maps the value to the nearest element of the
                               float value set.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.8.3-120-B"></a>Suppose execution of a
                               Java Virtual Machine instruction that is not FP-strict causes a value of type
                               <code class="literal">double</code> to be pushed onto an operand stack that is FP-strict,
                               passed as a parameter, or stored into a local variable, a field,
                               or an element of an array. If the value is not an element of the
                               double value set, it maps the value to the nearest element of the
                               double value set.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jvms-2.8.3-130"></a>Such required value set
                  conversions may occur as a result of passing a parameter of a
                  floating-point type during method invocation, including <code class="literal">native</code>
                  method invocation; returning a value of a floating-point type from a
                  method that is not FP-strict to a method that is FP-strict; or storing
                  a value of a floating-point type into a local variable, a field, or an
                  array in a method that is not FP-strict.
               </p>
               <p class="norm"><a name="jvms-2.8.3-140"></a>Not all values from an
                  extended-exponent value set can be mapped exactly to a value in the
                  corresponding standard value set. If a value being mapped is too large
                  to be represented exactly (its exponent is greater than that permitted
                  by the standard value set), it is converted to a (positive or
                  negative) infinity of the corresponding type. If a value being mapped
                  is too small to be represented exactly (its exponent is smaller than
                  that permitted by the standard value set), it is rounded to the
                  nearest of a representable denormalized value or zero of the same
                  sign.
               </p>
               <p class="norm"><a name="jvms-2.8.3-150"></a>Value set conversion
                  preserves infinities and NaNs and cannot change the sign of the value
                  being converted. Value set conversion has no effect on a value that is
                  not of a floating-point type.
               </p>
            </div>
         </div>
         <div class="section" title="2.9.&nbsp;Special Methods">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jvms-2.9"></a>2.9.&nbsp;Special Methods
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jvms-2.9-100"></a>At the level of the Java Virtual Machine,
               every constructor written in the Java programming language (JLS &sect;8.8) appears as
               an <span class="emphasis"><em>instance initialization method</em></span> that has the
               special name <code class="literal">&lt;init&gt;</code>. This name is supplied by a compiler. Because the
               name <code class="literal">&lt;init&gt;</code> is not a valid identifier, it cannot be used directly in a
               program written in the Java programming language. Instance initialization methods may
               be invoked only within the Java Virtual Machine by the <span class="emphasis"><em>invokespecial</em></span> instruction
               (<a class="xref" href="jvms-6.html#jvms-6.5.invokespecial" title="invokespecial">&sect;<span class="emphasis"><em>invokespecial</em></span></a>), and they may be invoked only
               on uninitialized class instances. An instance initialization method
               takes on the access permissions (JLS &sect;6.6) of the constructor from
               which it was derived.
            </p>
            <p class="norm"><a name="jvms-2.9-200"></a>A class or interface has at
               most one <span class="emphasis"><em>class or interface initialization method</em></span>
               and is initialized (<a class="xref" href="jvms-5.html#jvms-5.5" title="5.5.&nbsp;Initialization">&sect;5.5</a>) by invoking that
               method. The initialization method of a class or interface has the
               special name <code class="literal">&lt;clinit&gt;</code>, takes no arguments, and is void
               (<a class="xref" href="jvms-4.html#jvms-4.3.3" title="4.3.3.&nbsp;Method Descriptors">&sect;4.3.3</a>).
            </p>
            <p class="note">Other methods named <code class="literal">&lt;clinit&gt;</code> in a <code class="literal">class</code> file are
               of no consequence. They are not class or interface initialization
               methods. They cannot be invoked by any Java Virtual Machine instruction and are never
               invoked by the Java Virtual Machine itself.
            </p>
            <p class="norm"><a name="jvms-2.9-210"></a>In a <code class="literal">class</code> file whose
               version number is 51.0 or above, the method must additionally have its
               <code class="literal">ACC_STATIC</code> flag (<a class="xref" href="jvms-4.html#jvms-4.6" title="4.6.&nbsp;Methods">&sect;4.6</a>) set in order to be the
               class or interface initialization method.
            </p>
            <p class="note">This requirement was introduced in Java SE 7. In a
               class file whose version number is 50.0 or below, a method named
               <code class="literal">&lt;clinit&gt;</code> that is void and takes no arguments is considered the class
               or interface initialization method regardless of the setting of its
               <code class="literal">ACC_STATIC</code> flag.
            </p>
            <p class="norm"><a name="jvms-2.9-220"></a>The name <code class="literal">&lt;clinit&gt;</code> is supplied
               by a compiler. Because the name <code class="literal">&lt;clinit&gt;</code> is not a valid identifier, it
               cannot be used directly in a program written in the Java programming language. Class
               and interface initialization methods are invoked implicitly by the
               Java Virtual Machine; they are never invoked directly from any Java Virtual Machine instruction, but
               are invoked only indirectly as part of the class initialization
               process.
            </p>
            <p class="norm"><a name="jvms-2.9-300"></a>A method
               is <span class="emphasis"><em>signature polymorphic</em></span> if all of the following
               are true:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.9-300-A"></a>
                              It is declared in the <code class="literal">java.lang.invoke.MethodHandle</code> class.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.9-300-B"></a>
                              It has a single formal parameter of type
                              <code class="literal">Object</code><code class="literal">[]</code>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.9-300-C"></a>
                              It has a return type of <code class="literal">Object</code>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.9-300-D"></a>
                              It has the <code class="literal">ACC_VARARGS</code> and <code class="literal">ACC_NATIVE</code> flags set.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="note">In Java SE 8, the only signature polymorphic methods
               are the <code class="literal">invoke</code> and <code class="literal">invokeExact</code> methods of the class
               <code class="literal">java.lang.invoke.MethodHandle</code>.
            </p>
            <p class="norm"><a name="jvms-2.9-310"></a>The Java Virtual Machine gives special
               treatment to signature polymorphic methods in the <span class="emphasis"><em>invokevirtual</em></span>
               instruction (<a class="xref" href="jvms-6.html#jvms-6.5.invokevirtual" title="invokevirtual">&sect;<span class="emphasis"><em>invokevirtual</em></span></a>), in order to
               effect invocation of a <span class="emphasis"><em>method handle</em></span>. A method
               handle is a strongly typed, directly executable reference to an
               underlying method, constructor, field, or similar low-level operation
               (<a class="xref" href="jvms-5.html#jvms-5.4.3.5" title="5.4.3.5.&nbsp;Method Type and Method Handle Resolution">&sect;5.4.3.5</a>), with optional transformations of
               arguments or return values. These transformations are quite general,
               and include such patterns as conversion, insertion, deletion, and
               substitution. See the <code class="literal">java.lang.invoke</code> package in
               the Java SE platform API for more information.
            </p>
         </div>
         <div class="section" title="2.10.&nbsp;Exceptions">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jvms-2.10"></a>2.10.&nbsp;Exceptions
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jvms-2.10-100"></a>An exception in the Java Virtual Machine is
               represented by an instance of the class <code class="literal">Throwable</code> or one of its
               subclasses. Throwing an exception results in an immediate nonlocal
               transfer of control from the point where the exception was
               thrown.
            </p>
            <p class="norm"><a name="jvms-2.10-110"></a>Most exceptions occur
               synchronously as a result of an action by the thread in which they
               occur. An asynchronous exception, by contrast, can potentially occur
               at any point in the execution of a program. The Java Virtual Machine throws an
               exception for one of three reasons:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.10-110-A"></a>An <span class="emphasis"><em>athrow</em></span> instruction
                            (<a class="xref" href="jvms-6.html#jvms-6.5.athrow" title="athrow">&sect;<span class="emphasis"><em>athrow</em></span></a>) was executed.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.10-110-B"></a>An abnormal execution
                            condition was synchronously detected by the Java Virtual Machine. These
                            exceptions are not thrown at an arbitrary point in the program,
                            but only synchronously after execution of an instruction that
                            either:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="circle">
                           <li class="listitem">
                              <p class="norm"><a name="jvms-2.10-110-B-A"></a>Specifies the
                                 	exception as a possible result, such as:
                              </p>
                              <div class="norm">
                                 <ul class="norm" type="square">
                                    <li class="listitem">
                                       <p class="norm"><a name="jvms-2.10-110-B-A-A"></a>When the
                                          	    instruction embodies an operation that violates the
                                          	    semantics of the Java programming language, for example indexing outside
                                          	    the bounds of an array.
                                       </p>
                                    </li>
                                    <li class="listitem">
                                       <p class="norm"><a name="jvms-2.10-110-B-A-B"></a>When an
                                          	    error occurs in loading or linking part of the
                                          	    program.
                                       </p>
                                    </li>
                                 </ul>
                              </div>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jvms-2.10-110-B-B"></a>Causes some limit
                                 	on a resource to be exceeded, for example when too much memory
                                 	is used.
                              </p>
                           </li>
                        </ul>
                     </div>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.10-110-C"></a>An asynchronous
                            exception occurred because:
                     </p>
                     <div class="norm">
                        <ul class="norm" type="circle">
                           <li class="listitem">
                              <p class="norm"><a name="jvms-2.10-110-C-A"></a>The <code class="literal">stop</code> method
                                 	of class <code class="literal">Thread</code>
                                 	or <code class="literal">ThreadGroup</code> was invoked, or
                              </p>
                           </li>
                           <li class="listitem">
                              <p class="norm"><a name="jvms-2.10-110-C-B"></a>An internal error
                                 	occurred in the Java Virtual Machine implementation.
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p class="norm"><a name="jvms-2.10-110-C.1"></a>The <code class="literal">stop</code> methods
                              may be invoked by one thread to affect another thread or all the
                              threads in a specified thread group. They are asynchronous
                              because they may occur at any point in the execution of the
                              other thread or threads. An internal error is considered
                              asynchronous (<a class="xref" href="jvms-6.html#jvms-6.3" title="6.3.&nbsp;Virtual Machine Errors">&sect;6.3</a>).
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jvms-2.10-200"></a>A Java Virtual Machine may permit a small
               but bounded amount of execution to occur before an asynchronous
               exception is thrown. This delay is permitted to allow optimized code
               to detect and throw these exceptions at points where it is practical
               to handle them while obeying the semantics of the Java programming language.
            </p>
            <p class="note">A simple implementation might poll for asynchronous
               exceptions at the point of each control transfer instruction. Since a
               program has a finite size, this provides a bound on the total delay in
               detecting an asynchronous exception. Since no asynchronous exception
               will occur between control transfers, the code generator has some
               flexibility to reorder computation between control transfers for
               greater performance. The paper <em class="citetitle">Polling Efficiently on Stock
                  Hardware</em> by Marc Feeley, <em class="citetitle">Proc. 1993 Conference
                  on Functional Programming and Computer Architecture</em>,
               Copenhagen, Denmark, pp. 179&#8211;187, is recommended as further
               reading.
            </p>
            <p class="norm"><a name="jvms-2.10-300"></a>Exceptions thrown by the
               Java Virtual Machine are precise: when the transfer of control takes place, all
               effects of the instructions executed before the point from which the
               exception is thrown must appear to have taken place. No instructions
               that occur after the point from which the exception is thrown may
               appear to have been evaluated. If optimized code has speculatively
               executed some of the instructions which follow the point at which the
               exception occurs, such code must be prepared to hide this speculative
               execution from the user-visible state of the program.
            </p>
            <p class="norm"><a name="jvms-2.10-400"></a>Each method in the Java Virtual Machine may
               be associated with zero or more <span class="emphasis"><em>exception
                     handlers</em></span>. An exception handler specifies the range of
               offsets into the Java Virtual Machine code implementing the method for which the
               exception handler is active, describes the type of exception that the
               exception handler is able to handle, and specifies the location of the
               code that is to handle that exception. An exception matches an
               exception handler if the offset of the instruction that caused the
               exception is in the range of offsets of the exception handler and the
               exception type is the same class as or a subclass of the class of
               exception that the exception handler handles. When an exception is
               thrown, the Java Virtual Machine searches for a matching exception handler in the
               current method. If a matching exception handler is found, the system
               branches to the exception handling code specified by the matched
               handler.
            </p>
            <p class="norm"><a name="jvms-2.10-410"></a>If no such exception handler
               is found in the current method, the current method invocation
               completes abruptly (<a class="xref" href="jvms-2.html#jvms-2.6.5" title="2.6.5.&nbsp;Abrupt Method Invocation Completion">&sect;2.6.5</a>). On abrupt
               completion, the operand stack and local variables of the current
               method invocation are discarded, and its frame is popped, reinstating
               the frame of the invoking method. The exception is then rethrown in
               the context of the invoker's frame and so on, continuing up the method
               invocation chain. If no suitable exception handler is found before the
               top of the method invocation chain is reached, the execution of the
               thread in which the exception was thrown is terminated.
            </p>
            <p class="norm"><a name="jvms-2.10-420"></a>The order in which the
               exception handlers of a method are searched for a match is
               important. Within a <code class="literal">class</code> file, the exception handlers for each
               method are stored in a table (<a class="xref" href="jvms-4.html#jvms-4.7.3" title="4.7.3.&nbsp;The Code Attribute">&sect;4.7.3</a>). At run
               time, when an exception is thrown, the Java Virtual Machine searches the exception
               handlers of the current method in the order that they appear in the
               corresponding exception handler table in the <code class="literal">class</code> file, starting
               from the beginning of that table.
            </p>
            <p class="norm"><a name="jvms-2.10-430"></a>Note that the Java Virtual Machine does not
               enforce nesting of or any ordering of the exception table entries of a
               method. The exception handling semantics of the Java programming language are
               implemented only through cooperation with the compiler
               (<a class="xref" href="jvms-3.html#jvms-3.12" title="3.12.&nbsp;Throwing and Handling Exceptions">&sect;3.12</a>). When <code class="literal">class</code> files are generated by
               some other means, the defined search procedure ensures that
               all  Java Virtual Machine implementations will behave
               consistently.
            </p>
         </div>
         <div class="section" title="2.11.&nbsp;Instruction Set Summary">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jvms-2.11"></a>2.11.&nbsp;Instruction Set Summary
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jvms-2.11-100"></a>A Java Virtual Machine instruction consists
               of a one-byte <span class="emphasis"><em>opcode</em></span> specifying the operation to
               be performed, followed by zero or more <span class="emphasis"><em>operands</em></span>
               supplying arguments or data that are used by the operation. Many
               instructions have no operands and consist only of an opcode.
            </p>
            <p class="norm"><a name="jvms-2.11-110"></a>Ignoring exceptions, the
               inner loop of a Java Virtual Machine interpreter is effectively
            </p><pre class="screen">
do {
    atomically calculate pc and fetch opcode at pc;
    if (operands) fetch operands;
    execute the action for the opcode;
} while (there is more to do);
</pre><p class="norm"><a name="jvms-2.11-200"></a>The number and size of the
               operands are determined by the opcode. If an operand is more than one
               byte in size, then it is stored in <span class="emphasis"><em>big-endian</em></span>
               order - high-order byte first. For example, an unsigned 16-bit index
               into the local variables is stored as two unsigned
               bytes, <span class="emphasis"><em>byte1</em></span> and
               <span class="emphasis"><em>byte2</em></span>, such that its value is
               (<span class="emphasis"><em>byte1</em></span> <code class="literal">&lt;&lt;</code> 8)
               | <span class="emphasis"><em>byte2</em></span>.
            </p>
            <p class="norm"><a name="jvms-2.11-210"></a>The bytecode instruction
               stream is only single-byte aligned. The two exceptions are the
               <span class="emphasis"><em>lookupswitch</em></span> and <span class="emphasis"><em>tableswitch</em></span> instructions
               (<a class="xref" href="jvms-6.html#jvms-6.5.lookupswitch" title="lookupswitch">&sect;<span class="emphasis"><em>lookupswitch</em></span></a>,
               <a class="xref" href="jvms-6.html#jvms-6.5.tableswitch" title="tableswitch">&sect;<span class="emphasis"><em>tableswitch</em></span></a>), which are padded to force
               internal alignment of some of their operands on 4-byte
               boundaries.
            </p>
            <p class="note">The decision to limit the Java Virtual Machine opcode to a byte and
               to forgo data alignment within compiled code reflects a conscious bias
               in favor of compactness, possibly at the cost of some performance in
               naive implementations. A one-byte opcode also limits the size of the
               instruction set. Not assuming data alignment means that immediate data
               larger than a byte must be constructed from bytes at run time on many
               machines.
            </p>
            <div class="section" title="2.11.1.&nbsp;Types and the Java Virtual Machine">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.11.1"></a>2.11.1.&nbsp;Types and the Java Virtual Machine
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.11.1-100"></a>Most of the instructions in
                  the Java Virtual Machine instruction set encode type information about the operations
                  they perform. For instance, the <span class="emphasis"><em>iload</em></span> instruction
                  (<a class="xref" href="jvms-6.html#jvms-6.5.iload" title="iload">&sect;<span class="emphasis"><em>iload</em></span></a>) loads the contents of a local
                  variable, which must be an <code class="literal">int</code>, onto the operand stack. The <span class="emphasis"><em>fload</em></span>
                  instruction (<a class="xref" href="jvms-6.html#jvms-6.5.fload" title="fload">&sect;<span class="emphasis"><em>fload</em></span></a>) does the same with a
                  <code class="literal">float</code> value. The two instructions may have identical
                  implementations, but have distinct opcodes.
               </p>
               <p class="norm"><a name="jvms-2.11.1-110"></a>For the majority of typed
                  instructions, the instruction type is represented explicitly in the
                  opcode mnemonic by a letter: <span class="emphasis"><em>i</em></span> for an <code class="literal">int</code> operation, <span class="emphasis"><em>l</em></span> for
                  <code class="literal">long</code>, <span class="emphasis"><em>s</em></span> for <code class="literal">short</code>, <span class="emphasis"><em>b</em></span> for <code class="literal">byte</code>, <span class="emphasis"><em>c</em></span> for <code class="literal">char</code>,
                  <span class="emphasis"><em>f</em></span> for <code class="literal">float</code>, <span class="emphasis"><em>d</em></span> for <code class="literal">double</code>, and <span class="emphasis"><em>a</em></span> for <code class="literal">reference</code>. Some
                  instructions for which the type is unambiguous do not have a type
                  letter in their mnemonic. For instance, <span class="emphasis"><em>arraylength</em></span> always operates
                  on an object that is an array. Some instructions, such as <span class="emphasis"><em>goto</em></span>, an
                  unconditional control transfer, do not operate on typed
                  operands.
               </p>
               <p class="norm"><a name="jvms-2.11.1-120"></a>Given the Java Virtual Machine's one-byte
                  opcode size, encoding types into opcodes places pressure on the design
                  of its instruction set. If each typed instruction supported all of the
                  Java Virtual Machine's run-time data types, there would be more instructions than
                  could be represented in a byte. Instead, the instruction set of the
                  Java Virtual Machine provides a reduced level of type support for certain
                  operations. In other words, the instruction set is intentionally not
                  orthogonal. Separate instructions can be used to convert between
                  unsupported and supported data types as necessary.
               </p>
               <p class="norm"><a name="jvms-2.11.1-200"></a>
                  <a class="xref" href="jvms-2.html#jvms-2.11.1-220" title="Table&nbsp;2.11.1-A.&nbsp;Type support in the Java Virtual Machine instruction set">Table&nbsp;2.11.1-A</a> summarizes the type support in the
                  instruction set of the Java Virtual Machine. A specific instruction, with type
                  information, is built by replacing the <span class="emphasis"><em>T</em></span> in the
                  instruction template in the opcode column by the letter in the type
                  column. If the type column for some instruction template and type is
                  blank, then no instruction exists supporting that type of
                  operation. For instance, there is a load instruction for type <code class="literal">int</code>,
                  <span class="emphasis"><em>iload</em></span>, but there is no load instruction for type <code class="literal">byte</code>.
               </p>
               <p class="norm"><a name="jvms-2.11.1-210"></a>Note that most instructions
                  in <a class="xref" href="jvms-2.html#jvms-2.11.1-220" title="Table&nbsp;2.11.1-A.&nbsp;Type support in the Java Virtual Machine instruction set">Table&nbsp;2.11.1-A</a> do not have forms for the
                  integral types <code class="literal">byte</code>, <code class="literal">char</code>, and <code class="literal">short</code>. None have forms for the
                  <code class="literal">boolean</code> type. A compiler encodes loads of literal values of types
                  <code class="literal">byte</code> and <code class="literal">short</code> using Java Virtual Machine instructions that sign-extend those
                  values to values of type <code class="literal">int</code> at compile-time or run-time. Loads of
                  literal values of types <code class="literal">boolean</code> and <code class="literal">char</code> are encoded using
                  instructions that zero-extend the literal to a value of type <code class="literal">int</code> at
                  compile-time or run-time. Likewise, loads from arrays of values of
                  type <code class="literal">boolean</code>, <code class="literal">byte</code>, <code class="literal">short</code>, and <code class="literal">char</code> are encoded using Java Virtual Machine
                  instructions that sign-extend or zero-extend the values to values of
                  type <code class="literal">int</code>. Thus, most operations on values of actual types <code class="literal">boolean</code>,
                  <code class="literal">byte</code>, <code class="literal">char</code>, and <code class="literal">short</code> are correctly performed by instructions
                  operating on values of computational type <code class="literal">int</code>.
               </p>
               <div class="table"><a name="jvms-2.11.1-220"></a><p class="title"><b>Table&nbsp;2.11.1-A.&nbsp;Type support in the Java Virtual Machine instruction set</b></p>
                  <div class="table-contents">
                     <table summary="Type support in the Java Virtual Machine instruction set" border="1">
                        <colgroup>
                           <col>
                           <col>
                           <col>
                           <col>
                           <col>
                           <col>
                           <col>
                           <col>
                           <col>
                        </colgroup>
                        <thead>
                           <tr>
                              <th>opcode</th>
                              <th><code class="literal">byte</code></th>
                              <th><code class="literal">short</code></th>
                              <th><code class="literal">int</code></th>
                              <th><code class="literal">long</code></th>
                              <th><code class="literal">float</code></th>
                              <th><code class="literal">double</code></th>
                              <th><code class="literal">char</code></th>
                              <th><code class="literal">reference</code></th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <td><span class="emphasis"><em>Tipush</em></span></td>
                              <td><span class="emphasis"><em>bipush</em></span></td>
                              <td><span class="emphasis"><em>sipush</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Tconst</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>iconst</em></span></td>
                              <td><span class="emphasis"><em>lconst</em></span></td>
                              <td><span class="emphasis"><em>fconst</em></span></td>
                              <td><span class="emphasis"><em>dconst</em></span></td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>aconst</em></span></td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Tload</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>iload</em></span></td>
                              <td><span class="emphasis"><em>lload</em></span></td>
                              <td><span class="emphasis"><em>fload</em></span></td>
                              <td><span class="emphasis"><em>dload</em></span></td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>aload</em></span></td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Tstore</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>istore</em></span></td>
                              <td><span class="emphasis"><em>lstore</em></span></td>
                              <td><span class="emphasis"><em>fstore</em></span></td>
                              <td><span class="emphasis"><em>dstore</em></span></td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>astore</em></span></td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Tinc</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>iinc</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Taload</em></span></td>
                              <td><span class="emphasis"><em>baload</em></span></td>
                              <td><span class="emphasis"><em>saload</em></span></td>
                              <td><span class="emphasis"><em>iaload</em></span></td>
                              <td><span class="emphasis"><em>laload</em></span></td>
                              <td><span class="emphasis"><em>faload</em></span></td>
                              <td><span class="emphasis"><em>daload</em></span></td>
                              <td><span class="emphasis"><em>caload</em></span></td>
                              <td><span class="emphasis"><em>aaload</em></span></td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Tastore</em></span></td>
                              <td><span class="emphasis"><em>bastore</em></span></td>
                              <td><span class="emphasis"><em>sastore</em></span></td>
                              <td><span class="emphasis"><em>iastore</em></span></td>
                              <td><span class="emphasis"><em>lastore</em></span></td>
                              <td><span class="emphasis"><em>fastore</em></span></td>
                              <td><span class="emphasis"><em>dastore</em></span></td>
                              <td><span class="emphasis"><em>castore</em></span></td>
                              <td><span class="emphasis"><em>aastore</em></span></td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Tadd</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>iadd</em></span></td>
                              <td><span class="emphasis"><em>ladd</em></span></td>
                              <td><span class="emphasis"><em>fadd</em></span></td>
                              <td><span class="emphasis"><em>dadd</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Tsub</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>isub</em></span></td>
                              <td><span class="emphasis"><em>lsub</em></span></td>
                              <td><span class="emphasis"><em>fsub</em></span></td>
                              <td><span class="emphasis"><em>dsub</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Tmul</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>imul</em></span></td>
                              <td><span class="emphasis"><em>lmul</em></span></td>
                              <td><span class="emphasis"><em>fmul</em></span></td>
                              <td><span class="emphasis"><em>dmul</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Tdiv</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>idiv</em></span></td>
                              <td><span class="emphasis"><em>ldiv</em></span></td>
                              <td><span class="emphasis"><em>fdiv</em></span></td>
                              <td><span class="emphasis"><em>ddiv</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Trem</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>irem</em></span></td>
                              <td><span class="emphasis"><em>lrem</em></span></td>
                              <td><span class="emphasis"><em>frem</em></span></td>
                              <td><span class="emphasis"><em>drem</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Tneg</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>ineg</em></span></td>
                              <td><span class="emphasis"><em>lneg</em></span></td>
                              <td><span class="emphasis"><em>fneg</em></span></td>
                              <td><span class="emphasis"><em>dneg</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Tshl</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>ishl</em></span></td>
                              <td><span class="emphasis"><em>lshl</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Tshr</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>ishr</em></span></td>
                              <td><span class="emphasis"><em>lshr</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Tushr</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>iushr</em></span></td>
                              <td><span class="emphasis"><em>lushr</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Tand</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>iand</em></span></td>
                              <td><span class="emphasis"><em>land</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Tor</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>ior</em></span></td>
                              <td><span class="emphasis"><em>lor</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Txor</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>ixor</em></span></td>
                              <td><span class="emphasis"><em>lxor</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>i2T</em></span></td>
                              <td><span class="emphasis"><em>i2b</em></span></td>
                              <td><span class="emphasis"><em>i2s</em></span></td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>i2l</em></span></td>
                              <td><span class="emphasis"><em>i2f</em></span></td>
                              <td><span class="emphasis"><em>i2d</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>l2T</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>l2i</em></span></td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>l2f</em></span></td>
                              <td><span class="emphasis"><em>l2d</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>f2T</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>f2i</em></span></td>
                              <td><span class="emphasis"><em>f2l</em></span></td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>f2d</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>d2T</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>d2i</em></span></td>
                              <td><span class="emphasis"><em>d2l</em></span></td>
                              <td><span class="emphasis"><em>d2f</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Tcmp</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>lcmp</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Tcmpl</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>fcmpl</em></span></td>
                              <td><span class="emphasis"><em>dcmpl</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Tcmpg</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>fcmpg</em></span></td>
                              <td><span class="emphasis"><em>dcmpg</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>if_TcmpOP</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>if_icmpOP</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>if_acmpOP</em></span></td>
                           </tr>
                           <tr>
                              <td><span class="emphasis"><em>Treturn</em></span></td>
                              <td>&nbsp;</td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>ireturn</em></span></td>
                              <td><span class="emphasis"><em>lreturn</em></span></td>
                              <td><span class="emphasis"><em>freturn</em></span></td>
                              <td><span class="emphasis"><em>dreturn</em></span></td>
                              <td>&nbsp;</td>
                              <td><span class="emphasis"><em>areturn</em></span></td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
               </div><br class="table-break"><p class="norm"><a name="jvms-2.11.1-300"></a>The mapping between Java Virtual Machine
                  actual types and Java Virtual Machine computational types is summarized by
                  <a class="xref" href="jvms-2.html#jvms-2.11.1-320" title="Table&nbsp;2.11.1-B.&nbsp;Actual and Computational types in the Java Virtual Machine">Table&nbsp;2.11.1-B</a>.
               </p>
               <p class="norm"><a name="jvms-2.11.1-310"></a>Certain Java Virtual Machine instructions
                  such as <span class="emphasis"><em>pop</em></span> and <span class="emphasis"><em>swap</em></span> operate on the operand stack without regard
                  to type; however, such instructions are constrained to use only on
                  values of certain categories of computational types, also given in
                  <a class="xref" href="jvms-2.html#jvms-2.11.1-320" title="Table&nbsp;2.11.1-B.&nbsp;Actual and Computational types in the Java Virtual Machine">Table&nbsp;2.11.1-B</a>.
               </p>
               <div class="table"><a name="jvms-2.11.1-320"></a><p class="title"><b>Table&nbsp;2.11.1-B.&nbsp;Actual and Computational types in the Java Virtual Machine</b></p>
                  <div class="table-contents">
                     <table summary="Actual and Computational types in the Java Virtual Machine" border="1">
                        <colgroup>
                           <col>
                           <col>
                           <col>
                        </colgroup>
                        <thead>
                           <tr>
                              <th>Actual type</th>
                              <th>Computational type</th>
                              <th>Category</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <td><code class="literal">boolean</code></td>
                              <td><code class="literal">int</code></td>
                              <td>1</td>
                           </tr>
                           <tr>
                              <td><code class="literal">byte</code></td>
                              <td><code class="literal">int</code></td>
                              <td>1</td>
                           </tr>
                           <tr>
                              <td><code class="literal">char</code></td>
                              <td><code class="literal">int</code></td>
                              <td>1</td>
                           </tr>
                           <tr>
                              <td><code class="literal">short</code></td>
                              <td><code class="literal">int</code></td>
                              <td>1</td>
                           </tr>
                           <tr>
                              <td><code class="literal">int</code></td>
                              <td><code class="literal">int</code></td>
                              <td>1</td>
                           </tr>
                           <tr>
                              <td><code class="literal">float</code></td>
                              <td><code class="literal">float</code></td>
                              <td>1</td>
                           </tr>
                           <tr>
                              <td><code class="literal">reference</code></td>
                              <td><code class="literal">reference</code></td>
                              <td>1</td>
                           </tr>
                           <tr>
                              <td><code class="literal">returnAddress</code></td>
                              <td><code class="literal">returnAddress</code></td>
                              <td>1</td>
                           </tr>
                           <tr>
                              <td><code class="literal">long</code></td>
                              <td><code class="literal">long</code></td>
                              <td>2</td>
                           </tr>
                           <tr>
                              <td><code class="literal">double</code></td>
                              <td><code class="literal">double</code></td>
                              <td>2</td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
               </div><br class="table-break"></div>
            <div class="section" title="2.11.2.&nbsp;Load and Store Instructions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.11.2"></a>2.11.2.&nbsp;Load and Store Instructions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.11.2-100"></a>The load and store
                  instructions transfer values between the local variables
                  (<a class="xref" href="jvms-2.html#jvms-2.6.1" title="2.6.1.&nbsp;Local Variables">&sect;2.6.1</a>) and the operand stack
                  (<a class="xref" href="jvms-2.html#jvms-2.6.2" title="2.6.2.&nbsp;Operand Stacks">&sect;2.6.2</a>) of a Java Virtual Machine frame
                  (<a class="xref" href="jvms-2.html#jvms-2.6" title="2.6.&nbsp;Frames">&sect;2.6</a>):
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.2-100-A"></a>Load a local variable
                               onto the operand stack: <span class="emphasis"><em>iload</em></span>, <span class="emphasis"><em>iload_&lt;n&gt;</em></span>, <span class="emphasis"><em>lload</em></span>, <span class="emphasis"><em>lload_&lt;n&gt;</em></span>,
                               <span class="emphasis"><em>fload</em></span>, <span class="emphasis"><em>fload_&lt;n&gt;</em></span>, <span class="emphasis"><em>dload</em></span>, <span class="emphasis"><em>dload_&lt;n&gt;</em></span>, <span class="emphasis"><em>aload</em></span>, <span class="emphasis"><em>aload_&lt;n&gt;</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.2-100-B"></a>Store a value from
                               the operand stack into a local variable: <span class="emphasis"><em>istore</em></span>, <span class="emphasis"><em>istore_&lt;n&gt;</em></span>,
                               <span class="emphasis"><em>lstore</em></span>, <span class="emphasis"><em>lstore_&lt;n&gt;</em></span>, <span class="emphasis"><em>fstore</em></span>, <span class="emphasis"><em>fstore_&lt;n&gt;</em></span>, <span class="emphasis"><em>dstore</em></span>, <span class="emphasis"><em>dstore_&lt;n&gt;</em></span>,
                               <span class="emphasis"><em>astore</em></span>, <span class="emphasis"><em>astore_&lt;n&gt;</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.2-100-C"></a>Load a constant on to
                               the operand stack: <span class="emphasis"><em>bipush</em></span>, <span class="emphasis"><em>sipush</em></span>, <span class="emphasis"><em>ldc</em></span>, <span class="emphasis"><em>ldc_w</em></span>, <span class="emphasis"><em>ldc2_w</em></span>,
                               <span class="emphasis"><em>aconst_null</em></span>, <span class="emphasis"><em>iconst_m1</em></span>, <span class="emphasis"><em>iconst_&lt;i&gt;</em></span>, <span class="emphasis"><em>lconst_&lt;l&gt;</em></span>, <span class="emphasis"><em>fconst_&lt;f&gt;</em></span>,
                               <span class="emphasis"><em>dconst_&lt;d&gt;</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.2-100-D"></a>Gain access to more
                               local variables using a wider index, or to a larger immediate
                               operand: <span class="emphasis"><em>wide</em></span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jvms-2.11.2-110"></a>Instructions that access
                  fields of objects and elements of arrays
                  (<a class="xref" href="jvms-2.html#jvms-2.11.5" title="2.11.5.&nbsp;Object Creation and Manipulation">&sect;2.11.5</a>) also transfer data to and from the
                  operand stack.
               </p>
               <p class="norm"><a name="jvms-2.11.2-200"></a>Instruction mnemonics shown
                  above with trailing letters between angle brackets (for instance,
                  <span class="emphasis"><em>iload_&lt;n&gt;</em></span>) denote families of instructions (with
                  members <span class="emphasis"><em>iload_0</em></span>, <span class="emphasis"><em>iload_1</em></span>, <span class="emphasis"><em>iload_2</em></span>,
                  and <span class="emphasis"><em>iload_3</em></span> in the case of <span class="emphasis"><em>iload_&lt;n&gt;</em></span>). Such
                  families of instructions are specializations of an additional generic
                  instruction (<span class="emphasis"><em>iload</em></span>) that takes one operand. For the specialized
                  instructions, the operand is implicit and does not need to be stored
                  or fetched. The semantics are otherwise the same
                  (<span class="emphasis"><em>iload_0</em></span> means the same thing as <span class="emphasis"><em>iload</em></span> with the
                  operand <span class="emphasis"><em>0</em></span>). The letter between the angle brackets
                  specifies the type of the implicit operand for that family of
                  instructions: for <span class="emphasis"><em>&lt;n&gt;</em></span>, a nonnegative
                  integer; for <span class="emphasis"><em>&lt;i&gt;</em></span>, an <code class="literal">int</code>;
                  for <span class="emphasis"><em>&lt;l&gt;</em></span>, a <code class="literal">long</code>;
                  for <span class="emphasis"><em>&lt;f&gt;</em></span>, a <code class="literal">float</code>; and
                  for <span class="emphasis"><em>&lt;d&gt;</em></span>, a <code class="literal">double</code>. Forms for type <code class="literal">int</code>
                  are used in many cases to perform operations on values of type <code class="literal">byte</code>,
                  <code class="literal">char</code>, and <code class="literal">short</code> (<a class="xref" href="jvms-2.html#jvms-2.11.1" title="2.11.1.&nbsp;Types and the Java Virtual Machine">&sect;2.11.1</a>).
               </p>
               <p class="norm"><a name="jvms-2.11.2-300"></a>This notation for
                  instruction families is used throughout this specification.
               </p>
            </div>
            <div class="section" title="2.11.3.&nbsp;Arithmetic Instructions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.11.3"></a>2.11.3.&nbsp;Arithmetic Instructions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.11.3-100"></a>The arithmetic instructions
                  compute a result that is typically a function of two values on the
                  operand stack, pushing the result back on the operand stack. There are
                  two main kinds of arithmetic instructions: those operating on integer
                  values and those operating on floating-point values. Within each of
                  these kinds, the arithmetic instructions are specialized to Java Virtual Machine
                  numeric types. There is no direct support for integer arithmetic on
                  values of the <code class="literal">byte</code>, <code class="literal">short</code>, and <code class="literal">char</code> types
                  (<a class="xref" href="jvms-2.html#jvms-2.11.1" title="2.11.1.&nbsp;Types and the Java Virtual Machine">&sect;2.11.1</a>), or for values of the <code class="literal">boolean</code> type;
                  those operations are handled by instructions operating on type
                  <code class="literal">int</code>. Integer and floating-point instructions also differ in their
                  behavior on overflow and divide-by-zero. The arithmetic instructions
                  are as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.3-100-A"></a>Add: <span class="emphasis"><em>iadd</em></span>, <span class="emphasis"><em>ladd</em></span>,
                               <span class="emphasis"><em>fadd</em></span>, <span class="emphasis"><em>dadd</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.3-100-B"></a>Subtract: <span class="emphasis"><em>isub</em></span>,
                               <span class="emphasis"><em>lsub</em></span>, <span class="emphasis"><em>fsub</em></span>, <span class="emphasis"><em>dsub</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.3-100-C"></a>Multiply: <span class="emphasis"><em>imul</em></span>,
                               <span class="emphasis"><em>lmul</em></span>, <span class="emphasis"><em>fmul</em></span>, <span class="emphasis"><em>dmul</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.3-100-D"></a>Divide: <span class="emphasis"><em>idiv</em></span>,
                               <span class="emphasis"><em>ldiv</em></span>, <span class="emphasis"><em>fdiv</em></span>, <span class="emphasis"><em>ddiv</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.3-100-E"></a>Remainder: <span class="emphasis"><em>irem</em></span>,
                               <span class="emphasis"><em>lrem</em></span>, <span class="emphasis"><em>frem</em></span>, <span class="emphasis"><em>drem</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.3-100-F"></a>Negate: <span class="emphasis"><em>ineg</em></span>,
                               <span class="emphasis"><em>lneg</em></span>, <span class="emphasis"><em>fneg</em></span>, <span class="emphasis"><em>dneg</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.3-100-G"></a>Shift: <span class="emphasis"><em>ishl</em></span>,
                               <span class="emphasis"><em>ishr</em></span>, <span class="emphasis"><em>iushr</em></span>, <span class="emphasis"><em>lshl</em></span>, <span class="emphasis"><em>lshr</em></span>, <span class="emphasis"><em>lushr</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.3-100-H"></a>Bitwise OR: <span class="emphasis"><em>ior</em></span>,
                               <span class="emphasis"><em>lor</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.3-100-I"></a>Bitwise AND: <span class="emphasis"><em>iand</em></span>,
                               <span class="emphasis"><em>land</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.3-100-J"></a>Bitwise exclusive OR:
                               <span class="emphasis"><em>ixor</em></span>, <span class="emphasis"><em>lxor</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.3-100-K"></a>Local variable
                               increment: <span class="emphasis"><em>iinc</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.3-100-L"></a>Comparison: <span class="emphasis"><em>dcmpg</em></span>,
                               <span class="emphasis"><em>dcmpl</em></span>, <span class="emphasis"><em>fcmpg</em></span>, <span class="emphasis"><em>fcmpl</em></span>, <span class="emphasis"><em>lcmp</em></span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jvms-2.11.3-110"></a>The semantics of the
                  Java programming language operators on integer and floating-point values (JLS &sect;4.2.2,
                  JLS &sect;4.2.4) are directly supported by the semantics of the Java Virtual Machine
                  instruction set.
               </p>
               <p class="norm"><a name="jvms-2.11.3-200"></a>The Java Virtual Machine does not indicate
                  overflow during operations on integer data types. The only integer
                  operations that can throw an exception are the integer divide
                  instructions (<span class="emphasis"><em>idiv</em></span> and <span class="emphasis"><em>ldiv</em></span>) and the integer remainder
                  instructions (<span class="emphasis"><em>irem</em></span> and <span class="emphasis"><em>lrem</em></span>), which throw an <code class="literal">ArithmeticException</code>
                  if the divisor is zero.
               </p>
               <p class="norm"><a name="jvms-2.11.3-300"></a>Java Virtual Machine operations on
                  floating-point numbers behave as specified in IEEE 754. In particular,
                  the Java Virtual Machine requires full support of IEEE
                  754 <span class="emphasis"><em>denormalized</em></span> floating-point numbers and
                  <span class="emphasis"><em>gradual underflow</em></span>, which make it easier to prove
                  desirable properties of particular numerical algorithms.
               </p>
               <p class="norm"><a name="jvms-2.11.3-400"></a>The Java Virtual Machine requires that
                  floating-point arithmetic behave as if every floating-point operator
                  rounded its floating-point result to the result
                  precision. <span class="emphasis"><em>Inexact</em></span> results must be rounded to the
                  representable value nearest to the infinitely precise result; if the
                  two nearest representable values are equally near, the one having a
                  least significant bit of zero is chosen. This is the IEEE 754
                  standard's default rounding mode, known as <span class="emphasis"><em>round to
                        nearest</em></span> mode.
               </p>
               <p class="norm"><a name="jvms-2.11.3-410"></a>The Java Virtual Machine uses the IEEE 754
                  <span class="emphasis"><em>round towards zero</em></span> mode when converting a
                  floating-point value to an integer. This results in the number being
                  truncated; any bits of the significand that represent the fractional
                  part of the operand value are discarded. Round towards zero mode
                  chooses as its result the type's value closest to, but no greater in
                  magnitude than, the infinitely precise result.
               </p>
               <p class="norm"><a name="jvms-2.11.3-420"></a>The Java Virtual Machine's floating-point
                  operators do not throw run-time exceptions (not to be confused with
                  IEEE 754 floating-point exceptions). An operation that overflows
                  produces a signed infinity, an operation that underflows produces a
                  denormalized value or a signed zero, and an operation that has no
                  mathematically definite result produces NaN. All numeric operations
                  with NaN as an operand produce NaN as a result.
               </p>
               <p class="norm"><a name="jvms-2.11.3-430"></a>Comparisons on values of
                  type <code class="literal">long</code> (<span class="emphasis"><em>lcmp</em></span>) perform a signed comparison. Comparisons on
                  values of floating-point types (<span class="emphasis"><em>dcmpg</em></span>, <span class="emphasis"><em>dcmpl</em></span>, <span class="emphasis"><em>fcmpg</em></span>, <span class="emphasis"><em>fcmpl</em></span>)
                  are performed using IEEE 754 nonsignaling comparisons.
               </p>
            </div>
            <div class="section" title="2.11.4.&nbsp;Type Conversion Instructions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.11.4"></a>2.11.4.&nbsp;Type Conversion Instructions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.11.4-100"></a>The type conversion
                  instructions allow conversion between Java Virtual Machine numeric types. These may
                  be used to implement explicit conversions in user code or to mitigate
                  the lack of orthogonality in the instruction set of the Java Virtual Machine.
               </p>
               <p class="norm"><a name="jvms-2.11.4-110"></a>The Java Virtual Machine directly supports
                  the following widening numeric conversions:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.4-110-A"></a><code class="literal">int</code> to <code class="literal">long</code>,
                               <code class="literal">float</code>, or <code class="literal">double</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.4-110-B"></a><code class="literal">long</code> to <code class="literal">float</code> or
                               <code class="literal">double</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.4-110-C"></a><code class="literal">float</code> to
                               <code class="literal">double</code></p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jvms-2.11.4-120"></a>The widening numeric
                  conversion instructions are <span class="emphasis"><em>i2l</em></span>, <span class="emphasis"><em>i2f</em></span>, <span class="emphasis"><em>i2d</em></span>, <span class="emphasis"><em>l2f</em></span>, <span class="emphasis"><em>l2d</em></span>, and
                  <span class="emphasis"><em>f2d</em></span>. The mnemonics for these opcodes are straightforward given the
                  naming conventions for typed instructions and the punning use of 2 to
                  mean "to." For instance, the <span class="emphasis"><em>i2d</em></span> instruction converts an <code class="literal">int</code> value
                  to a <code class="literal">double</code>.
               </p>
               <p class="norm"><a name="jvms-2.11.4-130"></a>Most widening numeric
                  conversions do not lose information about the overall magnitude of a
                  numeric value. Indeed, conversions widening from <code class="literal">int</code> to <code class="literal">long</code> and
                  <code class="literal">int</code> to <code class="literal">double</code> do not lose any information at all; the numeric
                  value is preserved exactly. Conversions widening from <code class="literal">float</code> to
                  <code class="literal">double</code> that are FP-strict (<a class="xref" href="jvms-2.html#jvms-2.8.2" title="2.8.2.&nbsp;Floating-Point Modes">&sect;2.8.2</a>) also
                  preserve the numeric value exactly; only such conversions that are not
                  FP-strict may lose information about the overall magnitude of the
                  converted value.
               </p>
               <p class="norm"><a name="jvms-2.11.4-140"></a>Conversions from <code class="literal">int</code> to
                  <code class="literal">float</code>, or from <code class="literal">long</code> to <code class="literal">float</code>, or from <code class="literal">long</code> to <code class="literal">double</code>, may
                  lose <span class="emphasis"><em>precision</em></span>, that is, may lose some of the
                  least significant bits of the value; the resulting floating-point
                  value is a correctly rounded version of the integer value, using IEEE
                  754 round to nearest mode.
               </p>
               <p class="norm"><a name="jvms-2.11.4-150"></a>Despite the fact that loss
                  of precision may occur, widening numeric conversions never cause the
                  Java Virtual Machine to throw a run-time exception (not to be confused with an IEEE
                  754 floating-point exception).
               </p>
               <p class="norm"><a name="jvms-2.11.4-160"></a>A widening numeric
                  conversion of an <code class="literal">int</code> to a <code class="literal">long</code> simply sign-extends the
                  two's-complement representation of the <code class="literal">int</code> value to fill the wider
                  format. A widening numeric conversion of a <code class="literal">char</code> to an integral type
                  zero-extends the representation of the <code class="literal">char</code> value to fill the wider
                  format.
               </p>
               <p class="norm"><a name="jvms-2.11.4-170"></a>Note that widening numeric
                  conversions do not exist from integral types <code class="literal">byte</code>, <code class="literal">char</code>, and
                  <code class="literal">short</code> to type <code class="literal">int</code>. As noted in <a class="xref" href="jvms-2.html#jvms-2.11.1" title="2.11.1.&nbsp;Types and the Java Virtual Machine">&sect;2.11.1</a>,
                  values of type <code class="literal">byte</code>, <code class="literal">char</code>, and <code class="literal">short</code> are internally widened to
                  type <code class="literal">int</code>, making these conversions implicit.
               </p>
               <p class="norm"><a name="jvms-2.11.4-200"></a>The Java Virtual Machine also directly
                  supports the following narrowing numeric conversions:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.4-200-A"></a><code class="literal">int</code> to <code class="literal">byte</code>,
                               <code class="literal">short</code>, or <code class="literal">char</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.4-200-B"></a><code class="literal">long</code> to
                               <code class="literal">int</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.4-200-C"></a><code class="literal">float</code> to <code class="literal">int</code> or
                               <code class="literal">long</code></p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.4-200-D"></a><code class="literal">double</code> to <code class="literal">int</code>,
                               <code class="literal">long</code>, or <code class="literal">float</code></p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jvms-2.11.4-210"></a>The narrowing numeric
                  conversion instructions are <span class="emphasis"><em>i2b</em></span>, <span class="emphasis"><em>i2c</em></span>, <span class="emphasis"><em>i2s</em></span>, <span class="emphasis"><em>l2i</em></span>, <span class="emphasis"><em>f2i</em></span>, <span class="emphasis"><em>f2l</em></span>,
                  <span class="emphasis"><em>d2i</em></span>, <span class="emphasis"><em>d2l</em></span>, and <span class="emphasis"><em>d2f</em></span>. A narrowing numeric conversion can result in
                  a value of different sign, a different order of magnitude, or both; it
                  may thereby lose precision.
               </p>
               <p class="norm"><a name="jvms-2.11.4-220"></a>A narrowing numeric
                  conversion of an <code class="literal">int</code> or <code class="literal">long</code> to an integral type <span class="type">T</span> simply
                  discards all but the <span class="emphasis"><em>n</em></span> lowest-order bits, where <span class="emphasis"><em>n</em></span> is the
                  number of bits used to represent type <span class="type">T</span>. This may cause the
                  resulting value not to have the same sign as the input value.
               </p>
               <p class="norm"><a name="jvms-2.11.4-230"></a>In a narrowing numeric
                  conversion of a floating-point value to an integral type <span class="type">T</span>, where
                  <span class="type">T</span> is either <code class="literal">int</code> or <code class="literal">long</code>, the floating-point value is converted
                  as follows:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.4-230-A"></a>If the floating-point
                               value is NaN, the result of the conversion is an <code class="literal">int</code> or <code class="literal">long</code>
                               <code class="literal">0</code>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.4-230-B"></a>Otherwise, if the
                               floating-point value is not an infinity, the floating-point value
                               is rounded to an integer value <span class="emphasis"><em>V</em></span> using IEEE
                               754 round towards zero mode. There are two cases:
                        </p>
                        <div class="norm">
                           <ul class="norm" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jvms-2.11.4-230-B-A"></a>If <span class="type">T</span> is
                                    	<code class="literal">long</code> and this integer value can be represented as a <code class="literal">long</code>,
                                    	then the result is the <code class="literal">long</code> value <span class="emphasis"><em>V</em></span>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jvms-2.11.4-230-B-B"></a>If <span class="type">T</span> is of
                                    	type <code class="literal">int</code> and this integer value can be represented as an
                                    	<code class="literal">int</code>, then the result is the <code class="literal">int</code>
                                    	value <span class="emphasis"><em>V</em></span>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.4-230-C"></a>Otherwise:
                        </p>
                        <div class="">
                           <ul class="" type="circle">
                              <li class="listitem">
                                 <p class="norm"><a name="jvms-2.11.4-230-C-A"></a>Either the
                                    	value must be too small (a negative value of large magnitude
                                    	or negative infinity), and the result is the smallest
                                    	representable value of type <code class="literal">int</code> or <code class="literal">long</code>.
                                 </p>
                              </li>
                              <li class="listitem">
                                 <p class="norm"><a name="jvms-2.11.4-230-C-B"></a>Or the value
                                    	must be too large (a positive value of large magnitude or
                                    	positive infinity), and the result is the largest
                                    	representable value of type <code class="literal">int</code> or <code class="literal">long</code>.
                                 </p>
                              </li>
                           </ul>
                        </div>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jvms-2.11.4-240"></a>A narrowing numeric
                  conversion from <code class="literal">double</code> to <code class="literal">float</code> behaves in accordance with IEEE
                  754. The result is correctly rounded using IEEE 754 round to nearest
                  mode. A value too small to be represented as a <code class="literal">float</code> is converted to
                  a positive or negative zero of type <code class="literal">float</code>; a value too large to be
                  represented as a <code class="literal">float</code> is converted to a positive or negative
                  infinity. A <code class="literal">double</code> NaN is always converted to a <code class="literal">float</code> NaN.
               </p>
               <p class="norm"><a name="jvms-2.11.4-300"></a>Despite the fact that
                  overflow, underflow, or loss of precision may occur, narrowing
                  conversions among numeric types never cause the Java Virtual Machine to throw a
                  run-time exception (not to be confused with an IEEE 754 floating-point
                  exception).
               </p>
            </div>
            <div class="section" title="2.11.5.&nbsp;Object Creation and Manipulation">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.11.5"></a>2.11.5.&nbsp;Object Creation and Manipulation
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.11.5-100"></a>Although both class
                  instances and arrays are objects, the Java Virtual Machine creates and manipulates
                  class instances and arrays using distinct sets of instructions:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.5-100-A"></a>
                                 Create a new class instance: <span class="emphasis"><em>new</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.5-100-B"></a>
                                 Create a new array: <span class="emphasis"><em>newarray</em></span>, <span class="emphasis"><em>anewarray</em></span>, <span class="emphasis"><em>multianewarray</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.5-100-C"></a>
                                 Access fields of classes (<code class="literal">static</code> fields, known as class
                                 variables) and fields of class instances (non-<code class="literal">static</code> fields,
                                 known as instance variables): 
                                 <span class="emphasis"><em>getstatic</em></span>, <span class="emphasis"><em>putstatic</em></span>, <span class="emphasis"><em>getfield</em></span>, <span class="emphasis"><em>putfield</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.5-100-D"></a>
                                 Load an array component onto the operand stack: <span class="emphasis"><em>baload</em></span>,
                                 <span class="emphasis"><em>caload</em></span>, <span class="emphasis"><em>saload</em></span>, <span class="emphasis"><em>iaload</em></span>, <span class="emphasis"><em>laload</em></span>, <span class="emphasis"><em>faload</em></span>, <span class="emphasis"><em>daload</em></span>,
                                 <span class="emphasis"><em>aaload</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.5-100-E"></a>
                                 Store a value from the operand stack as an array component:
                                 <span class="emphasis"><em>bastore</em></span>, <span class="emphasis"><em>castore</em></span>, <span class="emphasis"><em>sastore</em></span>, <span class="emphasis"><em>iastore</em></span>, <span class="emphasis"><em>lastore</em></span>,
                                 <span class="emphasis"><em>fastore</em></span>, <span class="emphasis"><em>dastore</em></span>, <span class="emphasis"><em>aastore</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.5-100-F"></a>
                                 Get the length of array: <span class="emphasis"><em>arraylength</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.5-100-G"></a>
                                 Check properties of class instances or arrays: <span class="emphasis"><em>instanceof</em></span>,
                                 <span class="emphasis"><em>checkcast</em></span>.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" title="2.11.6.&nbsp;Operand Stack Management Instructions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.11.6"></a>2.11.6.&nbsp;Operand Stack Management Instructions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.11.6-100"></a>A number of instructions
                  are provided for the direct manipulation of the operand stack: <span class="emphasis"><em>pop</em></span>,
                  <span class="emphasis"><em>pop2</em></span>, <span class="emphasis"><em>dup</em></span>, <span class="emphasis"><em>dup2</em></span>, <span class="emphasis"><em>dup_x1</em></span>, <span class="emphasis"><em>dup2_x1</em></span>, <span class="emphasis"><em>dup_x2</em></span>, <span class="emphasis"><em>dup2_x2</em></span>,
                  <span class="emphasis"><em>swap</em></span>.
               </p>
            </div>
            <div class="section" title="2.11.7.&nbsp;Control Transfer Instructions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.11.7"></a>2.11.7.&nbsp;Control Transfer Instructions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.11.7-100"></a>The control transfer
                  instructions conditionally or unconditionally cause the Java Virtual Machine to
                  continue execution with an instruction other than the one following
                  the control transfer instruction. They are:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.7-100-A"></a>Conditional branch:
                               <span class="emphasis"><em>ifeq</em></span>, <span class="emphasis"><em>ifne</em></span>, <span class="emphasis"><em>iflt</em></span>, <span class="emphasis"><em>ifle</em></span>, <span class="emphasis"><em>ifgt</em></span>, <span class="emphasis"><em>ifge</em></span>, <span class="emphasis"><em>ifnull</em></span>,
                               <span class="emphasis"><em>ifnonnull</em></span>, <span class="emphasis"><em>if_icmpeq</em></span>, <span class="emphasis"><em>if_icmpne</em></span>, <span class="emphasis"><em>if_icmplt</em></span>, <span class="emphasis"><em>if_icmple</em></span>,
                               <span class="emphasis"><em>if_icmpgt</em></span> <span class="emphasis"><em>if_icmpge</em></span>, <span class="emphasis"><em>if_acmpeq</em></span>, <span class="emphasis"><em>if_acmpne</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.7-100-B"></a>Compound conditional
                               branch: <span class="emphasis"><em>tableswitch</em></span>, <span class="emphasis"><em>lookupswitch</em></span>.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.7-100-C"></a>Unconditional branch:
                               <span class="emphasis"><em>goto</em></span>, <span class="emphasis"><em>goto_w</em></span>, <span class="emphasis"><em>jsr</em></span>, <span class="emphasis"><em>jsr_w</em></span>, <span class="emphasis"><em>ret</em></span>.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jvms-2.11.7-110"></a>The Java Virtual Machine has distinct sets
                  of instructions that conditionally branch on comparison with data of
                  <code class="literal">int</code> and <code class="literal">reference</code> types. It also has distinct conditional branch
                  instructions that test for the null reference and thus it is not
                  required to specify a concrete value for <code class="literal">null</code>
                  (<a class="xref" href="jvms-2.html#jvms-2.4" title="2.4.&nbsp;Reference Types and Values">&sect;2.4</a>).
               </p>
               <p class="norm"><a name="jvms-2.11.7-120"></a>Conditional branches on
                  comparisons between data of types <code class="literal">boolean</code>, <code class="literal">byte</code>, <code class="literal">char</code>, and
                  <code class="literal">short</code> are performed using <code class="literal">int</code> comparison instructions
                  (<a class="xref" href="jvms-2.html#jvms-2.11.1" title="2.11.1.&nbsp;Types and the Java Virtual Machine">&sect;2.11.1</a>). A conditional branch on a comparison
                  between data of types <code class="literal">long</code>, <code class="literal">float</code>, or <code class="literal">double</code> is initiated using
                  an instruction that compares the data and produces an <code class="literal">int</code> result of
                  the comparison (<a class="xref" href="jvms-2.html#jvms-2.11.3" title="2.11.3.&nbsp;Arithmetic Instructions">&sect;2.11.3</a>). A subsequent <code class="literal">int</code>
                  comparison instruction tests this result and effects the conditional
                  branch. Because of its emphasis on <code class="literal">int</code> comparisons, the Java Virtual Machine
                  provides a rich complement of conditional branch instructions for type
                  <code class="literal">int</code>.
               </p>
               <p class="norm"><a name="jvms-2.11.7-130"></a>All <code class="literal">int</code> conditional
                  control transfer instructions perform signed comparisons.
               </p>
            </div>
            <div class="section" title="2.11.8.&nbsp;Method Invocation and Return Instructions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.11.8"></a>2.11.8.&nbsp;Method Invocation and Return Instructions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.11.8-100"></a>The following five
                  instructions invoke methods:
               </p>
               <div class="norm">
                  <ul class="norm" type="disc">
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.8-100-A"></a><span class="emphasis"><em>invokevirtual</em></span>
                                 invokes an instance method of an object, dispatching on the
                                 (virtual) type of the object. This is the normal method dispatch
                                 in the Java programming language.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.8-100-B"></a><span class="emphasis"><em>invokeinterface</em></span>
                               invokes an interface method, searching the methods implemented by
                               the particular run-time object to find the appropriate
                               method.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.8-100-C"></a><span class="emphasis"><em>invokespecial</em></span>
                               invokes an instance method requiring special handling, whether an
                               instance initialization method (<a class="xref" href="jvms-2.html#jvms-2.9" title="2.9.&nbsp;Special Methods">&sect;2.9</a>), a
                               <code class="literal">private</code> method, or a superclass method.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.8-100-D"></a><span class="emphasis"><em>invokestatic</em></span>
                               invokes a class (<code class="literal">static</code>) method in a named class.
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.8-100-E"></a><span class="emphasis"><em>invokedynamic</em></span>
                               invokes the method which is the target of the call site object
                               bound to the <span class="emphasis"><em>invokedynamic</em></span> instruction. The call site object was
                               bound to a specific lexical occurrence of the <span class="emphasis"><em>invokedynamic</em></span>
                               instruction by the Java Virtual Machine as a result of running a bootstrap method
                               before the first execution of the instruction. Therefore, each
                               occurrence of an <span class="emphasis"><em>invokedynamic</em></span> instruction has a unique linkage
                               state, unlike the other instructions which invoke methods.
                        </p>
                     </li>
                  </ul>
               </div>
               <p class="norm"><a name="jvms-2.11.8-200"></a>The method return
                  instructions, which are distinguished by return type, are <span class="emphasis"><em>ireturn</em></span>
                  (used to return values of type <code class="literal">boolean</code>, <code class="literal">byte</code>, <code class="literal">char</code>, <code class="literal">short</code>, or
                  <code class="literal">int</code>), <span class="emphasis"><em>lreturn</em></span>, <span class="emphasis"><em>freturn</em></span>, <span class="emphasis"><em>dreturn</em></span>, and <span class="emphasis"><em>areturn</em></span>. In addition,
                  the <span class="emphasis"><em>return</em></span> instruction is used to return from methods declared to be
                  void, instance initialization methods, and class or interface
                  initialization methods.
               </p>
            </div>
            <div class="section" title="2.11.9.&nbsp;Throwing Exceptions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.11.9"></a>2.11.9.&nbsp;Throwing Exceptions
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.11.9-100"></a>An exception is thrown
                  programmatically using the <span class="emphasis"><em>athrow</em></span> instruction. Exceptions can also
                  be thrown by various Java Virtual Machine instructions if they detect an abnormal
                  condition.
               </p>
            </div>
            <div class="section" title="2.11.10.&nbsp;Synchronization">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="jvms-2.11.10"></a>2.11.10.&nbsp;Synchronization
                        </h3>
                     </div>
                  </div>
               </div>
               <p class="norm"><a name="jvms-2.11.10-100"></a>The Java Virtual Machine supports
                  synchronization of both methods and sequences of instructions within a
                  method by a single synchronization construct:
                  the <span class="emphasis"><em>monitor</em></span>.
               </p>
               <p class="norm"><a name="jvms-2.11.10-110"></a>Method-level
                  synchronization is performed implicitly, as part of method invocation
                  and return (<a class="xref" href="jvms-2.html#jvms-2.11.8" title="2.11.8.&nbsp;Method Invocation and Return Instructions">&sect;2.11.8</a>). A <code class="literal">synchronized</code> method is
                  distinguished in the run-time constant pool's <code class="literal">method_info</code> structure
                  (<a class="xref" href="jvms-4.html#jvms-4.6" title="4.6.&nbsp;Methods">&sect;4.6</a>) by the <code class="literal">ACC_SYNCHRONIZED</code> flag, which is
                  checked by the method invocation instructions. When invoking a method
                  for which <code class="literal">ACC_SYNCHRONIZED</code> is set, the executing thread enters a
                  monitor, invokes the method itself, and exits the monitor whether the
                  method invocation completes normally or abruptly. During the time the
                  executing thread owns the monitor, no other thread may enter it. If an
                  exception is thrown during invocation of the <code class="literal">synchronized</code> method and
                  the <code class="literal">synchronized</code> method does not handle the exception, the monitor
                  for the method is automatically exited before the exception is
                  rethrown out of the <code class="literal">synchronized</code> method.
               </p>
               <p class="norm"><a name="jvms-2.11.10-120"></a>Synchronization of
                  sequences of instructions is typically used to encode the
                  <code class="literal">synchronized</code> block of the Java programming language. The Java Virtual Machine supplies the
                  <span class="emphasis"><em>monitorenter</em></span> and <span class="emphasis"><em>monitorexit</em></span> instructions to support such language
                  constructs. Proper implementation of <code class="literal">synchronized</code> blocks requires
                  cooperation from a compiler targeting the Java Virtual Machine
                  (<a class="xref" href="jvms-3.html#jvms-3.14" title="3.14.&nbsp;Synchronization">&sect;3.14</a>).
               </p>
               <p class="norm"><a name="jvms-2.11.10-200"></a><span class="emphasis"><em>Structured
                        locking</em></span> is the situation when, during a method invocation,
                  every exit on a given monitor matches a preceding entry on that
                  monitor. Since there is no assurance that all code submitted to the
                  Java Virtual Machine will perform structured locking, implementations of the Java Virtual Machine
                  are permitted but not required to enforce both of the following two
                  rules guaranteeing structured locking. Let <span class="emphasis"><em>T</em></span> be a
                  thread and <span class="emphasis"><em>M</em></span> be a monitor. Then:
               </p>
               <div class="orderedlist">
                  <ol class="orderedlist" type="1">
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.10-200-A"></a>
                                 The number of monitor entries performed
                                 by <span class="emphasis"><em>T</em></span> on <span class="emphasis"><em>M</em></span> during a
                                 method invocation must equal the number of monitor exits
                                 performed by <span class="emphasis"><em>T</em></span> on <span class="emphasis"><em>M</em></span>
                                 during the method invocation whether the method invocation
                                 completes normally or abruptly. 
                        </p>
                     </li>
                     <li class="listitem">
                        <p class="norm"><a name="jvms-2.11.10-200-B"></a>
                                 At no point during a method invocation may the number of monitor
                                 exits performed by <span class="emphasis"><em>T</em></span>
                                 on <span class="emphasis"><em>M</em></span> since the method invocation exceed the
                                 number of monitor entries performed by <span class="emphasis"><em>T</em></span>
                                 on <span class="emphasis"><em>M</em></span> since the method invocation.
                        </p>
                     </li>
                  </ol>
               </div>
               <p class="norm"><a name="jvms-2.11.10-210"></a>Note that the monitor
                  entry and exit automatically performed by the Java Virtual Machine when invoking a
                  <code class="literal">synchronized</code> method are considered to occur during the calling
                  method's invocation.
               </p>
            </div>
         </div>
         <div class="section" title="2.12.&nbsp;Class Libraries">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jvms-2.12"></a>2.12.&nbsp;Class Libraries
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jvms-2.12-100"></a>The Java Virtual Machine must provide
               sufficient support for the implementation of the class libraries of
               the  Java SE platform. Some of the classes in
               these libraries cannot be implemented without the cooperation of the
               Java Virtual Machine.
            </p>
            <p class="norm"><a name="jvms-2.12-110"></a>Classes that might require
               special support from the Java Virtual Machine include those that support:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.12-110-A"></a>Reflection, such as the
                            classes in the package <code class="literal">java.lang.reflect</code> and
                            the class <code class="literal">Class</code>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.12-100-B"></a>Loading and creation of
                            a class or interface. The most obvious example is the class
                            <code class="literal">ClassLoader</code>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.12-100-C"></a>Linking and
                            initialization of a class or interface. The example classes cited
                            above fall into this category as well.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.12-100-D"></a>Security, such as the
                            classes in the package <code class="literal">java.security</code> and other
                            classes such as <code class="literal">SecurityManager</code>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.12-100-E"></a>Multithreading, such as
                            the class <code class="literal">Thread</code>.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.12-100-F"></a>Weak references, such
                            as the classes in the
                            package <code class="literal">java.lang.ref</code>.
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jvms-2.12-120"></a>The list above is meant to be
               illustrative rather than comprehensive. An exhaustive list of these
               classes or of the functionality they provide is beyond the scope of
               this specification. See the specifications of the Java SE platform class
               libraries for details.
            </p>
         </div>
         <div class="section" title="2.13.&nbsp;Public Design, Private Implementation">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="jvms-2.13"></a>2.13.&nbsp;Public Design, Private Implementation
                     </h2>
                  </div>
               </div>
            </div>
            <p class="norm"><a name="jvms-2.13-100"></a>Thus far this specification
               has sketched the public view of the Java Virtual Machine: the <code class="literal">class</code> file format and
               the instruction set. These components are vital to the hardware-,
               operating system-, and implementation-independence of the Java Virtual Machine. The
               implementor may prefer to think of them as a means to securely
               communicate fragments of programs between hosts each implementing the
               Java SE platform, rather than as a blueprint to be followed exactly.
            </p>
            <p class="norm"><a name="jvms-2.13-110"></a>It is important to understand
               where the line between the public design and the private
               implementation lies. A Java Virtual Machine implementation must be able to read
               <code class="literal">class</code> files and must exactly implement the semantics of the Java Virtual Machine
               code therein. One way of doing this is to take this document as a
               specification and to implement that specification literally. But it is
               also perfectly feasible and desirable for the implementor to modify or
               optimize the implementation within the constraints of this
               specification. So long as the <code class="literal">class</code> file format can be read and the
               semantics of its code are maintained, the implementor may implement
               these semantics in any way. What is "under the hood" is the
               implementor's business, as long as the correct external interface is
               carefully maintained.
            </p>
            <p class="note">There are some exceptions: debuggers, profilers, and
               just-in-time code generators can each require access to elements of
               the Java Virtual Machine that are normally considered to be &#8220;under the hood.&#8221; Where
               appropriate, Oracle works with other Java Virtual Machine implementors and with tool
               vendors to develop common interfaces to the Java Virtual Machine for use by such
               tools, and to promote those interfaces across the industry.
            </p>
            <p class="norm"><a name="jvms-2.13-120"></a>The implementor can use this
               flexibility to tailor Java Virtual Machine implementations for high performance, low
               memory use, or portability. What makes sense in a given implementation
               depends on the goals of that implementation. The range of
               implementation options includes the following:
            </p>
            <div class="norm">
               <ul class="norm" type="disc">
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.13-120-A"></a>Translating Java Virtual Machine code
                            at load-time or during execution into the instruction set of
                            another virtual machine.
                     </p>
                  </li>
                  <li class="listitem">
                     <p class="norm"><a name="jvms-2.13-120-B"></a>Translating Java Virtual Machine code
                            at load-time or during execution into the native instruction set
                            of the host CPU (sometimes referred to
                            as <span class="emphasis"><em>just-in-time</em></span>, or <span class="emphasis"><em>JIT</em></span>,
                            code generation).
                     </p>
                  </li>
               </ul>
            </div>
            <p class="norm"><a name="jvms-2.13-130"></a>The existence of a precisely
               defined virtual machine and object file format need not significantly
               restrict the creativity of the implementor. The Java Virtual Machine is designed to
               support many different implementations, providing new and interesting
               solutions while retaining compatibility between
               implementations.
            </p>
         </div>
      </div>
      <div class="navfooter">
         <hr>
         <table width="100%" summary="Navigation footer">
            <tr>
               <td width="40%" align="left"><a accesskey="p" href="jvms-1.html">Prev</a>&nbsp;
               </td>
               <td width="20%" align="center">&nbsp;</td>
               <td width="40%" align="right">&nbsp;<a accesskey="n" href="jvms-3.html">Next</a></td>
            </tr>
            <tr>
               <td width="40%" align="left" valign="top">Chapter&nbsp;1.&nbsp;Introduction&nbsp;</td>
               <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
               <td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;3.&nbsp;Compiling for the Java Virtual Machine</td>
            </tr>
         </table>
      </div>
      <div xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:rx="http://www.renderx.com/XSL/Extensions" class="navfooter">
         <hr><a href="jvms-0-front.html">
                Legal Notice
              </a></div>
   </body>
</html>