<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Книга: UNIX: взаимодействие процессов</title>
    <meta name="Author" content="Стивенс Уильям">
    <meta name="description" content="Автор: Стивенс Уильям, Перевод: Солнышков Д., Книга: UNIX: взаимодействие процессов, Жанр: компьютерная литература, Издание: 6 г.">
    <meta name="revisit" content="6 months">
<style type="text/css">

BODY { padding-left: 20px; padding-right: 20px; margin-top: 20px; font-family: Tahoma, Geneva, Arial, Helvetica, sans-srif;  }

TABLE { border: 1px solid darkgrey; border-spacing: 0px; border-right: 0px; border-bottom: 0px;empty-cells: show;}
TH { border-right: 1px solid darkgrey; border-bottom: 1px solid darkgrey; background-color: #fafafa;  text-align: center; padding-left: 5px; padding-right: 5px;}
TD { border-right: 1px solid darkgrey; border-bottom: 1px solid darkgrey; padding-left: 5px; padding-right: 5px;}

H1, H1 > P { text-align: center; font-size: x-large; }
H2, H2 > P { text-align: center; font-size: large; }

P { text-indent: 4ex; text-align: justify; margin: 3px;}

.epigraph DIV { text-align: right; margin-right: 50px; font-style: italic; font-size: small; }

.cite P { text-align: center; font-style: italic; margin: 0px; padding: 0px; }

.stanza {  margin: 1em; }

.bookfooter { position: fixed; top: 0px; left: 0px; width: 100%; z-index: 2; background-color: white; color: black;
	border-bottom: 1px solid green;  margin-left: 0px; margin-right: 0px; padding-left: 20px; padding-right: 20px;
	font-size: 12px; 
	}
.hbooktitle { font-size: 4px; display: none; }
.bookfooter A { text-decoration: none; }



</style>
<script type="text/javascript">

var xmlHttp = false;
/*@cc_on @*/
/*@if (@_jscript_version >= 5)
try {
  xmlHttp = new ActiveXObject("Msxml2.XMLHTTP");
} catch (e) {
  try {
    xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");
  } catch (e2) {
    xmlHttp = false;
  }
}
@end @*/

if (!xmlHttp && typeof XMLHttpRequest != 'undefined') {
  xmlHttp = new XMLHttpRequest();
}

function Get_Cookie( name )
{
	var start = document.cookie.indexOf( name + "=" );
	var len = start + name.length + 1;
	if ( ( !start ) && ( name != document.cookie.substring( 0, name.length ) ) ) {return null;}
	if ( start == -1 ) return null;
	var end = document.cookie.indexOf( ";", len );
	if ( end == -1 ) end = document.cookie.length;
	return unescape( document.cookie.substring( len, end ) );
} 

function hidelayer( layer_ref )
{
  state = 'hidden';
  if (document.all) { //IS IE 4 or 5 (or 6 beta)
    eval( "if( document.all." + layer_ref +" ) document.all." + layer_ref + ".style.visibility = state");
  }
  if (document.layers) { //IS NETSCAPE 4 or below
    if( document.layers[layer_ref] ) document.layers[layer_ref].visibility = state;
  }
  if (document.getElementById && !document.all) {
    maxwell_smart = document.getElementById(layer_ref);
    if( maxwell_smart ) maxwell_smart.style.visibility = state;
  }
}

function showlayer( layer_ref )
{
  state = 'visible';
  if (document.all) { //IS IE 4 or 5 (or 6 beta)
    eval( "if( document.all." + layer_ref +" ) document.all." + layer_ref + ".style.visibility = state");
  }
  if (document.layers) { //IS NETSCAPE 4 or below
    if( document.layers[layer_ref] ) document.layers[layer_ref].visibility = state;
  }
  if (document.getElementById && !document.all) {
    maxwell_smart = document.getElementById(layer_ref);
    if( maxwell_smart ) maxwell_smart.style.visibility = state;
  }
}


function GotoContent()
{
	window.location.replace("#label"+document.bookfooter.contents.value);
}

function getBodyScrollTop()
{
  return self.pageYOffset || 
    (document.documentElement && document.documentElement.scrollTop) || 
    (document.body && document.body.scrollTop);
}

function getDocumentHeight()
{
  return (document.body.scrollHeight > document.body.offsetHeight)?
    document.body.scrollHeight:
    document.body.offsetHeight;
}

var timeoutpid=0;
function ServerStatus()
{
   if (xmlHttp.readyState == 4)
   {
   		var response = xmlHttp.responseText;
   		if( response.length>2 )
   		{
			document.getElementById('note').innerHTML = '<br>'+response;
			showlayer('note');
			clearTimeout(timeoutpid);
			timeoutpid=setTimeout("document.getElementById('note').innerHTML = ''; hidelayer('note');",10000);
		}
   }
}


function SavePosition()
{
	var pos=getBodyScrollTop();
	var height=getDocumentHeight();
	var percent=Math.round(pos*100000/height);
	var url = "/saveBookPos.php?book=148368&pos="+percent;
	document.cookie="booklastposition148368="+percent+"; path=/; expires=Mon, 01-Jan-2050 00:00:00 GMT";
    p=percent/1000;
    document.getElementById('scrollpercent').innerHTML = p.toFixed(1)+'%';
}

function RestorePosition( ppos )
{
	var percent=Get_Cookie('booklastposition148368');
	if( ppos  )
	{
		percent=ppos;
	}
	else
	{
		if( Get_Cookie('bgColor') ) document.bgColor='#'+Get_Cookie('bgColor');
		if( Get_Cookie('fgColor') ) document.fgColor='#'+Get_Cookie('fgColor');
		var b=document.getElementsByTagName('p');
		var fontSize=Get_Cookie('fontSize');
		if( fontSize )
		{
			for( i=0; i<b.length; i++ )
			{
				b[i].style.fontSize = fontSize+'px';
			}
		
		}
	}
	var height=getDocumentHeight();
	var pos=Math.round(percent*height/100000);
	if( percent>0 )
	{
	    if( typeof( window.pageYOffset ) == 'number' )
	    {
	        window.pageYOffset=pos;
	    }
	    else if( document.body && ( document.body.scrollLeft || document.body.scrollTop ) )
	    {
	        document.body.scrollTop=pos;
        }
        else if( document.documentElement && document.documentElement.scrollTop )
        {
            document.documentElement.scrollTop=pos;
        }
        window.scroll(0, pos);
    }
	document.getElementById('note').innerHTML = '';
}

function ReaderSettings()
{
	var bcolor=document.bookfooter.backgroundcolor.value;
	if( bcolor.length==6 )
	{
		document.bgColor="#"+bcolor;
		document.cookie="bgColor="+bcolor+"; path=/; expires=Mon, 01-Jan-2050 00:00:00 GMT";
	}
	var fcolor=document.bookfooter.textcolor.value;
	if( fcolor.length==6 )
	{
		document.fgColor="#"+fcolor;
		document.cookie="fgColor="+fcolor+"; path=/; expires=Mon, 01-Jan-2050 00:00:00 GMT";
	}
	var fsize=document.bookfooter.fsize.value;
	if( fsize>4 )
	{
		var pos=getBodyScrollTop();
		var height=getDocumentHeight();
		var percent=Math.round(pos*100000/height);
		var b=document.getElementsByTagName('p');
		for( i=0; i<b.length; i++ ) 
		{
			b[i].style.fontSize = fsize+"px";
		
		}
		if( percent==0 ) percent=1;
		setTimeout("RestorePosition("+percent+")",500);
		document.cookie="fontSize="+fsize+"; path=/; expires=Mon, 01-Jan-2050 00:00:00 GMT";
	}

}

function DisplaySettings( id )
{
	state='unknown';
	if (document.all) { //IS IE 4 or 5 (or 6 beta)
    	eval( "if( document.all." + id +" ) state=document.all." + id + ".style.display");
    }
	if (document.layers) { //IS NETSCAPE 4 or below
    	if( document.layers[id] ) state=document.layers[id].display;
	}
	if (document.getElementById && !document.all) {
    	maxwell_smart = document.getElementById(id);
    	if( maxwell_smart ) state=maxwell_smart.style.display;
	}
	if( state == 'none' ) state='inline';
	else state='none'; 
	if (document.all) { 
    	eval( "if( document.all." + id +" ) document.all." + id + ".style.display = state");
	}
	if (document.layers) {
    	if( document.layers[id] ) document.layers[id].display = state;
	}
	if (document.getElementById && !document.all) {
    	maxwell_smart = document.getElementById(id);
    	if( maxwell_smart ) maxwell_smart.style.display = state;
	}
}

function tableruler()
{
	return 0;
}

</script>
</head>
<body onScroll="SavePosition();" onUnload="SavePosition();" onLoad="RestorePosition();">
<div class=content id=bookcontent><br><center><h1>Книга: UNIX: взаимодействие процессов</h1><script type="text/javascript"><!--
google_ad_client = "ca-pub-1271376699634376";
/* 728x90, bookreader */
google_ad_slot = "7890934750";
google_ad_width = 728;
google_ad_height = 90;
google_page_url = "http://www.e-reading.ws/bookreader.php/save/148368/%D0%A1%D1%82%D0%B8%D0%B2%D0%B5%D0%BD%D1%81_-_UNIX%3A_%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2.html";
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br></center><br><center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader0.jpg" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>
<DIV class=bookbody>
  <H1>
   <P><a name=label1 style="border:none;"></a>Уильям Стивенс</P>
   <P>UNIX: взаимодействие процессов</P>
   <P>МАСТЕР-КЛАСС</P>
  </H1>
<textarea name="topadvert_request_async" disabled="true" style="display:none;">
title: <b>Купить книгу "UNIX: взаимодействие процессов":</b>
feed_id: 5296
pattern_id: 2266
book_author: Стивенс Уильям
book_name: UNIX: взаимодействие процессов
</textarea><div class="topadvert_div" style="display:none; font-size:12px;line-height:2.5;"></div>
<script type="text/javascript" charset="utf-8" src="http://loader.topadvert.ru/load.utf8.js"></script>
<div style="float:left;border:1px dotted lightgrey;width:160px;height:600px;margin:25px 10px 5px -20px;"><div class=clear></div>
  <script type="text/javascript"><!--
  google_ad_client = "ca-pub-1271376699634376";
  /* 160x600, book.php right */
  google_ad_slot = "1251195223";
  google_ad_width = 160;
  google_ad_height = 600;
  //-->
  </script>
  <script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script>
</div>
<!-- SHOWADS bannercount=0 160x600 -->

  <DIV class=epigraph>
   <P>Всему сообществу Usenet, где можно найти много ЧаВо с ответами на все вопросы и случаи жизни</P>
  </DIV>
  <DIV class=section>
   <H1>
    <P><a name=label2 style="border:none;"></a>Предисловие</P>
   </H1>
   <H2><a name=label3 style="border:none;"></a>Введение</H2>
   <P>Большинство нетривиальных программ пишутся с использованием одной из форм межпроцессного взаимодействия (IPC — Interprocess Communication). Это естественное следствие принципа разработки, заключающегося в том, что лучше создавать приложение, состоящее из отдельных взаимодействующих элементов, чем одну большую программу. Исторически разработка приложений пережила следующие этапы развития:</P>
   <P>1. Сначала были большие цельные программы, которые делали все необходимое. Отдельные части программы реализовывались в виде функций, обменивавшихся информацией через аргументы, возвращаемые значения и глобальные переменные.</P>
   <P>2. Потом стали создаваться небольшие программы, взаимодействующие друг с другом посредством различных средств IPC. Многие стандартные утилиты Unix были разработаны именно таким образом, причем для передачи информации использовались каналы интерпретатора.</P>
   <P>3. Наконец, сейчас появилась возможность писать цельные программы, состоящие из взаимодействующих между собой потоков. В данном случае мы все равно применяем термин IPC, хотя процесс имеется только один.</P>
   <P>Комбинация последних двух вариантов также возможна: несколько процессов, каждый из которых состоит из нескольких потоков, вполне могут взаимодействовать между собой.</P>
   <P>Мы описываем возможность разделения решаемых задач между несколькими процессами или даже между потоками одного процесса. В мультипроцессорной системе такое приложение сможет выполняться гораздо быстрее, поэтому разделение задач между процессами способно повысить его быстродействие.</P>
   <P>В этой книге подробно описываются четыре формы IPC:</P>
   <P>1. Передача сообщений (каналы, FIFO, очереди сообщений).</P>
   <P>2. Синхронизация (взаимные исключения, условные переменные, блокировки чтения-записи, блокировка файлов и записей, семафоры).</P>
   <P>3. Разделяемая память (неименованная и именованная).</P>
   <P>4. Удаленный вызов процедур (двери, Sun RPC).</P>
   <P>Здесь не рассматриваются вопросы написания программ, взаимодействующих по сети. Такая форма взаимодействия обычно подразумевает использование интерфейса сокетов и стека протоколов TCP/IP; эти темы были подробно разобраны в первом томе книги ([24]).</P>
   <P>Нам могут возразить, что средства IPC, не предназначенные для взаимодействия по сети, вообще не следует использовать и что вместо этого следует изначально разрабатывать приложения с расчетом на использование в сети. Однако на практике средства IPC, работающие только в пределах одного узла, функционируют гораздо быстрее, чем сетевые, да и программы с их использованием оказываются проще. Разделяемая память и средства синхронизации обычно не могут использоваться по сети — они доступны только в пределах одного узла. Опыт и история показывают, что существует потребность в наличии как несетевых, так и сетевых форм IPC.</P>
   <P>В этой книге используется материал первого тома и других моих книг:</P>
   <P>■ UNIX Network Programming, том 1, 1998 [24];</P>
   <P>■ Advanced Programming in the UNIX Environment, 1992 [21];</P>
   <P>■ TCP/IP Illustrated, том 1, 1994 [22];</P>
   <P>■ TCP/IP Illustrated, том 2, написанной в соавторстве с Гари Райтом (Gary Wright),1995, [27];</P>
   <P>■ TCP/IP Illustrated, том 3, 1996 [23].</P>
   <P>Может показаться странным, что я описываю средства IPC в книге, заглавие которой содержит слова «Network Programming». Замечу, что IPC часто используется и в сетевых приложениях. Как говорилось в предисловии к книге «UNIX Network Programming» 1990 года издания, «для понимания методов разработки сетевых приложений необходимо понимание средств межпроцессного взаимодействия (IPC)».</P>
   <H2><a name=label4 style="border:none;"></a>Изменения со времени первого издания</H2>
   <P>Этот том содержит полностью переписанные главы 3 и 18 книги «UNIX Network Programming» 1990 года издания. Если подсчитать количество слов, объем материала увеличился в пять раз. Ниже перечислены основные отличия данного издания:</P>
   <P>■ В дополнение к трем формам System V IPC (очереди сообщений, семафоры, разделяемая память) рассматриваются более новые функции Posix, реализующие эти же три формы IPC. О стандартах Posix более подробно говорится в разделе 1.7. В будущем можно ожидать перехода к использованию функций Posix, обладающих определенными преимуществами по сравнению с аналогами System V.</P>
   <P>■ Рассматриваются средства синхронизации Posix: взаимные исключения, условные переменные, блокировки чтения-записи. Эти средства могут использоваться для синхронизации потоков или процессов и часто привлекаются для обеспечения синхронизации доступа к разделяемой памяти.</P>
   <P>■ В этом томе предполагается наличие поддержки потоков Posix (Pthreads), и многие примеры написаны с использованием многопоточного (а не многопроцессного) программирования.</P>
   <P>■ Описание именованных и неименованных каналов и блокировок записей основано на их определениях в стандарте Posix.</P>
   <P>■ В дополнение к описанию средств IPC и примерам их использования я также привожу примеры реализации очередей сообщений, блокировок чтения-записи и семафоров Posix (все это может быть скомпилировано в пользовательские библиотеки). Эти реализации задействуют множество разных средств одновременно. Например, одна из реализаций семафоров Posix использует взаимные исключения, условные переменные и отображение в память. В комментариях отмечаются важные моменты, которые следует учитывать при разработке приложений (ситуации гонок, обработка ошибок, утечка памяти, использование списков аргументов переменной длины). Понимание реализации какого-либо средства ведет к лучшему его использованию.</P>
   <P>■ При описании RPC основное внимание уделяется пакету Sun RPC. Рассказ предваряется описанием нового интерфейса дверей в Solaris, который похож на RPC, но используется только в пределах одного узла. Описание дверей является как бы введением, в котором описываются важные вопросы вызова процедур в других процессах без необходимости учитывать особенности сетевой реализации.</P>
   <H2><a name=label5 style="border:none;"></a>Кому адресована эта книга?</H2>
   <P>Эта книга может использоваться как учебник по IPC или как справочник для опытных программистов. Текст разделен на четыре части:</P>
   <P>■ передача сообщений;</P>
   <P>■ синхронизация;</P>
   <P>■ разделяемая память;</P>
   <P>■ удаленный вызов процедур.</P>
   <P>Возможно, некоторые читатели будут интересоваться содержимым конкретных подразделов. Большая часть глав может читаться совершенно независимо от остальных, хотя в главе 2 объединены многие общие особенности средств Posix IPC, в главе 3 — System V IPC, а глава 12 является введением в разделяемую память (как Posix, так и System V). Всем читателям настоятельно рекомендуется прочесть главу 1, в особенности раздел 1.6, в котором описываются используемые в книге функции-обертки. Главы, описывающие средства Posix IPC, могут читаться отдельно от глав, посвященных System V IPC. Описание каналов и блокировок записей стоит особняком. Две главы, посвященные удаленному вызову процедур, также могут читаться отдельно от прочих.</P>
   <P>Подробный индекс упрощает использование книги в качестве справочника. Для читающих текст в случайном порядке приводятся многочисленные перекрестные ссылки на сходный материал.</P>
   <H2><a name=label6 style="border:none;"></a>Исходный код и опечатки</H2>
   <P>Исходный код всех примеров можно загрузить с домашней страницы автора (адрес — в конце предисловия). Лучший способ изучить IPC — это изменить программы из примеров или даже улучшить их. Написание программ лучше всего способствует усвоению концепций и методов. В конце каждой главы даются упражнения, решения к большей части которых даны в приложении Г.</P>
   <P>Список замеченных опечаток можно также найти на домашней странице автора.</P>
   <H2><a name=label7 style="border:none;"></a>Благодарности</H2>
   <P>Хотя на обложке книги стоит имя только одного автора, в ее создании участвовало множество людей. Прежде всего это члены семьи автора, которые смирились с ушедшими на ее написание часами. Еще раз спасибо, Салли, Билл, Эллен и Дэвид.</P>
   <P>Спасибо всем, кто помогал работать с содержимым книги. Ваша помощь была просто неоценимой (135 печатных страниц). Вы исправляли ошибки, отмечали недостаточную четкость пояснений, предлагали другие объяснения и варианты программ. Спасибо вам, Гевин Боуи, Аллен Бриггс, Дейв Бутенхов, Ван-Тех Чанг, Крис Клилэнд, Боб Фриснан, Эндрю Гиерт, Скотт Джонсон, Марти Леиснер, Ларри Мак-Вой, Крейг Метз, Боб Нельсон, Стив Рэго, Джим Рейд, Свами К. Ситарама, Джон К. Снейдер, Иан Ланс Тейлор, Рик Тир и Энди Такер.</P>
   <P>Мне помогали и те, кто отвечал на мои электронные письма, в которых порой было множество вопросов. Ваши ответы помогли сделать книгу более точной и ясной: Дэвид Баусум, Дейв Бутенхов, Билл Голмейстер, Макеш Кэкер, Брайан Керниган, Ларри МакВой, Стив Рэго, Кейт Скорвран, Барт Смаалдерс, Энди Такер и Джон Уэйт.</P>
   <P>Отдельная благодарность Ларри Рафски из GSquared. Спасибо, как обычно, говорю я NOAO, Сиднею Вульфу, Ричарду Вульфу и Стиву Гранди за возможность работать с их сетями и компьютерами. Джим Баунд, Мэтт Томас, Мэри Клаутер и Барб Гловер из Digital Equipment Corp. предоставили систему Alpha, на которой выполнялась большая часть примеров данной книги. Часть программ была протестирована и в других системах. Спасибо Майклу Джонсону из Red Hat Software (за новейшие версии Red Hat Linux), Дейву Маркуардту и Джесси Хауг за компьютер RS/6000 и доступ к последним версиям AIX.</P>
   <P>Благодарю сотрудников Prentice Hall — редактора Мэри Франц вместе с Норин Регина, Софи Папаниколау и Патти Гуэрриери — за помощь, в особенности в соблюдении сроков.</P>
   <H2><a name=label8 style="border:none;"></a>Выходные сведения</H2>
   <P>Оригинал-макет этой книги был подготовлен на языке PostScript. Форматирование осуществлялось с помощью замечательного пакета groff (автор — Джеймс Кларк) на SparcStation под управлением Solaris 2.6. (Сведения о смерти groff сильно преувеличены). Я набил все 138 897 слов книги в редакторе vi, создал 72 рисунка с помощью программы gpic (используя макросы Гари Райта), сделал 35 таблиц с помощью программы gtbl, подготовил индекс (с помощью сценариев на языке awk, написанных Джоном Бентли и Брайаном Керниганом) и сверстал все это вместе. Программа Дейва Хэнсона loom, пакет GNU indent и сценарии Гари Райта помогли добавить в книгу 8046 строк исходного кода на языке С.</P>
   <P>С нетерпением жду комментариев, предложений и сообщений о замеченных опечатках.</P>
   <P>W. Richard Stevens Tucson, Arizona July 1998</P>
   <P>rstevens@kohala.com http://www.kohala.com/~rstevens</P>
   <H2><a name=label9 style="border:none;"></a>От издательства</H2>
   <P>Ваши замечания, предложения, вопросы отправляйте по адресу электронной почты comp@piter.com (издательство «Питер», компьютерная редакция).</P>
   <P>Мы будем рады узнать ваше мнение!</P>
   <P>Все исходные тексты, приведенные в книге, вы можете найти по адресу http://www.piter.com/download.</P>
   <P>На web-сайте издательства http://www.piter.com вы найдете подробную информацию о наших книгах.</P>
  </DIV>
  <DIV class=section>
   <H1>
    <P><a name=label10 style="border:none;"></a>ЧАСТЬ 1</P>
    <P>ВВЕДЕНИЕ В IPC UNIX</P>
   </H1>
   <DIV class=section>
    <H1>
     <P><a name=label11 style="border:none;"></a>ГЛАВА 1</P>
     <P>Обзор средств взаимодействия процессов Unix</P>
    </H1>
    <DIV class=section>
     <H1>
      <P><a name=label12 style="border:none;"></a>1.1. Введение</P>
     </H1>
     <P>Аббревиатура IPC расшифровывается как <EM>interprocess communication,</EM> то есть взаимодействие процессов. Обычно под этим понимается передача сообщений различных видов между процессами в какой-либо операционной системе. При этом могут использоваться различные формы синхронизации, требуемой современными видами взаимодействия, осуществляемыми, например, через разделяемую память.</P>
     <P>В процессе развития операционных систем семейства Unix за последние 30 лет методы передачи сообщений эволюционировали следующим образом:</P>
     <P>■ Каналы (pipes — глава 4) были первой широко используемой формой взаимодействия процессов, доступной программам и пользователю (из интерпретатора команд). Основным недостатком каналов является невозможность их использования между процессами, не имеющими общего родителя (ancestor), но этот недостаток был устранен с появлением именованных каналов (named pipes), или каналов FIFO (глава 4).</P>
     <P>■ Очереди сообщений стандарта System V (System V message queues — глава 4) были добавлены к ядрам System V в начале 80-х. Они могут использоваться для передачи сообщений между процессами на одном узле вне зависимости от того, являются ли эти процессы родственными. Несмотря на сохранившийся префикс «System V», большинство современных версий Unix, включая и те, которые не произошли от System V, поддерживают эти очереди.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>В отношении процессов Unix термин «родство» означает, что у процессов имеется общий предок. Подразумевается, что процессы, являющиеся родственниками, были созданы этим процессом-предком с помощью одной или нескольких «вилок» (forks). Простейшим примером будет вызов fork некоторым процессом дважды, что приведет к созданию двух порожденных процессов. Тогда можно говорить о родстве этих процессов между собой. Естественно, каждый порожденный процесс является родственником породившего. Родитель может позаботиться о возможности взаимодействия с порожденным процессом (создав канал или очередь сообщений) перед вызовом fork, и этот объект IPC будет унаследован порожденным процессом. Более подробно о наследовании объектов IPC рассказано в табл. 1.4. Нужно также отметить, что все процессы Unix теоретически являются потомками процесса init, который запускает все необходимое в процессе загрузки системы (bootstrapping). С практической точки зрения отсчет родства процессов лучше вести с оболочки (login shell) и всех процессов, ею созданных. В главе 9 [24] рассказано о сеансах и родственных отношениях процессов более подробно. </P>
     </DIV>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Примечания вроде этого будут использоваться нами для того, чтобы уточнять особенности реализации, давать исторические справки и полезные советы. </P>
     </DIV>
     <P>■ Очереди сообщений Posix (Posix message queues — глава 5) были добавлены в стандарт Posix (1003.1b-1993, о котором более подробно рассказано в разделе 1.7). Они могут использоваться для взаимодействия родственных и неродственных процессов на каком-либо узле.</P>
     <P>■ Удаленный вызов процедур (remote procedure calls — RPC, часть 5) появился в 80-х в качестве средства для вызова функций на одной системе (сервере) программой, выполняемой на другой системе (клиенте). Это средство было разработано в качестве альтернативы для упрощения сетевого программирования. Поскольку между клиентом и сервером обычно передается информация (передаются аргументы для вызова функции и возвращаемые значения) и поскольку удаленный вызов процедур может использоваться между клиентом и сервером на одном узле, RPC можно также считать одной из форм передачи сообщений.</P>
     <P>Интересно также взглянуть на эволюцию различных форм синхронизации в процессе развития Unix:</P>
     <P>■ Самые первые программы, которым требовалась синхронизация (чаще всего для предотвращения одновременного изменения содержимого файла несколькими процессами), использовали особенности файловой системы, некоторые из которых описаны в разделе 9.8,</P>
     <P>■ Возможность блокирования записей (record locking — глава 9) была добавлена к ядрам Unix в начале 80-х и стандартизована в версии Posix.1 в 1988.</P>
     <P>■ Семафоры System V (System V semaphores — глава 11) были добавлены вместе с возможностью совместного использования памяти (System V shared memory — глава 14) и одновременно с очередями сообщений System V (начало 80-х). Эти IPC поддерживаются большинством современных версий Unix.</P>
     <P>■ Семафоры Posix (Posix semaphores — глава 10) и разделяемая память Posix (Posix shared memory— глава 13) были также добавлены в стандарт Posix (1003.1b-1993, который ранее упоминался в связи с очередями сообщений Posix).</P>
     <P>■ Взаимные исключения и условные переменные (mutex, conditional variable — глава 7) представляют собой две формы синхронизации, определенные стандартом программных потоков Posix (Posix threads, Pthreads — 1003.1с-1995). Хотя обычно они используются для синхронизации между потоками, их можно применять и при организации взаимодействия процессов.</P>
     <P>■ Блокировки чтения-записи (read-write locks — глава 8) представляют собой дополнительную форму синхронизации. Она еще не включена в стандарт Posix, но, вероятно, скоро будет.</P>
    
<!-- SHOWADS bannercount=1 -->
<br><center>
<script type="text/javascript"><!--
google_ad_client = "ca-pub-1271376699634376";
/* 728x90, bookreader */
google_ad_slot = "7890934750";
google_ad_width = 728;
google_ad_height = 90;
google_page_url = "http://www.e-reading.ws/bookreader.php/save/148368/%D0%A1%D1%82%D0%B8%D0%B2%D0%B5%D0%BD%D1%81_-_UNIX%3A_%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2.html";
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br></center>
</DIV>
    <DIV class=section>
     <H1>
      <P><a name=label13 style="border:none;"></a>1.2. Процессы, потоки и общий доступ к информации</P>
     </H1>
     <DIV class=section>
      <P>В традиционной модели программирования Unix в системе могут одновременно выполняться несколько процессов, каждому из которых выделяется собственное адресное пространство. Это иллюстрирует рис. 1.1. </P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader9" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 1.1. Совместное использование информации процессами</P>
      <BR>
      <P>1. Два процесса в левой части совместно используют информацию, хранящуюся в одном из объектов файловой системы. Для доступа к этим данным каждый процесс должен обратиться к ядру (используя функции read, write, lseek, write, lseek и аналогичные). Некоторая форма синхронизации требуется при изменении файла, для исключения помех при одновременной записи в файл несколькими процессами и для защиты процессов, читающих из файла, от тех, которые пишут в него.</P>
      <P>2. Два процесса в середине рисунка совместно используют информацию, хранящуюся в ядре. Примерами в данном случае являются канал, очередь сообщений или семафор System V. Для доступа к совместно используемой информации в этом случае будут использоваться системные вызовы.</P>
      <P>3. Два процесса в правой части используют общую область памяти, к которой может обращаться каждый из процессов. После того как будет получен доступ к этой области памяти, процессы смогут обращаться к данным вообще без помощи ядра. В этом случае, как и в первом, процессам, использующим общую память, также требуется синхронизация.</P>
      <P>Обратите внимание, что ни в одном из этих случаев количество взаимодействующих процессов не ограничивается двумя. Любой из описанных методов работает для произвольного числа взаимодействующих процессов. На рисунке мы изображаем только два для простоты.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label14 style="border:none;"></a>Потоки</P>
      </H1>
      <P>Хотя концепция процессов в системах Unix используется уже очень давно, возможность использовать несколько потоков внутри одного процесса появилась относительно недавно. Стандарт потоков Posix.1, называемый Pthreads, был принят в 1995 году. С точки зрения взаимодействия процессов все потоки одного процесса имеют общие глобальные переменные (то есть поточной модели свойственно использование общей памяти). Однако потокам требуется синхронизация доступа к глобальным данным. Вообще, синхронизация, не являясь собственно формой IPC, часто используется совместно с различными формами IPC для управления доступом к данным.</P>
      <P>В этой книге описано взаимодействие между процессами и между потоками. Мы предполагаем наличие среды, в которой поддерживается многопоточное программирование, и будем использовать выражения вида «если канал пуст, вызывающий поток блокируется до тех пор, пока какой-нибудь другой поток не произведет запись в канал». Если система не поддерживает потоки, можно в этом предложении заменить «потоки» на «процессы» и получится классическое определение блокировки в Unix, возникающей при считывании из пустого канала командой read. Однако в системе, поддерживающей потоки, блокируется только поток, запросивший данные из пустого канала, а все остальные потоки процесса будут продолжать выполняться. Записать данные в канал сможет другой поток этого же процесса или какой-либо поток другого процесса.</P>
      <P>В приложении Б сведены некоторые основные характеристики потоков и дано описание пяти основных функций Pthread, используемых в программах этой книги.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label15 style="border:none;"></a>1.3. Живучесть объектов IPC</P>
     </H1>
     <P>Можно определить живучесть (persistence) любого объекта IPC как продолжительность его существования. На рис. 1.2 изображены три возможные группы, к которым могут быть отнесены объекты по живучести.</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader11" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 1.2. Живучесть объектов IPC</P>
     <BR>
     <P>1. Объект IPC, живучесть которого определяется процессом (process-persistent), существует до тех пор, пока не будет закрыт последним процессом, в котором он еще открыт. Примером являются неименованные и именованные каналы (pipes, FIFO).</P>
     <P>2. Объект IPC, живучесть которого определяется ядром (kernel-persistent), существует до перезагрузки ядра или до явного удаления объекта. Примером являются очереди сообщений стандарта System V, семафоры и разделяемая память. Живучесть очередей сообщений Posix, семафоров и разделяемой памяти должна определяться по крайней мере ядром, но может определяться и файловой системой в зависимости от реализации.</P>
     <P>3. Объект IPC, живучесть которого определяется файловой системой (filesystem-persistent), существует до тех пор, пока не будет удален явно. Его значение сохраняется даже при перезагрузке ядра. Очереди сообщений Posix, семафоры и память с общим доступом обладают этим свойством, если они реализованы через отображаемые файлы (так бывает не всегда).</P>
     <P>Следует быть аккуратным при определении живучести объекта IPC, поскольку она не всегда очевидна. Например, данные в канале (pipe) обрабатываются ядром, но живучесть каналов определяется процессами, а не ядром, потому что после того, как последний процесс, которым канал был открыт на чтение, закроет его, ядро сбросит все данные и удалит канал. Аналогично, хотя каналы FIFO и обладают именами в файловой системе, живучесть их также определяется процессами, поскольку все данные в таком канале сбрасываются после того, как последний процесс, в котором он был открыт, закроет его.</P>
     <P>В табл. 1.1 сведена информация о живучести перечисленных ранее объектов IPC.</P>
     <BR>
    </DIV>
    <DIV class=section>
     <P>Таблица 1.1. Живучесть различных типов объектов IPC</P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Тип IPC</TH>
       <TH ALIGN=left VALIGN=top >Живучесть определяет</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Программный канал (pipe)</TD>
       <TD ALIGN=left VALIGN=top >Процесс</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Именованный канал (FIFO)</TD>
       <TD ALIGN=left VALIGN=top >Процесс</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Взаимное исключение Posix (mutex)</TD>
       <TD ALIGN=left VALIGN=top >Процесс</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Условная переменная Posix (condition variable)</TD>
       <TD ALIGN=left VALIGN=top >Процесс</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Блокировка чтения-записи Posix (lock)</TD>
       <TD ALIGN=left VALIGN=top >Процесс</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Блокировка записи fcntl</TD>
       <TD ALIGN=left VALIGN=top >Процесс</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Очередь сообщений Posix (message queue)</TD>
       <TD ALIGN=left VALIGN=top >Ядро</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Именованный семафор Posix (named semaphore)</TD>
       <TD ALIGN=left VALIGN=top >Ядро</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Семафор Posix в памяти (memory-based semaphore)</TD>
       <TD ALIGN=left VALIGN=top >Процесс</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Разделяемая память Posix (shared memory)</TD>
       <TD ALIGN=left VALIGN=top >Ядро</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Очередь сообщений System V</TD>
       <TD ALIGN=left VALIGN=top >Ядро</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Семафор System V</TD>
       <TD ALIGN=left VALIGN=top >Ядро</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Память с общим доступом System V</TD>
       <TD ALIGN=left VALIGN=top >Ядро</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Сокет TCP (TCP socket)</TD>
       <TD ALIGN=left VALIGN=top >Процесс</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Сокет UDP (UDP socket)</TD>
       <TD ALIGN=left VALIGN=top >Процесс</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Доменный сокет Unix (Unix domain socket)</TD>
       <TD ALIGN=left VALIGN=top >Процесс</TD>
      </TR>
     </TABLE>
     <P>Обратите внимание, что ни один тип IPC в этой таблице не обладает живучестью, определяемой файловой системой. Мы уже упомянули о том, что три типа объектов IPC в стандарте Posix <EM>могут </EM>иметь этот тип живучести в зависимости от реализации. Очевидно, что запись данных в файл обеспечивает живучесть, определяемую файловой системой, но обычно IPC таким образом не реализуются. Большая часть объектов IPC не предназначена для того, чтобы существовать и после перезагрузки, потому что ее не переживают процессы. Требование живучести, определяемой файловой системой, скорее всего, снизит производительность данного типа IPC, а обычно одной из задач разработчика является именно обеспечение высокой производительности.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label16 style="border:none;"></a>1.4. Пространства имен</P>
     </H1>
     <P>Если два неродственных процесса используют какой-либо вид IPC для обмена информацией, объект IPC должен иметь имя или идентификатор, чтобы один из процессов (называемый обычно сервером — server) мог создать этот объект, а другой процесс (обычно один или несколько клиентов — client) мог обратиться к этому конкретному объекту.</P>
     <P>Программные каналы (pipes) именами не обладают (и поэтому не могут использоваться для взаимодействия между неродственными процессами), но каналам FIFO сопоставляются имена в файловой системе, являющиеся их идентификаторами (поэтому каналы FIFO могут использоваться для взаимодействия неродственных процессов). Для других типов IPC, рассматриваемых в последующих главах, используются дополнительные соглашения об именовании (naming conventions). Множество возможных имен для определенного типа IPC называется его пространством имен (name space). Пространство имен — важный термин, поскольку для всех видов IPC, за исключением простых каналов, именем определяется способ связи клиента и сервера для обмена сообщениями.</P>
     <P>В табл. 1.2 сведены соглашения об именовании для различных видов IPC.</P>
     <BR>
     <P>Таблица 1.2. Пространства имен для различных типов IPC</P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Тип IPC</TH>
       <TH ALIGN=left VALIGN=top >Пространство имен для создания или открытия</TH>
       <TH ALIGN=left VALIGN=top >Идентификатор после открытия</TH>
       <TH ALIGN=left VALIGN=top >Posix.1 1996</TH>
       <TH ALIGN=left VALIGN=top >Unix 98</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Канал</TD>
       <TD ALIGN=left VALIGN=top >(Без имени)</TD>
       <TD ALIGN=left VALIGN=top >Дескриптор</TD>
       <TD ALIGN=left VALIGN=top >•</TD>
       <TD ALIGN=left VALIGN=top >•</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >FIFO</TD>
       <TD ALIGN=left VALIGN=top >Имя файла (pathname)</TD>
       <TD ALIGN=left VALIGN=top >Дескриптор</TD>
       <TD ALIGN=left VALIGN=top >•</TD>
       <TD ALIGN=left VALIGN=top >•</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Взаимное исключение Posix</TD>
       <TD ALIGN=left VALIGN=top >(Без имени)</TD>
       <TD ALIGN=left VALIGN=top >Указатель типа pthread_mutex_t</TD>
       <TD ALIGN=left VALIGN=top >•</TD>
       <TD ALIGN=left VALIGN=top >•</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Условная переменная Posix</TD>
       <TD ALIGN=left VALIGN=top >(Без имени)</TD>
       <TD ALIGN=left VALIGN=top >Указатель типа pthread_cond_t</TD>
       <TD ALIGN=left VALIGN=top >•</TD>
       <TD ALIGN=left VALIGN=top >•</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Блокировка чтения-записи Posix</TD>
       <TD ALIGN=left VALIGN=top >(Без имени)</TD>
       <TD ALIGN=left VALIGN=top >Указатель типа pthread_rwlock_t</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top >•</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Блокировка записей fcntl</TD>
       <TD ALIGN=left VALIGN=top >Имя файла</TD>
       <TD ALIGN=left VALIGN=top >Дескриптор</TD>
       <TD ALIGN=left VALIGN=top >•</TD>
       <TD ALIGN=left VALIGN=top >•</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Разделяемая память Posix</TD>
       <TD ALIGN=left VALIGN=top >Posix-имя IPC</TD>
       <TD ALIGN=left VALIGN=top >Дескриптор</TD>
       <TD ALIGN=left VALIGN=top >•</TD>
       <TD ALIGN=left VALIGN=top >•</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Очередь сообщений System V</TD>
       <TD ALIGN=left VALIGN=top >Ключ key_t</TD>
       <TD ALIGN=left VALIGN=top >Идентификатор IPC System V</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top >•</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Семафор System V</TD>
       <TD ALIGN=left VALIGN=top >Ключ key_t</TD>
       <TD ALIGN=left VALIGN=top >Идентификатор IPC System V</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top >•</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Разделяемая память System V</TD>
       <TD ALIGN=left VALIGN=top >Ключ key_t</TD>
       <TD ALIGN=left VALIGN=top >Идентификатор IPC System V</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top >•</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Двери (doors)</TD>
       <TD ALIGN=left VALIGN=top >Имя файла</TD>
       <TD ALIGN=left VALIGN=top >Дескриптор</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Удаленный вызов процедур (RPC) Sun</TD>
       <TD ALIGN=left VALIGN=top >Программа/версия</TD>
       <TD ALIGN=left VALIGN=top >Дескриптор (handle) RPC</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Сокет TCP</TD>
       <TD ALIGN=left VALIGN=top >IP-адрес и порт TCP</TD>
       <TD ALIGN=left VALIGN=top >Дескриптор</TD>
       <TD ALIGN=left VALIGN=top >.1g</TD>
       <TD ALIGN=left VALIGN=top >•</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Сокет UDP</TD>
       <TD ALIGN=left VALIGN=top >IP-адрес и порт TCP</TD>
       <TD ALIGN=left VALIGN=top >Дескриптор</TD>
       <TD ALIGN=left VALIGN=top >.1g</TD>
       <TD ALIGN=left VALIGN=top >•</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Доменный сокет Unix (domain socket)</TD>
       <TD ALIGN=left VALIGN=top >Полное имя файла</TD>
       <TD ALIGN=left VALIGN=top >Дескриптор</TD>
       <TD ALIGN=left VALIGN=top >.1g</TD>
       <TD ALIGN=left VALIGN=top >•</TD>
      </TR>
     </TABLE>
     <P>Здесь также указано, какие формы IPC содержатся в стандарте Posix.1 1996 года и какие были включены в стандарт Unix 98. Об обоих этих стандартах более подробно рассказано в разделе 1.7. Для сравнения мы включили в эту таблицу три типа сокетов, которые подробно описаны в [24]. Обратите внимание, что интерфейс сокетов (Application Program Interface — API) стандартизируется рабочей группой Posix.1g и должен в будущем стать частью стандарта Posix.1.</P>
     <P>Хотя стандарт Posix. 1 и дает возможность использования семафоров, их поддержка не является обязательной для производителей. В табл. 1.3 сведены функции, описанные в стандартах Posix.1 и Unix 98. Каждая функция может быть обязательной (mandatory), неопределенной (not defined) или необязательной (дополнительной — optional). Для необязательных функций мы указываем имя константы (например, _POSIX_THREADS), которая будет определена (обычно в заголовочном файле &lt;unistd.h&gt;), если эта функция поддерживается. Обратите внимание, что Unix 98 содержит в себе Posix.1 в качестве подмножества.</P>
     <BR>
     <P>Таблица 1.3. Доступность различных форм IPC</P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Тип IPC</TH>
       <TH ALIGN=left VALIGN=top >Posix.1 1996</TH>
       <TH ALIGN=left VALIGN=top >Unix 98</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Программный канал</TD>
       <TD ALIGN=left VALIGN=top >Обязателен</TD>
       <TD ALIGN=left VALIGN=top >Обязателен</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >FIFO</TD>
       <TD ALIGN=left VALIGN=top >Обязателен</TD>
       <TD ALIGN=left VALIGN=top >Обязателен</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Взаимное исключение Posix</TD>
       <TD ALIGN=left VALIGN=top >_POSIX_THREADS</TD>
       <TD ALIGN=left VALIGN=top >Обязателен</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Условная переменная Posix</TD>
       <TD ALIGN=left VALIGN=top >_POSIX_THREADS</TD>
       <TD ALIGN=left VALIGN=top >Обязателен</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Взаимные исключения и условные переменные между процессами</TD>
       <TD ALIGN=left VALIGN=top >_POSIX_THREADS_PROCESS_SHARED</TD>
       <TD ALIGN=left VALIGN=top >Обязателен</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Блокировка чтения-записи Posix</TD>
       <TD ALIGN=left VALIGN=top >(He определен)</TD>
       <TD ALIGN=left VALIGN=top >Обязателен</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Блокировка записей fcntl</TD>
       <TD ALIGN=left VALIGN=top >Обязателен</TD>
       <TD ALIGN=left VALIGN=top >Обязателен</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Очередь сообщений Posix</TD>
       <TD ALIGN=left VALIGN=top >_POSIX_MESSAGE_PASSING</TD>
       <TD ALIGN=left VALIGN=top >_XOPEN_REALTIME</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Семафоры Posix</TD>
       <TD ALIGN=left VALIGN=top >_POSIX_SEMAPHORES_</TD>
       <TD ALIGN=left VALIGN=top >_XOPEN_REALTIME</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Память с общим доступом Posix</TD>
       <TD ALIGN=left VALIGN=top >_POSIX_SHARED_MEMORY_OBJECTS</TD>
       <TD ALIGN=left VALIGN=top >_XOPEN_REALTIME</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Очередь сообщений System V</TD>
       <TD ALIGN=left VALIGN=top >(He определен)</TD>
       <TD ALIGN=left VALIGN=top >Обязателен</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Семафор System V</TD>
       <TD ALIGN=left VALIGN=top >(He определен)</TD>
       <TD ALIGN=left VALIGN=top >Обязателен</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Память с общим доступом System V</TD>
       <TD ALIGN=left VALIGN=top >(He определен)</TD>
       <TD ALIGN=left VALIGN=top >Обязателен</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Двери (doors)</TD>
       <TD ALIGN=left VALIGN=top >(He определен)</TD>
       <TD ALIGN=left VALIGN=top >(Не определен)</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Удаленный вызов процедур Sun</TD>
       <TD ALIGN=left VALIGN=top >(He определен)</TD>
       <TD ALIGN=left VALIGN=top >(Не определен)</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Отображение памяти mmap</TD>
       <TD ALIGN=left VALIGN=top >_POSIX_MAPPED_FILES или POSIX_SHARED_MEMORY_OBJECTS</TD>
       <TD ALIGN=left VALIGN=top >Обязателен</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Сигналы реального времени (realtime signals)</TD>
       <TD ALIGN=left VALIGN=top >_POSIX_REALTIME_SIGNALS</TD>
       <TD ALIGN=left VALIGN=top >_XOPEN_REALTIME</TD>
      </TR>
     </TABLE>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label17 style="border:none;"></a>1.5. Действие команд fork, exec и exit на объекты IPC</P>
     </H1>
     <P>Нам нужно достичь понимания действия функций fork, exec и _exit на различные формы IPC, которые мы обсуждаем (последняя из перечисленных функций вызывается функцией exit). Информация по этому вопросу сведена в табл. 1.4.</P>
     <P>Большинство функций описаны далее в тексте книги, но здесь нужно сделать несколько замечаний. Во-первых, вызов fork из многопоточного процесса (multithreaded process) приводит к беспорядку в безымянных переменных синхронизации (взаимных исключениях, условных переменных, блокировках и семафорах, хранящихся в памяти). Раздел 6.1 книги [3] содержит необходимые детали. Мы просто отметим в добавление к таблице, что если эти переменные хранятся в памяти с общим доступом и создаются с атрибутом общего доступа для процессов, они будут доступны любому процессу, который может обращаться к этой области памяти. Во-вторых, три формы IPC System V не могут быть открыты или закрыты. Из листинга 6.6 и упражнений 11.1 и 14.1 видно, что все, что нужно знать, чтобы получить доступ к этим трем формам IPC, — это идентификатор. Поэтому они доступны всем процессам, которым известен этот идентификатор, хотя для семафоров и памяти с общим доступом требуется некая особая обработка.</P>
     <BR>
     <P>Таблица 1.4. Действие fork, exec и _exit на IPC</P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Тип IPC</TH>
       <TH ALIGN=left VALIGN=top >fork</TH>
       <TH ALIGN=left VALIGN=top >exec</TH>
       <TH ALIGN=left VALIGN=top >_exit</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Неименованные и именованные каналы</TD>
       <TD ALIGN=left VALIGN=top >Порожденный процесс получает копии всех дескрипторов родительского процесса</TD>
       <TD ALIGN=left VALIGN=top >Все открытые дескрипторы остаются открытыми, если для них не установлен бит FD_CLOEXEC</TD>
       <TD ALIGN=left VALIGN=top >Все открытые дескрипторы закрываются, данные из программного канала и FIFO удаляются после последнего закрытия</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Очереди сообщений Posix</TD>
       <TD ALIGN=left VALIGN=top >Порожденный процесс получает копии всех открытых родительских процессов</TD>
       <TD ALIGN=left VALIGN=top >Все открытые дескрипторы очередей сообщений закрываются</TD>
       <TD ALIGN=left VALIGN=top >Все открытые дескрипторы очередей сообщений закрываются</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Очереди сообщений System V</TD>
       <TD ALIGN=left VALIGN=top >Не действует</TD>
       <TD ALIGN=left VALIGN=top >Не действует</TD>
       <TD ALIGN=left VALIGN=top >Не действует</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Взаимные исключения и условные переменные Posix</TD>
       <TD ALIGN=left VALIGN=top >Общий доступ, если используется разделяемая память с атрибутом разделения между процессами</TD>
       <TD ALIGN=left VALIGN=top >Исчезает, если не хранится в разделяемой памяти, которая остается открытой и имеет атрибут разделения</TD>
       <TD ALIGN=left VALIGN=top >Исчезает, если не находится в разделяемой памяти, которая остается открытой и имеет атрибут разделения</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Блокировки чтения-записи Posix</TD>
       <TD ALIGN=left VALIGN=top >Общий доступ, если используется память с общим доступом и атрибутом разделения между процессами</TD>
       <TD ALIGN=left VALIGN=top >Исчезает, если не хранится в разделяемой памяти, которая остается открытой и имеет атрибут разделения</TD>
       <TD ALIGN=left VALIGN=top >Исчезает, если не хранится в разделяемой памяти, которая остается открытой и имеет атрибут разделения</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Семафоры Posix, хранящиеся в памяти</TD>
       <TD ALIGN=left VALIGN=top >Общий доступ, если используется память с общим доступом и атрибутом разделения между процессами</TD>
       <TD ALIGN=left VALIGN=top >Исчезает, если не хранится в разделяемой памяти, которая остается открытой и имеет атрибут разделения</TD>
       <TD ALIGN=left VALIGN=top >Исчезает, если не хранится в разделяемой памяти, которая остается открытой и имеет атрибут разделения</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Именованные семафоры Posix</TD>
       <TD ALIGN=left VALIGN=top >Все открытые в родительском процессе остаются открытыми в порожденном</TD>
       <TD ALIGN=left VALIGN=top >Все открытые закрываются</TD>
       <TD ALIGN=left VALIGN=top >Все открытые закрываются</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Семафоры System V</TD>
       <TD ALIGN=left VALIGN=top >Все значения semadj в порожденном процессе устанавливаются в 0</TD>
       <TD ALIGN=left VALIGN=top >Все значения semadj передаются новой программе</TD>
       <TD ALIGN=left VALIGN=top >Все значения semadj добавляются к значению соответствующего семафора</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Блокировка записей fcntl</TD>
       <TD ALIGN=left VALIGN=top >Блокировки в родительском процессе не наследуются порожденным процессом</TD>
       <TD ALIGN=left VALIGN=top >Блокировки не изменяются до тех пор, пока не закроется дескриптор</TD>
       <TD ALIGN=left VALIGN=top >Все несброшенные блокировки, установленные процессом, снимаются</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Отображение памяти</TD>
       <TD ALIGN=left VALIGN=top >Отображения памяти родительского процесса сохраняются в порожденном</TD>
       <TD ALIGN=left VALIGN=top >Отображения памяти сбрасываются (unmap)</TD>
       <TD ALIGN=left VALIGN=top >Отображения памяти сбрасываются</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Разделяемая память Posix</TD>
       <TD ALIGN=left VALIGN=top >Отображения памяти родительского процесса сохраняются в порожденном</TD>
       <TD ALIGN=left VALIGN=top >Отображения памяти сбрасываются</TD>
       <TD ALIGN=left VALIGN=top >Отображения памяти сбрасываются</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Разделяемая память System V</TD>
       <TD ALIGN=left VALIGN=top >Присоединенные сегменты разделяемой памяти остаются присоединенными в порожденном процессе</TD>
       <TD ALIGN=left VALIGN=top >Присоединенные сегменты разделяемой памяти отсоединяются</TD>
       <TD ALIGN=left VALIGN=top >Присоединенные сегменты разделяемой памяти отсоединяются</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Двери (doors)</TD>
       <TD ALIGN=left VALIGN=top >Порожденный процесс получает копии всех открытых дескрипторов родительского процесса, но только родительский процесс является сервером при активизации дверей через дескрипторы</TD>
       <TD ALIGN=left VALIGN=top >Все дескрипторы дверей должны быть закрыты, потому что они создаются с установленным битом FD_CLOEXEC</TD>
       <TD ALIGN=left VALIGN=top >Все открытые дескрипторы закрываются</TD>
      </TR>
     </TABLE>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label18 style="border:none;"></a>1.6. Обработка ошибок: функции-обертки</P>
     </H1>
     <DIV class=section>
      <P>В любой реальной программе при любом вызове требуется проверка возвращаемого значения на наличие ошибки. Поскольку обычно работа программ при возникновении ошибок завершается, мы можем сократить объем текста, определив функции-обертки (wrapper functions), которые осуществляют собственно вызов функции, проверяют возвращаемое значение и завершают работу при возникновении ошибок. В соответствии с соглашениями имена функций-оберток совпадают с именами самих функций, за исключением первой буквы, которая делается заглавной, например </P>
<!-- SHOWADS bannercount=2 -->
<br><center>
<script type="text/javascript"><!--
google_ad_client = "pub-0321943928525350";
/* 728x90, bookreader */
google_ad_slot = "0629089296";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br></center>

      <P><CODE>Sem_post(ptr);</CODE></P>
      <P>Пример функции-обертки приведен в листинге 1.1<A HREF="#n_1" onmouseover="ShowBookNote('n_1')" onmouseout="HideBookNote('n_1')"><SUP>[1]</SUP></A> </P>
      <H2><a name=label19 style="border:none;"></a>Листинг 1.1. Функция-обертка к функции sem_post</H2>
      <P><CODE>// lib/wrapunix.c</CODE></P>
      <P><CODE>387 void</CODE></P>
      <P><CODE>388 Sem_post(sem_t *sem)</CODE></P>
      <P><CODE>389 {</CODE></P>
      <P><CODE>390  if (sem_post(sem) == –1)</CODE></P>
      <P><CODE>391   err_sys("sem_post error");</CODE></P>
      <P><CODE>392 }</CODE></P>
      <P>Если в тексте вы встретите имя функции, начинающееся с заглавной буквы, знайте: это наша собственная функция-обертка. Она вызывает функцию с тем же именем, начинающимся со строчной буквы. Функция-обертка приводит к завершению работы процесса с выводом сообщения об ошибке, если таковая возникает.</P>
      <P>При описании исходного кода, включенного в книгу, мы всегда говорим о вызываемой функции самого низкого уровня (например, sem_post), а не о функции-обертке (например, Sem_post). Аналогично в алфавитном указателе приведены имена самих функций, а не оберток к ним.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Вышеприведенный формат исходного кода используется во всем тексте. Все непустые строки нумеруются. Текст, описывающий разделы кода, начинается с номеров первой и последней строк на пустом поле слева. Иногда перед абзацем текста присутствует краткий заголовок, набранный полужирным шрифтом, излагающий основное содержание описываемого кода.</P>
       <P>В начале кода указывается имя исходного файла. В данном примере — это файл wrapunix.c в каталоге lib. Поскольку исходный код всех примеров этой книги распространяется свободно (см. предисловие), вы можете легко найти требуемый файл. Компиляция, выполнение и особенно изменение этих программ в процессе чтения книги — лучший способ изучить концепции взаимодействия процессов.</P>
      </DIV>
      <P>Хотя может показаться, что использовать такие функции-обертки не слишком выгодно, вы избавитесь от этого заблуждения в главе 7, где мы обнаружим, что функции для работы с потоками (thread functions) не присваивают значение стандартной переменной Unix errno при возникновении ошибки; вместо этого код ошибки просто возвращается функцией. Это означает, что при вызове функции pthread мы должны каждый раз выделять память под переменную, сохранять в ней возвращаемое функцией значение, а затем устанавливать значение переменной errno равным этой переменной, прежде чем вызывать функцию err_sys (листинг В.4). Чтобы не загромождать текст фигурными скобками, мы используем оператор языка Си «запятая» (comma) и совмещаем присваивание значения переменной errno и вызов err_sys в одном операторе, как в нижеследующем примере:</P>
      <P><CODE>int n;</CODE></P>
      <P><CODE>if ((n = pthread_mutex_lock(&amp;ndone_mutex))!=0) errno=n, err_sys("pthread_mutex_lock error");</CODE></P>
      <P>Альтернативой является определение новой функции обработки ошибок, принимающей код ошибки в качестве аргумента. Однако мы можем сделать этот фрагмент кода гораздо более читаемым, записав</P>
      <P><CODE>Pthread_mutex_lock(&amp;ndone_mutex);</CODE></P>
      <P>где используется наша собственная функция-обертка, приведенная в листинге 1.2.</P>
      <H2><a name=label20 style="border:none;"></a>Листинг 1.2. Реализация обертки к функции pthread_mutex_lock</H2>
      <P><CODE>//lib/wrappthread.c</CODE></P>
      <P><CODE>125 void</CODE></P>
      <P><CODE>126 Pthread_mutex_lock(pthread_mutex_t *mptr)</CODE></P>
      <P><CODE>127 {</CODE></P>
      <P><CODE>128  int n;</CODE></P>
      <P><CODE>129  if ((n=pthread_mutex_lock(mptr))==0)</CODE></P>
      <P><CODE>130   return;</CODE></P>
      <P><CODE>131  errno=n;</CODE></P>
      <P><CODE>132  err_sys("pthread_mutex_lock error");</CODE></P>
      <P><CODE>133 }</CODE></P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Аккуратно используя возможности языка Си, мы могли бы применять макросы вместо функций, что увеличило бы скорость выполнения программ, но эти функции-обертки редко бывают (если вообще бывают) узким местом.</P>
       <P>Наше соглашение о замене первой буквы имени функции на заглавную является компромиссом. Рассматривалось много других форм записи: использование префикса е ([10, с. 182]), суффикса _е и т. д. Наш вариант кажется наименее отвлекающим внимание и одновременно дающим визуальное указание на то, что вызывается какая-то другая функция.</P>
       <P>Этот метод имеет побочное полезное свойство: проверяются ошибки, возвращаемые функциями, код возврата которых обычно игнорируется, например close и pthread_ mutex_lock.</P>
      </DIV>
      <P>Далее в тексте книги мы будем использовать эти функции-обертки, если только не потребуется явно проверить наличие ошибки и обработать ее произвольным образом, отличным от завершения процесса. Мы не приводим в книге исходный код для всех оберток, но он свободно доступен в Интернете (см. предисловие).</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label21 style="border:none;"></a>Значение errno</P>
      </H1>
      <P>При возникновении ошибки в функции Unix глобальной переменной errno присваивается положительное значение, указывающее на тип ошибки; при этом функция обычно возвращает значение –1. Наша функция err_sys выводит соответствующее коду ошибки сообщение (например, Resource temporarily unavailable — ресурс временно недоступен, — если переменная errno имеет значение EAGAIN).</P>
      <P>Функция присваивает значение переменной errno только при возникновении ошибки. В случае нормального завершения работы значение этой переменной не определено. Все положительные значения соответствуют константам с именами из заглавных букв, начинающимися с Е, определяемым обычно в заголовочном файле &lt;sys/errno.h&gt;. Отсутствию ошибок соответствует значение 0. </P>
      <P>При работе с несколькими потоками в каждом из них должна быть собственная переменная errno. Выделение переменной каждому потоку происходит автоматически, однако обычно это требует указания компилятору на то, что должна быть возможность повторного входа в программу. Задается это с помощью ключей –D_REENTRANT или –D_POSIX_C_SOURCE=199506L или аналогичных. Часто в заголовке &lt;errno.h&gt; переменная errno определяется как макрос, раскрываемый в вызов функции, если определена константа _REENTRANT. Функция обеспечивает доступ к копии errno, относящейся к данному потоку.</P>
      <P>Далее в тексте мы используем выражения наподобие «функция mq_send возвращает EMSGSIZE», означающие, что функция возвращает ошибку (обычно возвращаемое значение при этом равно –1) и присваивает переменной errno значение указанной константы.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label22 style="border:none;"></a>1.7. Стандарты Unix</P>
     </H1>
     <DIV class=section>
      <P>В настоящее время стандарты Unix определяются Posix и The Open Group.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label23 style="border:none;"></a>Posix</P>
      </H1>
      <P>Название Posix образовано от «Portable Operating System Interface», что означает приблизительно «интерфейс переносимых операционных систем». Это не один стандарт, а целое семейство, разработанное Институтом инженеров по электротехнике и радиоэлектронике (Institute for Electrical and Electronics Engineers — IEEE). Стандарты Posix были также приняты в качестве международных стандартов ISO (International Organization for Standardization, Международная организация по стандартизации) и IEC (International Electrotechnical Commission, Международная электротехническая комиссия), или ISO/IEC. Стандарты Posix прошли несколько стадий разработки.</P>
      <P>■ Стандарт IEEE 1003.1-1988 (317 страниц) был первым стандартом Posix. Он определял интерфейс взаимодействия языка С с ядром Unix-типа в следующих областях: примитивы для реализации процессов (вызовы fork, exec, сигналы и таймеры), среда процесса (идентификаторы пользователей, группы процессов), файлы и каталоги (все функции ввода-вывода), работа с терминалом, базы данных системы (файлы паролей и групп), форматы архивов tar и cpio.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Первый стандарт Posix вышел в рабочем варианте под названием IEEEIX в 1986 году. Название Posix было предложено Ричардом Штолманом (Richard Stallman). </P>
      </DIV>
      <P>■ Затем вышел стандарт IEЕЕ 1003.1-1990 (356 страниц). Он одновременно являлся и международным стандартом ISO/IEC 9945-1:1990. По сравнению с версией 1988 года изменения в версии 1990 года были минимальными. К заголовку было добавлено: «Part 1: System Application Program Interface (API) [C Language]» («Часть 1: Системный интерфейс разработки программ (API) [Язык С])», и это означало, что стандарт описывал программный интерфейс (API) языка С. </P>
      <P>■ IEEE 1003.2-1992 вышел в двух томах общим объемом около 1300 страниц, и его заголовок содержал строку «Part 2: Shell and Utilities» (Часть 2: «Интерпретатор и утилиты»). Эта часть определяла интерпретатор (основанный на Bourne shell в Unix System V) и около ста утилит (программ, обычно вызываемых из интерпретатора — от awk и basename до vi и уасс). В настоящей книге мы будем ссылаться на этот стандарт под именем Posix. 2.</P>
      <P>■ IEEE 1003.1b-1993 (590 страниц) изначально был известен как IEEE P1003.4. Этот стандарт представлял собой дополнение к стандарту 1003.1-1990 и включал расширения реального времени, разработанные рабочей группой Р1003.4: синхронизацию файлов, асинхронный ввод-вывод, семафоры, управление памятью, планирование выполнения (scheduling), часы, таймеры и очереди сообщений.</P>
      <P>■ IEEE 1003.1, издание 1996 года [8] (743 страницы), включает 1003.1-1990 (базовый интерфейс API), 1003.1b-1993 (расширения реального времени), 1003.1-1995 (Pthreads — программные потоки Posix) и 1003.1i-1995 (технические поправки к 1003.1b). Этот стандарт также называется ISO/IEC 9945-1: 1996. В него были добавлены три главы о потоках и дополнительные разделы, касающиеся синхронизации потоков (взаимные исключения и условные переменные), планирование выполнения потоков, планирование синхронизации. В настоящей книге мы называем этот стандарт Posix.1.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Более четверти из 743 страниц стандарта представляли собой приложение, озаглавленное «Rationale and Notes» («Обоснование и примечания»). Это обоснование содержит историческую информацию и объяснение причин, по которым некоторые функции были или не были включены в стандарт. Часто обоснование оказывается не менее полезным, чем собственно стандарт.</P>
       <P>К сожалению, стандарты IEEE не являются свободно доступными через Интернет. Информация о том, где можно заказать книгу, дана в библиографии под ссылкой [8]. Обратите внимание, что семафоры были определены в стандарте расширений реального времени, отдельно от взаимных исключений и условных переменных (которые были определены в стандарте Pthreads), что объясняет некоторые различия в интерфейсах API этих средств.</P>
       <P>Наконец, заметим, что блокировки чтения-записи не являются частью стандартов Posix. Об этом более подробно рассказано в главе 8. </P>
      </DIV>
      <P>В будущем планируется выход новой версии IEEE 1003.1, включающей стандарт P1003.1g, сетевые интерфейсы (сокеты и XTI), которые описаны в первом томе этой книги.</P>
      <P>В предисловии стандарта Posix.1 1996 года утверждается, что стандарт ISO/IEC 9945 состоит из следующих частей:</P>
      <P>1. Системный интерфейс разработки программ (API) (язык С).</P>
      <P>2. Интерпретатор и утилиты.</P>
      <P>3. Администрирование системы (в разработке).</P>
      <P>Части 1 и 2 представляют собой то, что мы называем Posix.1 и Posix.2. </P>
      <P>Работа над стандартами Posix постоянно продолжается, и авторам книг, с ними связанных, приходится заниматься стрельбой по движущейся мишени. О текущем состоянии стандартов можно узнать на сайте http://www.pasc.org/standing/sd11.html.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label24 style="border:none;"></a>The Open Group</P>
      </H1>
      <P>The Open Group (Открытая группа) была сформирована в 1996 году объединением X/Open Company (основана в 1984 году) и Open Software Foundation (OSF, основан в 1988 году). Эта группа представляет собой международный консорциум производителей и потребителей из промышленности, правительства и образовательных учреждений. Их стандарты тоже выходили в нескольких версиях:</P>
      <P>■ В 1989 году Х/Open опубликовала 3-й выпуск X/Open Portability Guide (Руководство по разработке переносимых программ) — XPG3.</P>
      <P>■ В 1992 году был опубликован четвертый выпуск (Issue 4), а в 1994 году — вторая его версия (Issue 4, Version 2). Последняя известна также под названием Spec 1170, где магическое число 1170 представляет собой сумму количества интерфейсов системы (926), заголовков (70) и команд (174). Есть и еще два названия: X/Open Single Unix Specification (Единая спецификация Unix) и Unix 95.</P>
      <P>■ В марте 1997 года было объявлено о выходе второй версии Единой спецификации Unix. Этот стандарт программного обеспечения называется также Unix 98, и именно так мы ссылаемся на эту спецификацию далее в тексте книги. Количество интерфейсов в Unix 98 возросло с 1170 до 1434, хотя для рабочей станции это количество достигает 3030, поскольку в это число включается CDE (Common Desktop Environment — общее окружение рабочего стола), которое, в свою очередь, требует системы X Window System и пользовательского интерфейса Motif. Подробно об этом написано в книге [9]. Полезную информацию можно также найти по адресу http://www.UNIX-systems.org/version2.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>С этого сайта можно свободно скачать единую спецификацию Unix практически целиком.</P>
      </DIV>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label25 style="border:none;"></a>Версии Unix и переносимость</P>
      </H1>
      <P>Практически все версии Unix, с которыми можно столкнуться сегодня, соответствуют какому-либо варианту стандарта Posix.1 или Posix.2. Мы говорим «какому-либо», потому что после внесения изменений в Posix (например, Добавление расширений реального времени в 1993 и потоков в 1996) производителям обычно требуется год или два, чтобы подогнать свои программы под эти стандарты.</P>
      <P>Исторически большинство систем Unix являются потомками либо BSD, либо System V, но различия между ними постепенно стираются, по мере того как производители переходят к использованию стандартов Posix. Основные различия лежат в области системного администрирования, поскольку ни один стандарт Posix на данный момент не описывает эту область.</P>
      <P>В большинстве примеров этой книги мы использовали операционные системы Solaris 2.6 и Digital Unix 4.0B. Дело в том, что на момент написания книги (конец 1997 — начало 1998 года) только эти две операционные системы поддерживали System V IPC, Posix IPC и программные потоки Posix (Pthreads).</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label26 style="border:none;"></a>1.8. Комментарий к примерам IPC</P>
     </H1>
     <P>Чаще всего для иллюстрации различных функций в книге используются три шаблона (модели) взаимодействия:</P>
     <P>1. Сервер файлов: приложение клиент-сервер, причем клиент посылает серверу запрос с именем файла, а сервер возвращает клиенту его содержимое.</P>
     <P>2. Производитель-потребитель: один или несколько потоков или процессов (производителей) помещают данные в буфер общего пользования, а другие потоки или процессы (потребители) производят с этими данными различные операции.</P>
     <P>3. Увеличение последовательного номера: один или несколько потоков или процессов увеличивают общий для всех индекс. Число это может храниться в файле с общим доступом или в совместно используемой области памяти.</P>
     <P>Первый пример иллюстрирует различные формы передачи сообщений, а других два — разнообразные виды синхронизации и использования разделяемой памяти.</P>
     <P>Таблицы 1.5, 1.6 и 1.7 представляют собой своего рода путеводитель по разрабатываемым нами программам на различные темы, изложенные в книге. В этих таблицах кратко описаны сами программы и указаны номера соответствующих листингов.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label27 style="border:none;"></a>1.9. Резюме</P>
     </H1>
     <P>Взаимодействие процессов традиционно является одной из проблемных областей в Unix. По мере развития системы предлагались различные решения, и ни одно из них не было совершенным. Мы подразделяем IPC на четыре главных типа.</P>
     <P>1. Передача сообщений (каналы, FIFO, очереди сообщений).</P>
     <P>2. Синхронизация (взаимные исключения, условные переменные, блокировки чтения-записи, семафоры).</P>
     <P>3. Разделяемая память (неименованная и именованная).</P>
     <P>4. Вызов процедур (двери в Solaris, RPC Sun).</P>
     <P>Мы рассматриваем взаимодействие как отдельных потоков одного процесса, так и нескольких независимых процессов.</P>
     <P>Живучесть каждого типа IPC определяется либо процессом, либо ядром, либо файловой системой в зависимости от продолжительности его существования. При выборе типа IPC для конкретного применения нужно учитывать его живучесть.</P>
     <P>Другим свойством каждого типа IPC является пространство имен, определяющее идентификацию объектов IPC процессами и потоками, использующими его. Некоторые объекты не имеют имен (каналы, взаимные исключения, условные переменные, блокировки чтения-записи), другие обладают именами в рамках файловой системы (каналы FIFO), третьи характеризуются тем, что в главе 2 названо «именами IPC стандарта Posix», а четвертые — еще одним типом имен, который описан в главе 3 (ключи или идентификаторы IPC стандарта System V). Обычно сервер создает объект IPC с некоторым именем, а клиенты используют это имя для получения доступа к объекту.</P>
     <P>В исходных кодах, приведенных в книге, используются функции-обертки, описанные в разделе 1.6, позволяющие уменьшить объем кода, обеспечивая, тем не менее, проверку возврата ошибки для любой вызываемой функции. Имена всех функций-оберток начинаются с заглавной буквы.</P>
     <P>Стандарты IEEE Posix — Posix.1, определяющий основы интерфейса С в Unix, и Posix.2, определяющий основные команды, — это те стандарты, к которым движутся большинство производителей. Однако стандарты Posix в настоящее время быстро поглощаются (включаются в качестве части) и расширяются коммерческими стандартами, в частности The Open Group (Unix 98).</P>
     <BR>
     <P>Таблица 1.5. Версии модели клиент-сервер  </P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Листинг</TH>
       <TH ALIGN=left VALIGN=top >Описание</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >4.1</TD>
       <TD ALIGN=left VALIGN=top >Два канала между родительским и порожденным процессами</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >4.5</TD>
       <TD ALIGN=left VALIGN=top >Использует popen и cat</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >4.6</TD>
       <TD ALIGN=left VALIGN=top >Использует два канала FIFO между родительским и порожденным процессами</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >4.7</TD>
       <TD ALIGN=left VALIGN=top >Два канала FIFO между независимым сервером и неродственным клиентом</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >4.10</TD>
       <TD ALIGN=left VALIGN=top >Каналы FIFO между независимым последовательным сервером и несколькими клиентами</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >4.12</TD>
       <TD ALIGN=left VALIGN=top >Программный канал или FIFO: формирование записей в потоке байтов</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >6.7</TD>
       <TD ALIGN=left VALIGN=top >Две очереди сообщений System V</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >6.12</TD>
       <TD ALIGN=left VALIGN=top >Одна очередь сообщений System V с несколькими клиентами</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >6.16</TD>
       <TD ALIGN=left VALIGN=top >Одна очередь сообщений System V для каждого клиента; клиентов несколько</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >15.15</TD>
       <TD ALIGN=left VALIGN=top >Передача дескриптора через дверь</TD>
      </TR>
     </TABLE>
     <BR>
     <P>Таблица 1.6. Версии модели производитель-потребитель</P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Листинг</TH>
       <TH ALIGN=left VALIGN=top >Описание</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >7.1</TD>
       <TD ALIGN=left VALIGN=top >Взаимное исключение, несколько производителей, один потребитель</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >7.5</TD>
       <TD ALIGN=left VALIGN=top >Взаимное исключение и условная переменная, несколько производителей, один потребитель</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >10.8</TD>
       <TD ALIGN=left VALIGN=top >Именованные семафоры Posix, один производитель, один потребитель</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >10.11</TD>
       <TD ALIGN=left VALIGN=top >Семафоры Posix в памяти, один производитель, один потребитель</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >10.12</TD>
       <TD ALIGN=left VALIGN=top >Семафоры Posix в памяти, несколько производителей, один потребитель</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >10.15</TD>
       <TD ALIGN=left VALIGN=top >Семафоры Posix в памяти, несколько производителей, несколько потребителей</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >10.18</TD>
       <TD ALIGN=left VALIGN=top >Семафоры Posix в памяти, один производитель, один потребитель: несколько буферов</TD>
      </TR>
     </TABLE>
     <BR>
     <P>Таблица 1.7. Версии программы с увеличением последовательного номера</P>
<!-- SHOWADS bannercount=3 -->
<br><center>
<script type="text/javascript"><!--
google_ad_client = "ca-pub-1271376699634376";
/* 728x90, bookreader */
google_ad_slot = "7890934750";
google_ad_width = 728;
google_ad_height = 90;
google_page_url = "http://www.e-reading.ws/bookreader.php/save/148368/%D0%A1%D1%82%D0%B8%D0%B2%D0%B5%D0%BD%D1%81_-_UNIX%3A_%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2.html";
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br></center>

     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Листинг</TH>
       <TH ALIGN=left VALIGN=top >Описание</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >9.1</TD>
       <TD ALIGN=left VALIGN=top >Индекс в файле, без блокировки</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >9.3</TD>
       <TD ALIGN=left VALIGN=top >Индекс в файле, блокировка с помощью fcntl</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >9.9</TD>
       <TD ALIGN=left VALIGN=top >Индекс в файле, блокировка с использованием функции open</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >10.10</TD>
       <TD ALIGN=left VALIGN=top >Индекс в файле, блокировка с помощью именованного семафора Posix</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >12.2</TD>
       <TD ALIGN=left VALIGN=top >Индекс в общей памяти mmap, блокировка с помощью именованного семафора Posix</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >12.3</TD>
       <TD ALIGN=left VALIGN=top >Индекс в общей памяти mmap, блокировка с помощью семафора Posix в памяти</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >12.4</TD>
       <TD ALIGN=left VALIGN=top >Индекс в неименованной общей памяти 4.4BSD, блокировка с помощью именованного семафора Posix</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >12.5</TD>
       <TD ALIGN=left VALIGN=top >Индекс в общей памяти SVR4 /dev/zero, блокировка с помощью именованного семафора Posix</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >13.6</TD>
       <TD ALIGN=left VALIGN=top >Индекс в общей памяти Posix, блокировка с помощью семафора Posix в памяти</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >А.19</TD>
       <TD ALIGN=left VALIGN=top >Измерение производительности: блокировка взаимным исключением между потоками</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >А.22</TD>
       <TD ALIGN=left VALIGN=top >Измерение производительности: блокировка чтения-записи между потоками</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >А.23</TD>
       <TD ALIGN=left VALIGN=top >Измерение производительности: блокировка между потоками с помощью семафоров Posix в памяти</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >А.25</TD>
       <TD ALIGN=left VALIGN=top >Измерение производительности: блокировка между потоками с помощью именованных семафоров Posix</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >А.28</TD>
       <TD ALIGN=left VALIGN=top >Измерение производительности: блокировка между потоками с помощью семафоров System V</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >А.29</TD>
       <TD ALIGN=left VALIGN=top >Измерение производительности: блокировка между потоками с помощью fcntl</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >А.33</TD>
       <TD ALIGN=left VALIGN=top >Измерение производительности: блокировка между процессами с помощью взаимных исключений</TD>
      </TR>
     </TABLE>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label28 style="border:none;"></a>Упражнения</P>
     </H1>
     <P>1. На рис 1.1 изображены два процесса, обращающиеся к одному файлу. Если оба процесса только дописывают данные к концу файла (возможно, длинного), какой нужен будет тип синхронизации?</P>
     <P>2. Изучите заголовочный файл &lt;errno.h&gt; в вашей системе и выясните, как определена errno.</P>
     <P>3. Дополните табл. 1.3 используемыми вами функциями, поддерживаемыми Unix-системами.</P>
    </DIV>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label29 style="border:none;"></a>ГЛАВА 2</P>
     <P>Posix IPC</P>
    </H1>
    <DIV class=section>
     <H1>
      <P><a name=label30 style="border:none;"></a>2.1. Введение</P>
     </H1>
     <P>Из имеющихся типов IPC следующие три могут быть отнесены к Posix IPC, то есть к методам взаимодействия процессов, соответствующим стандарту Posix:</P>
     <P>■ очереди сообщений Posix (глава 5);</P>
     <P>■ семафоры Posix (глава 10);</P>
     <P>■ разделяемая память Posix (глава 13).</P>
     <P>Эти три вида IPC обладают общими свойствами, и для работы с ними используются похожие функции. В этой главе речь пойдет об общих требованиях к полным именам файлов, используемых в качестве идентификаторов, о флагах, указываемых при открытии или создании объектов IPC, и о разрешениях на доступ к ним.</P>
     <P>Полный список функций, используемых для работы с данными типами IPC, приведен в табл. 2.1.</P>
     <BR>
     <P>Таблица 2.1. Функции Posix IPC</P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top ></TH>
       <TH ALIGN=left VALIGN=top >Очереди сообщений</TH>
       <TH ALIGN=left VALIGN=top >Семафоры</TH>
       <TH ALIGN=left VALIGN=top >Общая память</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Заголовочный файл</TD>
       <TD ALIGN=left VALIGN=top >&lt;mqueue.h&gt;</TD>
       <TD ALIGN=left VALIGN=top >&lt;semaphore.h&gt;</TD>
       <TD ALIGN=left VALIGN=top >&lt;sys/mman.h&gt;</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Функции для создания, открытия и удаления</TD>
       <TD ALIGN=left VALIGN=top >mq_open mq_close mq_unlink</TD>
       <TD ALIGN=left VALIGN=top >sem_open sem_close sem_unlink sem_init sem_destroy</TD>
       <TD ALIGN=left VALIGN=top >shm_open shm_unlink</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Операции управления</TD>
       <TD ALIGN=left VALIGN=top >mq_getattr mq_setattr</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top >ftruncate fstat</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Операции IPC</TD>
       <TD ALIGN=left VALIGN=top >mq_send mq_receive mq_notify</TD>
       <TD ALIGN=left VALIGN=top >sem_wait sem_trywait sem_post sem_getvalue</TD>
       <TD ALIGN=left VALIGN=top >mmap munmap</TD>
      </TR>
     </TABLE>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label31 style="border:none;"></a>2.2. Имена IPC</P>
     </H1>
     <DIV class=section>
      <P>В табл. 1.2 мы отметили, что три типа IPC стандарта Posix имеют идентификаторы (имена), соответствующие этому стандарту. Имя IPC передается в качестве первого аргумента одной из трех функций: mq_open, sem_open и shm_open, причем оно не обязательно должно соответствовать реальному файлу в файловой системе. Стандарт Posix.1 накладывает на имена IPC следующие ограничения:</P>
      <P>■ Имя должно соответствовать существующим требованиям к именам файлов (не превышать в длину РАТНМАХ байтов, включая завершающий символ с кодом 0).</P>
      <P>■ Если имя начинается со слэша (/), вызов любой из этих функций приведет к обращению к одной и той же очереди. В противном случае результат зависит от реализации.</P>
      <P>■ Интерпретация дополнительных слэшей в имени зависит от реализации.</P>
      <P>Таким образом, для лучшей переносимости имена должны начинаться со слэша (/) и не содержать в себе дополнительных слэшей. К сожалению, эти правила, в свою очередь, приводят к проблемам с переносимостью.</P>
      <P>В системе Solaris 2.6 требуется наличие начального слэша и запрещается использование дополнительных. Для очереди сообщений, например, при этом создаются три файла в каталоге /tmp, причем имена этих файлов начинаются с .MQ. Например, если аргумент функции mq_open имеет вид /queue.1234, то созданные файлы будут иметь имена /tmp/.MQDqueue.1234, /tmp/.MQLqueue.1234 и /tmp/.MQPqueue.1234. В то же время в системе Digital Unix 4.0B просто создается файл с указанным при вызове функции именем.</P>
      <P>Проблема с переносимостью возникает при указании имени с единственным слэшем в начале: при этом нам нужно иметь разрешение на запись в корневой каталог. Например, очередь с именем /tmp.1234 допустима стандартом Posix и не вызовет проблем в системе Solaris, но в Digital Unix возникнет ошибка создания файла, если разрешения на запись в корневой каталогу программы нет. Если мы укажем имя /tmp/test.1234, проблемы в Digital Unix и аналогичных системах, создающих файл с указанным именем, пропадут (предполагается существование каталога /tmp и наличие у программы разрешения на запись в него, что обычно для большинства систем Unix), однако в Solaris использование этого имени будет невозможно.</P>
      <P>Для решения подобных проблем с переносимостью следует определять имя в заголовке с помощью директивы #define, чтобы обеспечить легкость его изменения при переносе программы в другую систему.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Разработчики стремились разрешить использование очередей сообщений, семафоров и разделяемой памяти для существующих ядер Unix и в независимых бездисковых системах. Это тот случай, когда стандарт получается чересчур общим и в результате вызывает проблемы с переносимостью. В отношении Posix это называется «как стандарт становится нестандартным».</P>
      </DIV>
      <P>Стандарт Posix.1 определяет три макроса:</P>
      <P><CODE>S_TYPEISMQ(<EM>buf</EM>)</CODE></P>
      <P><CODE>S_TYPEISSEM(<EM>buf</EM>)</CODE></P>
      <P><CODE>S_TYPEISSHM(<EM>buf</EM>)</CODE></P>
      <P>которые принимают единственный аргумент — указатель на структуру типа stat, содержимое которой задается функциями fstat, lstat и stat. Эти три макроса возвращают ненулевое значение, если указанный объект IPC (очередь сообщений, семафор или сегмент разделяемой памяти) реализован как особый вид файла и структура stat ссылается на этот тип. В противном случае макрос возвращает 0.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>К сожалению, проку от этих макросов мало, потому что нет никаких гарантий, что эти типы IPC реализованы как отдельные виды файлов. Например, в Solaris 2.6 все три макроса всегда возвращают 0.</P>
       <P>Все прочие макросы, используемые для проверки типа файла, имеют имена, начинающиеся с S_IS, и принимают всегда единственный аргумент: поле st_mode структуры stat. Поскольку макросы, используемые для проверки типа IPC, принимают аргументы другого типа, их имена начинаются с S_TYPEIS. </P>
      </DIV>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label32 style="border:none;"></a>Функция px_ipc_name</P>
      </H1>
      <P>Существует и другое решение упомянутой проблемы с переносимостью. Можно определить нашу собственную функцию px_ipc_name, которая добавляет требуемый каталог в качестве префикса к имени Posix IPC.</P>
      <P><CODE>#include "unpipc.h"</CODE></P>
      <P><CODE>char *px_ipc_name(const char <EM>*name</EM>);</CODE></P>
      <P><CODE>/* Возвращает указатель при успешном завершении, NULL при возникновении ошибки */</CODE></P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Так выглядят листинги наших собственных функций, то есть функций, не являющихся стандартными системными. Обычно включается заголовочный файл unpipc.h (листинг B.1).</P>
      </DIV>
      <P>Аргумент <EM>пате </EM>(имя) не должен содержать слэшей. Тогда, например, при вызове px_ipc_name("test1") будет возвращен указатель на строку /test1 в Solaris 2.6 или на строку /tmp/test1 в Digital Unix 4.0B. Память для возвращаемой строки выделяется динамически и освобождается вызовом free. Можно установить произвольное значение переменной окружения PX_IPC_NAME, чтобы задать другой каталог по умолчанию.</P>
      <P>В листинге 2.1<A HREF="#n_1" onmouseover="ShowBookNote('n_1')" onmouseout="HideBookNote('n_1')"><SUP>[1]</SUP></A> приведен наш вариант реализации этой функции.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Возможно, в этом листинге вы в первый раз встретитесь с функцией snprintf. Значительная часть существующих программ используют вместо нее функцию sprintf, однако последняя не производит проверки переполнения приемного буфера. В отличие от нее snprintf получает в качестве второго аргумента размер приемного буфера и впоследствии предотвращает его переполнение. Умышленное переполнение буфера программы, использующей sprintf, в течение многих лет использовалось хакерами для взлома систем.</P>
       <P>Функция snprintf еще не является частью стандарта ANSI С, но планируется ее включение в обновленный стандарт, называющийся С9Х. Тем не менее многие производители включают ее в стандартную библиотеку С. Везде в тексте мы используем функцию snprintf в нашем собственном варианте, обеспечивающем вызов sprintf, если в системной библиотеке функция snprinft отсутствует. </P>
      </DIV>
      <H2><a name=label33 style="border:none;"></a>Листинг 2.1. Функция px_ipc_name в нашей реализации.</H2>
      <P><CODE>//lib/px_ipc_name.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  char *</CODE></P>
      <P><CODE>3  px_ipc_name(const char *name)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   char *dir, *dst, *slash;</CODE></P>
      <P><CODE>6   if ((dst = malloc(РАТН_МАХ)) == NULL)</CODE></P>
      <P><CODE>7    return(NULL);</CODE></P>
      <P><CODE>8   /* есть возможность задать другое имя каталога с помощью переменной окружения */</CODE></P>
      <P><CODE>9   if ((dir = getenv("PX IPC_NAME")) == NULL) {</CODE></P>
      <P><CODE>10 #ifdef POSIX_IPC_PREFIX</CODE></P>
      <P><CODE>11   dir = POSIX_IPC_PREFIX; /* из "config.h" */</CODE></P>
      <P><CODE>12 #else</CODE></P>
      <P><CODE>13   dir = "/tmp/"; /* по умолчанию */</CODE></P>
      <P><CODE>14 #endif</CODE></P>
      <P><CODE>15  }</CODE></P>
      <P><CODE>16  /* имя каталога должно заканчиваться символом '/' */</CODE></P>
      <P><CODE>17  slash = (dir[strlen(dir) – 1] == '/') ? "" : "/";</CODE></P>
      <P><CODE>18  snprintf(dst, PATH_MAX, "%s%s%s", dir, slash, name);</CODE></P>
      <P><CODE>19  return(dst); /* для освобождения этого указателя можно вызвать free() */</CODE></P>
      <P><CODE>20 }</CODE></P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label34 style="border:none;"></a>2.3. Создание и открытие каналов IPC</P>
     </H1>
     <P>Все три функции, используемые для создания или открытия объектов IPC: mq_open, sem_open и shm_open, — принимают специальный флаг <EM>oflag</EM> в качестве второго аргумента. Он определяет параметры открытия запрашиваемого объекта аналогично второму аргументу стандартной функции open. Все константы, из которых можно формировать этот аргумент, приведены в табл. 2.2.</P>
     <BR>
     <P>Таблица 2.2. Константы, используемые при создании и открытии объектов IPC </P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Описание</TH>
       <TH ALIGN=left VALIGN=top >mq_open</TH>
       <TH ALIGN=left VALIGN=top >sem_open</TH>
       <TH ALIGN=left VALIGN=top >shm_open</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Только чтение</TD>
       <TD ALIGN=left VALIGN=top >О_RDONLY</TD>
       <TD ALIGN=left VALIGN=top > </TD>
       <TD ALIGN=left VALIGN=top >О_RDONLY</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Только запись</TD>
       <TD ALIGN=left VALIGN=top >О_WRONLY</TD>
       <TD ALIGN=left VALIGN=top > </TD>
       <TD ALIGN=left VALIGN=top > </TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Чтение и запись</TD>
       <TD ALIGN=left VALIGN=top >О_RDWR</TD>
       <TD ALIGN=left VALIGN=top > </TD>
       <TD ALIGN=left VALIGN=top >О_RDWR</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Создать, если не существует</TD>
       <TD ALIGN=left VALIGN=top >О_CREAT</TD>
       <TD ALIGN=left VALIGN=top >О_CREAT</TD>
       <TD ALIGN=left VALIGN=top >О_CREAT</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Исключающее создание</TD>
       <TD ALIGN=left VALIGN=top >О_EXCL</TD>
       <TD ALIGN=left VALIGN=top >О_EXCL</TD>
       <TD ALIGN=left VALIGN=top >О_EXCL</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Без блокировки</TD>
       <TD ALIGN=left VALIGN=top >О_NONBLOCK</TD>
       <TD ALIGN=left VALIGN=top > </TD>
       <TD ALIGN=left VALIGN=top > </TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Сократить (truncate) существующий</TD>
       <TD ALIGN=left VALIGN=top > </TD>
       <TD ALIGN=left VALIGN=top > </TD>
       <TD ALIGN=left VALIGN=top >O_TRUNC </TD>
      </TR>
     </TABLE>
     <P>Первые три строки описывают тип доступа к создаваемому объекту: только чтение, только запись, чтение и запись. Очередь сообщений может быть открыта в любом из трех режимов доступа, тогда как для семафора указание этих констант не требуется (для любой операции с семафором требуется доступ на чтение и запись). Наконец, объект разделяемой памяти не может быть открыт только на запись.</P>
     <P>Указание прочих флагов из табл. 2.2 не является обязательным.</P>
     <P>O_CREAT — создание очереди сообщений, семафора или сегмента разделяемой памяти, если таковой еще не существует (см. также флаг O_EXCL, влияющий на результат).</P>
     <P>При создании новой очереди сообщений, семафора или сегмента разделяемой памяти требуется указание по крайней мере одного дополнительного аргумента, определяющего режим. Этот аргумент указывает биты разрешения на доступ к файлу и формируется путем побитового логического сложения констант из табл. 2.3.</P>
     <BR>
     <P>Таблица 2.3. Константы режима доступа при создании нового объекта IPC </P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Константа</TH>
       <TH ALIGN=left VALIGN=top >Описание</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >S_IRUSR</TD>
       <TD ALIGN=left VALIGN=top >Владелец — чтение</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >S_IWUSR</TD>
       <TD ALIGN=left VALIGN=top >Владелец — запись</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >S_IRGRP</TD>
       <TD ALIGN=left VALIGN=top >Группа — чтение</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >S_IWGRP</TD>
       <TD ALIGN=left VALIGN=top >Группа — запись</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >S_IROTH</TD>
       <TD ALIGN=left VALIGN=top >Прочие — чтение</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >S_IWOTH</TD>
       <TD ALIGN=left VALIGN=top >Прочие — запись </TD>
      </TR>
     </TABLE>
     <P>Эти константы определены в заголовке &lt;sys/stat.h&gt;. Указанные биты разрешений изменяются наложением маски режима создания файлов для данного процесса (с. 83-85 [21]) или с помощью команды интерпретатора umask.</P>
     <P>Как и со вновь созданным файлом, при создании очереди сообщений, семафора или сегмента разделяемой памяти им присваивается идентификатор пользователя, соответствующий действующему (effective) идентификатору пользователя процесса. Идентификатор группы семафора или сегмента разделяемой памяти устанавливается равным действующему групповому идентификатору процесса или групповому идентификатору, установленному по умолчанию для системы в целом. Групповой идентификатор очереди сообщений всегда устанавливается равным действующему групповому идентификатору процесса (на с. 77-78 [21] рассказывается о групповых и пользовательских идентификаторах более подробно).</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Кажется странным наличие разницы в установке группового идентификатора для разных видов Posix IPC. Групповой идентификатор нового файла, создаваемого с помощью функции open, устанавливается равным либо действительному идентификатору группы процесса, либо идентификатору группы каталога, в котором создается файл, но функции IPC не могут заранее предполагать, что для объекта IPC создается реальный файл в файловой системе.</P>
     </DIV>
     <P>O_EXCL — если этот флаг указан одновременно с O_CREAT, функция создает новую очередь сообщений, семафор или объект разделяемой памяти только в том случае, если таковой не существует. Если объект уже существует и указаны флаги O_CREAT | O_EXCL, возвращается ошибка EEXIST.</P>
     <P>Проверка существования очереди сообщений, семафора или сегмента разделяемой памяти и его создание (в случае отсутствия) должны производиться только одним процессом. Два аналогичных флага имеются и в System V IPC, они описаны в разделе 3.4.</P>
     <P>O_NONBLOCK — этот флаг создает очередь сообщений без блокировки. Блокировка обычно устанавливается для считывания из пустой очереди или записи в полную очередь. Об этом более подробно рассказано в подразделах, посвященных функциям mq_send и mq_receive раздела 5.4.</P>
     <P>O_TRUNC — если уже существующий сегмент общей памяти открыт на чтение и запись, этот флаг указывает на необходимость сократить его размер до 0.</P>
     <P>На рис. 2.1 показана реальная последовательность логических операций при открытии объекта IPC. Что именно подразумевается под проверкой разрешений доступа, вы узнаете в разделе 2.4. Другой подход к изображенному на рис. 2.1 представлен в табл. 2.4. </P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader40" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 2.1. Логика открытия объекта IPC</P>
     <BR>
     <P>Обратите внимание, что в средней строке табл. 2.4, где задан только флаг O_CREAT, мы не получаем никакой информации о том, был ли создан новый объект или открыт существующий.</P>
     <BR>
     <P>Таблица 2.4. Логика открытия объекта IPC </P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Аргумент oflag</TH>
       <TH ALIGN=left VALIGN=top >Объект не существует</TH>
       <TH ALIGN=left VALIGN=top >Объект уже существует</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Нет специальных флагов</TD>
       <TD ALIGN=left VALIGN=top >Ошибка, errno=ENOENT</TD>
       <TD ALIGN=left VALIGN=top >OK, открывается существующий объект</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >O_CREAT</TD>
       <TD ALIGN=left VALIGN=top >OK, создается новый объект</TD>
       <TD ALIGN=left VALIGN=top >OK, открывается существующий объект</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >O_CREAT|O_EXCL</TD>
       <TD ALIGN=left VALIGN=top >OK, создается новый объект</TD>
       <TD ALIGN=left VALIGN=top >Ошибка, errno=EEXIST </TD>
      </TR>
     </TABLE>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label35 style="border:none;"></a>2.4. Разрешения IPC</P>
     </H1>
     <P>Новая очередь сообщений, именованный семафор или сегмент разделяемой памяти создается функциями mq_open, sem_open и shm_open, при условии, что аргумент <EM>oflag</EM> содержит константу O_CREAT. Согласно табл. 2.3, любому из данных типов IPC присваиваются определенные права доступа (permissions), аналогичные разрешениям доступа к файлам в Unix.</P>
     <P>При открытии существующей очереди сообщений, семафора или сегмента разделяемой памяти теми же функциями (в случае, когда не указан флаг O_CREAT или указан O_CREAT без O_EXCL и объект уже существует) производится проверка разрешений:</P>
     <P>1. Проверяются биты разрешений, присвоенные объекту IPC при создании.</P>
     <P>2. Проверяется запрошенный тип доступа (O_RDONLY, O_WRONLY, O_RDWR).</P>
     <P>3. Проверяется действующий идентификатор пользователя вызывающего процесса, действующий групповой идентификатор процесса и дополнительные групповые идентификаторы процесса (последние могут не поддерживаться).</P>
     <P>Большинством систем Unix производятся следующие конкретные проверки:</P>
     <P>1. Если действующий идентификатор пользователя для процесса есть 0 (привилегированный пользователь), доступ будет разрешен.</P>
     <P>2. Если действующий идентификатор пользователя процесса совпадает с идентификатором владельца объекта IPC: если соответствующий бит разрешения для пользователя установлен, доступ разрешен, иначе в доступе отказывается.</P>
     <P>Под соответствующим битом разрешения мы подразумеваем, например, бит разрешения на чтение, если процесс открывает объект только для чтения. Если процесс открывает объект для записи, должен быть установлен соответственно бит разрешения на запись для владельца (user-write).</P>
     <P>3. Если действующий идентификатор группы процесса или один из дополнительных групповых идентификаторов процесса совпадает с групповым идентификатором объекта IPC: если соответствующий бит разрешения для группы установлен, доступ будет разрешен, иначе в доступе отказывается.</P>
     <P>4. Если соответствующий бит разрешения доступа для прочих пользователей установлен, доступ будет разрешен, иначе в доступе будет отказано. </P>
     <P>Эти четыре проверки производятся в указанном порядке. Следовательно, если процесс является владельцем объекта IPC (шаг 2), доступ разрешается или запрещается на основе одних только разрешений пользователя (владельца). Разрешения группы при этом не проверяются. Аналогично, если процесс не является владельцем объекта IPC, но принадлежит к нужной группе, доступ разрешается или запрещается на основе разрешений группы — разрешения для прочих пользователей при этом не проверяются.</P>
<!-- SHOWADS bannercount=4 -->
<br><center>
<script type="text/javascript"><!--
google_ad_client = "pub-0321943928525350";
/* 728x90, bookreader */
google_ad_slot = "0629089296";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br></center>

     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Согласно табл. 2.2, функция sem_open не использует флаги O_RDONLY, O_WRONLY, O_RDWR. В разделе 10.2, однако, будет сказано о том, что некоторые реализации Unix подразумевают наличие флага O_RDWR, потому что любое обращение к семафору подразумевает чтение и запись его значения.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label36 style="border:none;"></a>2.5. Резюме</P>
     </H1>
     <P>Три типа Posix IPC — очереди сообщений, семафоры и разделяемая память — идентифицируются их полными именами. Они могут являться или не являться реальными именами файлов в файловой системе, и это вызывает проблемы с переносимостью. Решение проблемы — использовать собственную функцию px_ipc_name. При создании или открытии объекта IPC требуется указать набор флагов, аналогичных указываемым при использовании функции open. При создании нового объекта IPC требуется указать разрешения для него, используя те же константы S_xxx, что и для функции open (табл. 2.3). При открытии существующего объекта IPC производится проверка разрешений процесса, аналогичная проверке при открытии файла.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label37 style="border:none;"></a>Упражнения</P>
     </H1>
     <P>1. Каким образом биты установки идентификатора пользователя (set-user-ID, SUID) и установки идентификатора группы (set-group-ID) (раздел 4.4 [21]) программы, использующей Posix IPC, влияют на проверку разрешений, описанную в разделе 2.4?</P>
     <P>2. Когда программа открывает объект IPC, как она может определить, был ли создан новый объект IPC или производится обращение к существующему объекту? </P>
    </DIV>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label38 style="border:none;"></a>ГЛАВА 3</P>
     <P>System V IPC</P>
    </H1>
    <DIV class=section>
     <H1>
      <P><a name=label39 style="border:none;"></a>3.1. Введение</P>
     </H1>
     <P>Из имеющихся типов IPC следующие три могут быть отнесены к System V IPC, то есть к методам взаимодействия процессов, соответствующим стандарту System V:</P>
     <P>■ очереди сообщений System V (глава 6);</P>
     <P>■ семафоры System V (глава 11);</P>
     <P>■ общая память System V (глава 14).</P>
     <P>Термин «System V IPC» говорит о происхождении этих средств: впервые они появились в Unix System V. У них много общего: схожи функции, с помощью которых организуется доступ к объектам; также схожи формы хранения информации в ядре. В этой главе описываются общие для трех типов IPC черты.</P>
     <P>Информация о функциях сведена в табл. 3.1.</P>
     <BR>
     <P>Таблица 3.1. Функции System V IPC</P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Очереди сообщений</TH>
       <TH ALIGN=left VALIGN=top >Семафоры</TH>
       <TH ALIGN=left VALIGN=top >Общая память</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Заголовочный файл</TD>
       <TD ALIGN=left VALIGN=top >&lt;sys/msg.h&gt;</TD>
       <TD ALIGN=left VALIGN=top >&lt;sys/sem.h&gt;</TD>
       <TD ALIGN=left VALIGN=top >&lt;sys/shm.h&gt;</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Создание или открытие</TD>
       <TD ALIGN=left VALIGN=top >msgget</TD>
       <TD ALIGN=left VALIGN=top >semget</TD>
       <TD ALIGN=left VALIGN=top >shmget</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Операции управления</TD>
       <TD ALIGN=left VALIGN=top >msgctl</TD>
       <TD ALIGN=left VALIGN=top >semctl</TD>
       <TD ALIGN=left VALIGN=top >shmctl</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Операции IPC</TD>
       <TD ALIGN=left VALIGN=top >msgsnd msgrcv</TD>
       <TD ALIGN=left VALIGN=top >semop</TD>
       <TD ALIGN=left VALIGN=top >shmat shmdt</TD>
      </TR>
     </TABLE>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Информация об истории разработки и развития функций System V IPC не слишком легко доступна. [16] предоставляет следующую информацию: очереди сообщений, семафоры и разделяемая память этого типа были разработаны в конце 70-х в одном из филиалов Bell Laboratories в городе Колумбус, штат Огайо, для одной из версий Unix, предназначенной для внутреннего использования. Версия эта называлась Columbus Unix, или CB Unix. Она использовалась в так называемых системах поддержки операций — системах обработки транзакций — для автоматизации управления и ведения записей в телефонной компании. System V IPC были добавлены в коммерческую версию Unix System V. приблизительно в 1983 году.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label40 style="border:none;"></a>3.2. Ключи типа key_t и функция ftok</P>
     </H1>
     <DIV class=section>
      <P>В табл. 1.2 было отмечено, что в именах трех типов System V IPC использовались значения key_t. Заголовочный файл &lt;sys/types.h&gt; определяет тип key_t как целое (по меньшей мере 32-разрядное). Значения переменным этого типа обычно присваиваются функцией ftok.</P>
      <P>Функция ftok преобразовывает существующее полное имя и целочисленный идентификатор в значение типа key_t (называемое ключом IPC — IPC key):</P>
      <P><CODE>#include &lt;sys/ipc.h&gt;</CODE></P>
      <P><CODE>key_t ftok(const char <EM>*pathname,</EM> int <EM>id</EM>);</CODE></P>
      <P><CODE>//Возвращает ключ IPC либо –1 при возникновении ошибки</CODE></P>
      <P>На самом деле функция использует полное имя файла и младшие 8 бит идентификатора для формирования целочисленного ключа IPC.</P>
      <P>Эта функция действует в предположении, что для конкретного приложения, использующего IPC, клиент и сервер используют одно и то же полное имя объекта IPC, имеющее какое-то значение в контексте приложения. Это может быть имя демона сервера или имя файла данных, используемого сервером, или имя еще какого-нибудь объекта файловой системы. Если клиенту и серверу для связи требуется только один канал IPC, идентификатору можно присвоить, например, значение 1. Если требуется несколько каналов IPC (например, один от сервера к клиенту и один в обратную сторону), идентификаторы должны иметь разные значения: например, 1 и 2. После того как клиент и сервер договорятся о полном имени и идентификаторе, они оба вызывают функцию ftok для получения одинакового ключа IPC.</P>
      <P>Большинство реализаций ftok вызывают функцию stat, а затем объединяют:</P>
      <P>■ информацию о файловой системе, к которой относится полное имя <EM>pathname</EM> (поле st_dev структуры stat);</P>
      <P>■ номер узла (i-node) в файловой системе (поле st_ino структуры stat);</P>
      <P>■ младшие 8 бит идентификатора (который не должен равняться нулю).</P>
      <P>Из комбинации этих трех значений обычно получается 32-разрядный ключ. Нет никакой гарантии того, что для двух различных путей с одним и тем же идентификатором получатся разные ключи, поскольку количество бит информации в трех перечисленных элементах (идентификатор файловой системы, номер узла, идентификатор IPC) может превышать число бит в целом (см. упражнение 3.5).</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Номер узла всегда отличен от нуля, поэтому большинство реализаций определяют константу IPC_PRIVATE (раздел 3.4) равной нулю.</P>
      </DIV>
      <P>Если указанное полное имя не существует или недоступно вызывающему процессу, ftok возвращает значение –1. Помните, что файл, имя которого используется для вычисления ключа, не должен быть одним из тех, которые создаются и удаляются сервером в процессе работы, поскольку каждый раз при создании заново эти файлы получают, вообще говоря, другой номер узла, а это может изменить ключ, возвращаемый функцией ftok при очередном вызове.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label41 style="border:none;"></a>Пример</P>
      </H1>
      <P>Программа в листинге 3.1 принимает полное имя в качестве аргумента командной строки, вызывает функции stat и ftok, затем выводит значения полей st_dev и st_ino структуры stat и получающийся ключ IPC. Эти три значения выводятся в шестнадцатеричном формате, поэтому легко видеть, как именно ключ IPC формируется из этих двух значений и идентификатора 0x57.</P>
      <H2><a name=label42 style="border:none;"></a>Листинг 3.1<A HREF="#n_1" onmouseover="ShowBookNote('n_1')" onmouseout="HideBookNote('n_1')"><SUP>[1]</SUP></A>. Получение и вывод информации о файле и созданного ключа IPC</H2>
      <P><CODE>//svipc/ftok.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   struct stat stat;</CODE></P>
      <P><CODE>6   if (argc != 2)</CODE></P>
      <P><CODE>7    err_quit("usage: ftok &lt;pathname&gt;");</CODE></P>
      <P><CODE>8   Stat(argv[1], &amp;stat);</CODE></P>
      <P><CODE>9   printf("st_dev: &amp;lx, st_ino: %Ix, key: %x\n",</CODE></P>
      <P><CODE>10   (u_long) stat.st_dev, (u_long) stat.st_ino,</CODE></P>
      <P><CODE>11   Ftok(argv[1], 0x57));</CODE></P>
      <P><CODE>12  exit(0);</CODE></P>
      <P><CODE>13 }</CODE></P>
      <P>Выполнение этой программы в системе Solaris 2.6 приведет к следующим результатам:</P>
      <P><CODE>solaris %<STRONG>ftok /etc/system</STRONG></CODE></P>
      <P><CODE>st_dev: 800018, st_ino: 4a1b, key: 57018a1b</CODE></P>
      <P><CODE>solaris %<STRONG>ftok /usr/tmp</STRONG></CODE></P>
      <P><CODE>st_dev: 800015, st_ino: 10b78, key: 57015b78</CODE></P>
      <P><CODE>solaris %<STRONG>ftok /home/rstevens/Mail.out</STRONG></CODE></P>
      <P><CODE>st_dev: 80001f, st_ino: 3b03, key: 5702fb03</CODE></P>
      <P>Очевидно, идентификатор определяет старшие 8 бит ключа; младшие 12 бит st_dev определяют следующие 12 бит ключа, и наконец, младшие 12 бит st_ino определяют младшие 12 бит ключа.</P>
      <P>Цель этого примера не в том, чтобы впоследствии рассчитывать на такой способ формирования ключа из перечисленной информации, а в том, чтобы проиллюстрировать алгоритм комбинации полного имени и идентификатора конкретной реализацией. В других реализациях алгоритм может быть другим.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>В FreeBSD используются младшие 8 бит идентификатора, младшие 8 бит st_dev и младшие 16 бит st_ino.</P>
       <P>Учтите, что отображение, производимое функцией ftok, — одностороннее, поскольку часть бит st_dev и st_ino не используются. По данному ключу нельзя определить полное имя файла, заданное для вычислений.</P>
      </DIV>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label43 style="border:none;"></a>3.3. Структура ipc_perm</P>
     </H1>
     <P>Для каждого объекта IPC, как для обычного файла, в ядре хранится набор информации, объединенной в структуру.</P>
     <P><CODE>struct ipc_perm {</CODE></P>
     <P><CODE> uid_t uid; /*идентификатор пользователя владельца*/</CODE></P>
     <P><CODE> gid_t gid; /*идентификатор группы владельца */</CODE></P>
     <P><CODE> uid_t cuid; /*идентификатор пользователя создателя*/</CODE></P>
     <P><CODE> gid_t cgid; /*идентификатор группы создателя*/</CODE></P>
     <P><CODE> mode_t mode; /*разрешения чтения-записи*/</CODE></P>
     <P><CODE> ulong_t seq; /*последовательный номер канала*/</CODE></P>
     <P><CODE> key_t key; /* ключ IPC */</CODE></P>
     <P><CODE>}</CODE></P>
     <P>Эта структура вместе с другими переименованными константами для функций System V IPC определена в файле &lt;sys/ipc.h&gt;. В этой главе мы расскажем о полях структуры ipc_perm более подробно.</P>
     <BR>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label44 style="border:none;"></a>3.4. Создание и открытие каналов IPC</P>
     </H1>
     <P>Три функции getXXX, используемые для создания или открытия объектов IPC (табл. 3.1), принимают ключ IPC (типа key_t) в качестве одного из аргументов и возвращают целочисленный идентификатор. Этот идентификатор отличается от того, который передавался функции ftok, как мы вскоре увидим. У приложения есть две возможности задания ключа (первого аргумента функций getXXX):</P>
     <P>1. Вызвать ftok, передать ей полное имя и идентификатор.</P>
     <P>2. Указать в качестве ключа константу IPCPRIVATE, гарантирующую создание нового уникального объекта IPC.</P>
     <P>Последовательность действий иллюстрирует рис. 3.1. </P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader48" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 3.1. Вычисление идентификаторов IPC по ключам</P>
     <BR>
     <P>Все три функции getXXX (табл. 3.1) принимают в качестве второго аргумента набор флагов <EM>oflag,</EM> задающий биты разрешений чтения-записи (поле mode структуры ipc_perm) для объекта IPC и определяющий, создается ли новый объект IPC или производится обращение к уже существующему. Для этого имеются следующие правила.</P>
     <P>■ Ключ IPC_PRIVATE гарантирует создание уникального объекта IPC. Никакие возможные комбинации полного имени и идентификатора не могут привести к тому, что функция ftok вернет в качестве ключа значение IPC_PRIVATE.</P>
     <P>■ Установка бита IPC_CREAT аргумента <EM>oflag</EM> приводит к созданию новой записи для указанного ключа, если она еще не существует. Если же обнаруживается существующая запись, возвращается ее идентификатор. </P>
     <P>Одновременная установка битов IPC_CREAT и IPC_EXCL аргумента <EM>oflag </EM>приводит к созданию новой записи для указанного ключа только в том случае, если такая запись еще не существует. Если же обнаруживается существующая запись, функция возвращает ошибку EEXIST (объект IPC уже существует).</P>
     <P>Комбинация IPC_CREAT и IPC_EXCL в отношении объектов IPC действует аналогично комбинации O_CREAT и O_EXCL для функции open.</P>
     <P>Установка только бита IPC_EXCL без IPC_CREAT никакого эффекта не дает.</P>
     <P>Логическая диаграмма последовательности действий при открытии объекта IPC изображена на рис. 3.2. В табл. 3.2 показан альтернативный взгляд на этот процесс.</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader50" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 3.2. Диаграмма открытия объекта IPC</P>
     <BR>
     <P>Обратите внимание, что в средней строке табл. 3.2 для флага IPC_CREAT без IPC_EXCL мы не получаем никакой информации о том, был ли создан новый объект или получен доступ к существующему. Для большинства приложений характерно создание сервером объекта IPC с указанием IPC_CREAT (если безразлично, существует ли уже объект) или IPC_CREAT | IPC_EXCL (если требуется проверка существования объекта). Клиент вообще не указывает флагов, предполагая, что сервер уже создал объект.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Функции System V IPC в отличие от функций Posix IPC определяют свои собственные константы IРС_ххх вместо использования O_CREAT и OEXCL, принимаемых стандартной функцией open (табл. 2.2).</P>
      <P>Обратите также внимание на то, что функции System V IPC совмещают константы IРС_ххх с битами разрешений (описанными в следующем разделе) в едином аргументе oflag, тогда как для функции open и для Posix IPC характерно наличие двух аргументов: oflag, в котором задаются флаги вида О_ххх, и mode, определяющего биты разрешений доступа.</P>
     </DIV>
     <BR>
     <P>Таблица 3.2. Логика создания и открытия объектов IPC</P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Аргумент oflag</TH>
       <TH ALIGN=left VALIGN=top >Ключ не существует</TH>
       <TH ALIGN=left VALIGN=top >Ключ существует</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Специальные флаги не установлены</TD>
       <TD ALIGN=left VALIGN=top >Ошибка, errno=ENOENT</TD>
       <TD ALIGN=left VALIGN=top >OK, открытие существующего объекта</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >IPC_CREAT</TD>
       <TD ALIGN=left VALIGN=top >OK, создается новая запись</TD>
       <TD ALIGN=left VALIGN=top >OK, открытие существующего</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >IPC CREAT|IPC_EXCL</TD>
       <TD ALIGN=left VALIGN=top >OK, создается новая запись</TD>
       <TD ALIGN=left VALIGN=top >Ошибка, errno=EEXIST</TD>
      </TR>
     </TABLE>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label45 style="border:none;"></a>3.5. Разрешения IPC</P>
     </H1>
     <P>При создании нового объекта IPC с помощью одной из функций getXXX, вызванной с флагом IPC_CREAT, в структуру ipc_perm заносится следующая информация (раздел 3.3):</P>
     <P>1. Часть битов аргумента <EM>oflag</EM> задают значение поля mode структуры ipc_perm. В табл. 3.3 приведены биты разрешений для трех типов IPC (запись &gt;&gt;3 означает сдвиг вправо на три бита).</P>
     <P>2. Поля cuid и cgid получают значения, равные действующим идентификаторам пользователя и группы вызывающего процесса. Эти два поля называются идентификаторами создателя.</P>
     <P>3. Поля uid и gid структуры iрс_perm также устанавливаются равными действующим идентификаторам вызывающего процесса. Эти два поля называются идентификаторами владельца.</P>
     <BR>
     <P>Таблица 3.3. Значения mode для разрешений чтения-записи IPC </P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Число (восьмеричное)</TH>
       <TH ALIGN=left VALIGN=top >Очередь сообщений</TH>
       <TH ALIGN=left VALIGN=top >Семафор</TH>
       <TH ALIGN=left VALIGN=top >Разделяемая память</TH>
       <TH ALIGN=left VALIGN=top >Описание</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >0400</TD>
       <TD ALIGN=left VALIGN=top >MSG_R</TD>
       <TD ALIGN=left VALIGN=top >SEM_R</TD>
       <TD ALIGN=left VALIGN=top >SHM_R</TD>
       <TD ALIGN=left VALIGN=top >Пользователь — чтение</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >0200</TD>
       <TD ALIGN=left VALIGN=top >MSG_W</TD>
       <TD ALIGN=left VALIGN=top >SEM_A</TD>
       <TD ALIGN=left VALIGN=top >SHM_W</TD>
       <TD ALIGN=left VALIGN=top >Пользователь — запись</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >0040</TD>
       <TD ALIGN=left VALIGN=top >MSG R&gt;&gt;3</TD>
       <TD ALIGN=left VALIGN=top >SEM_R&gt;&gt;3</TD>
       <TD ALIGN=left VALIGN=top >SHM_R&gt;&gt;3</TD>
       <TD ALIGN=left VALIGN=top >Группа — чтение</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >0020</TD>
       <TD ALIGN=left VALIGN=top >MSG_W&gt;&gt;3</TD>
       <TD ALIGN=left VALIGN=top >SEM_A&gt;&gt;3</TD>
       <TD ALIGN=left VALIGN=top >SHM_W&gt;&gt;3</TD>
       <TD ALIGN=left VALIGN=top >Группа — запись</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >0004</TD>
       <TD ALIGN=left VALIGN=top >MSG_R&gt;&gt;6</TD>
       <TD ALIGN=left VALIGN=top >SEM_R&gt;&gt;6</TD>
       <TD ALIGN=left VALIGN=top >SHM_R&gt;&gt;6</TD>
       <TD ALIGN=left VALIGN=top >Прочие — чтение</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >0002</TD>
       <TD ALIGN=left VALIGN=top >MSG_W&gt;&gt;6</TD>
       <TD ALIGN=left VALIGN=top >SEM_A&gt;&gt;6</TD>
       <TD ALIGN=left VALIGN=top >SHM_W&gt;&gt;6</TD>
       <TD ALIGN=left VALIGN=top >Прочие — запись</TD>
      </TR>
     </TABLE>
     <P>Идентификатор создателя изменяться не может, тогда как идентификатор владельца может быть изменен процессом с помощью вызова функции ctlXXX для данного механизма IPC с командой IPC_SET. Три функции ctlXXX позволяют процессу изменять биты разрешений доступа (поле mode) объекта IPC.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>В большинстве реализаций определены шесть констант: MSG_R, MSG_W, SEM_R, SEM_A, SHM_R и SHM_W, показанные в табл. 3.3. Константы эти определяются в заголовочных файлах &lt;sys/msg.h&gt;, &lt;sys/sem.h&gt; и &lt;sys/shm.h&gt;. Однако стандарт Unix 98 не требует их наличия. Суффикс А в SEM_A означает «alter» (изменение).</P>
      <P>Тройка функций getXXX не используют стандартную маску создания файла Unix. Разрешения очереди сообщений, семафора и разделяемой памяти устанавливаются в точности равными аргументу функции.</P>
      <P>Posix IPC не дает создателю IPC возможности изменить владельца объекта. В Posix нет аналогов команды IPC_SET. Однако в Posix IPC имя объекта принадлежит файловой системе, и потому владелец может быть изменен привилегированным пользователем с помощью команды chown.</P>
     </DIV>
     <P>Когда какой-либо процесс предпринимает попытку доступа к объекту IPC, производится двухэтапная проверка: первый раз при открытии файла (функция getXXX) и затем каждый раз при обращении к объекту IPC:</P>
     <P>1. При установке доступа к существующему объекту IPC с помощью одной из функций getXXX производится первичная проверка аргумента <EM>oflag,</EM> вызывающего функцию процесса. Аргумент не должен указывать биты доступа, не установленные в поле mode структуры ipc_perm (нижний квадрат на рис. 3.2). Например, процесс-сервер может установить значение члена mode для своей очереди входящих сообщений, сбросив биты чтения для группы и прочих пользователей. Любой процесс, попытавшийся указать эти биты в аргументе <EM>oflag</EM> функции msgget, получит ошибку. Надо отметить, что от этой проверки, производимой функциями getXXX, мало пользы. Она подразумевает наличие у вызывающего процесса информации о том, к какой группе пользователей он принадлежит: он может являться владельцем файла, может принадлежать к той же группе или к прочим пользователям. Если создающий процесс сбросит некоторые биты разрешений, а вызывающий процесс попытается их установить, функция getXXX вернет ошибку. Любой процесс может полностью пропустить эту проверку, указав аргумент <EM>oflag,</EM> равный 0, если заранее известно о существовании объекта IPC.</P>
     <P>2. При любой операции с объектами IPC производится проверка разрешений для процесса, эту операцию запрашивающего. Например, каждый раз когда процесс пытается поместить сообщение в очередь с помощью команды msgsnd, производятся нижеследующие проверки (при получении доступа последующие этапы пропускаются).</P>
     <P> □ Привилегированному пользователю доступ предоставляется всегда.</P>
     <P> □ Если действующий идентификатор пользователя совпадает со значением uid или cuid объекта IPC и установлен соответствующий бит разрешения доступа в поле mode объекта IPC, доступ будет разрешен. Под соответствующим битом разрешения доступа подразумевается бит, разрешающий чтение, если вызывающий процесс запрашивает операцию чтения для данного объекта IPC (например, получение сообщения из очереди), или бит, разрешающий запись, если процесс хочет осуществить ее.</P>
     <P> □ Если действующий идентификатор группы совпадает со значением gid или cgid объекта IPC и установлен соответствующий бит разрешения доступа в поле mode объекта IPC, доступ будет разрешен.</P>
     <P> □ Если доступ не был разрешен на предыдущих этапах, проверяется наличие соответствующих установленных битов доступа для прочих пользователей.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label46 style="border:none;"></a>3.6. Повторное использование идентификаторов</P>
     </H1>
     <P>Структура ipc_perm (раздел 3.3) содержит переменную seq, в которой хранится порядковый номер канала. Эта переменная представляет собой счетчик, заводимый ядром для каждого объекта IPC в системе. При удалении объекта IPC номер канала увеличивается, а при переполнении сбрасывается в ноль.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>В этом разделе мы описываем характерную для SVR4 реализацию. Стандарт Unix 98 не исключает использование других вариантов.</P>
     </DIV>
     <P>В счетчике возникает потребность по двум причинам. Во-первых, вспомним о дескрипторах файлов, хранящихся в ядре для каждого из открытых файлов. Они обычно представляют собой небольшие целые числа, имеющие значение только внутри одного процесса — для каждого процесса создаются собственные дескрипторы. Прочитать из файла с дескриптором 4 можно только в том процессе, в котором есть открытый файл с таким дескриптором. Есть ли открытые файлы с тем же дескриптором в других процессах — значения не имеет. В отличие от дескрипторов файлов идентификаторы System V IPC устанавливаются для всей системы, а не для процесса.</P>
     <P>Идентификатор IPC возвращается одной из функций getXXX: msgget, semget, shmget. Как и дескрипторы файлов, идентификаторы представляют собой целые числа, имеющие в отличие от дескрипторов одинаковое значение для всех процессов. Если два неродственных процесса (клиент и сервер) используют одну очередь сообщений, ее идентификатор, возвращаемый функцией msgget, должен иметь одно и то же целочисленное значение в обоих процессах, чтобы они получили доступ к одной и той же очереди. Такая особенность дает возможность какому-либо процессу, созданному злоумышленником, попытаться прочесть сообщение из очереди, созданной другим приложением, последовательно перебирая различные идентификаторы (если бы они представляли собой небольшие целые числа) и надеясь на существование открытой в текущий момент очереди, доступной для чтения всем. Если бы идентификаторы представляли собой небольшие целые числа (как дескрипторы файлов), вероятность найти правильный идентификатор составляла бы около 1/50 (предполагая ограничение в 50 дескрипторов на процесс).</P>
     <P>Для исключения такой возможности разработчики средств IPC решили расширить возможный диапазон значений идентификатора так, чтобы он включал вообще все целые числа, а не только небольшие. Расширение диапазона обеспечивается путем увеличения значения идентификатора, возвращаемого вызывающему процессу, на количество записей в системной таблице IPC каждый раз, когда происходит повторное использование одной из них. Например, если система настроена на использование не более 50 очередей сообщений, при первом использовании первой записи процессу будет возвращен идентификатор 0. После удаления этой очереди сообщений при попытке повторного использования первой записи в таблице процессу будет возвращен идентификатор 50. Далее он будет принимать значения 100, 150 и т. д. Поскольку seq обычно определяется как длинное целое без знака (ulong — см. структуру ipc_perm в разделе 3.3), возврат к уже использовавшимся идентификаторам происходит, когда запись в таблице будет использована 85899346 раз (2³²/50 в предположении, что целое является 32-разрядным).</P>
     <P>Второй причиной, по которой понадобилось ввести последовательный номер канала, является необходимость исключить повторное использование идентификаторов System V IPC через небольшой срок. Это помогает гарантировать то, что досрочно завершивший работу и впоследствии перезапущенный сервер не станет использовать тот же идентификатор.</P>
     <P>Иллюстрируя эту особенность, программа в листинге 3.2 выводит первые десять значений идентификаторов, возвращаемых msgget.</P>
     <H2><a name=label47 style="border:none;"></a>Листинг 3.2. Вывод идентификатора очереди сообщений десять раз подряд</H2>
     <P><CODE>//svmsg/slot.c</CODE></P>
     <P><CODE>1  #include &lt;unpipc.h&gt;</CODE></P>
     <P><CODE>2  int</CODE></P>
     <P><CODE>3  main(int argc, char **argv)</CODE></P>
     <P><CODE>4  {</CODE></P>
     <P><CODE>5   int i, msqid;</CODE></P>
     <P><CODE>6   for (i=0;i&lt;10;i++) {</CODE></P>
     <P><CODE>7    msqid=Msgget(IPC_PRIVATE, SVMSG_MODE|IPC_CREAT);</CODE></P>
     <P><CODE>8    printf("msqid = %d\n", msqid);</CODE></P>
     <P><CODE>9    Msgctl(msqid, IPC_RMID, NULL);</CODE></P>
     <P><CODE>10  }</CODE></P>
     <P><CODE>11  exit(0);</CODE></P>
     <P><CODE>12 }</CODE></P>
     <P>При очередном прохождении цикла msgget создает очередь сообщений, a msgctl с командой IPC_RMID в качестве аргумента удаляет ее. Константа SVMSG_MODE определяется в нашем заголовочном файле unpipc.h (листинг В.1) и задает разрешения по умолчанию для очереди сообщений System V. Вывод программы будет иметь следующий вид:</P>
     <P><CODE>solaris %<STRONG>slot</STRONG></CODE></P>
     <P><CODE>msqid = 0</CODE></P>
     <P><CODE>msqid = 50</CODE></P>
     <P><CODE>msqid = 100</CODE></P>
     <P><CODE>msqid = 150</CODE></P>
     <P><CODE>msqid = 200</CODE></P>
     <P><CODE>msqid = 250</CODE></P>
     <P><CODE>msqid = 300</CODE></P>
     <P><CODE>msqid = 350</CODE></P>
     <P><CODE>msqid = 400</CODE></P>
     <P><CODE>msqid = 450</CODE></P>
     <P>При повторном запуске программы мы увидим наглядную иллюстрацию того, что последовательный номер канала — это переменная, хранящаяся в ядре и продолжающая существовать и после завершения процесса.</P>
     <P><CODE>solaris % <STRONG>slot</STRONG></CODE></P>
     <P><CODE>msqid = 500</CODE></P>
     <P><CODE>msqid = 550</CODE></P>
     <P><CODE>msqid = 600</CODE></P>
     <P><CODE>msqid = 650</CODE></P>
     <P><CODE>msqid = 700</CODE></P>
     <P><CODE>msqid = 750</CODE></P>
     <P><CODE>msqid = 800</CODE></P>
     <P><CODE>msqid = 850</CODE></P>
     <P><CODE>msqid = 900</CODE></P>
     <P><CODE>msqid = 950</CODE></P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label48 style="border:none;"></a>3.7. Программы ipcs и ipcrm</P>
     </H1>
     <P>Поскольку объектам System V IPC не сопоставляются имена в файловой системе, мы не можем просмотреть их список или удалить их, используя стандартные программы ls и rm. Вместо них в системах, поддерживающих эти типы IPC, предоставляются две специальные программы: ipcs, выводящая различную информацию о свойствах System V IPC, и ipcrm, удаляющая очередь сообщений System V, семафор или сегмент разделяемой памяти. Первая из этих функций поддерживает около десятка параметров командной строки, управляющих отображением информации о различных типах IPC. Второй (ipcrm) можно задать до шести параметров. Подробную информацию о них можно получить в справочной системе.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Поскольку System V IPC не стандартизуется Posix, эти команды не входят в Posix.2. Они описаны в стандарте Unix 98.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label49 style="border:none;"></a>3.8. Ограничения ядра</P>
     </H1>
     <P>Большинству реализаций System V IPC свойственно наличие внутренних ограничений, налагаемых ядром. Это, например, максимальное количество очередей сообщений или ограничение на максимальное количество семафоров в наборе. Характерные значения этих ограничений приведены в табл. 6.2, 11.1 и 14.1. Большая часть ограничений унаследована от исходной реализации System V. </P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Раздел 11.2 книги [1] и глава 8 [6] описывают реализацию очередей сообщений, семафоров и разделяемой памяти в System V. Некоторые из этих ограничений описаны уже там.</P>
     </DIV>
     <P>К сожалению, некоторые из накладываемых ограничений достаточно жестки, поскольку они унаследованы от исходной реализации, базировавшейся на системе с небольшим адресным пространством (16-разрядный PDP-11). К счастью, большинство систем позволяют администратору изменять некоторые из установленных по умолчанию ограничений, но необходимые для этого действия специфичны для каждой версии Unix. В большинстве случаев после внесения изменений требуется перезагрузка ядра. К сожалению, в некоторых реализациях для хранения некоторых параметров до сих пор используются 16-разрядные целые, а это уже устанавливает аппаратные ограничения.</P>
     <P>В Solaris 2.6, например, таких ограничений 20. Их текущие значения можно вывести на экран, используя команду sysdef. Учтите, что вместо реальных значений будут выведены нули, если соответствующий модуль ядра не загружен (то есть средство не было ранее использовано). Это можно исключить, добавив к файлу /etc/system любой из нижеследующих операторов. Файл /etc/system считывается в процессе перезагрузки системы:</P>
     <P><CODE>set msgsys:msginfo_msgseg = значение</CODE></P>
     <P><CODE>set msgsys:msginfo_msgssz = значение</CODE></P>
     <P><CODE>set msgsys:msginfo_msgtql = значение</CODE></P>
     <P><CODE>set msgsys:msginfo_msgmap = значение</CODE></P>
     <P><CODE>set msgsys:msginfo_msgmax = значение</CODE></P>
     <P><CODE>set msgsys:msginfo_msgmnb = значение</CODE></P>
     <P><CODE>set msgsys:msginfo_msgmni = значение</CODE></P>
     <BR>
     <P><CODE>set semsys:seminfo_semopm = значение</CODE></P>
     <P><CODE>set semsys:seminfo_semume = значение</CODE></P>
     <P><CODE>set semsys:seminfo_semaem = значение</CODE></P>
     <P><CODE>set semsys:seminfo_semmap = значение</CODE></P>
     <P><CODE>set semsys:seminfo_semvmx = значение</CODE></P>
     <P><CODE>set semsys:seminfo_semmsl = значение</CODE></P>
     <P><CODE>set semsys:seminfo_semmni = значение</CODE></P>
     <P><CODE>set semsys:seminfo_semmns = значение</CODE></P>
     <P><CODE>set semsys:seminfo_semmnu = значение</CODE></P>
     <BR>
     <P><CODE>set shmsys:shminfo_shmmin = значение</CODE></P>
     <P><CODE>set shmsys:shminfo_shmseg = значение</CODE></P>
     <P><CODE>set shmsys:shminfo_shmmax = значение</CODE></P>
     <P><CODE>set shmsys:shminfo_shmmni = значение</CODE></P>
     <P>Последние шесть символов имени слева от знака равенства представляют собой переменные, перечисленные в табл. 6.2, 11.1 и 14.1.</P>
     <P>В Digital Unix 4.0B программа sysconfig позволяет узнать или изменить множество параметров и ограничений ядра. Ниже приведен вывод этой команды, запущенной с параметром –q. Команда выводит текущие ограничения для подсистемы ipc. Некоторые строки в выводе, не имеющие отношения к средствам IPC System V, были опущены:</P>
     <P><CODE>alpha % <STRONG>/sbin/sysconfig –q ipc</STRONG></CODE></P>
     <P><CODE>ipc:</CODE></P>
     <P><CODE>msg-max = 8192</CODE></P>
     <P><CODE>msg-mnb = 16384</CODE></P>
     <P><CODE>msg-mni = 64</CODE></P>
     <P><CODE>msg-tql = 40</CODE></P>
     <BR>
     <P><CODE>shm-max = 4194304</CODE></P>
     <P><CODE>shm-min = 1</CODE></P>
     <P><CODE>shm-mni = 128</CODE></P>
     <P><CODE>shm-seg = 32</CODE></P>
     <BR>
     <P><CODE>sem-mni = 16</CODE></P>
     <P><CODE>sem-msl = 25</CODE></P>
     <P><CODE>sem-opm = 10</CODE></P>
     <P><CODE>sem-ume = 10</CODE></P>
     <P><CODE>sem-vmx = 32767</CODE></P>
     <P><CODE>sem-aem = 16384</CODE></P>
     <P><CODE>num-of-sems = 60</CODE></P>
     <P>Для этих параметров можно указать другие значения по умолчанию, изменив файл /etc/sysconfigtab. Делать это следует с помощью программы sysconfigdb. Этот файл также считывается в процессе начальной загрузки системы.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label50 style="border:none;"></a>3.9. Резюме</P>
     </H1>
     <P>Первым аргументом функций msgget, semget и shmget является ключ IPC System V. Эти ключи вычисляются по полному имени файла с помощью системной функции ftok. В качестве ключа можно также указать значение IPCPRIVATE. Эти три функции создают новый объект IPC или открывают существующий и возвращают идентификатор System V IPC — целое число, которое потом используется для распознавания объекта в прочих функциях, имеющих отношение к IPC. Эти идентификаторы имеют смысл не только в рамках одного процесса (как дескрипторы файлов), но и в рамках всей системы. Они могут повторно использоваться ядром, но лишь спустя некоторое время.</P>
     <P>С каждым объектом System V IPC связана структура ipc_perm, содержащая информацию о нем, такую как идентификатор пользователя владельца, идентификатор группы, разрешения чтения и записи и др. Одним из отличий между System V и Posix IPC является то, что для объекта IPC System V эта информация доступна всегда (доступ к ней можно получить с помощью одной из функций XXXctl с аргументом IPC_STAT), а в Posix IPC доступ к ней зависит от реализации. Если объект Posix IPC хранится в файловой системе и мы знаем его имя в ней, мы можем получить доступ к этой информации, используя стандартные средства файловой системы.</P>
     <P>При создании нового или открытии существующего объекта System V IPC функции getXXX передаются два флага (IPC_CREAT и IPC_EXCL) и 9 бит разрешений.</P>
     <P>Без сомнения, главнейшей проблемой в использовании System V IPC является наличие искусственных ограничений в большинстве реализаций. Ограничения накладываются на размер объектов, причем они берут свое начало от самых первых реализаций. Это означает, что для интенсивного использования средств System V IPC приложениями требуется изменение ограничений ядра, а внесение этих изменений в каждой системе осуществляется по-разному. </P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label51 style="border:none;"></a>Упражнения</P>
     </H1>
     <P>1. Прочитайте о функции msgctl в разделе 6.5 и измените программу в листинге 3.2 так, чтобы выводился не только идентификатор, но и поле seq структуры ipc_perm.</P>
     <P>2. Непосредственно после выполнения программы листинга 3.2 мы запускаем программу, создающую две очереди сообщений. Предполагая, что никакие другие приложения не использовали очереди сообщений с момента загрузки системы, определите, какие значения будут возвращены функцией msgget в качестве идентификаторов очередей сообщений.</P>
     <P>3. В разделе 3.5 было отмечено, что функции getXXX System V IPC не используют маску создания файла. Напишите тестовую программу, создающую канал FIFO (с помощью функции mkfifо, описанной в разделе 4.6) и очередь сообщений System V, указав для обоих разрешение 666 (в восьмеричном формате). Сравните разрешения для созданных объектов (FIFO и очереди сообщений). Перед запуском программы удостоверьтесь, что значение umask отлично от нуля.</P>
     <P>4. Серверу нужно создать уникальную очередь сообщений для своих клиентов. Что предпочтительнее: использовать какое-либо постоянное имя файла (например, имя сервера) в качестве аргумента функции ftok или использовать ключ IPC_PRIVATE?</P>
     <P>5. Измените листинг 3.1 так, чтобы выводился только ключ IPC и путь к файлу. Запустите программу find, чтобы вывести список всех файлов вашей файловой системы, и передайте вывод вашей только что созданной программе. Скольким именам файлов будет соответствовать один и тот же ключ?</P>
     <P>6. Если в вашей системе есть программа sar (system activity reporter — информация об активности системы), запустите команду</P>
     <P><CODE>sar –m 5 6</CODE></P>
     <P>На экран будет выведено количество операций в секунду с очередями сообщений и семафорами, замеряемыми каждые 5 секунд 6 раз. </P>
    </DIV>
   </DIV>
  </DIV>
  <DIV class=section>
   <H1>
    <P><a name=label52 style="border:none;"></a>ЧАСТЬ 2</P>
    <P>ОБМЕН СООБЩЕНИЯМИ</P>
   </H1>
   <DIV class=section>
    <H1>
     <P><a name=label53 style="border:none;"></a>ГЛАВА 4</P>
     <P>Именованные и неименованные каналы</P>
    </H1>
    <DIV class=section>
     <H1>
      <P><a name=label54 style="border:none;"></a>4.1. Введение</P>
     </H1>
     <P>Неименованные каналы — это самая первая форма IPC в Unix, появившаяся еще в 1973 году в третьей версии (Third Edition [17]). Несмотря на полезность во многих случаях, главным недостатком неименованных каналов является отсутствие имени, вследствие чего они могут использоваться для взаимодействия только родственными процессами. Это было исправлено в Unix System III (1982) добавлением каналов FIFO, которые иногда называются именованными каналами. Доступ и к именованным каналам, и к неименованным организуется с помощью обычных функций read и write.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Программные (неименованные) каналы в принципе могут использоваться неродственными процессами, если предоставить им возможность передавать друг другу дескрипторы (см. раздел 15.8 этой книги или раздел 13.7 [24]). Однако на практике эти каналы обычно используются для осуществления взаимодействия между процессами, у которых есть общий предок.</P>
     </DIV>
     <P>В этой главе описываются детали, касающиеся создания и использования программных каналов и каналов FIFO. Мы рассмотрим пример простейшего сервера файлов, а также обратим внимание на некоторые детали модели клиент-сервер, в частности постараемся определить количество требуемых каналов IPC, сравним последовательные серверы с параллельными и неструктурированные потоки байтов с сообщениями.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label55 style="border:none;"></a>4.2. Приложение типа клиент-сервер</P>
     </H1>
     <P>Пример приложения модели клиент-сервер приведен на рис. 4.1. Именно на него мы будем ссылаться в тексте этой главы и главы 6 при необходимости проиллюстрировать использование программных каналов, FIFO и очередей сообщений System V.</P>
     <P>Клиент считывает полное имя (файла) из стандартного потока ввода и записывает его в канал IPC. Сервер считывает это имя из канала IPC и производит попытку открытия файла на чтение. Если попытка оказывается успешной, сервер считывает файл и записывает его в канал IPC. В противном случае сервер возвращает клиенту сообщение об ошибке. Клиент считывает данные из канала IPC и записывает их в стандартный поток вывода. Если сервер не может считать файл, из канала будет считано сообщение об ошибке. В противном случае будет принято содержимое файла. Две штриховые линии между клиентом и сервером на рис. 4.1 представляют собой канал IPC. </P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader58" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 4.1. Пример приложения типа клиент-сервер</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label56 style="border:none;"></a>4.3. Программные каналы</P>
     </H1>
     <DIV class=section>
      <P>Программные каналы имеются во всех существующих реализациях и версиях Unix. Канал создается вызовом pipe и предоставляет возможность однонаправленной (односторонней) передачи данных:</P>
      <P><CODE>#include &lt;unistd.h&gt;</CODE></P>
      <P><CODE>int pipe(int fd[2]);</CODE></P>
      <P><CODE>/* возвращает 0 в случае успешного завершения. –1 – в случае ошибки:*/</CODE></P>
      <P>Функция возвращает два файловых дескриптора: fd[0] и fd[1], причем первый открыт для чтения, а второй — для записи.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Некоторые версии Unix, в частности SVR4, поддерживают двусторонние каналы (full-duplex pipes). В этом случае канал открыт на запись и чтение с обоих концов. Другой способ создания двустороннего канала IPC заключается в вызове функции socketpair, описанной в разделе 14.3 [24]. Его можно использовать в большинстве современных версий Unix. Однако чаще всего каналы используются при работе с интерпретатором команд, где уместно использование именно односторонних каналов.</P>
       <P>Стандарты Posix.1 и Unix 98 требуют только односторонних каналов, и мы будем исходить из этого.</P>
      </DIV>
      <P>Для определения типа дескриптора (файла, программного канала или FIFO) можно использовать макрос S_ISFIFO. Он принимает единственный аргумент: поле st_mode структуры stat и возвращает значение «истина» (ненулевое значение) или «ложь» (ноль). Структуру stat для канала возвращает функция fstat. Для FIFO структура возвращается функциями fstat, lstat и stat.</P>
      <P>На рис. 4.2 изображен канал при использовании его единственным процессом.</P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader60" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 4.2. Канал в одиночном процессе</P>
      <BR>
      <P>Хотя канал создается одним процессом, он редко используется только этим процессом (пример канала в одиночном процессе приведен в листинге 5.12). Каналы обычно используются для связи между двумя процессами (родительским и дочерним) следующим образом: процесс создает канал, а затем вызывает fork, создавая свою копию — дочерний процесс (рис. 4.3). Затем родительский процесс закрывает открытый для чтения конец канала, а дочерний, в свою очередь, — открытый на запись конец канала. Это обеспечивает одностороннюю передачу данных между процессами, как показано на рис. 4.4.</P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader61" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 4.3. Канал после вызова fork</P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader62" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 4.4. Канал между двумя процессами </P>
      <BR>
      <P>При вводе команды наподобие</P>
      <P><CODE>who|sort|lp</CODE></P>
      <P>в интерпретаторе команд Unix интерпретатор выполняет вышеописанные действия для создания трех процессов с двумя каналами между ними. Интерпретатор также подключает открытый для чтения конец каждого канала к стандартному потоку ввода, а открытый на запись — к стандартному потоку вывода. Созданный таким образом канал изображен на рис. 4.5.</P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader64" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 4.5. Каналы между тремя процессами при конвейерной обработке </P>
      <BR>
      <P>Все рассмотренные выше каналы были однонаправленными (односторонними), то есть позволяли передавать данные только в одну сторону. При необходимости передачи данных в обе стороны нужно создавать пару каналов и использовать каждый из них для передачи данных в одну сторону. Этапы создания двунаправленного канала IPC следующие:</P>
      <P>1. Создаются каналы 1 (fd1[0] и fd1[1]) и 2 (fd2[0] и fd2[1]).</P>
      <P>2. Вызов fork.</P>
      <P>3. Родительский процесс закрывает доступный для чтения конец канала 1 (fd1[0]).</P>
      <P>4. Родительский процесс закрывает доступный для записи конец канала 2 (fd2[1]).</P>
      <P>5. Дочерний процесс закрывает доступный для записи конец канала 1 (fd1[1]).</P>
      <P>6. Дочерний процесс закрывает доступный для чтения конец канала 2 (fd2[0]).</P>
      <P>Текст программы, выполняющей эти действия, приведен в листинге 4.1. При этом создается структура каналов, изображенная на рис. 4.6.</P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader65" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 4.6. Двусторонняя передача данных по двум каналам</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label57 style="border:none;"></a>Пример</P>
      </H1>
      <P>Давайте напишем программу, описанную в разделе 4.2, с использованием каналов. Функция main создает два канала и вызывает fork для создания копии процесса. Родительский процесс становится клиентом, а дочерний — сервером. Первый канал используется для передачи полного имени от клиента серверу, а второй — для передачи содержимого файла (или сообщения об ошибке) от сервера клиенту. Таким образом мы получаем структуру, изображенную на рис. 4.7. </P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader67" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 4.7. Реализация рис. 4.1 с использованием двух каналов</P>
      <BR>
      <P>Обратите внимание на то, что мы изображаем на рис. 4.7 два канала, соединяющих сервер с клиентом, но оба канала проходят через ядро, поэтому каждый передаваемый байт пересекает интерфейс ядра дважды: при записи в канал и при считывании из него.</P>
      <P>В листинге 4.1<A HREF="#n_1" onmouseover="ShowBookNote('n_1')" onmouseout="HideBookNote('n_1')"><SUP>[1]</SUP></A> приведена функция main для данного примера.</P>
      <H2><a name=label58 style="border:none;"></a>Листинг 4.1. Функция main для приложения клиент-сервер, использующего два канала</H2>
      <P><CODE>//pipe/mainpipe.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  void client(int, int), server(int, int);</CODE></P>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int pipe1[2], pipe2[2]:</CODE></P>
      <P><CODE>7   pid_t childpid;</CODE></P>
      <P><CODE>8   Pipe(pipe1); /* создание двух каналов */</CODE></P>
      <P><CODE>9   Pipe(pipe2);</CODE></P>
      <P><CODE>10  if ((childpid = Fork()) == 0) { /* child */</CODE></P>
      <P><CODE>11   Close(pipe1[1]);</CODE></P>
      <P><CODE>12   Close(pipe2[0]);</CODE></P>
      <P><CODE>13   server(pipe1[0], pipe2[1]);</CODE></P>
      <P><CODE>14   exit(0);</CODE></P>
      <P><CODE>15  }</CODE></P>
      <P><CODE>16  /* родитель */</CODE></P>
      <P><CODE>17  Close(pipel[0]);</CODE></P>
      <P><CODE>18  Close(pipe2[1]);</CODE></P>
      <P><CODE>19  client(pipe2[0], pipel[1]);</CODE></P>
      <P><CODE>20  Waitpid(childpid, NULL, 0); /* ожидание завершения дочернего процесса */</CODE></P>
      <P><CODE>21  exit(0);</CODE></P>
      <P><CODE>22 }</CODE></P>
      <H2><a name=label59 style="border:none;"></a>Создание каналов, вызов fork</H2>
      <P>8-19 Создаются два канала и выполняются шесть шагов, уже упоминавшиеся в отношении рис. 4.6. Родительский процесс вызывает функцию client (листинг 4.2), а дочерний — функцию server (листинг 4.3).</P>
      <H2><a name=label60 style="border:none;"></a>Использование waitpid дочерним процессом</H2>
      <P>20 Процесс-сервер (дочерний процесс) завершает свою работу первым, вызывая функцию exit после завершения записи данных в канал. После этого он становится процессом-зомби. Процессом-зомби называется дочерний процесс, завершивший свою работу, родитель которого еще функционирует, но не получил сигнал о завершении работы дочернего процесса. При завершении работы дочернего процесса ядро посылает его родителю сигнал SIGCHLD, но родитель его не принимает и этот сигнал по умолчанию игнорируется. После этого функция client родительского процесса возвращает управление функции main, закончив Считывание данных из канала. Затем родительский процесс вызывает waitpid для получения информации о статусе дочернего процесса (зомби). Если родительский процесс не вызовет waitpid, а просто завершит работу, клиент будет унаследован процессом init, которому будет послан еще один сигнал SIGCHLD.</P>
      <P>Функция client приведена в листинге 4.2.</P>
      <H2><a name=label61 style="border:none;"></a>Листинг 4.2. Функция client для приложения типа клиент-сервер с двумя каналами</H2>
      <P><CODE>//pipe/client.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  void</CODE></P>
      <P><CODE>3  client(int readfd, int writefd)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   size_t len;</CODE></P>
      <P><CODE>6   ssize_t n;</CODE></P>
      <P><CODE>7   char buff[MAXLINE];</CODE></P>
      <P><CODE>8   /* получение полного имени файла */</CODE></P>
      <P><CODE>9   Fgets(buff, MAXLINE, stdin);</CODE></P>
      <P><CODE>10  len = strlen(buff); /* fgets() гарантирует завершающий нулевой байт */</CODE></P>
      <P><CODE>11  if (buff[Len-l] == <EM>'</EM> \n<EM>'</EM> )</CODE></P>
      <P><CODE>12   len--; /* удаление перевода строки из fgets() */</CODE></P>
      <P><CODE>13  /* запись полного имени в канал IPC */</CODE></P>
      <P><CODE>14  Write(writefd, buff, len);</CODE></P>
      <P><CODE>15  /* считывание из канала, вывод в stdout */</CODE></P>
      <P><CODE>16  while ((n = Read(readfd, buff, MAXLINE)) &gt; 0)</CODE></P>
      <P><CODE>17   Write(STDOUT_FILENO, buff, n);</CODE></P>
      <P><CODE>18 }</CODE></P>
      <H2><a name=label62 style="border:none;"></a>Считывание полного имени из стандартного потока ввода</H2>
      <P>8-14 Полное имя файла считывается из стандартного потока ввода и записывается в канал после удаления завершающего символа перевода строки, возвращаемого функцией fgets.</P>
      <H2><a name=label63 style="border:none;"></a>Копирование из канала в стандартный поток вывода</H2>
      <P>15-17 Затем клиент считывает все, что сервер направляет в канал, и записывает эти данные в стандартный поток вывода. Ожидается, что это будет содержимое файла, но в случае его отсутствия будет принято и записано в стандартный поток вывода сообщение об ошибке.</P>
      <P>В листинге 4.3 приведена функция server.</P>
      <H2><a name=label64 style="border:none;"></a>Листинг 4.3. Функция server для приложения клиент-сервер с двумя каналами</H2>
      <P><CODE>//pipe/server.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  void</CODE></P>
      <P><CODE>3  server(int readfd, int writefd)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int fd;</CODE></P>
      <P><CODE>6   ssize_t n;</CODE></P>
      <P><CODE>7   char buff[MAXLINE+1];</CODE></P>
      <P><CODE>8   /* получение полного имени из канала IPC */</CODE></P>
      <P><CODE>9   if ((n = Read(readfd, buff, MAXLINE)) == 0)</CODE></P>
      <P><CODE>10   err_quit("end-of-file while reading pathname"):</CODE></P>
      <P><CODE>11  buff[n] = '\0'; /* полное имя завершается 0 */</CODE></P>
      <P><CODE>12  if ((fd = open(buff, O_RDONLY)) &lt; 0) {</CODE></P>
      <P><CODE>13   /* 4error: must tell client */</CODE></P>
      <P><CODE>14   snprintf(buff + n, sizeof(buff) – n, ": can't open. %s\n".</CODE></P>
      <P><CODE>15   strerror(errno)):</CODE></P>
      <P><CODE>16   n = strlen(buff);</CODE></P>
      <P><CODE>17   Write(writefd, buff, n);</CODE></P>
      <P><CODE>18  } else {</CODE></P>
      <P><CODE>19   /* файл успешно открыт и копируется в канал */</CODE></P>
      <P><CODE>20   while ( (n = Read(fd, buff, MAXLINE)) &gt; 0)</CODE></P>
      <P><CODE>21    Write(writefd, buff, n);</CODE></P>
      <P><CODE>22   Close(fd);</CODE></P>
      <P><CODE>23  }</CODE></P>
      <P><CODE>24 }</CODE></P>
      <H2><a name=label65 style="border:none;"></a>Считывание полного имени файла из канала</H2>
      <P>8-11 Записанное в канал клиентом имя файла считывается сервером и дополняется завершающим символом с кодом 0 (null-terminated). Обратите внимание, что функция read возвращает данные, как только они помещаются в поток, не ожидая накопления некоторого их количества (MAXLINE в данном примере).</P>
      <H2><a name=label66 style="border:none;"></a>Открытие файла, обработка возможной ошибки</H2>
      <P>12-17 Файл открывается для чтения и при возникновении ошибки сообщение о ней возвращается клиенту с помощью канала. Для получения строки с соответствующим значению переменной errno сообщением об ошибке вызывается функция strerror (в книге [24, с. 690-691] вы найдете более подробный рассказ об этой функции).</P>
      <H2><a name=label67 style="border:none;"></a>Копирование из файла в канал</H2>
      <P>18-23 При успешном завершении работы функции open содержимое файла копируется в канал.</P>
      <P>Ниже приведен результат работы программы в случае наличия файла с указанным полным именем и в случае возникновения ошибок:</P>
      <P><CODE>solaris % <STRONG>mainpipe /etc/inet/ntp.conf</STRONG> <EM>файл, состоящий из двух строк</EM></CODE></P>
      <P><CODE>multicastclient 224.0.1.1</CODE></P>
      <P><CODE>driftfile /etc/inet/ntp.drift</CODE></P>
      <P><CODE>solaris % <STRONG>mainpipe /etc/shadow</STRONG>          <EM>фaйл, на чтение которого нет разрешения</EM></CODE></P>
      <P><CODE>/etc/shadow: can't open. Permission denied</CODE></P>
      <P><CODE>solaris % <STRONG>mainpipe /no/such/file</STRONG>        <EM>несуществующий файл</EM></CODE></P>
      <P><CODE>/no/such/file: can't open. No such file or directory</CODE></P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label68 style="border:none;"></a>4.4. Двусторонние каналы</P>
     </H1>
     <P>В предыдущем разделе мы отметили, что во многих системах реализованы двусторонние каналы. В Unix SVR4 это обеспечивается самой функцией pipe, а во многих других ядрах — функцией socketpair. Но что в действительности представляет собой двусторонний канал? Представим себе сначала однонаправленный канал, изображенный на рис. 4.8.</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader72" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 4.8. Односторонний канал</P>
     <BR>
     <P>Двусторонний канал мог бы быть реализован так, как это изображено на рис. 4.9. В этом случае неявно предполагается существование единственного буфера, в который помещается все, что записывается в канал (с любого конца, то есть дескриптора), и при чтении из канала данные просто считываются из буфера.</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader74" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 4.9. Одна из возможных реализаций двустороннего канала (неправильная)</P>
     <BR>
     <P>Такая реализация вызовет проблемы, например, в программе листинга А.14. Здесь требуется двусторонняя передача информации, причем потоки данных должны быть независимы. В противном случае некоторый процесс, записав данные в канал и перейдя затем в режим чтения из этого же канала, рискует считать обратно те же данные, которые были им только что туда записаны.</P>
     <P>На рис. 4.10 изображена правильная реализация двустороннего канала.</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader75" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 4.10. Правильная реализация двустороннего канала</P>
     <BR>
     <P>Здесь двусторонний канал получается из объединения двух односторонних. Все данные, записываемые в fd[1], будут доступны для чтения из fd[0], а данные, записываемые в fd[0], будут доступны для чтения из fd[1].</P>
     <P>Программа в листинге 4.4 иллюстрирует использование одного двустороннего канала для двусторонней передачи информации.</P>
     <H2><a name=label69 style="border:none;"></a>Листинг 4.4. Двусторонняя связь через двусторонний канал</H2>
     <P><CODE>//pipe/fduplex.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  int</CODE></P>
     <P><CODE>3  main(int argc, char **argv)</CODE></P>
     <P><CODE>4  {</CODE></P>
     <P><CODE>5   int fd[2], n;</CODE></P>
     <P><CODE>6   char c;</CODE></P>
     <P><CODE>7   pid_t childpid;</CODE></P>
     <P><CODE>8   Pipe(fd); /* предполагается двусторонний канал (напр., SVR4) */</CODE></P>
     <P><CODE>9   if ((childpid = Fork()) == 0) { /* child */</CODE></P>
     <P><CODE>10   sleep(3):</CODE></P>
     <P><CODE>11   if ((n = Read(fd[0], &amp;c, 1)) != 1)</CODE></P>
     <P><CODE>12    err_quit("child: read returned %d", n);</CODE></P>
     <P><CODE>13   printf("child read %c\n", c):</CODE></P>
     <P><CODE>14   Write(fd[0], "c", 1);</CODE></P>
     <P><CODE>15   exit(0);</CODE></P>
     <P><CODE>16  }</CODE></P>
     <P><CODE>17  /* родитель */</CODE></P>
     <P><CODE>18  Write(fd[1], "p", 1);</CODE></P>
     <P><CODE>19  if ((n = Read(fd[1], &amp;c, 1)) != 1)</CODE></P>
     <P><CODE>20   err_quit("parent: read returned %d", n):</CODE></P>
     <P><CODE>21  printf("parent read %c\n", c);</CODE></P>
     <P><CODE>22  exit(0);</CODE></P>
     <P><CODE>23 }</CODE></P>
     <P>В этой программе сначала создается двусторонний канал, затем делается системный вызов fork. Породивший процесс записывает символ р в канал, а затем считывает из канала данные. Дочерний процесс ждет три секунды, считывает символ из канала, а потом записывает туда символ с. Задержка чтения для дочернего процесса позволяет породившему процессу вызвать read первым — таким образом мы можем узнать, не будет ли им считан обратно только что записанный символ.</P>
     <P>При запуске этой программы в Solaris 2.6, в которой организована поддержка двусторонних каналов, мы получим ожидаемый результат:</P>
     <P><CODE>solaris % <STRONG>fduplex</STRONG></CODE></P>
     <P><CODE>child read p</CODE></P>
     <P><CODE>parent read с</CODE></P>
     <P>Символ р передается по одному из двух односторонних каналов, изображенных на рис. 4.10, а именно по верхнему каналу. Символ с передается по нижнему одностороннему каналу. Родительский процесс не считывает обратно записанный им в канал символ р (что и требуется).</P>
     <P>При запуске этой программы в Digital Unix 4.0B, в которой по умолчанию создаются односторонние каналы (двусторонние каналы — как в SVR4 — будут создаваться в том случае, если при компиляции указать специальные параметры), мы увидим результат, ожидаемый для одностороннего канала:</P>
     <P><CODE>alpha % <STRONG>fduplex</STRONG></CODE></P>
     <P><CODE>read error: Bad file number</CODE></P>
     <P><CODE>alpha % child read p</CODE></P>
     <P><CODE>write error: Bad file number</CODE></P>
     <P>Родительский процесс записывает символ р, который успешно считывается дочерним процессом, однако при попытке считывания из канала (дескриптор fd[l]) родительский процесс прерывается с ошибкой, как и дочерний процесс, при попытке записи в канал (дескриптор fd[0]). Вспомните рис. 4.8. Функция read возвращает код ошибки EBADF, означающий, что дескриптор не открыт для чтения. Аналогично write возвращает тот же код ошибки, если дескриптор не был открыт на запись.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label70 style="border:none;"></a>4.5. Функции popen и pclose</P>
     </H1>
     <DIV class=section>
      <P>Другим примером использования каналов является имеющаяся в стандартной библиотеке ввода-вывода функция popen, которая создает канал и запускает другой процесс, записывающий данные в этот канал или считывающий их из него:</P>
      <P><CODE>#include &lt;stdio.h&gt;</CODE></P>
      <P><CODE>FILE *popen(const char *<EM>соmmаnd,</EM> const char <EM>*tуре</EM>);</CODE></P>
      <P><CODE>/* Возвращает указатель FILE * в случае успешного выполнения, NULL – в случае ошибки */</CODE></P>
      <P><CODE>int pclose(FILE *s<EM>trеаm</EM>);</CODE></P>
      <P><CODE>/* Возвращает код завершения команды интерпретатора или –1 – в случае ошибки */</CODE></P>
      <P>Аргумент <EM>command</EM> представляет собой команду интерпретатора. Он обрабатывается программой sh (обычно это интерпретатор Bourne shell), поэтому для поиска исполняемого файла, вызываемого командой <EM>command</EM>, используется переменная PATH. Канал создается между вызывающим процессом и указанной командой. Возвращаемое функцией popen значение представляет собой обычный указатель на тип FILE, который может использоваться для ввода или для вывода в зависимости от содержимого строки <EM>type</EM>:</P>
      <P>■ если <EM>type</EM> имеет значение r, вызывающий процесс считывает данные, направляемые командой <EM>command</EM> в стандартный поток вывода;</P>
      <P>■ если <EM>type</EM> имеет значение w, вызывающий процесс записывает данные в стандартный поток ввода команды <EM>command</EM>.</P>
      <P>Функция pclose закрывает стандартный поток ввода-вывода stream, созданный командой popen, ждет завершения работы программы и возвращает код завершения, принимаемый от интерпретатора.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Информацию о реализациях popen и pclose можно найти в разделе 14.3 [21].</P>
      </DIV>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label71 style="border:none;"></a>Пример</P>
      </H1>
      <P>В листинге 4.5 изображено еще одно решение задачи с клиентом и сервером, использующее функцию popen и программу (утилиту Unix) cat.</P>
      <H2><a name=label72 style="border:none;"></a>Листинг 4.5. Клиент-сервер с использованием popen</H2>
      <P><CODE>//pipe/mainpopen.c </CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   size_t n;</CODE></P>
      <P><CODE>6   char buff[MAXLINE], command[MAXLINE];</CODE></P>
      <P><CODE>7   FILE *fp;</CODE></P>
      <P><CODE>8   /* считывание полного имени */</CODE></P>
      <P><CODE>9   Fgets(buff, MAXLINE, stdin);</CODE></P>
      <P><CODE>10  n = strlen(buff); /* fgets() гарантирует завершающий ноль */</CODE></P>
      <P><CODE>11  if (buff[n-1] == '\n')</CODE></P>
      <P><CODE>12   n--; /* удаление перевода строки из возврата fgets() */</CODE></P>
      <P><CODE>13  snprintf(command, sizeof(command), "cat %s", buff);</CODE></P>
      <P><CODE>14  fp = Popen(command, "r");</CODE></P>
      <P><CODE>15  /* копирование из канала в стандартный вывод */</CODE></P>
      <P><CODE>16  while(Fgets(buff, MAXLINE, fp) != NULL)</CODE></P>
      <P><CODE>17   Fputs(buff, stdout);</CODE></P>
      <P><CODE>18  Pclose(fp);</CODE></P>
      <P><CODE>19  exit(0);</CODE></P>
      <P><CODE>20 }</CODE></P>
      <P>8-17 Полное имя файла считывается из стандартного потока ввода, как и в программе в листинге 4.2. Формируется командная строка, которая передается popen. Вывод интерпретатора команд или команды cat копируется в стандартный поток вывода.</P>
      <P>Одним из отличий этой реализации от приведенной в листинге 4.1 является отсутствие возможности формировать собственные сообщения об ошибках. Теперь мы целиком зависим от программы cat, а выводимые ею сообщения не всегда адекватны. Например, в системе Solaris 2.6 при попытке считать данные из файла, доступ на чтение к которому для нас запрещен, будет выведена следующая ошибка:</P>
      <P><CODE>solaris % <STRONG>cat/etc/shadow</STRONG></CODE></P>
      <P><CODE>cat: cannot open /etc/shadow</CODE> </P>
      <P>А в BSD/OS 3.1 мы получим более информативное сообщение в аналогичной ситуации:</P>
      <P><CODE>bsdi % <STRONG>cat /etc/master.passwd</STRONG></CODE></P>
      <P><CODE>cat: /etc/master.passwd: cannot open [Permission denied]</CODE></P>
      <P>Обратите также внимание на тот факт, что вызов popen в данном случае оказывается успешным, однако при первом же вызове fgets будет возвращен символ конца файла (EOF). Программа cat записывает сообщение об ошибке в стандартный поток сообщений об ошибках (stderr), а popen с этим потоком не связывается — к создаваемому каналу подключается только стандартный поток вывода.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label73 style="border:none;"></a>4.6. Именованные каналы (FIFO)</P>
     </H1>
     <DIV class=section>
      <P>Программные каналы не имеют имен, и их главным недостатком является невозможность передачи информации между неродственными процессами. Два неродственных процесса не могут создать канал для связи между собой (если не передавать дескриптор).</P>
      <P>Аббревиатура FIFO расшифровывается как «first in, first out» — «первым вошел, первым вышел», то есть эти каналы работают как очереди. Именованные каналы в Unix функционируют подобно неименованным — они позволяют передавать данные только в одну сторону. Однако в отличие от программных каналов каждому каналу FIFO сопоставляется полное имя в файловой системе, что позволяет двум неродственным процессам обратиться к одному и тому же FIFO.</P>
      <P>FIFO создается функцией mkfifо:</P>
      <P><CODE>#include &lt;sys/types.h&gt;</CODE></P>
      <P><CODE>#include &lt;sys/stat.h&gt;</CODE></P>
      <P><CODE>int mkfifo(const char *<EM>раthnаme</EM>, mode_t <EM>mоdе</EM>);</CODE></P>
      <P><CODE>/* Возвращает 0 при успешном выполнении, –1 – при возникновении ошибок */</CODE></P>
      <P>Здесь <EM>pathname</EM> — обычное для Unix полное имя файла, которое и будет именем FIFO.</P>
      <P>Аргумент mode указывает битовую маску разрешений доступа к файлу, аналогично второму аргументу команды open. В табл. 2.3 приведены шесть констант, определенных в заголовке &lt;sys/stat.h&gt;. Эти константы могут использоваться для задания разрешений доступа и к FIFO.</P>
      <P>Функция mkfifo действует как open, вызванная с аргументом O_CREAT | O_EXCL. Это означает, что создается новый канал FIFO или возвращается ошибка EEXIST, в случае если канал с заданным полным именем уже существует. Если не требуется создавать новый канал, вызывайте open вместо mkfifo. Для открытия существующего канала или создания нового в том случае, если его еще не существует, вызовите mkfifo, проверьте, не возвращена ли ошибка EEXIST, и если такое случится, вызовите функцию open.</P>
      <P>Команда mkfifо также создает канал FIFO. Ею можно пользоваться в сценариях интерпретатора или из командной строки.</P>
      <P>После создания канал FIFO должен быть открыт на чтение или запись с помощью либо функции open, либо одной из стандартных функций открытия файлов из библиотеки ввода-вывода (например, fopen). FIFO может быть открыт либо только на чтение, либо только на запись. Нельзя открывать канал на чтение и запись, поскольку именованные каналы могут быть только односторонними. </P>
      <P>При записи в программный канал или канал FIFO вызовом write данные всегда добавляются к уже имеющимся, а вызов read считывает данные, помещенные в программный канал или FIFO первыми. При вызове функции lseek для программного канала или FIFO будет возвращена ошибка ESPIPE.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label74 style="border:none;"></a>Пример</P>
      </H1>
      <P>Переделаем программу, приведенную в листинге 4.1, таким образом, чтобы использовать два канала FIFO вместо двух программных каналов. Функции client и server останутся прежними; отличия появятся только в функции main, новый текст которой приведен в листинге 4.6.</P>
      <H2><a name=label75 style="border:none;"></a>Листинг 4.6. Функция main приложения клиент-сервер, использующего две очереди</H2>
      <P><CODE>//pipe/mainfifo.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #define FIFO1 "/tmp/fifo.1"</CODE></P>
      <P><CODE>3  #define FIFO2 "/tmp/fifo.2"</CODE></P>
      <P><CODE>4  void client(int, int), server(int. int);</CODE></P>
      <P><CODE>5  int</CODE></P>
      <P><CODE>6  main(int argc, char **argv)</CODE></P>
      <P><CODE>7  {</CODE></P>
      <P><CODE>8   int readfd, writefd;</CODE></P>
      <P><CODE>9   pid_t childpid;</CODE></P>
      <P><CODE>10  /* создание двух FIFO, если существуют – OK */</CODE></P>
      <P><CODE>11  if ((mkfifo(FIF01, FILE_MODE) &lt; 0) &amp;&amp; (errno != EEXIST))</CODE></P>
      <P><CODE>12   err_sys("can't create %s", FIF01);</CODE></P>
      <P><CODE>13  if ((mkfifo(FIF02, FILE_MODE) &lt; 0) &amp;&amp; (errno != EEXIST)) {</CODE></P>
      <P><CODE>14   unlink(FIF01);</CODE></P>
      <P><CODE>15   err_sys("can't create %s", FIF02);</CODE></P>
      <P><CODE>16  }</CODE></P>
      <P><CODE>17  if ((childpid = Fork()) == 0) { /* child */</CODE></P>
      <P><CODE>18   readfd = Open(FIF01, O_RDONLY, 0);</CODE></P>
      <P><CODE>19   writefd = Open(FIF02, O_WRONLY, 0);</CODE></P>
      <P><CODE>20   server(readfd, writefd);</CODE></P>
      <P><CODE>21   exit(0);</CODE></P>
      <P><CODE>22  }</CODE></P>
      <P><CODE>23  /* родительский процесс */</CODE></P>
      <P><CODE>24  writefd = Open(FIF01, O_WRONLY, 0);</CODE></P>
      <P><CODE>25  readfd = Open(FIF02, O_RDONLY, 0);</CODE></P>
      <P><CODE>26  client(readfd, writefd);</CODE></P>
      <P><CODE>27  waitpid(childpid, NULL, 0); /* ожидание завершения дочернего процесса */</CODE></P>
      <P><CODE>28  Close(readfd):</CODE></P>
      <P><CODE>29  Close(writefd);</CODE></P>
      <P><CODE>30  Unlink(FIF01);</CODE></P>
      <P><CODE>31  Unlink(FIF02);</CODE></P>
      <P><CODE>32  exit(0);</CODE></P>
      <P><CODE>33 }</CODE></P>
      <H2><a name=label76 style="border:none;"></a>Создание двух FIFO</H2>
      <P>10-16 В файловой системе в каталоге /tmp создается два канала. Если какой-либо из них уже существует — ничего страшного. Константа FILE_MODE определена в нашем заголовке unpiрс.h (листинг В.1) как</P>
      <P><CODE>#define FILEMODE(S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)</CODE></P>
      <P><CODE>/* разрешения по умолчанию для вновь создаваемых файлов */</CODE></P>
      <P>При этом владельцу файла разрешается чтение и запись в него, а группе и прочим пользователям — только чтение. Эти биты разрешений накладываются на маску режима доступа создаваемых файлов (file mode creation mask) процесса.</P>
      <P>17-27 Далее происходит вызов fork, дочерний процесс вызывает функцию server (листинг 4.3), а родительский процесс вызывает функцию client (листинг 4.2). Перед вызовом этих функций родительский процесс открывает первый канал на запись, а второй на чтение, в то время как дочерний процесс открывает первый канал на чтение, а второй — на запись. Картина аналогична примеру с каналами и иллюстрируется рис. 4.11. </P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader81" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 4.11. Приложение клиент-сервер, использующее две очереди</P>
      <BR>
      <P>Изменения по сравнению с примером, в которым использовались программные каналы, следующие:</P>
      <P>■ Для создания и открытия программного канала требуется только один вызов — pipe. Для создания и открытия FIFO требуется вызов mkfifo и последующий вызов open.</P>
      <P>■ Программный канал автоматически исчезает после того, как будет закрыт последним использующим его процессом. Канал FIFO удаляется из файловой системы только после вызова unlink. Польза от лишнего вызова, необходимого для создания FIFO, следующая: канал FIFO получает имя в файловой системе, что позволяет одному процессу создать такой канал, а другому открыть его, даже если последний не является родственным первому. С программными каналами это неосуществимо.</P>
      <P>В программах, некорректно использующих каналы FIFO, могут возникать неочевидные проблемы. Рассмотрим, например, листинг 4.6: если поменять порядок двух вызовов функции open в породившем процессе, программа перестанет работать. Причина в том, что чтение из FIFO блокирует процесс, если канал еще не открыт на запись каким-либо другим процессом. Действительно, если мы меняем порядок вызовов open в породившем процессе, и породивший, и порожденный процессы открывают канал на чтение, притом что на запись он еще не открыт, так что оба процесса блокируются. Такая ситуация называется блокированием, или зависанием (deadlock). Она будет рассмотрена подробно в следующем разделе.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label77 style="border:none;"></a>Пример: неродственные клиент и сервер</P>
      </H1>
      <P>В листинге 4.6 клиент и сервер все еще являлись родственными процессами. Переделаем этот пример так, чтобы родство между ними отсутствовало. В листинге 4.7 приведен текст программы-сервера. Текст практически идентичен той части программы из листинга 4.6, которая относилась к серверу.</P>
      <P>Содержимое заголовка fifо.h приведено в листинге 4.8. Этот файл определяет имена двух FIFO, которые должны быть известны как клиенту, так и серверу.</P>
      <P>В листинге 4.9 приведен текст программы-клиента, которая не слишком отличается от части программы из листинга 4.6, относящейся к клиенту. Обратите внимание, что именно клиент, а не сервер удаляет канал FIFO по завершении работы, потому что последние операции с этим каналом выполняются им.</P>
      <H2><a name=label78 style="border:none;"></a>Листинг 4.7. Функция main независимого сервера</H2>
      <P><CODE>//pipe/server_main.c</CODE></P>
      <P><CODE>1  #include "fifo.h"</CODE></P>
      <P><CODE>2  void server(int, int);</CODE></P>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int readfd, writefd;</CODE></P>
      <P><CODE>7   /* создание двух FIFO. OK, если они существуют */</CODE></P>
      <P><CODE>8   if ((mkfifo(FIF01, FILE_MODE) &lt; 0) &amp;&amp; (errno != EEXIST))</CODE></P>
      <P><CODE>9    err_sys("can't create %s", FIF01);</CODE></P>
      <P><CODE>10  if ((mkfifo(FIF02, FILE MODE) &lt; 0) &amp;&amp; (errno != EEXIST)) {</CODE></P>
      <P><CODE>11   unlink(FIF01);</CODE></P>
      <P><CODE>12   err_sys("can't create %s", FIF02);</CODE></P>
      <P><CODE>13  }</CODE></P>
      <P><CODE>14  readfd = Open(FIF01, O_RDONLY, 0);</CODE></P>
      <P><CODE>15  writefd = Open(FIFO2, O_WRONLY, 0);</CODE></P>
      <P><CODE>16  server(readfd, writefd);</CODE></P>
      <P><CODE>17  exit(0);</CODE></P>
      <P><CODE>18 }</CODE> </P>
      <H2><a name=label79 style="border:none;"></a>Листинг 4.8. Заголовочный файл fifo.h, используемый и клиентом, и сервером</H2>
      <P><CODE>//pipe/fifo.h</CODE></P>
      <P><CODE>1 #include "unpipc.h"</CODE></P>
      <P><CODE>2 #define FIFO1 "/tmp/fifo.1"</CODE></P>
      <P><CODE>3 #define FIFO2 "/tmp/fifo.2"</CODE></P>
      <H2><a name=label80 style="border:none;"></a>Листинг 4.9. Функция main независимого клиента</H2>
      <P><CODE>//pipe/client_main.c</CODE></P>
      <P><CODE>1  #include "fifo.h"</CODE></P>
      <P><CODE>2  void client(int, int);</CODE></P>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int readfd, writefd;</CODE></P>
      <P><CODE>7   writefd = Open(FIFO1, O_WRONLY, 0);</CODE></P>
      <P><CODE>8   readfd = Open(FIFO2, O_RDONLY, 0);</CODE></P>
      <P><CODE>9   client(readfd, writefd);</CODE></P>
      <P><CODE>10  Close(readfd);</CODE></P>
      <P><CODE>11  Close(writefd);</CODE></P>
      <P><CODE>12  Unlink(FIFO1);</CODE></P>
      <P><CODE>13  UnLink(FIFO2);</CODE></P>
      <P><CODE>14  exit(0);</CODE></P>
      <P><CODE>15 }</CODE></P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Для программных каналов и каналов FIFO ядро ведет подсчет числа открытых дескрипторов, относящихся к ним, поэтому безразлично, кто именно вызовет unlink — клиент или сервер. Хотя эта функция и удаляет файл из файловой системы, она не влияет на открытые в момент ее выполнения дескрипторы. Однако для других форм IPC, таких как очереди сообщений стандарта System V, счетчик отсутствует, и если сервер удалит очередь после записи в нее последнего сообщения, она может быть удалена еще до того, как клиент это сообщение считает.</P>
      </DIV>
      <P>Для запуска клиента и сервера запустите сервер в фоновом режиме:</P>
      <P><CODE>% server_fifo &amp;</CODE></P>
      <P>а затем запустите клиент. Можно было сделать и по-другому: запускать только программу-клиент, которая запускала бы сервер с помощью fork и exec. Клиент мог бы передавать серверу имена FIFO в качестве аргументов командной строки в команде exec, вместо того чтобы обе программы считывали их из заголовка. Но в этом случае сервер являлся бы дочерним процессом и проще было бы обойтись программным каналом.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label81 style="border:none;"></a>4.7. Некоторые свойства именованных и неименованных каналов</P>
     </H1>
     <P>Некоторые свойства именованных и неименованных каналов, относящиеся к их открытию, а также чтению и записи данных, заслуживают более пристального внимания. Прежде всего можно сделать дескриптор неблокируемым двумя способами. </P>
     <P>1. При вызове open указать флаг O_NONBLOCK. Например, первый вызов open в листинге 4.9 мог бы выглядеть так:</P>
     <P><CODE>writefd = Open(FIFO1, O_WRONLY | O_NONBLOCK, 0);</CODE></P>
     <P>2. Если дескриптор уже открыт, можно использовать fcntl для включения флага O_NONBLOCK. Этот прием нужно применять для программных каналов, поскольку для них не вызывается функция open и нет возможности указать флаг O_NONBLOCK при ее вызове. Используя fcntl, мы сначала получаем текущий статус файла с помощью F_GETFL, затем добавляем к нему с помощью побитового логического сложения (OR) флаг O_NONBLOCK и записываем новый статус с помощью команды F_SETFL:</P>
     <P><CODE>int flags;</CODE></P>
     <P><CODE>if ((flags = fcntl(fd, F_GETFL, 0)) &lt; 0) err_sys("F_GETFL error");</CODE></P>
     <P><CODE>flags |= O_NONBLOCK;</CODE></P>
     <P><CODE>if (fcntl(fd, F_SETFL, flags) &lt; 0) err_sys("F_SETFL error");</CODE></P>
     <P>Будьте аккуратны с программами, которые просто устанавливают требуемый флаг, поскольку при этом сбрасываются все прочие флаги состояния:</P>
     <P><CODE>/* Неправильное отключение блокировки */</CODE></P>
     <P><CODE>if (fcntl(fd, F_SETFL, O_NONBLOCK) &lt; 0) err_sys("F_SETFL error");</CODE></P>
     <P>Таблица 4.1 иллюстрирует действие флага, отключающего блокировку, при открытии очереди и при чтении данных из пустого программного канала или канала FIFO.</P>
     <BR>
     <P>Таблица 4.1. Действие флага O_NONBLOCK на именованные и неименованные каналы </P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Операция</TH>
       <TH ALIGN=left VALIGN=top >Наличие открытых каналов</TH>
       <TH ALIGN=left VALIGN=top >Блокировка включена (по умолчанию)</TH>
       <TH ALIGN=left VALIGN=top >Флаг O_NONBLOCK установлен</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Открытие (open) FIFO только для чтения</TD>
       <TD ALIGN=left VALIGN=top >FIFO открыт на запись</TD>
       <TD ALIGN=left VALIGN=top >Возвращается код успешного завершения операции</TD>
       <TD ALIGN=left VALIGN=top >Возвращается код успешного завершения операции</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Открытие (open) FIFO только для чтения</TD>
       <TD ALIGN=left VALIGN=top >FIFO не открыт на запись</TD>
       <TD ALIGN=left VALIGN=top >Процесс блокируется, пока FIFO не будет открыт на запись</TD>
       <TD ALIGN=left VALIGN=top >Возвращается код успешного завершения операции</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Открытие (open) FIFO только для записи</TD>
       <TD ALIGN=left VALIGN=top >FIFO открыт на чтение</TD>
       <TD ALIGN=left VALIGN=top >Возвращает код успешного завершения операции</TD>
       <TD ALIGN=left VALIGN=top >Возвращает код успешного завершения операции</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Открытие (open) FIFO только для записи</TD>
       <TD ALIGN=left VALIGN=top >FIFO не открыт на чтение</TD>
       <TD ALIGN=left VALIGN=top >Блокируется до тех пор, пока FIFO не будет открыт на чтение</TD>
       <TD ALIGN=left VALIGN=top >Возвращает ошибку с кодом ENXIO</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Чтение (read) из пустого программного канала или FIFO</TD>
       <TD ALIGN=left VALIGN=top >Программный канал или FIFO открыт на запись</TD>
       <TD ALIGN=left VALIGN=top >Блокируется до тех пор, пока в программный канал или FIFO не будут помещены данные или они не будут закрыты всеми процессами, которыми они были открыты на запись</TD>
       <TD ALIGN=left VALIGN=top >Возвращает ошибку с кодом EAGAIN</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Чтение (read) из пустого программного канала или FIFO</TD>
       <TD ALIGN=left VALIGN=top >Программный канал или FIFO не открыт на запись</TD>
       <TD ALIGN=left VALIGN=top >read возвращает 0 (конец файла)</TD>
       <TD ALIGN=left VALIGN=top >read возвращает 0 (конец файла)</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Запись (write) в программный канал или FIFO</TD>
       <TD ALIGN=left VALIGN=top >Программный канал или FIFO открыт на чтение</TD>
       <TD ALIGN=left VALIGN=top >(См. в тексте)</TD>
       <TD ALIGN=left VALIGN=top >(См. в тексте)</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Запись (write) в программный канал или FIFO</TD>
       <TD ALIGN=left VALIGN=top >Программный канал или FIFO не открыт на чтение</TD>
       <TD ALIGN=left VALIGN=top >Программному потоку посылается сигнал SIGPIPE</TD>
       <TD ALIGN=left VALIGN=top >Программному потоку посылается сигнал SIGPIPE </TD>
      </TR>
     </TABLE>
     <P>Запомните несколько дополнительных правил, действующих при чтении и записи данных в программные каналы и FIFO.</P>
     <P>■ При попытке считать больше данных, чем в данный момент содержится в программном канале или FIFO, возвращается только имеющийся объем данных. Нужно предусмотреть обработку ситуации, в которой функция read возвращает меньше данных, чем было запрошено.</P>
     <P>■ Если количество байтов, направленных на запись функции write, не превышает значения PIPE_BUF (ограничение, устанавливаемое стандартом Posix, о котором более подробно рассказывается в разделе 4.11), то ядро гарантирует <EM>атомарность</EM> операции записи. Это означает, что если два процесса запишут данные в программный канал или FIFO приблизительно одновременно, то в буфер будут помещены сначала все данные от первого процесса, а затем от второго, либо наоборот. Данные от двух процессов при этом не будут смешиваться. Однако если количество байтов превышает значение PIPEBUF, атомарность операции записи не гарантируется.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Posix.1 требует, чтобы значение PIPE_BUF равнялось по меньшей мере 512. Характерные значения, встречающиеся на практике, лежат в диапазоне от 1024 (BSD/OS 3.1) до 5120 байт (Solaris 2.6). В разделе 4.11 приведен текст программы, выводящей значение этой константы.</P>
     </DIV>
     <P>■ Установка флага O_NONBLOCK не влияет на атомарность операции записи в про-грaммный канал или FIFO — она определяется исключительно объемом посылаемых данных в сравнении с величиной PIPE_BUF. Однако если для прогрaммнoгo канала или FIFO отключена блокировка, возвращаемое функцией write значение зависит от количества байтов, отправленных на запись, и наличия свободного места в пpoгрaммнoм канале или FIFO. Если количество байтов не превышает величины PIPE_BUF, то:</P>
     <P> □ Если в канале достаточно места для записи требуемого количества данных, они будут переданы все сразу.</P>
     <P> □ Если места в пpoгрaммнoм канале или FIFO недостаточно для записи требуемого объема данных, происходит немедленное завершение работы функции с возвратом ошибки EAGAIN. Поскольку установлен флаг O_NONBLOCK, процесс не может быть заблокирован, но в то же время ядро не может принять лишь часть данных, так как при этом невозможно гарантировать атомарность операции записи. Поэтому ядро возвращает ошибку, сообщающую процессу о необходимости попытаться произвести запись еще раз.</P>
     <P>■ Если количество байтов превышает значение PIPE_BUF, то:</P>
     <P> □ Если в программном канале или FIFO есть место хотя бы для одного байта, ядро передает в буфер ровно столько данных, сколько туда может поместиться, и это переданное количество возвращается функцией write.</P>
     <P> □ Если в программном канале или FIFO свободное место отсутствует, происходит немедленное завершение работы с возвратом ошибки EAGAIN.</P>
     <P>■ При записи в программный канал или FIFO, не открытый для чтения, ядро посылает сигнал SIGPIPE:</P>
     <P> □ Если процесс не принимает (catch) и не игнорирует SIGPIPE, выполняется действие по умолчанию — завершение работы процесса.</P>
     <P> □ Если процесс игнорирует сигнал SIGPIPE или перехватывает его и возвращается из подпрограммы его обработки, write возвращает ошибку с кодом EPIPE.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>SIGPIPE считается синхронным сигналом, что означает, что он привязан к конкретному программному потоку, а именно тому, который вызвал функцию write. Простейшим способом обработки сигнала является его игнорирование (установка SIG_IGN) и предоставление функции write возможности вернуть ошибку с кодом EPIPE. В приложении всегда должна быть предусмотрена обработка ошибок, возвращаемых функцией write, а вот определить, что процесс был завершен сигналом SIGPIPE, сложнее. Если сигнал не перехватывается, придется посмотреть на статус завершения работы процесса (termination status) из интерпретатора команд, чтобы узнать, что процесс был принудительно завершен сигналом и каким именно сигналом. В разделе 5.13 [24] о сигнале SIGPIPE рассказывается более подробно.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label82 style="border:none;"></a>4.8. Один сервер, несколько клиентов</P>
     </H1>
     <DIV class=section>
      <P>Преимущества канала FIFO проявляются более явно в том случае, когда сервер представляет собой некоторый длительно функционирующий процесс (например, демон, наподобие описанного в главе 12 [24]), не являющийся родственным клиенту. Демон создает именованный канал с вполне определенным известным именем, открывает его на чтение, а запускаемые впоследствии клиенты открывают его на запись и отправляют демону команды и необходимые данные. Односторонняя связь в этом направлении (от клиента к серверу) легко реализуется с помощью FIFO, однако необходимость отправки данных в обратную сторону (от сервера к клиенту) усложняет задачу. Рисунок 4.12 иллюстрирует прием, применяемый в этом случае. </P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader85" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 4.12. Один сервер, несколько клиентов</P>
      <BR>
      <P>Сервер создает канал с известным полным именем, в данном случае /tmp/fifо.serv. Из этого канала он считывает запросы клиентов. Каждый клиент при запуске создает свой собственный канал, полное имя которого определяется его идентификатором процесса. Клиент отправляет свой запрос в канал сервера с известным именем, причем запрос этот содержит идентификатор процесса клиента и имя файла, отправку которого клиент запрашивает у сервера. В листинге 4.10 приведен текст программы сервера.</P>
      <H2><a name=label83 style="border:none;"></a>Листинг 4.10. Сервер, обслуживающий несколько клиентов с помощью канала FIFO</H2>
      <P><CODE>//fifocliserv/mainserver.с</CODE></P>
      <P><CODE>1  #include "fifo.h"</CODE></P>
      <P><CODE>2  void server(int, int);</CODE></P>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int readfifo, writefifo, dummyfd, fd;</CODE></P>
      <P><CODE>7   char *ptr, buff[MAXLINE], fifoname[MAXLINE];</CODE></P>
      <P><CODE>8   pid_t pid;</CODE></P>
      <P><CODE>9   ssize_t n;</CODE></P>
      <P><CODE>10  /* создание FIFO сервера с известным именем. ОК, если уже существует */</CODE></P>
      <P><CODE>11  if ((mkfifo(SERV_FIFO, FILE_MODE) &lt; 0) &amp;&amp; (errno != EEXIST))</CODE></P>
      <P><CODE>12   err_sys("can't create %s", SERV_FIFO);</CODE></P>
      <P><CODE>13  /* открытие FIFO-cepвepa на чтение */</CODE></P>
      <P><CODE>14  readfifo = Open(SERV_FIFO, O_RDONLY, 0);</CODE></P>
      <P><CODE>15  dummyfd = Open(SERV_FIFO, O_WRONLY, 0); /* не используется */</CODE></P>
      <P><CODE>16  while ((n = Readline(readfifo, buff, MAXLINE)) &gt; 0) {</CODE></P>
      <P><CODE>17   if (buff[n-1] == '\n')</CODE></P>
      <P><CODE>18    n--; /* delete newline from readline() */</CODE></P>
      <P><CODE>19   buff[n] = '\0'; /* полное имя, завершаемое 0 */</CODE></P>
      <P><CODE>20   if ((ptr = strchr(buff, ' ')) == NULL) {</CODE></P>
      <P><CODE>21    err_msg("bogus request: ls", buff);</CODE></P>
      <P><CODE>22    continue;</CODE></P>
      <P><CODE>23   }</CODE></P>
      <P><CODE>24   *ptr++ = 0; /* идентификатор процесса, указатель на имя файла */</CODE></P>
      <P><CODE>25   pid = atol(buff);</CODE></P>
      <P><CODE>26   snprintf(fifoname, sizeof(fifoname), "/tmp/fifo.%ld", (long) pid);</CODE></P>
      <P><CODE>27   if ( (writefifo = open(fifoname, O_WRONLY, 0)) &lt; 0) {</CODE></P>
      <P><CODE>28    err_msg("cannot open: ls", fifoname);</CODE></P>
      <P><CODE>29    continue;</CODE></P>
      <P><CODE>30   }</CODE></P>
      <P><CODE>31   if ((fd = open(ptr, O_RDONLY)) &lt; 0) {</CODE></P>
      <P><CODE>32    /* ошибка, нужно сообщить клиенту */</CODE></P>
      <P><CODE>33    snprintf(buff + n, sizeof(buff) – n, ": can't open, %s\n",</CODE></P>
      <P><CODE>34     strerror(errno));</CODE></P>
      <P><CODE>35    n = strlen(ptr);</CODE></P>
      <P><CODE>36    Write(writefifo, ptr, n);</CODE></P>
      <P><CODE>37    Close(writefifo);</CODE></P>
      <P><CODE>38</CODE></P>
      <P><CODE>39   } else {</CODE></P>
      <P><CODE>40    /* успешное открытие, копируем файл */</CODE></P>
      <P><CODE>41    while ((n = Read(fd, buff, MAXLINE)) &gt; 0)</CODE></P>
      <P><CODE>42     Write(writefifo, buff, n);</CODE></P>
      <P><CODE>43    Close(fd);</CODE></P>
      <P><CODE>44    Close(writefifo);</CODE></P>
      <P><CODE>45   }</CODE></P>
      <P><CODE>46  }</CODE></P>
      <P><CODE>47 }</CODE></P>
      <H2><a name=label84 style="border:none;"></a>Создание канала и открытие его только для записи и только для чтения</H2>
      <P>10-15 Сервер создает канал FIFO с известным именем, обрабатывая ситуацию, когда такой канал уже существует. Затем этот канал открывается дважды: один раз только для чтения, а второй — только для записи. Дескриптор readfifo используется для приема запросов от клиентов, а дескриптор dummyfd не используется вовсе. Причина, по которой нужно открыть канал для записи, видна из табл. 4.1. Если канал не открыть на запись, то при завершении работы очередного клиента этот канал будет опустошаться и сервер будет считывать 0, означающий конец файла. Пришлось бы каждый раз закрывать канал вызовом close, а затем заново открывать его с флагом O_RDONLY, что приводило бы к блокированию демона до подключения следующего клиента. Мы же всегда будем иметь дескриптор, открытый на запись, поэтому функция read не будет возвращать 0, означающий конец файла, при отсутствии клиентов. Вместо этого сервер просто будет блокироваться при вызове read, ожидая подключения следующего клиента. Этот трюк упрощает код программы-сервера и уменьшает количество вызовов open для канала сервера.</P>
      <P>При запуске сервера первый вызов open (с флагом O_RDONLY) приводит к блокированию процесса до появления первого клиента, открывающего канал сервера на запись (см. табл. 4.1). Второй вызов open (с флагом O_WRONLY) не приводит к блокированию, поскольку канал уже открыт на запись. </P>
      <H2><a name=label85 style="border:none;"></a>Считывание запроса от клиента</H2>
      <P>16 Каждый запрос, принимаемый от клиента, представляет собой одну строку, состоящую из идентификатора процесса, пробела и полного имени требуемого файла. Эта строка считывается функцией readline (приведенной в [24, с.79]).</P>
      <H2><a name=label86 style="border:none;"></a>Анализ запроса клиента</H2>
      <P>17-26 Символ перевода строки, возвращаемый функцией readline, удаляется. Этот символ может отсутствовать только в том случае, если буфер был заполнен, прежде чем был обнаружен символ перевода строки, либо если последняя введенная строка не была завершена этим символом. Функция strchr возвращает указатель на первый пробел в этой строке, который затем увеличивается на единицу, чтобы он указывал на первый символ полного имени файла, следующего за пробелом. Полное имя канала клиента формируется из его идентификатора процесса, и этот канал открывается сервером на запись.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label87 style="border:none;"></a>Открытие файла и отправка его в FIFO клиента</P>
      </H1>
      <P>27-44 Оставшаяся часть кода пpoгрaммы-cepвepa аналогична функции server из листинга 4.3. Программа открывает файл; если при этом возникает ошибка — клиенту отсылается сообщение о ней. Если открытие файла завершается успешно, его содержимое копируется в канал клиента. После завершения копирования открытый сервером «конец» (дескриптор) канала клиента должен быть закрыт с помощью функции close, чтобы функция read вернула пpoгрaммe-клиeнтy значение 0 (конец файла). Сервер не удаляет канал клиента; клиент должен самостоятельно позаботиться об этом после приема от сервера символа конца файла. Текст пpoгрaммы-клиeнтa приведен в листинге 4.11.</P>
      <H2><a name=label88 style="border:none;"></a>Листинг 4.11. Клиент, связывающийся с сервером (листинг 4.10) с помощью канала FIFO</H2>
      <P><CODE>//fifocliserv/mainclient.с</CODE></P>
      <P><CODE>1  #include "fifo.h"</CODE></P>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int readfifo, writefifo;</CODE></P>
      <P><CODE>6   size_t len;</CODE></P>
      <P><CODE>7   ssize_t n;</CODE></P>
      <P><CODE>8   char *ptr, fifoname[MAXLINE], buff[MAXLINE];</CODE></P>
      <P><CODE>9   pid_t pid;</CODE></P>
      <P><CODE>10  /* создание FIFO с включением в его имя PID */</CODE></P>
      <P><CODE>11  pid = getpid();</CODE></P>
      <P><CODE>12  snprintf(fifoname, sizeof(fifoname), "/tmp/fifo,%ld", (long) pid):</CODE></P>
      <P><CODE>13  if ((mkfifo(fifoname, FILE_MODE) &lt; 0) &amp;&amp; (errno != EEXIST))</CODE></P>
      <P><CODE>14   err_sys("can't create %s", fifoname);</CODE></P>
      <P><CODE>15  /* инициализация буфера PID и пробелом */</CODE></P>
      <P><CODE>16  snprintf(buff, sizeof(buff), "%ld ", (long) pid);</CODE></P>
      <P><CODE>17  len = strlen(buff);</CODE></P>
      <P><CODE>18  ptr = buff + len;</CODE></P>
      <P><CODE>19  /* считывание полного имени */</CODE></P>
      <P><CODE>20  Fgets(ptr, MAXLINE – len, stdin);</CODE></P>
      <P><CODE>21  len = strlen(buff); /* fgets() гарантирует завершающий 0 */</CODE></P>
      <P><CODE>22  /* открытие FIFO сервера и запись в него полного имени и PID */</CODE></P>
      <P><CODE>23  writefifo = Open(SERV_FIFO, O_WRONLY, 0);</CODE></P>
      <P><CODE>24  Write(writefifo, buff, len);</CODE></P>
      <P><CODE>25  /* открытие созданного FIFO; блокирование до открытия его сервером */</CODE></P>
      <P><CODE>26  readfifo = Open(fifoname, O_RDONLY; 0);</CODE></P>
      <P><CODE>27  /* считывание из канала IPC, запись в stdout */</CODE></P>
      <P><CODE>28  while ((n = Read(readfifo, buff, MAXLINE)) &gt; 0)</CODE></P>
      <P><CODE>29   Write(STDOUT_FILENO, buff, n);</CODE></P>
      <P><CODE>30  Close(readfifo);</CODE></P>
      <P><CODE>31  Unlink(fifoname);</CODE></P>
      <P><CODE>32  exit(0);</CODE></P>
      <P><CODE>33 }</CODE></P>
      <H2><a name=label89 style="border:none;"></a>Создание канала</H2>
      <P>10-14 Идентификатор процесса клиента содержится в имени создаваемого им канала.</P>
      <H2><a name=label90 style="border:none;"></a>Формирование строки запроса</H2>
      <P>15-21 Запрос клиента состоит из его идентификатора процесса, одного пробела, полного имени запрашиваемого им файла и символа перевода строки. Строка запроса формируется в массиве buff, причем имя файла считывается из стандартного потока ввода.</P>
      <H2><a name=label91 style="border:none;"></a>Открытие канала сервера и отправка запроса</H2>
      <P>22-24 Клиент открывает канал сервера и записывает в него строку запроса. Если клиент окажется первым с момента запуска сервера, вызов open разблокирует сервер, заблокированный после сделанного им вызова open (с флагом O_RDONLY).</P>
      <H2><a name=label92 style="border:none;"></a>Прием содержимого файла или сообщения об ошибке от сервера</H2>
      <P>25-31 Ответ сервера считывается из канала и записывается в стандартный поток вывода, после чего канал клиента закрывается и* удаляется.</P>
      <P>Сервер может быть запущен в одном из окон, а клиент — в другом, и программа будет работать так, как мы и рассчитывали. Ниже мы приводим только текст, выводимый клиентом:</P>
      <P><CODE>solaris % <STRONG>mainclient /etc/shadow</STRONG>          <EM>файл, который нам нельзя читать</EM></CODE></P>
      <P><CODE>/etc/shadow: can't open. Permission denied</CODE></P>
      <P><CODE>solaris % <STRONG>mainclient /etc/inet/ntp.conf</STRONG>  <EM>файл из двух строк</EM></CODE></P>
      <P><CODE>multicastclient 224.0.1.1</CODE></P>
      <P><CODE>driftfile /etc/inet/ntp.drift</CODE> </P>
      <P>Мы можем также связаться с сервером из интерпретатора команд, поскольку каналы FIFO обладают именами в файловой системе.</P>
      <P><CODE>solaris % <STRONG>Pid=$$</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>mkfifo /tmp/fifo.$Pid</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>echo "$Pid /etc/inet/ntp.conf" &gt; /tmp/fifo.serv</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>cat &lt; /tmp/fifo.$Pid</STRONG></CODE></P>
      <P><CODE>multicastclient 224.0.1.1</CODE></P>
      <P><CODE>driftfile /etc/inet/ntp.drift</CODE></P>
      <P><CODE>solaris % <STRONG>rm /tmp/fifo.$Pid</STRONG></CODE></P>
      <P>Мы отсылаем серверу идентификатор процесса текущей копии интерпретатора и полное имя файла одной командой интерпретатора (echo) и считываем из канала сервера результат с помощью другой команды (cat). Между выполнением этих двух команд может пройти произвольный промежуток времени. Таким образом, сервер помещает содержимое файла в канал, а клиент затем запускает команду cat, чтобы считать оттуда данные. Может показаться, что данные каким-то образом хранятся в канале, хотя он не открыт ни одним процессом. На самом деле все не так. После закрытия пpoгрaммнoгo канала или FIFO последним процессом с помощью команды close все данные, в нем находящиеся, теряются. В нашем примере сервер, считав строку запроса от клиента, блокируется при попытке открыть канал клиента, потому что клиент (наша копия интерпретатора) еще не открыл его на чтение (вспомним табл. 4.1). Только после вызова cat некоторое время спустя канал будет открыт на чтение, и тогда сервер разблокируется. Кстати, таким образом осуществляется атака типа «отказ в обслуживании» (denial-of-service attack), которую мы обсудим в следующем разделе.</P>
      <P>Использование интерпретатора позволяет провести простейшую проверку способности сервера обрабатывать ошибки. Мы можем отправить серверу строку без идeнтификaтopa процесса или отослать ему такой идентификатор, которому не соответствует никакой канал FIFO в каталоге /tmp. Например, если мы запустим сервер и введем нижеследующие строки:</P>
      <P><CODE>solaris % <STRONG>cat &gt; /tmp/fifo.serv /no/process/id</STRONG></CODE></P>
      <P><CODE>999999 /invalid/process/id</CODE></P>
      <P>то сервер выдаст текст:</P>
      <P><CODE>solaris % <STRONG>server</STRONG></CODE></P>
      <P><CODE>bogus request: /no/process/id</CODE></P>
      <P><CODE>cannot open: /tmp/fifo.999999</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label93 style="border:none;"></a>Атомарность записи в FIFO</P>
      </H1>
      <P>Наша простейшая пара клиент-сервер позволяет наглядно показать важность наличия свойства атомарности записи в пpoгрaммныe каналы и FIFO. Предположим, что два клиента посылают серверу запрос приблизительно в один и тот же момент. Первый клиент отправляет следующую строку:</P>
      <P><CODE>1234 /etc/inet/ntp.conf</CODE></P>
      <P>второй:</P>
      <P><CODE>9876 /etc/passwd</CODE></P>
      <P>Предполагая, что каждый клиент помещает данные в FIFO за один вызов write и кaждая строка имеет размер, не превышающий величины PIPE_BUF (что чаще всего заведомо выполняется, поскольку PIPE_BUF обычно лежит в диапазоне 1024-5120, а длина полного имени обычно oгрaничeнa 1024 байт), мы можем гарантировать, что в FIFO данные будут иметь следующий вид:</P>
      <P><CODE>1234 /etc/inet/ntp.conf</CODE></P>
      <P><CODE>9876 /etc/passwd</CODE></P>
      <P>либо</P>
      <P><CODE>9876 /etc/passwd</CODE></P>
      <P><CODE>1234 /etc/inet/ntp.conf</CODE></P>
      <P>Данные в канале не могут смешаться в «кашу», наподобие:</P>
      <P><CODE>1234 /etc/inet9876 /etc/passwd</CODE></P>
      <P><CODE>/ntp.conf</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label94 style="border:none;"></a>FIFO и NFS</P>
      </H1>
      <P>Каналы FIFO представляют собой вид IPC, который может использоваться только в пределах одного узла. Хотя FIFO и обладают именами в файловой системе, они могут применяться только в локальных файловых системах, но не в присоединенных сетевых (NFS).</P>
      <P><CODE>solaris % <STRONG>mkfifo /nsf/bsdi/usr/rstevens/fifo.temp</STRONG></CODE></P>
      <P><CODE>mkfifo: I/O error</CODE></P>
      <P>В этом примере файловая система /nfs/bsdi/usr — это файловая система /usr нa yзлe bsdi.</P>
      <P>Некоторые системы (например, BSD/OS) позволяют создавать FIFO в присоединенных файловых системах, но по ним нельзя передавать данные между узлами. В этом случае такой канал может использоваться лишь как «точка рандеву» в файловой системе между клиентами и серверами на одном и том же узле. Процесс, выполняемый на одном узле, <EM>нe мoжem</EM> послать данные через FIFO процессу, выполняемому на другом узле, даже если оба процесса смогут открыть этот канал, доступный обоим узлам через сетевую файловую систему.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label95 style="border:none;"></a>4.9. Последовательные и параллельные серверы</P>
     </H1>
     <DIV class=section>
      <P>Сервер в нашем простом примере из предыдущего раздела являлся последовательным сервером (iterative server). Он последовательно обрабатывал запросы клиентов, переходя к следующему только после полного завершения работы с предыдущим. Например, если два клиента пошлют запрос такому серверу приблизительно одновременно, причем один из них запросит 10-мегабайтный файл, отправка которого займет, например, 10 секунд, а второй — 10-байтный файл, то второму придется ждать по меньшей мере 10 секунд, пока не будет обслужен первый клиент.</P>
      <P>Альтернативой является параллельный сервер (concurrent server). Наиболее часто встречаемый в Unix вид такого сервера называется one-child-per-client (каждому клиенту — один дочерний процесс). Сервер вызывает fork для создания нового процесса каждый раз, когда появляется новый клиент. Дочерний процесс полностью обрабатывает запрос клиента, а поддержка многозадачности в Unix обеспечивает параллельность выполнения всех этих процессов. Однако существуют и другие методы решения задачи, подробно описанные в главе 27 [24]:</P>
      <P>■ создание пула дочерних процессов и передача нового клиента свободному дочернему процессу;</P>
      <P>■ создание одного пpoгрaммнoгo потока для каждого клиента;</P>
      <P>■ создание пула потоков и передача нового клиента свободному потоку.</P>
      <P>Хотя в [24] обсуждаются проблемы создания сетевых серверов, те же методы применимы и к серверам межпроцессного взаимодействия (IPC server), клиенты которых находятся на одном узле.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label96 style="border:none;"></a>Атака типа «отказ в обслуживании»</P>
      </H1>
      <P>Один из недостатков последовательных серверов был уже отмечен выше — некоторым клиентам приходится ждать дольше чем нужно, потому что их запросы приходят после запросов других клиентов, запрашивающих большие файлы. Существует и другая проблема. Вспомним наш пример с интерпретатором команд, приведенный после листинга 4.11, и относящееся к нему обсуждение того, что сервер блокируется при вызове open для FIFO клиента, если клиент еще не открыл этот канал (чего не происходит до выполнения cat). Это дает возможность злоумышленнику «подвесить» сервер, послав ему запрос, не открывая канала. Этот тип атаки называется «отказ в обслуживании» (Denial of Service — DoS). Чтобы исключить возможность такой атаки, нужно быть аккуратным при написании последовательной части любого сервера, учитывая возможность и потенциальную продолжительность его блокирования. Одним из методов решения проблемы является установка максимального времени ожидания для некоторых операций, однако обычно проще сделать сервер параллельным, а не последовательным, поскольку в данном случае атака будет действовать лишь на один из дочерних процессов, а не на весь сервер. Однако даже параллельный сервер не защищен от атаки полностью: злоумышленник все еще может послать множество запросов, что приведет к превышению предела количества порожденных сервером процессов и невозможности выполнения последующих вызовов fork.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label97 style="border:none;"></a>4.10. Потоки и сообщения</P>
     </H1>
     <P>Приведенные примеры пpoгрaммныx каналов и каналов FIFO использовали потоковую модель ввода-вывода, что естественно для Unix. При этом отсутствуют грaницы записей — данные при операциях чтения и записи не проверяются вовсе. Процесс, считывающий 100 байт из FIFO, не может определить, записал ли другой процесс в FIFO все 100 байт за 1 раз, или за 5 раз по 20 байт, или в любой другой комбинации общим объемом 100 байт. Возможно, один процесс записал в FIFO 55 байт, а потом другой — 45. Данные представляют собой просто поток байтов, никак не интерпретируемых системой. Если же требуется какая-либо интерпретация данных, пишущий и читающий процессы должны заранее «договориться» о ее правилах и выполнять всю работу самостоятельно.</P>
     <P>Иногда приложению может потребоваться передавать данные, обладающие некоторой внутренней структурой. Это могут быть, например, сообщения переменной длины: в этом случае читающий процесс должен знать, где заканчивается одно сообщение и начинается следующее. Для разграничения сообщений широко используются три метода:</P>
     <P>1. Специальная внутриполосная завершающая последовательность: множество приложений под Unix используют в качестве разделителя сообщений символ перевода строки. Пишущий процесс добавляет к каждому сообщению этот символ, а считывающий процесс производит построчное считывание. Так работают клиент и сервер из листингов 4.10 и 4.11, чтобы разделить запросы клиентов. Этот метод требует исключения символа-разделителя из самих передаваемых данных (в случае необходимости его передать он должен предваряться другим специальным символом).</P>
     <P>2. Явное указание длины: каждой записи предшествует информация об ее длине. Мы вскоре воспользуемся этим методом. Он также применяется в Sun RPC при использовании совместно с TCP. Одним из преимуществ этого метода является отсутствие необходимости исключать разделитель из передаваемых данных, поскольку получатель не проверяет все данные, а переходит сразу к концу очередной записи, чтобы узнать длину следующей.</P>
     <P>3. Одна запись за подключение: приложение закрывает подключение к партнеру (подключение TCP для сетевых приложений либо просто подключение IPC), обозначая конец записи. Это требует повторного подключения для передачи следующей записи, однако используется в стандарте HTTP 1.0.</P>
     <P>Стандартная библиотека ввода-вывода также может использоваться для считывания и записи данных в пpoгрaммный канал или FIFO. Поскольку канал может быть открыт только функцией piре, возвращающей открытый дескриптор, для создания нового стандартного потока, связанного с этим дескриптором, можно использовать стандартную функцию fdopen. Канал FIFO обладает именем, поэтому он может быть открыт с помощью функции fopen.</P>
     <P>Можно создавать и более структурированные сообщения — эта возможность предоставляется очередями сообщений и в Posix, и в System V. Мы вскоре узнаем, что каждое сообщение обладает длиной и приоритетом (типом в System V). Длина и приоритет указываются отправителем и возвращаются получателю после считывания сообщения. Каждое сообщение представляет собой запись, аналогично дeйтaгрaммaм UDP ([24]).</P>
     <P>Мы можем структурировать данные, передаваемые по программному каналу или FIFO, самостоятельно. Определим сообщение в нашем заголовочном файле mesg.h, как показано в листинге 4.12.</P>
     <H2><a name=label98 style="border:none;"></a>Листинг 4.12. Структура mymesg и сопутствующие определения</H2>
     <P><CODE>//pipemesg/mesg.h</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  /* Наши собственные "сообщения", которые могут использоваться с каналами, FIFO и очередями сообщений */</CODE></P>
     <P><CODE>3  /* Мы хотим, чтобы sizeof(struct mymesg) &lt;= PIPE_BUF */</CODE></P>
     <P><CODE>4  #define MAXMESGDATA (PIPE_BUF – 2*sizeof(long))</CODE></P>
     <P><CODE>5  /* Длина mesg_len и mesg_type */</CODE></P>
     <P><CODE>6  #define MESGHDRSIZE (sizeof(struct mymesg) – MAXMESGDATA)</CODE></P>
     <P><CODE>7  struct mymesg {</CODE></P>
     <P><CODE>8   long mesg_len; //количество байтов в mesg_data, может быть О</CODE></P>
     <P><CODE>9   long mesg_type;//тип сообщения, должен быть &gt; 0</CODE></P>
     <P><CODE>10  char mesg_data[MAXMESGDATA];</CODE></P>
     <P><CODE>11 };</CODE></P>
     <P><CODE>12 ssize_t mesg_send(int, struct mymesg *);</CODE></P>
     <P><CODE>13 void Mesg_send(int, struct mymesg *);</CODE></P>
     <P><CODE>14 ssize_t mesg_recv(int, struct mymesg *);</CODE></P>
     <P><CODE>15 ssize_t Mesg_recv(int, struct mymesg *);</CODE></P>
     <P>Каждое сообщение содержит в себе информацию о своем типе (mesg_type), причем значение этой переменной должно быть больше нуля. Пока мы будем игнорировать это поле в записи, но вернемся к нему в главе 6, где описываются очереди сообщений System V. Каждое сообщение также обладает длиной, кoтopая может быть и нулевой. Структура mymesg позволяет предварить каждое сообщение информацией о его типе и длине вместо использования символа перевода строки для сигнализации конца сообщения. Ранее мы отметили два преимущества этого подхода: получатель не должен сканировать все принятые байты в поисках конца сообщения и отсутствует необходимость исключать появление разделителя в самих данных.</P>
     <P>На рис. 4.13 изображен вид структуры mymesg и ее использование с каналами, FIFO и очередями сообщений System V. </P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader91" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 4.13. Структура mymesg</P>
     <BR>
     <P>Мы определяем две функции для отправки и приема сообщений. В листинге 4.13 приведен текст функции mesg_send, а в листинге 4.14 — функции mesg_recv.</P>
     <H2><a name=label99 style="border:none;"></a>Листинг 4.13. Функция mesg_send</H2>
     <P><CODE>//pipemesg/mesg_send.c</CODE></P>
     <P><CODE>1 #include "mesg.h"</CODE></P>
     <P><CODE>2 ssize_t</CODE></P>
     <P><CODE>3 mesg_send(int fd, struct mymesg *mptr)</CODE></P>
     <P><CODE>4 {</CODE></P>
     <P><CODE>5  return(write(fd, mptr, MESGHDRSIZE + mptr-&gt;mesg_len));</CODE></P>
     <P><CODE>6 }</CODE></P>
     <H2><a name=label100 style="border:none;"></a>Листинг 4.14. Функция mesg_recv</H2>
     <P><CODE>//pipemesg/mesg_recv.c</CODE></P>
     <P><CODE>1  #include "mesg.h"</CODE></P>
     <P><CODE>2  ssize_t</CODE></P>
     <P><CODE>3  mesg_recv(int fd, struct mymesg *mptr)</CODE></P>
     <P><CODE>4  {</CODE></P>
     <P><CODE>5   size_t len;</CODE></P>
     <P><CODE>6   ssize_t n;</CODE></P>
     <P><CODE>8   /* считывание заголовка сообщения для определения его длины */</CODE></P>
     <P><CODE>9   if ((n = Read(fd, mptr, MESGHDRSIZE)) == 0)</CODE></P>
     <P><CODE>10   return(0); /* end of file */</CODE></P>
     <P><CODE>11  else if (n != MESGHDRSIZE)</CODE></P>
     <P><CODE>12   err_quit("message header: expected %d, got %d". MESGHDRSIZE, n);</CODE></P>
     <P><CODE>13  if ((len = mptr-&gt;mesg_len) &gt; 0)</CODE></P>
     <P><CODE>14   if ((n = Read(fd, mptr-&gt;mesg_data, len)) != len)</CODE></P>
     <P><CODE>15    err_quit("message data: expected %d, got %d", len, n);</CODE></P>
     <P><CODE>16  return(len);</CODE></P>
     <P><CODE>17 }</CODE></P>
     <P>Теперь для каждого сообщения функция read вызывается дважды: один раз для считывания длины, а другой — для считывания самого сообщения (если его длина больше 0).</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Внимательные читатели могли заметить, что функция mesg_recv проверяет наличие всех возможных ошибок и прекращает работу при их обнаружении. Однако мы все же определили функцию-обертку Mesg_recv и вызываем из наших программ именно ее — для единообразия.</P>
     </DIV>
     <P>Изменим теперь функции client и server, чтобы воспользоваться новыми функциями mesg_send и mesg_recv. В листинге 4.15 приведен текст функции-клиента.</P>
     <H2><a name=label101 style="border:none;"></a>Листинг 4.15. Функция client с использованием сообщений</H2>
     <P><CODE>//pipemesg/client.c</CODE></P>
     <P><CODE>1  #include "mesg.h"</CODE></P>
     <P><CODE>2  void</CODE></P>
     <P><CODE>3  client(int readfd, int writefd)</CODE></P>
     <P><CODE>4  {</CODE></P>
     <P><CODE>5   size_t len;</CODE></P>
     <P><CODE>6   ssize_t n;</CODE></P>
     <P><CODE>7   struct mymesg mesg;</CODE></P>
     <P><CODE>8   /* считывание полного имени */</CODE></P>
     <P><CODE>9   Fgets(mesg.mesg_data, MAXMESGDATA, stdin);</CODE></P>
     <P><CODE>10  len = strlen(mesg.mesg_data);</CODE></P>
     <P><CODE>11  if (mesg.mesg_data[len-1] == '\n')</CODE></P>
     <P><CODE>12   len--; /* удаление перевода строки из fgets() */</CODE></P>
     <P><CODE>13  mesg.mesg_len = len;</CODE></P>
     <P><CODE>14  mesg.mesg_type = 1;</CODE></P>
     <P><CODE>15  /* запись полного имени в канал IPC */</CODE></P>
     <P><CODE>16  Mesg_send(writefd, &amp;mesg);</CODE></P>
     <P><CODE>17  /* считывание из канала IPC. запись в stdout */</CODE></P>
     <P><CODE>18  while ( (n = Mesg_recv(readfd, &amp;mesg)) &gt; 0)</CODE></P>
     <P><CODE>19   Write(STDOUT_FILENO, mesg.mesg_data, n);</CODE></P>
     <P><CODE>20 }</CODE></P>
     <H2><a name=label102 style="border:none;"></a>Считывание имени файла и отправка его серверу</H2>
     <P>8-16 Полное имя считывается из стандартного потока ввода и затем отправляется на сервер с помощью функции mesg_send.</P>
     <H2><a name=label103 style="border:none;"></a>Считывание содержимого файла или сообщения об ошибке от сервера</H2>
     <P>17-19 Клиент вызывает функцию mesg_recv в цикле, считывая все приходящие от сервера сообщения. По соглашению, когда mesg_recv возвращает нулевую длину сообщения, это означает конец передаваемых сервером данных. Мы увидим, что сервер добавляет символ перевода строки к каждому сообщению, отправляемому клиенту, поэтому пустая строка будет иметь длину сообщения 1. В листинге 4.16 приведен текст функции-сервера.</P>
     <H2><a name=label104 style="border:none;"></a>Листинг 4.16. Функция server, использующая сообщения</H2>
     <P><CODE>//pipemesg/server.c</CODE></P>
     <P><CODE>1  #include "mesg.h"</CODE></P>
     <P><CODE>2  void</CODE></P>
     <P><CODE>3  server(int readfd, int writefd)</CODE></P>
     <P><CODE>4  {</CODE></P>
     <P><CODE>5   FILE *fp;</CODE></P>
     <P><CODE>6   ssize_t n;</CODE></P>
     <P><CODE>7   struct mymesg mesg;</CODE></P>
     <P><CODE>8   /* считывание полного имени из канала */</CODE></P>
     <P><CODE>9   mesg.mesg_type = 1;</CODE></P>
     <P><CODE>10  if ((n = Mesg_recv(readfd, &amp;mesg)) == 0)</CODE></P>
     <P><CODE>11   err_quit("pathname missing");</CODE></P>
     <P><CODE>12  mesg.mesg_data[n] = '\0'; /* полное имя, завершающееся 0 */</CODE></P>
     <P><CODE>13  if ((fp = fopen(mesg.mesg_data, "r")) == NULL) {</CODE></P>
     <P><CODE>14   /* ошибка, нужно сообщить клиенту */</CODE></P>
     <P><CODE>15   snprintf(mesg.mesg_data + n, sizeof(mesg.mesg_data) – n,</CODE></P>
     <P><CODE>16    ": can't open, %s\n", strerror(errno));</CODE></P>
     <P><CODE>17   mesg.mesg_len = strlen(mesg.mesg_data);</CODE></P>
     <P><CODE>18   Mesg_send(writefd, &amp;mesg);</CODE></P>
     <P><CODE>19  } else {</CODE></P>
     <P><CODE>20   /* файл успешно открыт, передача данных */</CODE></P>
     <P><CODE>21   while (Fgets(mesg.mesg_data, MAXMESGDATA, fp) != NULL) {</CODE></P>
     <P><CODE>22    mesg.mesg_len = strlen(mesg.mesg_data);</CODE></P>
     <P><CODE>23    Mesg_send(writefd, &amp;mesg);</CODE></P>
     <P><CODE>24   }</CODE></P>
     <P><CODE>25   Fclose(fp);</CODE></P>
     <P><CODE>26  }</CODE></P>
     <P><CODE>27  /* отправка сообщения нулевой длины для обозначения конца связи */</CODE></P>
     <P><CODE>28  mesg.mesg_len = 0;</CODE></P>
     <P><CODE>29  Mesg_send(writefd, &amp;mesg);</CODE></P>
     <P><CODE>30 }</CODE></P>
     <H2><a name=label105 style="border:none;"></a>Считывание имени файла из канала IPC, открытие файла</H2>
     <P>8-18 Сервер принимает от клиента имя файла. Хотя значение mesg_type, равное 1, нигде не используется (оно затирается функцией mesg_recv из листинга 4.14), мы будем использовать ту же функцию при работе с очередями сообщений System V (листинг 6.8), а в данном случае в этом значении уже возникает потребность (см., например, листинг 6.11). Стандартная функция ввода-вывода fopen открывает файл, что отличается от листинга 4.3, где вызывалась функция open для получения дескриптора файла. Причина, по которой мы воспользовались fopen, заключается в том, что в этой пpoгрaммe мы пользуемся библиотечной функцией fgets для считывания содержимого файла построчно и затем отправляем клиенту строку за строкой.</P>
     <H2><a name=label106 style="border:none;"></a>Отправка файла клиенту</H2>
     <P>19-26 Если вызов fopen оказывается успешным, содержимое файла считывается с помощью функции fgets и затем отправляется клиенту построчно. Сообщение с нулевой длиной означает конец файла.</P>
     <P>При использовании пpoгрaммныx каналов или FIFO мы могли бы также закрыть канал IPC, чтобы дать клиенту знать о том, что передача файла завершена. Однако мы используем передачу сообщения нулевой длины, потому что другие типы IPC не поддерживают концепцию конца файла.</P>
     <P>Функции main, вызывающие новые функции client и server, вообще не претерпели никаких изменений. Мы можем использовать либо версию для работы с каналами (листинг 4.1), либо версию для работы с FIFO (листинг 4.6).</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label107 style="border:none;"></a>4.11. Ограничения программных каналов и FIFO</P>
     </H1>
     <P>На программные каналы и каналы FIFO системой накладываются всего два ограничения:</P>
     <P>■ OPEN_MAX — максимальное количество дескрипторов, которые могут быть одновременно открыты некоторым процессом (Posix устанавливает для этой величины ограничение снизу — 16);</P>
     <P>■ PIPE_BUF — максимальное количество данных, для которого гарантируется атомарность операции записи (описано в разделе 4.7; Posix требует по меньшей мере 512 байт).</P>
     <P>Значение OPEN_MAX можно узнать, вызвав функцию sysconf, как мы вскоре покажем. Обычно его можно изменить из интерпретатора команд с помощью команды ulimit (в Bourne shell и KornShell, как мы вскоре покажем) или с помощью команды limit (в С shell). Оно может быть изменено и самим процессом с помощью вызова функции setrlimit (подробно описана в разделе 7.11 [21]).</P>
     <P>Значение PIPE_BUF обычно определено в заголовочном файле &lt;limits.h&gt;, но с точки зрения стандарта Posix оно представляет собой переменную, зависимую от полного имени файла. Это означает, что ее значение может меняться в зависимости от указываемого имени файла (для FIFO, поскольку каналы имен не имеют), поскольку разные имена могут относиться к разным файловым системам и эти файловые системы могут иметь различные характеристики. Это значение можно получить в момент выполнения пpoгрaммы, вызвав либо pathconf, либо fpathconf. В листинге 4.17 приведен пример, выводящий текущее значение этих двух oгрaничeний.</P>
     <H2><a name=label108 style="border:none;"></a>Листинг 4.17. Определение значений PIPE_BUF и OPEN_MAX во время выполнения</H2>
     <P><CODE>//pipe/pipeconf.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  int</CODE></P>
     <P><CODE>3  main(int argc, char **argv)</CODE></P>
     <P><CODE>4  {</CODE></P>
     <P><CODE>5   if (argc != 2)</CODE></P>
     <P><CODE>6   err_quit("usage: pipeconf &lt;pathname&gt;");</CODE></P>
     <P><CODE>7   printf("PIPE_BUF = %ld. OPEN_MAX = %ld\n",</CODE></P>
     <P><CODE>8   Pathconf(argv[1], _PC_PIPE_BUF), Sysconf(_SC_OPEN_MAX));</CODE></P>
     <P><CODE>9   exit(0);</CODE></P>
     <P><CODE>10 }</CODE></P>
     <P>Вот несколько примеров, в которых указываются имена файлов, относящиеся к различным файловым системам:</P>
     <P><CODE>solaris % <STRONG>pipeconf /</STRONG> <EM>значения по умолчанию в Solaris 2.6</EM></CODE></P>
     <P><CODE>PIPE_BUF = 5120, OPEN_MAX = 64</CODE></P>
     <P><CODE>solaris % <STRONG>pipeconf /home</STRONG></CODE></P>
     <P><CODE>PIPE_BUF = 5120, OPEN_MAX = 64</CODE></P>
     <P><CODE>solaris % <STRONG>pipeconf /tmp</STRONG></CODE></P>
     <P><CODE>PIPE_BUF = 5120, OPEN_MAX = 64</CODE></P>
     <P><CODE>alpha % <STRONG>pipeconf /</STRONG>   <EM>значения по умолчанию в Digital Unix 4.0B</EM></CODE></P>
     <P><CODE>PIPE_BUF = 4096, OPEN_MAX = 4096</CODE></P>
     <P><CODE>alpha % <STRONG>pipeconf /usr</STRONG></CODE></P>
     <P><CODE>PIPE_BUF = 4096, OPEN_MAX = 4096</CODE></P>
     <P>Покажем теперь, как изменить значение OPEN_MAX в Solaris, используя интерпретатор KornShell:</P>
     <P><CODE>solaris % <STRONG>ulimit –nS</STRONG>     <EM>отображение максимального количества дескрипторов, мягкоео граничение</EM></CODE></P>
     <P><CODE>64</CODE></P>
     <P><CODE>solaris % <STRONG>ulimit –Nh</STRONG>     <EM>отображение максимального количества дескрипторов, жесткое ограничение</EM></CODE></P>
     <P><CODE>1024</CODE></P>
     <P><CODE>solaris % <STRONG>ulimit –nS 512</STRONG> <EM>установка мягкого ограничения в 512</EM></CODE></P>
     <P><CODE>solaris % <STRONG>pipeconf /</STRONG>     <EM>проверка внесенных изменений</EM></CODE></P>
     <P><CODE>PIPE_BUF = 5120, OPEN_MAX = 512</CODE> </P>
     <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
     <DIV class=cite>
      <P>Хотя значение PIPE_BUF для FIFO, в принципе, может меняться в зависимости от файловой системы, к которой относится файл, на самом деле это очень редкий случай.</P>
      <P>В главе 2 [21] описаны функции fpathconf, pathconf и sysconf, которые предоставляют информацию о некоторых ограничениях ядра во время выполнения программы. Стандарт Posix.1 определяет 12 констант, начинающихся с _РС_, и 52, начинающихся с _SC_. Системы Digital Unix 4.0B и Solaris 2.6 расширяют последнее ограничение, определяя около 100 констант, значения которых могут быть получены в момент выполнения программы с помощью sysconf. </P>
     </DIV>
     <P>Команда getconf определяется стандартом Posix.2 и выводит значения большинства этих ограничений. Например:</P>
     <P><CODE>alpha % <STRONG>getconf OPEN_MAX</STRONG></CODE></P>
     <P><CODE>4096</CODE></P>
     <P><CODE>alpha % <STRONG>getconf PIPE_BUF /</STRONG></CODE></P>
     <P><CODE>4096</CODE></P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label109 style="border:none;"></a>4.12. Резюме</P>
     </H1>
     <P>Именованные и неименованные каналы представляют собой базовые строительные блоки для множества приложений. Программные каналы (неименованные) обычно используются в интерпретаторе команд, а также внутри программ — часто для передачи информации от дочернего процесса к родительскому. Можно исключить часть кода, относящегося к использованию каналов (piре, fork, close, exec и waitpid), используя функции popen и pclose, которые берут на себя все тонкости и запускают интерпретатор команд.</P>
     <P>Каналы FIFO похожи на программные каналы, но создаются вызовом mkfifo и затем могут быть открыты с помощью функции open. При открытии FIFO следует быть аккуратным, поскольку процесс может быть заблокирован, а зависит это от множества условий (см. табл. 4.1).</P>
     <P>Используя программные каналы и FIFO, мы создали несколько вариантов приложении типа клиент-сервер: один сервер с несколькими клиентами, последовательный и параллельный серверы. Последовательный сервер единовременно обрабатывает запрос только от одного клиента; такие серверы обычно уязвимы для атак типа «отказ в обслуживании». Параллельный сервер запускает отдельный процесс или поток для обработки запроса нового клиента.</P>
     <P>Одним из свойств программных каналов и FIFO является то, что данные по ним передаются в виде потоков байтов, аналогично соединению TCP. Деление этого потока на самостоятельные записи целиком предоставляется приложению. Мы увидим в следующих двух главах, что очереди сообщений автоматически расставляют границы между записями, аналогично тому, как это делается в дейтаграммах UDP.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label110 style="border:none;"></a>Упражнения</P>
     </H1>
     <P>1. При переходе от рис. 4.3 к рис. 4.4: что могло бы произойти, если бы дочерний процесс не закрывал дескриптор (close(fd[1]))? </P>
     <P>2. Описывая mkfifo в разделе 4.6, мы сказали, что для открытия существующего FIFO или создания нового, если его не существует, следует вызвать mkfifо, проверить, не возвращается ли ошибка EEXIST, и вызвать open, если это происходит. Что если изменить логику и вызвать сначала open, а затем mkfifо, если FIFO не существует?</P>
     <P>3. Что происходит при вызове popen в листинге 4.5, если в интерпретаторе возникает ошибка?</P>
     <P>4. Удалите вызов open для FIFO сервера в листинге 4.10 и проверьте, приведет ли это к завершению работы сервера после отключения последнего клиента.</P>
     <P>5. К листингу 4.10: мы отметили, что при запуске сервера его работа блокируется при вызове первой функции open, пока FIFO не будет открыт на запись первым клиентом. Как можно обойти это таким образом, чтобы обе функции open завершали работу немедленно, а блокирование происходило при первом вызове readline?</P>
     <P>6. Что произойдет с клиентом в листинге 4.11, если поменять порядок вызовов open?</P>
     <P>7. Почему сигнал отправляется процессу, в котором канал FIFO открыт на запись, после отключения последнего читающего клиента, а не читающему клиенту после отключения последнего пишущего?</P>
     <P>8. Напишите небольшую тестирующую программу для определения того, возвращает ли fstat количество байтов в FIFO в качестве поля st_size структуры stat.</P>
     <P>9. Напишите небольшую тестирующую программу для определения того, что возвращает функция select при проверке возможности записи в дескриптор канала, у которого закрыт второй конец. </P>
    </DIV>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label111 style="border:none;"></a>ГЛАВА 5</P>
     <P>Очереди сообщений Posix</P>
    </H1>
    <DIV class=section>
     <H1>
      <P><a name=label112 style="border:none;"></a>5.1. Введение</P>
     </H1>
     <P>Очередь сообщений можно рассматривать как связный список сообщений. Программные потоки с соответствующими разрешениями могут помещать сообщения в очередь, а потоки с другими соответствующими разрешениями могут извлекать их оттуда. Каждое сообщение представляет собой запись (вспомните сравнение потоков и сообщений в разделе 4.10), и каждому сообщению его отправителем присваивается приоритет. Для записи сообщения в очередь не требуется наличия ожидающего его процесса. Это отличает очереди сообщений от программных каналов и FIFO, в которые нельзя произвести запись, пока не появится считывающий данные процесс.</P>
     <P>Процесс может записать в очередь какие-то сообщения, после чего они могут быть получены другим процессом в любое время, даже если первый завершит свою работу. Мы говорим, что очереди сообщений обладают живучестью ядра (kernel persistence, раздел 1.3). Это также отличает их от программных каналов и FIFO. В главе 4 говорится о том, что данные, остающиеся в именованном или неименованном канале, сбрасываются, после того как все процессы закроют его.</P>
     <P>В этой главе рассматриваются очереди сообщений стандарта Posix, а в главе 6 — стандарта System V. Функции для работы с ними во многом схожи, а главные отличия заключаются в следующем:</P>
     <P>■ операция считывания из очереди сообщений Posix всегда возвращает самое старое сообщение с наивысшим приоритетом, тогда как из очереди System V можно считать сообщение с произвольно указанным приоритетом;</P>
     <P>■ очереди сообщений Posix позволяют отправить сигнал или запустить программный поток при помещении сообщения в пустую очередь, тогда как для очередей System V ничего подобного не предусматривается.</P>
     <P>Каждое сообщение в очереди состоит из следующих частей: </P>
     <P>■ приоритет (беззнаковое целое, Posix) либо тип сообщения (целое типа long, System V);</P>
     <P>■ длина полезной части сообщения, которая может быть нулевой;</P>
     <P>■ собственно данные (если длина сообщения отлична от 0).</P>
     <P>Этим очереди сообщений отличаются от программных каналов и FIFO. Последние две части сообщения представляют собой байтовые потоки, в которых отсутствуют границы между сообщениями и никак не указывается их тип. Мы обсуждали этот вопрос в разделе 4.10 и добавили свой собственный интерфейс для пересылки сообщений по программным каналам и FIFO. На рис. 5.1 показан возможный вид очереди сообщений.</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader96" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 5.1. Очередь сообщений Posix, содержащая три сообщения</P>
     <BR>
     <P>Мы предполагаем реализацию через связный список, причем его заголовок содержит два атрибута очереди: максимально допустимое количество сообщений в ней и максимальный размер сообщения. Об этих атрибутах мы расскажем более подробно в разделе 5.3.</P>
     <P>В этой главе мы используем метод, к которому будем прибегать и в дальнейшем, рассматривая очереди сообщений, семафоры и разделяемую память. Поскольку все эти объекты IPC обладают по крайней мере живучестью ядра (вспомните раздел 1.3), мы можем писать небольшие программы, использующие эти методы для экспериментирования с ними и получения большей информации о том, как они работают. Например, мы можем написать программу, создающую очередь сообщений Posix, а потом написать другую программу, которая помещает сообщение в такую очередь, а потом еще одну, которая будет считывать сообщения из очереди. Помещая в очередь сообщения с различным приоритетом, мы увидим, в каком порядке они будут возвращаться функцией mq_receive.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label113 style="border:none;"></a>5.2. Функции mq_open, mq_close, mq_unlink</P>
     </H1>
     <DIV class=section>
      <P>Функция mq_open создает новую очередь сообщений либо открывает существующую:</P>
      <P><CODE>#include &lt;mqueue.h&gt;</CODE></P>
      <P><CODE>mqd_t mq_open(const char <EM>*name,</EM> int <EM>oflag, …</EM></CODE></P>
      <P><CODE>/* mode_t <EM>mode,</EM> struct mq_attr <EM>*attr</EM>*/ );</CODE></P>
      <P><CODE>/* Возвращает дескриптор очереди в случае успешного завершения;</CODE></P>
      <P><CODE> –1 – в противном случае. */</CODE></P>
      <P>Требования к аргументу <EM>пате</EM> описаны в разделе 2.2.</P>
      <P>Аргумент <EM>oflag</EM> может принимать одно из следующих значений: O_RDONLY, O_WRONLY, O_RDWR в сочетании (логическое сложение) с O_CREAT, O_EXCL, O_NONBLOCK. Все эти флаги описаны в разделе 2.3.</P>
      <P>При создании новой очереди (указан флаг O_CREAT и очередь сообщений еще не существует) требуется указание аргументов <EM>mode</EM> и <EM>attr.</EM> Возможные значения аргумента <EM>mode</EM> приведены в табл. 2.3. Аргумент <EM>attr </EM>позволяет задать некоторые атрибуты очереди. Если в качестве этого аргумента задать нулевой указатель, очередь будет создана с атрибутами по умолчанию. Эти атрибуты описаны в разделе 5.3.</P>
      <P>Возвращаемое функцией mq_open значение называется дескриптором очереди сообщений, но оно не обязательно должно быть (и, скорее всего, не является) небольшим целым числом, как дескриптор файла или программного сокета. Это значение используется в качестве первого аргумента оставшихся семи функций для работы с очередями сообщений.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>В системе Solaris 2.6 тип mqd_t определен как void*, а в Digital Unix 4.0B — как int. В нашем примере в разделе 5.8 эти дескрипторы трактуются как указатели на структуру. Название «дескриптор» было дано им по ошибке. </P>
      </DIV>
      <P>Открытая очередь сообщений закрывается функцией mq_close:</P>
      <P><CODE>#include &lt;mqueue.h&gt;</CODE></P>
      <P><CODE>int mq_close(mqd_t <EM>mqdes</EM>);</CODE></P>
      <P><CODE>/*Возвращает 0 в случае успешного завершения. –1 в случае ошибки */</CODE></P>
      <P>По действию эта функция аналогична close для открытого файла: вызвавший функцию процесс больше не может использовать дескриптор, но очередь сообщений из системы не удаляется. При завершении процесса все открытые очереди сообщений закрываются, как если бы для каждой был сделан вызов mq_close.</P>
      <P>Для удаления из системы имени (<EM>пате),</EM> которое использовалось в качестве аргумента при вызове mq_open, нужно использовать функцию mq_unlink:</P>
      <P><CODE>#include &lt;mqueue.h&gt;</CODE></P>
      <P><CODE>int mq_unlink(const char <EM>*name</EM>);</CODE></P>
      <P><CODE>/* Возвращает 0 в случае успешного завершения. –1 в случае ошибки */</CODE></P>
      <P>Для очереди сообщений (как и для файла) ведется подсчет числа процессов, в которых она открыта в данный момент, и по действию эта функция аналогична unlink для файла: имя <EM>(пате)</EM> может быть удалено из системы, даже пока число подключений к очереди отлично от нуля, но удаление очереди (в отличие от удаления имени из системы) не будет осуществлено до того, как очередь будет закрыта последним использовавшим ее процессом.</P>
      <P>Очереди сообщений Posix обладают по меньшей мере живучестью ядра (раздел 1.3), то есть они продолжают существовать, храня все имеющиеся в них сообщения, даже если нет процессов, в которых они были бы открыты. Очередь существует, пока она не будет удалена явно с помощью mq_unlink.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Мы увидим, что если очередь сообщений реализована через отображаемые в память файлы (раздел 12.2), она может обладать живучестью файловой системы, но это не является обязательным и рассчитывать на это нельзя.</P>
      </DIV>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label114 style="border:none;"></a>Пример: программа mqcreate1</P>
      </H1>
      <P>Поскольку очереди сообщений Posix обладают по крайней мере живучестью ядра, можно написать набор небольших программ для работы с ними — с этими программами будет проще экспериментировать. Программа из листинга 5.1<A HREF="#n_1" onmouseover="ShowBookNote('n_1')" onmouseout="HideBookNote('n_1')"><SUP>[1]</SUP></A> создает очередь сообщений, имя которой принимается в качестве аргумента командной строки.</P>
      <H2><a name=label115 style="border:none;"></a>Листинг 5.1. Создание очереди сообщений (указан флаг O_EXCL)</H2>
      <P><CODE>//pxmsg/mqcreate1.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int с flags:</CODE></P>
      <P><CODE>6   mqd_t mqd;</CODE></P>
      <P><CODE>7   flags = O_RDWR | O_CREAT;</CODE></P>
      <P><CODE>8   while ((c = Getopt(argc, argv, "e")) != –1) {</CODE></P>
      <P><CODE>9    switch (c) {</CODE></P>
      <P><CODE>10   case 'e':</CODE></P>
      <P><CODE>11    flags |= O_EXCL;</CODE></P>
      <P><CODE>12    break;</CODE></P>
      <P><CODE>13   }</CODE></P>
      <P><CODE>14  }</CODE></P>
      <P><CODE>15  if (optind != argc – 1)</CODE></P>
      <P><CODE>16   err_quit("usage: mqcreate [ –e ] &lt;name&gt;");</CODE></P>
      <P><CODE>17  mqd = Mq_open(argv[optind], flags, FILE_MODE, NULL);</CODE></P>
      <P><CODE>18  Mq_close(mqd);</CODE></P>
      <P><CODE>19  exit(0);</CODE></P>
      <P><CODE>20 }</CODE></P>
      <P>В командной строке можно указать параметр –е, управляющий исключающим созданием очереди. (О функции getopt и нашей обертке Getopt рассказано более подробно в комментарии к листингу 5.5.) При возвращении функция getopt сохраняет в переменной optind индекс следующего аргумента, подлежащего обработке.</P>
      <P>Мы вызываем функцию mq_open, указывая ей в качестве имени IPC полученный из командной строки параметр, не обращаясь к рассмотренной нами в разделе 2.2 функции px_ipc_name. Это даст нам возможность узнать, как в данной реализации обрабатываются имена Posix IPC (мы используем для этого наши маленькие тестовые программы на протяжении всей книги).</P>
      <P>Ниже приведен результат работы программы в Solaris 2.6:</P>
      <P><CODE>solaris % <STRONG>mqcreate1 /temp.1234    </STRONG><EM>очередь успешно создается</EM></CODE></P>
      <P><CODE>solaris % <STRONG>ls -l /tmp/.*1234</STRONG></CODE></P>
      <P><CODE>-rw-rw-rw– 1 rstevens other1 132632 Oct 23 17:08 /tmp/.MQDtemp.1234</CODE></P>
      <P><CODE>-rw-rw-rw– 1 rstevens other1      0 Oct 23 17:08 /tmp/.MQLtemp.1234</CODE></P>
      <P><CODE>-rw-r--r-- 1 rstevens other1      0 Oct 23 17:08 /tmp/.MQPDtemp.1234</CODE></P>
      <P><CODE>solaris % <STRONG>mqcreate1 –e /temp.1234 </STRONG><EM>очередь уже создана</EM></CODE></P>
      <P><CODE>mq_open error for /temp.1234: File exists</CODE></P>
      <P>Мы назвали эту версию программы mqcreate1, поскольку она будет улучшена в листинге 5.4, после того как мы обсудим использование атрибутов очереди. Разрешения на доступ к третьему файлу определяются константой FILE_MODE (чтение и запись для пользователя, только чтение для группы и прочих пользователей), но у двух первых файлов разрешения отличаются. Можно предположить, что в файле с буквой D в имени хранятся данные; файл с буквой L представляет собой какую-то блокировку, а в файле с буквой Р хранятся разрешения.</P>
      <P>В Digital Unix 4.0B мы указываем действительное имя создаваемого файла:</P>
      <P><CODE>alpha % <STRONG>mqcreate1 /tmp/myq.1234    </STRONG><EM>очередь успешно создается</EM></CODE></P>
      <P><CODE>alpha % <STRONG>ls –l /tmp/myq.1234</STRONG></CODE></P>
      <P><CODE>-rw-r--r-- 1 rstevens system 11976 Oct 23 17:04 /tmp/myq.1234</CODE></P>
      <P><CODE>alpha % <STRONG>mqcreate1 –e /tmp/myq.1234 </STRONG><EM>очередь уже создана</EM></CODE></P>
      <P><CODE>mq_open error for /tmp/myq.1234: File exists</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label116 style="border:none;"></a>Пример: программа mqunlink</P>
      </H1>
      <P>В листинге 5.2 приведена программа mqunlink, удаляющая из системы очередь сообщений.</P>
      <H2><a name=label117 style="border:none;"></a>Листинг 5.2. Удаление очереди из системы: mqunlink</H2>
      <P><CODE>//pxmsg/mqunlink.c</CODE></P>
      <P><CODE>1 #include "unpipc.h"</CODE></P>
      <P><CODE>2 int</CODE></P>
      <P><CODE>3 main(int argc, char **argv)</CODE></P>
      <P><CODE>4 {</CODE></P>
      <P><CODE>5  if (argc != 2)</CODE></P>
      <P><CODE>6   err_quit("usage: mqunlink &lt;name&gt;");</CODE></P>
      <P><CODE>7  Mq_unlink(argv[1]);</CODE></P>
      <P><CODE>8  exit(0);</CODE></P>
      <P><CODE>9 }</CODE></P>
      <P>С помощью этой программы мы можем удалить очередь сообщений, созданную программой mqcreate1:</P>
      <P><CODE>solaris % <STRONG>mqunlink /temp.1234</STRONG></CODE></P>
      <P>При этом будут удалены все три файла из каталога /tmp, которые относятся к этой очереди.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label118 style="border:none;"></a>5.3. Функции mq_getattr и mq_setattr</P>
     </H1>
     <DIV class=section>
      <P>У каждой очереди сообщений имеются четыре атрибута, которые могут быть получены функцией mq_getattr и установлены (по отдельности) функцией mq_setattr: </P>
      <P><CODE>#include &lt;mqueue.h&gt;</CODE></P>
      <P><CODE>int mq_getattr(mqd_t <EM>mqdes</EM>, struct mq_attr *<EM>attr</EM>);</CODE></P>
      <P><CODE>int mq_setattr(mqd_t <EM>mqdes</EM>, const struct mq_attr *<EM>attr</EM>, struct mq_attr *<EM>oattr</EM>);</CODE></P>
      <P><CODE>/* Обе функции возвращают 0 в случае успешного завершения; –1 – в случае возникновения ошибок */</CODE></P>
      <P>Структура mq_attr хранит в себе эти четыре атрибута:</P>
      <P><CODE>struct mq_attr {</CODE></P>
      <P><CODE> long mq_flags;   /* флаг очереди: 0, O_NONBLOCK */</CODE></P>
      <P><CODE> long mq_maxmsg;  /* максимальное количество сообщений в очереди */</CODE></P>
      <P><CODE> long mq_msgsize; /* максимальный размер сообщения (в байтах) */</CODE></P>
      <P><CODE> long mq_curmsgs; // текущее количество сообщений в очереди</CODE></P>
      <P><CODE>}</CODE></P>
      <P>Указатель на такую структуру может быть передан в качестве четвертого аргумента mq_open, что дает возможность установить параметры mq_maxmsg и mq_msgsize в момент создания очереди. Другие два поля структуры функцией mq_open игнорируются.</P>
      <P>Функция mq_getattr присваивает полям структуры, на которую указывает <EM>attr,</EM> текущие значения атрибутов очереди.</P>
      <P>Функция mq_setattr устанавливает атрибуты очереди, но фактически используется только поле mqflags той структуры, на которую указывает <EM>attr,</EM> что дает возможность сбрасывать или устанавливать флаг запрета блокировки. Другие три поля структуры игнорируются: максимальное количество сообщений в очереди и максимальный размер сообщения могут быть установлены только в момент создания очереди, а количество сообщений в очереди можно только считать, но не изменить.</P>
      <P>Кроме того, если указатель <EM>oattr</EM> ненулевой, возвращаются предыдущие значения атрибутов очереди (mq_flags, mq_maxmsg, mq_msgsize) и текущий статус очереди (mq_curmsgs).</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label119 style="border:none;"></a>Пример: программа mqgetattr</P>
      </H1>
      <P>Программа из листинга 5.3 открывает указанную очередь сообщений и выводит значения ее атрибутов.</P>
      <H2><a name=label120 style="border:none;"></a>Листинг 5.3. Получение и вывод значений атрибутов очереди сообщений</H2>
      <P><CODE>//pxmsg/mqgetattr.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   mqd_t mqd;</CODE></P>
      <P><CODE>6   struct mq_attr attr;</CODE></P>
      <P><CODE>7   if (argc != 2)</CODE></P>
      <P><CODE>8    err_quit("usage: mqgetattr &lt;name&gt;");</CODE></P>
      <P><CODE>9   mqd = Mq_open(argv[1], O_RDONLY);</CODE></P>
      <P><CODE>10  Mq_getattr(mqd, &amp;attr);</CODE></P>
      <P><CODE>11  printf ("max #msgs = %ld, max #bytes/msg = %ld, "</CODE></P>
      <P><CODE>12   "#currently on queue = %ld\n",</CODE></P>
      <P><CODE>13   attr.mq_maxmsg, attr.mq_msgsize, attr.mq_curmsgs);</CODE></P>
      <P><CODE>14  Mq_close(mqd);</CODE></P>
      <P><CODE>15  exit(0);</CODE></P>
      <P><CODE>16 }</CODE></P>
      <P>Мы можем создать очередь сообщений и вывести значения ее атрибутов, устанавливаемые по умолчанию:</P>
      <P><CODE>solaris % <STRONG>mqcreate1 /hello.world</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>mqgetattr /hello.world</STRONG></CODE></P>
      <P><CODE>max #msgs = 128, max #bytes/msg = 1024, #currently on queue = 0</CODE></P>
      <P>Вспомним размер одного из файлов очереди, созданной с использованием устанавливаемых по умолчанию значений атрибутов. Он был выведен командой ls в примере после листинга 5.1. Это значение можно получить как 128×1024+1560 = 132632.</P>
      <P>Добавочные 1560 байт представляют собой, скорее всего, дополнительную информацию: 8 байт на сообщение плюс добавочные 536 байт.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label121 style="border:none;"></a>Пример: программа mqcreate</P>
      </H1>
      <P>Мы можем изменить программу из листинга 5.1 таким образом, чтобы при создании очереди иметь возможность указывать максимальное количество сообщений и максимальный размер сообщения. Мы не можем указать только один из этих параметров; нужно обязательно задать оба (см., впрочем, упражнение 5.1). В листинге 5.4 приведен текст новой программы.</P>
      <H2><a name=label122 style="border:none;"></a>Листинг 5.4. Усовершенствованная программа mqcreate</H2>
      <P><CODE>//pxmsg/mqcreate.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  struct mq_attr attr; /* mq_maxmsg и mq_msgsize инициализируются О */</CODE></P>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int с flags;</CODE></P>
      <P><CODE>7   mqd_t mqd;</CODE></P>
      <P><CODE>8   flags = O_RDWR | O_CREAT;</CODE></P>
      <P><CODE>9   while ((c = Getopt(argc, argv, "em:z:")) != –1) {</CODE></P>
      <P><CODE>10   switch (c) {</CODE></P>
      <P><CODE>11   case 'e':</CODE></P>
      <P><CODE>12    flags |= O_EXCL;</CODE></P>
      <P><CODE>13    break;</CODE></P>
      <P><CODE>14   case 'm':</CODE></P>
      <P><CODE>15    attr.mq_maxmsg = atol(optarg);</CODE></P>
      <P><CODE>16    break;</CODE></P>
      <P><CODE>17   case 'z':</CODE></P>
      <P><CODE>18    attr.mq_msgsize = atol(optarg);</CODE></P>
      <P><CODE>19    break;</CODE></P>
      <P><CODE>20   }</CODE></P>
      <P><CODE>21  }</CODE></P>
      <P><CODE>22  if (optind != argc – 1)</CODE></P>
      <P><CODE>23   err_quit("usage: mqcreate [ –е ] [ –m maxmsg –z msgsize ] &lt;name&gt;");</CODE></P>
      <P><CODE>24  if ((attr.mq_maxmsg != 0 &amp;&amp; attr.mq_msgsize ==0) ||</CODE></P>
      <P><CODE>25   (attr.mq_maxmsg == 0 &amp;&amp; attr.mq_msgsize != 0))</CODE></P>
      <P><CODE>26   err_quit("must specify both –m maxmsg and –z msgsize");</CODE></P>
      <P><CODE>27  mqd = Mq_open(argv[optind], flags, FILE_MODE,</CODE></P>
      <P><CODE>28   (attr.mq_maxmsg != 0) ? &amp;attr : NULL);</CODE></P>
      <P><CODE>29  Mq_close(mqd);</CODE></P>
      <P><CODE>30  exit(0);</CODE></P>
      <P><CODE>31 }</CODE></P>
      <P>Параметр командной строки, требующий аргумента, указывается с помощью двоеточия (после параметров m и z в вызове getopt). В момент обработки символа параметр optarg указывает на аргумент.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Наша обертка Getopt вызывает стандартную библиотечную функцию getopt и завершает выполнение процесса в случае возникновения ошибок в ее работе: при появлении параметра, не указанного в третьем аргументе при вызове функции, или при наличии параметра без необходимого числового аргумента (потребность в нем указывается с помощью двоеточия после буквы параметра в третьем аргументе функции getopt). В любом случае, getopt помещает сообщение об ошибке в стандартный поток сообщений об ошибках и возвращает ошибку, что приводит к завершению работы оберткой Getopt. В двух приведенных ниже примерах ошибка обнаруживается функцией getopt:</P>
       <P><CODE>solaris %<STRONG>mqcreate –z</STRONG></CODE></P>
       <P><CODE>mqcreate: option requires an argument – z</CODE></P>
       <P><CODE>solaris %<STRONG>mqcreate –q</STRONG></CODE></P>
       <P><CODE>mqcreate: illegal option – q</CODE></P>
       <P>В следующем примере ошибка (не указан необходимый аргумент — имя очереди) обнаруживается самой программой:</P>
       <P><CODE>solaris %<STRONG>mqcreate</STRONG></CODE></P>
       <P><CODE>usage: mqcreate [ –e ] [ –m maxmsg –z msgsize ] &lt;name&gt;</CODE></P>
      </DIV>
      <P>Если не указан ни один из двух новых параметров, мы должны передать функции mq_open пустой указатель в качестве последнего аргумента. В противном случае мы передаем указатель на нашу структуру attr.</P>
      <P>Запустим теперь новую версию нашей программы в системе Solaris 2.6, указав максимальное количество сообщений 1024 и максимальный размер сообщения 8192 байт:</P>
      <P><CODE>solaris % <STRONG>mqcreate –e –m 1024 -z 8192 /foobar</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>ls –al /tmp/.*foobar</STRONG></CODE></P>
      <P><CODE>-rw-rw-rw– 1 rstevens other1 8397336 Oct 25 11:29 /tmp/.MQDfoobar</CODE></P>
      <P><CODE>–rw-rw-rw– 1 rstevens other1       0 Oct 25 11:29 /tmp/.MQLfoobar</CODE></P>
      <P><CODE>–rw-r--r-- 1 rstevens other1       0 Oct 25 11:29 /tmp/.MQPfoobar</CODE></P>
      <P>Размер файла, содержащего данные этой очереди, соответствует максимальному количеству сообщений в очереди и максимальному размеру сообщения (1024×8192 = 8388608), а оставшиеся 8728 байт предусматривают 8 байт информации на каждое сообщение (8×1024) плюс дополнительные 536 байт. </P>
      <P>При выполнении той же программы в Digital Unix 4.0B получим:</P>
      <P><CODE>alpha % <STRONG>mqcreate –m 256 -z 2048 /tmp/bigq</STRONG></CODE></P>
      <P><CODE>alpha % <STRONG>ls-l/tmp/bigq</STRONG></CODE></P>
      <P><CODE>-rw-r--r-- 1 rstevens system 537288 Oct 25 15:38 /tmp/bigq</CODE></P>
      <P>В этой реализации размер очереди соответствует максимальному количеству сообщений и максимальному размеру сообщения (256×2048 = 524288), а оставшиеся 13000 байт дают возможность хранить 48 байт добавочной информации для каждого сообщения (48×256) и еще 712 байт.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label123 style="border:none;"></a>5.4. Функции mqsend и mqreceive</P>
     </H1>
     <DIV class=section>
      <P>Эти две функции предназначены для помещения сообщений в очередь и получения их оттуда. Каждое сообщение имеет свой приоритет, который представляет собой беззнаковое целое, не превышающее MQ_PRIO_MAX. Стандарт Posix требует, чтобы эта величина была не меньше 32.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>В Solaris 2.6 значение MQ_PRIO_MAX равняется именно 32, но в Digital Unix 4.0B этот предел равен уже 256. В листинге 5.7 мы покажем, как получить эти значения.</P>
      </DIV>
      <P>Функция mq_receive всегда возвращает старейшее в указанной очереди сообщение с максимальным приоритетом, и приоритет может быть получен вместе с содержимым сообщения и его длиной.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Действие mq_receive отличается от действия msgrcv в System V (раздел 6.4). Сообщения System V имеют поле type, аналогичное по смыслу приоритету, но для функции msgrcv можно указать три различных алгоритма возвращения сообщений: старейшее сообщение в очереди, старейшее сообщение с указанным типом или старейшее сообщение с типом, не превышающим указанного значения.</P>
      </DIV>
      <P><CODE>#include &lt;mqueue.h&gt;</CODE></P>
      <P><CODE>int mq_send(mqd_t <EM>mqdes</EM>, const char *<EM>ptr</EM>, size_t <EM>len</EM>, unsigned int <EM>prio</EM>);</CODE></P>
      <P><CODE>/* Возвращает 0 в случае успешного завершения, –1 – в случае возникновения ошибок */</CODE></P>
      <P><CODE>ssize_t mq_receive(mqd_t <EM>mqdes</EM>, char *<EM>ptr</EM>, size_t <EM>len</EM>, unsigned int *<EM>priop</EM>);</CODE></P>
      <P><CODE>/* Возвращает количество байтов в сообщении в случае успешного завершения. –1 – в случае ошибки */</CODE></P>
      <P>Первые три аргумента обеих функций аналогичны первым трем аргументам функций write и read соответственно.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Объявление указателя на буфер как char* кажется ошибкой — тип void* больше соответствовал бы по духу прочим функциям Posix.1. </P>
      </DIV>
      <P>Значение аргумента len функции mq_receive должно быть по крайней мере не меньше максимального размера сообщения, которое может быть помещено в очередь, то есть значения поля mq_msgsize структуры mq_attr для этой очереди. Если len оказывается меньше этой величины, немедленно возвращается ошибка EMSGSIZE. </P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Это означает, что большинству приложений, использующих очереди сообщений Posix, придется вызывать mq_getattr после открытия очереди для определения максимального размера сообщения, а затем выделять память под один или несколько буферов чтения этого размера. Требование, чтобы буфер был больше по размеру, чем максимально возможное сообщение, позволяет функции mq_receive не возвращать уведомление о том, что размер письма превышает объем буфера. Сравните это, например, с флагом MSG_NOERROR и ошибкой E2BIG для очередей сообщений System V (раздел 6.4) и флагом MSG_TRUNC для функции recvmsg, используемой с дейтаграммами UDP (раздел 13.5 [24]). </P>
      </DIV>
      <P>Аргумент <EM>prio </EM>устанавливает приоритет сообщения для mq_send, его значение должно быть меньше MQ_PRIO_MAX. Если при вызове mq_receive <EM>priop </EM>является ненулевым указателем, в нем сохраняется приоритет возвращаемого сообщения. Если приложению не требуется использование различных приоритетов сообщений, можно указывать его равным нулю для mq_send и передавать mq_receive нулевой указатель в качестве последнего аргумента.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Разрешена передача сообщений нулевой длины. Это тот случай, когда важно не то, о чем говорится в стандарте (Posix.1), а то, о чем в нем не говорится: нигде не запрещена передача сообщений нулевой длины. Функция mq_receive возвращает количество байтов в сообщении (в случае успешного завершения работы) или –1 в случае возникновения ошибок, так что 0 обозначает сообщение нулевой длины. </P>
      </DIV>
      <P>Очередям сообщений Posix и System V не хватает полезной функции: получатель не может определить отправителя сообщения. Эта информация могла бы пригодиться многим приложениям. К сожалению, большинство механизмов передачи сообщений IPC не позволяют определить отправителя сообщений. В разделе 15.5 мы расскажем, как эта возможность обеспечивается для дверей. В разделе 14.8 [24] описано, как эта возможность обеспечивается в BSD/OS для доменных сокетов Unix. В разделе 15.3.1 [21] описано, как SVR4 передает информацию об отправителе по каналу при передаче по нему дескриптора. В настоящее время методы BSD/OS широко используются, и хотя реализация SVR4 является частью стандарта Unix 98, она требует передачи дескриптора по каналу, что обычно является более дорогостоящей операцией, чем просто передача данных. Мы не можем предоставить отправителю возможность передать информацию о себе (например, эффективный идентификатор пользователя) в самом сообщении, поскольку мы не можем быть уверены, что эта информация окажется истинной. Хотя разрешения доступа к очереди сообщений определяют, имеет ли право отправитель помещать в нее сообщения, это все равно не дает однозначности. Существует возможность создавать одну очередь для каждого отправителя (о которой рассказывается в связи с очередями System V в разделе 6.8), но это плохо подходит для больших приложений. Наконец, если функции для работы с очередями сообщений реализованы как пользовательские функции (как мы показываем в разделе 5.8), а не как часть ядра, мы не можем доверять никакой информации об отправителе, передаваемой с сообщением, так как ее легко подделать. </P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label124 style="border:none;"></a>Пример: программа mqsend</P>
      </H1>
      <P>В листинге 5.5 приведен текст программы, помещающей сообщение в очередь.</P>
      <H2><a name=label125 style="border:none;"></a>Листинг 5.5. Программа mqsend</H2>
      <P><CODE>//pxmsg/mqsend.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   mqd_t mqd;</CODE></P>
      <P><CODE>6   void *ptr;</CODE></P>
      <P><CODE>7   size_t len;</CODE></P>
      <P><CODE>8   uint_t prio;</CODE></P>
      <P><CODE>9   if (argc != 4)</CODE></P>
      <P><CODE>10   err_quit("usage: mqsend &lt;name&gt; &lt;#bytes&gt; &lt;priority&gt;");</CODE></P>
      <P><CODE>11  len = atoi(argv[2]);</CODE></P>
      <P><CODE>12  prio = atoi(argv[3]);</CODE></P>
      <P><CODE>13  mqd = Mq_open(argv[1], O_WRONLY);</CODE></P>
      <P><CODE>14  ptr = Calloc(len, sizeof (char));</CODE></P>
      <P><CODE>15  Mq_send(mqd, ptr, len, prio);</CODE></P>
      <P><CODE>16  exit(0);</CODE></P>
      <P><CODE>17 }</CODE></P>
      <P>И размер сообщения, и его приоритет являются обязательными аргументами командной строки. Буфер под сообщение выделяется функцией callос, которая инициализирует его нулем.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label126 style="border:none;"></a>Пример: программа mqreceive</P>
      </H1>
      <P>Программа в листинге 5.6 считывает сообщение из очереди.</P>
      <H2><a name=label127 style="border:none;"></a>Листинг 5.6. Программа mqreceive</H2>
      <P><CODE>//pxmsg/mqreceive.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int с flags;</CODE></P>
      <P><CODE>6   mqd_t mqd;</CODE></P>
      <P><CODE>7   ssize_t n;</CODE></P>
      <P><CODE>8   uint_t prio;</CODE></P>
      <P><CODE>9   void *buff;</CODE></P>
      <P><CODE>10  struct mq_attr attr;</CODE></P>
      <P><CODE>11  flags = O_RDONLY;</CODE></P>
      <P><CODE>12  while ((c = Getopt(argc, argv, "n")) != –1) {</CODE></P>
      <P><CODE>13   switch (c) {</CODE></P>
      <P><CODE>14   case 'n':</CODE></P>
      <P><CODE>15    flags |= O_NONBLOCK;</CODE></P>
      <P><CODE>16    break;</CODE></P>
      <P><CODE>17   }</CODE></P>
      <P><CODE>18  }</CODE></P>
      <P><CODE>19  if (optind != argc – 1)</CODE></P>
      <P><CODE>20   err_quit("usage: mqreceive [ –n ] &lt;name&gt;");</CODE></P>
      <P><CODE>21  mqd = Mq_open(argv[optind], flags);</CODE></P>
      <P><CODE>22  Mq_getattr(mqd, &amp;attr);</CODE></P>
      <P><CODE>23  buff = Malloc(attr.mqjnsgsize);</CODE></P>
      <P><CODE>24  n = Mq_receive(raqd, buff, attr.mq_msgsize, &amp;prio);</CODE></P>
      <P><CODE>25  printf("read %ld bytes, priority = %u\n", (long) n, prio);</CODE></P>
      <P><CODE>26  exit(0);</CODE></P>
      <P><CODE>27 }</CODE></P>
      <H2><a name=label128 style="border:none;"></a>Параметр -n запрещает блокировку</H2>
      <P>14-17 Параметр командной строки –n отключает блокировку. При этом программа возвращает сообщение об ошибке, если в очереди нет сообщений.</P>
      <H2><a name=label129 style="border:none;"></a>Открытие очереди и получение атрибутов</H2>
      <P>21-25 Мы открываем очередь и получаем ее атрибуты, вызвав mq_getattr. Нам обязательно нужно определить максимальный размер сообщения, потому что мы должны выделить буфер подходящего размера, чтобы вызвать mq_receive. Программа выводит размер считываемого сообщения и его приоритет.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Поскольку n имеет тип size_t и мы не знаем, int это или long, мы преобразуем эту величину к типу long и используем строку формата %ld. В 64-разрядной реализации int будет 32-разрядным целым, a long и size_t будут 64-разрядными целыми.</P>
      </DIV>
      <P>Воспользуемся обеими программами, чтобы проиллюстрировать использование поля приоритета.</P>
      <P><CODE>solaris % <STRONG>mqcreate /test1</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>mqgetattr /test1        </STRONG><EM>создаем очередь и смотрим на ее атрибуты</EM></CODE></P>
      <P><CODE>max #msgs = 128, max #bytes/msg = 1024, #currently on queue = 0</CODE></P>
      <P><CODE>solaris % <STRONG>mqsend /test1 100 99999 </STRONG><EM>отправка с некорректным значением приоритета</EM></CODE></P>
      <P><CODE>mq_send error: Invalid argument</CODE></P>
      <P><CODE>solaris % <STRONG>mqsend /test1 100 6     </STRONG><EM>100 байт, приоритет 6</EM></CODE></P>
      <P><CODE>solaris % <STRONG>mqsend /test1 50 18     </STRONG><EM>50 байт, приоритет 18</EM></CODE></P>
      <P><CODE>solaris % <STRONG>mqsend /test1 33 18     </STRONG><EM>33 байт, приоритет 18</EM></CODE></P>
      <P><CODE>solaris % <STRONG>mqreceive /test1</STRONG></CODE></P>
      <P><CODE>read 50 bytes, priority = 18         <EM>возвращается старейшее сообщение с</EM></CODE></P>
      <P><CODE>solaris % <STRONG>mqreceive /test1        </STRONG><EM>наивысшим приоритетом</EM></CODE></P>
      <P><CODE>read 33 bytes, priority = 18</CODE></P>
      <P><CODE>Solaris % <STRONG>mqreceive /test1</STRONG></CODE></P>
      <P><CODE>read 100 bytes, priority = 6</CODE></P>
      <P><CODE>Solaris % <STRONG>mqreceive –n /test1     </STRONG><EM>отключаем блокировку и убеждаемся, что очередь пуста</EM></CODE></P>
      <P><CODE>mq_receive error: Resource temporarily unavailable</CODE></P>
      <P>Мы видим, что mq_receive действительно возвращает старейшее сообщение с наивысшим приоритетом. </P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label130 style="border:none;"></a>5.5. Ограничения очередей сообщений</P>
     </H1>
     <DIV class=section>
      <P>Мы уже сталкивались с двумя ограничениями, устанавливаемыми для любой очереди в момент ее создания:</P>
      <P>■ mq_maxmsg — максимальное количество сообщений в очереди;</P>
      <P>■ mq_msgsize — максимальный размер сообщения.</P>
      <P>Не существует каких-либо ограничений на эти значения, хотя в рассматриваемых реализациях необходимо наличие в файловой системе места для файла требуемого размера. Кроме того, ограничения на эти величины могут накладываться реализацией виртуальной памяти (см. упражнение 5.5).</P>
      <P>Другие два ограничения определяются реализацией:</P>
      <P>■ MQ_OPEN_MAX — максимальное количество очередей сообщений, которые могут быть одновременно открыты каким-либо процессом (Posix требует, чтобы эта величина была не меньше 8);</P>
      <P>■ MQ_PRIO_MAX — максимальное значение приоритета плюс один (Posix требует, чтобы эта величина была не меньше 32).</P>
      <P>Эти две константы часто определяются в заголовочном файле &lt;unistd.h&gt; и могут быть получены во время выполнения программы вызовом функции sysconf, как мы покажем далее.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label131 style="border:none;"></a>Пример: программа mqsysconf</P>
      </H1>
      <P>Программа в листинге 5.7 вызывает функцию sysconf и выводит два ограничения на очереди сообщений, определяемые реализацией.</P>
      <H2><a name=label132 style="border:none;"></a>Листинг 5.7. Получение ограничений очередей с помощью sysconf</H2>
      <P><CODE>//pxmsg/mqsysconf.с</CODE></P>
      <P><CODE>1 #include "unpipc.h"</CODE></P>
      <P><CODE>2 int</CODE></P>
      <P><CODE>3 main(int argc, char **argv)</CODE></P>
      <P><CODE>4 {</CODE></P>
      <P><CODE>5  printf("MQ_OPEN_MAX = %ld, MQ_PRIO_MAX = %ld\n",</CODE></P>
      <P><CODE>6  Sysconf(_SC_MQ_OPEN_MAX), Sysconf(_SC_MQ_PRIO_MAX));</CODE></P>
      <P><CODE>7  exit(0);</CODE></P>
      <P><CODE>8 }</CODE></P>
      <P>Запустив эту программу в наших двух операционных системах, получим:</P>
      <P><CODE>solaris % <STRONG>mqsysconf</STRONG></CODE></P>
      <P><CODE>MQ_OPEN_MAX = 32, MQ_PRIO_MAX = 32</CODE></P>
      <P><CODE>alpha % <STRONG>mqsysconf</STRONG></CODE></P>
      <P><CODE>MQ_OPEN_MAX = 64, MQ_PRIO_MAX = 256</CODE></P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label133 style="border:none;"></a>5.6. Функция mq_notify</P>
     </H1>
     <DIV class=section>
      <P>Один из недостатков очередей сообщений System V, как мы увидим в главе 6, заключается в невозможности уведомить процесс о том, что в очередь было помещено сообщение. Мы можем заблокировать процесс при вызове msgrcv, но тогда мы не сможем выполнять другие действия во время ожидания сообщения. Если мы укажем флаг отключения блокировки при вызове msgrcv (IPC_NOWAIT), процесс не будет заблокирован, но нам придется регулярно вызывать эту функцию, чтобы получить сообщение, когда оно будет отправлено. Мы уже говорили, что такая процедура называется <EM>опросом </EM>и на нее тратится лишнее время. Нужно, чтобы система сама уведомляла процесс о том, что в пустую очередь было помещено новое сообщение.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>В этом и всех последующих разделах данной главы обсуждаются более сложные вопросы, которые могут быть пропущены при первом чтении. </P>
      </DIV>
      <P>Очереди сообщений Posix допускают асинхронное уведомление о событии, когда сообщение помещается в очередь. Это уведомление может быть реализовано либо отправкой сигнала, либо созданием программного потока для выполнения указанной функции.</P>
      <P>Мы включаем режим уведомления с помощью функции mq_notify:</P>
      <P><CODE>#include &lt;mqueue.h&gt;</CODE></P>
      <P><CODE>int mq_notify(mqd_t <EM>mqdes,</EM> const struct sigevent <EM>*notification);</EM></CODE></P>
      <P><CODE><EM>/*</EM> Возвращает 0 в случае успешного выполнения, –1 – в случае ошибки */</CODE></P>
      <P>Эта функция включает и выключает асинхронное уведомление о событии для указанной очереди. Структура sigevent впервые появилась в стандарте Posix.1 для сигналов реального времени, о которых более подробно рассказано в следующем разделе. Эта структура и все новые константы, относящиеся к сигналам, определены в заголовочном файле &lt;signal.h&gt;:</P>
      <P><CODE>union sigval {</CODE></P>
      <P><CODE> int sival_int; /* целое значение */</CODE></P>
      <P><CODE> void *sival_ptr; /* указатель */ </CODE></P>
      <P><CODE>};</CODE></P>
      <BR>
      <P><CODE>struct sigevent {</CODE></P>
      <P><CODE> int sigev_notify; /* SIGEV_{NONE,SIGNAL,THREAD} */</CODE></P>
      <P><CODE> int sigev_signo; /* номер сигнала, если SIGEV_SIGNAL */</CODE></P>
      <P><CODE> union sigval sigev_value; /* передается обработчику сигнала или потоку */</CODE></P>
      <P><CODE>/* Следующие два поля определены для SIGEV_THREAD */</CODE></P>
      <P><CODE>void (*sigev_notify_function) (union sigval);</CODE></P>
      <P><CODE>pthread_attr_t *sigev_notify_attributes;</CODE></P>
      <P>Мы вскоре приведем несколько примеров различных вариантов использования уведомления, но о правилах, действующих для этой функции всегда, можно упомянуть уже сейчас.</P>
      <P>1. Если аргумент <EM>notification</EM> ненулевой, процесс ожидает уведомления при поступлении нового сообщения в указанную очередь, пустую на момент его поступления. Мы говорим, что процесс <EM>регистрируется на уведомление для данной очереди.</EM></P>
      <P>2. Если аргумент <EM>notification</EM> представляет собой нулевой указатель и процесс уже зарегистрирован на уведомление для данной очереди, то уведомление для него отключается.</P>
      <P>3. Только один процесс может быть зарегистрирован на уведомление для любой данной очереди в любой момент.</P>
      <P>4.  При помещении сообщения в пустую очередь, для которой имеется зарегистрированный на уведомление процесс, оно будет отправлено только в том случае, если нет заблокированных в вызове mq_receive для этой очереди процессов. Таким образом, блокировка в вызове mq_receive имеет приоритет перед любой регистрацией на уведомление.</P>
      <P>5. При отправке уведомления зарегистрированному процессу регистрация снимается. Процесс должен зарегистрироваться снова (если в этом есть необходимость), вызвав mq_notify еще раз.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>С сигналами в Unix всегда была связана одна проблема: действие сигнала сбрасывалось на установленное по умолчанию каждый раз при отправке сигнала (раздел 10.4 [21]). Обычно первой функцией, вызываемой обработчиком сигнала, была signal, переопределявшая обработчик. Это создавало небольшой временной промежуток между отправкой сигнала и переопределением обработчика, в который процесс мог быть завершен при повторном появлении того же сигнала. На первый взгляд может показаться, что та же проблема должна возникать и при использовании mq_notify, поскольку процесс должен перерегистрироваться каждый раз после появления уведомления. Однако очереди сообщений отличаются по своим свойствам от сигналов, поскольку необходимость отправки уведомления не может возникнуть, пока очередь не будет пуста. Следовательно, необходимо аккуратно перерегистрироваться на получение уведомления <EM>до</EM> считывания пришедшего сообщения из очереди.</P>
      </DIV>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label134 style="border:none;"></a>Пример: простая программа с уведомлением</P>
      </H1>
      <P>Прежде чем углубляться в тонкости сигналов реального времени и потоков Posix, мы напишем простейшую программу, включающую отправку сигнала SI6USR1 при помещении сообщения в пустую очередь. Эта программа приведена в листинге 5.8, и мы отметим, что она содержит ошибку, о которой мы вскоре поговорим подробно.</P>
      <H2><a name=label135 style="border:none;"></a>Листинг 5.8. Отправка sigusr1 при помещении сообщения в пустую очередь (неправильная версия программы)</H2>
      <P><CODE>//pxmsg/mqnotifysigl.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  mqd_t mqd;</CODE></P>
      <P><CODE>3  void *buff;</CODE></P>
      <P><CODE>4  struct mq_attr attr;</CODE></P>
      <P><CODE>5  struct sigevent sigev;</CODE></P>
      <P><CODE>6  static void sig_usrl(int);</CODE></P>
      <BR>
      <P><CODE>7  int</CODE></P>
      <P><CODE>8  main(int argc, char **argv)</CODE></P>
      <P><CODE>9  {</CODE></P>
      <P><CODE>10  if (argc != 2)</CODE></P>
      <P><CODE>11   err_quit("usage: mqnotifysig1 &lt;name&gt;");</CODE></P>
      <P><CODE>12  /* открываем очередь, получаем атрибуты, выделяем буфер */</CODE></P>
      <P><CODE>13  mqd = Mq_open(argv[1], O_RDONLY);</CODE></P>
      <P><CODE>14  Mq_getattr(mqd, &amp;attr);</CODE></P>
      <P><CODE>15  buff = Malloc(attr.mq_msgsize);</CODE></P>
      <P><CODE>16  /* устанавливаем обработчик, включаем уведомление */</CODE></P>
      <P><CODE>17  Signal(SIGUSR1, sig_usr1);</CODE></P>
      <P><CODE>18  sigev.sigev_notify = SIGEV_SIGNAL;</CODE></P>
      <P><CODE>19  sigev.sigev_signo = SIGUSR1;</CODE></P>
      <P><CODE>20  Mq_notify(mqd, &amp;sigev);</CODE></P>
      <P><CODE>21  for (;;)</CODE></P>
      <P><CODE>22   pause(); /* все делает обработчик */</CODE></P>
      <P><CODE>23  exit(0);</CODE></P>
      <P><CODE>24 }</CODE></P>
      <BR>
      <P><CODE>25 static void</CODE></P>
      <P><CODE>26 sig_usr1(int signo)</CODE></P>
      <P><CODE>27 {</CODE></P>
      <P><CODE>28  ssize_t n;</CODE></P>
      <P><CODE>29  Mq_notify(mqd, &amp;sigev); /* сначала перерегистрируемся */</CODE></P>
      <P><CODE>30  n = Mq_receive(mqd, buff, attr.mq_msgsize, NULL);</CODE></P>
      <P><CODE>31  printf("SIGUSR1 received, read %ld bytes\n", (long) n);</CODE></P>
      <P><CODE>32  return;</CODE></P>
      <P><CODE>33 }</CODE></P>
      <H2><a name=label136 style="border:none;"></a>Объявление глобальных переменных</H2>
      <P>2-6 Мы объявляем несколько глобальных переменных, используемых совместно функцией main и нашим обработчиком сигнала (sig_usr1).</P>
      <H2><a name=label137 style="border:none;"></a>Открытие очереди, получение атрибутов, выделение буфера чтения</H2>
      <P>12-15 Мы открываем очередь сообщений, получаем ее атрибуты и выделяем буфер считывания соответствующего размера.</P>
      <H2><a name=label138 style="border:none;"></a>Установка обработчика сигнала, включение уведомления</H2>
      <P>16-20 Сначала мы устанавливаем свой обработчик для сигнала SIGUSR1. Мы присваиваем полю sigev_notify структуры sigevent значение SIGEV_SIGNAL, что говорит системе о необходимости отправки сигнала, когда очередь из пустой становится непустой. Полю sigev_signo присваивается значение, соответствующее тому сигналу, который мы хотим получить. Затем вызывается функция mq_notify.</P>
      <H2><a name=label139 style="border:none;"></a>Бесконечный цикл</H2>
      <P>Функция main после этого зацикливается, и процесс приостанавливается при вызове pause, возвращающей –1 при получении сигнала.</P>
      <H2><a name=label140 style="border:none;"></a>Получение сигнала, считывание сообщения</H2>
      <P>Обработчик сигнала вызывает mq_notify для перерегистрации, считывает сообщение и выводит его длину. В этой программе мы игнорируем приоритет полученного сообщения. </P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Оператор return в конце sig_usr1 не требуется, поскольку возвращаемое значение отсутствует, а конец текста функции неявно предусматривает возвращение в вызвавшую программу. Тем не менее автор всегда записывает return явно, чтобы указать, что возвращение из этой функции может происходит с особенностями. Например, может произойти преждевременный возврат (с ошибкой EINTR) в потоке, обрабатывающем сигнал. </P>
      </DIV>
      <P>Запустим теперь эту программу в одном из окон</P>
      <P><CODE>solaris % <STRONG>mqcreate /test1</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>mqnotifysig1 /test1</STRONG></CODE></P>
      <P>и затем выполним следующую команду в другом окне</P>
      <P><CODE>solaris % <STRONG>mqsend /test1 50 16</STRONG></CODE></P>
      <P>Как и ожидалось, программа mqnotifysig1 выведет сообщение: SIGUSR1 received, read 50 bytes.</P>
      <P>Мы можем проверить, что только один процесс может быть зарегистрирован на получение уведомления в любой момент, запустив копию пpoгрaммы в другом окне:</P>
      <P><CODE>solaris % <STRONG>mqnotifysig1 /test1</STRONG></CODE></P>
      <P><CODE>mq_notify error: Device busy</CODE></P>
      <P>Это сообщение соответствует коду ошибки EBUSY.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label141 style="border:none;"></a>Сигналы Posix: функции типа Async-Signal-Safe</P>
      </H1>
      <P>Недостаток пpoгрaммы из листинга 5.8 в том, что она вызывает mq_notify, mq_receive и printf из обработчика сигнала. Ни одну из этих функций вызывать оттуда не следует.</P>
      <P>Функции, которые могут быть вызваны из обработчика сигнала, относятся к группе, называемой, согласно Posix, <EM>async-signal-safe functions</EM> (функции, обеспечивающие безопасную обработку асинхронных сигналов). В табл. 5.1 приведены эти функции по стандарту Posix вместе с некоторыми дополнительными, появившимися только в Unix 98.</P>
      <P>Функции, которых нет в этом списке, не должны вызываться из обработчика сигнала. Обратите внимание, что в списке отсутствуют стандартные функции библиотеки ввода-вывода и функции pthread_XXX для работы с потоками. Из всех функций IPC, рассматриваемых в этой книге, в список попали только sem_post, read и write (подразумевается, что последние две используются с программными каналами и FIFO).</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Стандарт ANSI С указывает четыре функции, которые могут быть вызваны из обработчика сигналов: abort, exit, longjmp, signal. Первые три отсутствуют в списке функций async-signal-safe стандарта Unix 98. </P>
      </DIV>
      <BR>
      <P>Таблица 5.1. Функции, относящиеся к группе async-signal-safe</P>
      <P><CODE>access        fpathconf rename      sysconf</CODE></P>
      <P><CODE>aio_return    fstat     rmdir       tcdrain</CODE></P>
      <P><CODE>aio_suspend   fsync     sem_post    tcflow </CODE></P>
      <P><CODE>alarm         getegid   setgid      tcflush</CODE></P>
      <P><CODE>cfgetispeed   geteuid   setpgid     tcgetattr</CODE></P>
      <P><CODE>cfgetospeed   getgid    setsid      tcgetgrp</CODE></P>
      <P><CODE>cfsetispeed   getgroups setuid      tcsendbreak</CODE></P>
      <P><CODE>cfsetospeed   getpgrp   sigaction   tcsetattr</CODE></P>
      <P><CODE>chdir         getpid    sigaddset   tcsetpgrp</CODE></P>
      <P><CODE>chmod         getppid   sigdelset   time</CODE></P>
      <P><CODE>chown         getuid    sigemptyset timer_getoverrun</CODE></P>
      <P><CODE>clock_gettime kill      sigfillset  timer_gettime</CODE></P>
      <P><CODE>close         link      sigismember timer_settime</CODE></P>
      <P><CODE>creat         lseek     signal      times</CODE></P>
      <P><CODE>dup           mkdir     sigpause    umask</CODE></P>
      <P><CODE>dup2          mkfifo    sigpending  uname</CODE></P>
      <P><CODE>execle        open      sigprocmask unlink</CODE></P>
      <P><CODE>execve        pathconf  sigqueue    utime</CODE></P>
      <P><CODE>_exit         pause     sigset      wait</CODE></P>
      <P><CODE>fcntl         pipe      sigsuspend  waitpid</CODE></P>
      <P><CODE>fdatasync     raise     sleep       write</CODE></P>
      <P><CODE>fork          read      stat</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label142 style="border:none;"></a>Пример: уведомление сигналом</P>
      </H1>
      <P>Одним из способов исключения вызова каких-либо функций из обработчика сигнала является установка этим обработчиком глобального флага, который проверяется программным потоком для получения информации о приходе сообщения. В листинге 5.9 иллюстрируется этот метод, хотя новая программа также содержит ошибку, но уже другую, о которой мы вскоре поговорим подробнее.</P>
      <H2><a name=label143 style="border:none;"></a>Глобальная переменная</H2>
      <P>2 Поскольку единственное действие, выполняемое обработчиком сигнала, заключается в присваивании ненулевого значения флагу mqflag, глобальным переменным из листинга 5.8 уже не нужно являться таковыми. Уменьшение количества глобальных переменных — это всегда благо, особенно при использовании программных потоков.</P>
      <H2><a name=label144 style="border:none;"></a>Открытие очереди сообщений</H2>
      <P>15-18 Мы открываем очередь сообщений, получаем ее атрибуты и выделяем буфер считывания.</P>
      <H2><a name=label145 style="border:none;"></a>Инициализация наборов сигналов</H2>
      <P>19-22 Мы инициализируем три набора сигналов и устанавливаем бит для сигнала SIGUSR1 в наборе newmask.</P>
      <H2><a name=label146 style="border:none;"></a>Установка обработчика сигнала, включение уведомления</H2>
      <P>23-27 Мы устанавливаем обработчик сигнала для SIGUSR1, присваиваем значения полям структуры sigevent и вызываем mq_notify. </P>
      <H2><a name=label147 style="border:none;"></a>Листинг 5.9. Обработчик сигнала устанавливает флаг для главного потока (неправильная версия)</H2>
      <P><CODE>//pxmsg/mqnotifysig2.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  volatile sig_atomic_t mqflag; /* ненулевое значение устанавливается обработчиком */</CODE></P>
      <P><CODE>3  static void sig_usrl(int);</CODE></P>
      <BR>
      <P><CODE>4  int</CODE></P>
      <P><CODE>5  main(int argc, char **argv)</CODE></P>
      <P><CODE>6  {</CODE></P>
      <P><CODE>7   mqd_t mqd;</CODE></P>
      <P><CODE>8   void *buff;</CODE></P>
      <P><CODE>9   ssize_t n;</CODE></P>
      <P><CODE>10  sigset_t zeromask, newmask, oldmask;</CODE></P>
      <P><CODE>11  struct mq_attr attr;</CODE></P>
      <P><CODE>12  struct sigevent sigev;</CODE></P>
      <P><CODE>13  if (argc != 2)</CODE></P>
      <P><CODE>14   err_quit("usage: mqnotifysig2 &lt;name&gt;");</CODE></P>
      <P><CODE>15  /* открытие очереди, получение атрибутов, выделение буфера */</CODE></P>
      <P><CODE>16  mqd = Mq_open(argv[1], O_RDONLY);</CODE></P>
      <P><CODE>17  Mq_getattr(mqd, &amp;attr);</CODE></P>
      <P><CODE>18  buff = Malloc(attr.mq_msgsize);</CODE></P>
      <P><CODE>19  Sigemptyset(&amp;zeromask); /* сигналы не блокируются */</CODE></P>
      <P><CODE>20  Sigemptyset(&amp;newmask);</CODE></P>
      <P><CODE>21  Sigemptyset(&amp;oldmask);</CODE></P>
      <P><CODE>22  Sigaddset(&amp;newmask, SIGUSR1);</CODE></P>
      <P><CODE>23  /* установка обработчика, включение уведомления */</CODE></P>
      <P><CODE>24  Signal(SIGUSR1, sig_usr1);</CODE></P>
      <P><CODE>25  sigev.sigev_notify = SIGEV_SIGNAL;</CODE></P>
      <P><CODE>26  sigev.sigev_signo = SIGUSR1;</CODE></P>
      <P><CODE>27  Mq_notify(mqd, &amp;sigev);</CODE></P>
      <P><CODE>28  for (;;) {</CODE></P>
      <P><CODE>29   Sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask); /* блокируем SIGUSR1 */</CODE></P>
      <P><CODE>30   while (mqflag == 0)</CODE></P>
      <P><CODE>31    sigsuspend(&amp;zeromask);</CODE></P>
      <P><CODE>32   mqflag = 0; /* сброс флага */</CODE></P>
      <P><CODE>33   Mq_notify(mqd, &amp;sigev); /* перерегистрируемся */</CODE></P>
      <P><CODE>34   n = Mq_receive(mqd, buff, attr.mq_msgsize, NULL);</CODE></P>
      <P><CODE>35   printf("read %ld bytes\n", (long) n);</CODE></P>
      <P><CODE>36   Sigprocmask(SIG_UNBLOCK, &amp;newmask, NULL); /* разблокируем SIGUSR1 */</CODE></P>
      <P><CODE>37  }</CODE></P>
      <P><CODE>38  exit(0);</CODE></P>
      <P><CODE>39 }</CODE></P>
      <BR>
      <P><CODE>40 static void</CODE></P>
      <P><CODE>41 sig_usr1(int signo)</CODE></P>
      <P><CODE>42 {</CODE></P>
      <P><CODE>43  mqflag = 1;</CODE></P>
      <P><CODE>44  return;</CODE></P>
      <P><CODE>45 }</CODE> </P>
      <H2><a name=label148 style="border:none;"></a>Ожидание установки флага обработчиком</H2>
      <P>28-32 Мы вызываем sigprocmask, чтобы заблокировать SIGUSR1, сохраняя текущую маску сигналов в oldmask. Затем мы в цикле проверяем значение глобального флага mqflag, ожидая, когда обработчик сигнала установит его в ненулевое значение. Пока значение этого флага равно нулю, мы вызываем sigsuspend, что автоматически приостанавливает вызывающий поток и устанавливает его маску в zeromask (сигналы не блокируются). Раздел 10.16 [21] рассказывает о функции sigsuspend более подробно. Также там объясняются причины, по которым мы должны проверять значение переменной mqflag только при заблокированном сигнале SIGUSR1. Каждый раз при выходе из sigsuspend сигнал SIGUSR1 блокируется.</P>
      <H2><a name=label149 style="border:none;"></a>Перерегистрация и считывание сообщения</H2>
      <P>33-36 Когда флаг mqflag принимает ненулевое значение, мы регистрируемся на получение уведомления заново и считываем сообщение из очереди. Затем мы разблокируем сигнал SIGUSR1 и возвращаемся к началу цикла.</P>
      <P>Мы уже говорили, что в этой версии программы также присутствует ошибка. Посмотрим, что произойдет, если в очередь попадут два сообщения, прежде чем будет считано первое из них. Мы можем имитировать это, добавив sleep перед вызовом mq_notify. Проблема тут в том, что уведомление отсылается только в том случае, когда сообщение помещается в пустую очередь. Если в очередь поступают два сообщения, прежде чем первое будет считано, то отсылается только одно уведомление. Тогда мы считываем первое сообщение и вызываем sigsuspend, ожидая поступления еще одного. А в это время в очереди уже имеется сообщение, которое мы должны прочитать, но которое мы никогда не прочтем.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label150 style="border:none;"></a>Пример: уведомление сигналом с отключением блокировки</P>
      </H1>
      <P>Исправить описанную выше ошибку можно, отключив блокировку операции считывания сообщений. Листинг 5.10 содержит измененную версию программы из листинга 5.9. Новая программа считывает сообщения в неблокируемом режиме.</P>
      <H2><a name=label151 style="border:none;"></a>Листинг 5.10. Использование уведомления с помощью сигнала для считывания сообщения из очереди сообщений Posix</H2>
      <P><CODE>//pxmsg/mqnotifysig3.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  volatile sig_atomic_t mqflag; /* ненулевое значение устанавливается обработчиком сигнала */</CODE></P>
      <P><CODE>3  static void sig_usr1(int);</CODE></P>
      <BR>
      <P><CODE>4  int</CODE></P>
      <P><CODE>5  main(int argc, char **argv)</CODE></P>
      <P><CODE>6  {</CODE></P>
      <P><CODE>7   mqd_t mqd;</CODE></P>
      <P><CODE>8   void *buff;</CODE></P>
      <P><CODE>9   ssize_t n;</CODE></P>
      <P><CODE>10  sigset_t zeromask, newmask, oldmask;</CODE></P>
      <P><CODE>11  struct mq_attr attr;</CODE></P>
      <P><CODE>12  struct sigevent sigev;</CODE></P>
      <P><CODE>13  if (argc != 2)</CODE></P>
      <P><CODE>14   err_quit("usage: mqnotifysig3 &lt;name&gt;");</CODE></P>
      <P><CODE>15  /* открытие очереди, получение атрибутов, выделение буфера */</CODE></P>
      <P><CODE>16  mqd = Mq_open(argv[1], O_RDONLY | O_NONBLOCK);</CODE></P>
      <P><CODE>17  Mq_getattr(mqd, &amp;attr);</CODE></P>
      <P><CODE>18  buff = Malloc(attr.mq_msgsize);</CODE></P>
      <P><CODE>19  Sigemptyset(&amp;zeromask); /* сигналы не блокируются */</CODE></P>
      <P><CODE>20  Sigemptyset(&amp;newmask);</CODE></P>
      <P><CODE>21  Sigemptyset(&amp;oldmask);</CODE></P>
      <P><CODE>22  Sigaddset(&amp;newmask, SIGUSR1);</CODE></P>
      <P><CODE>23  /* установка обработчика, включение уведомления */</CODE></P>
      <P><CODE>24  Signal(SIGUSR1, sig_usr1);</CODE></P>
      <P><CODE>25  sigev.sigev_notify = SIGEV_SIGNAL;</CODE></P>
      <P><CODE>26  sigev.sigev_signo = SIGUSR1;</CODE></P>
      <P><CODE>27  Mq_notify(mqd, &amp;sigev);</CODE></P>
      <P><CODE>28  for (;;) {</CODE></P>
      <P><CODE>29   Sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask); /* блокируем SIGUSR1 */</CODE></P>
      <P><CODE>30   while (mqflag == 0)</CODE></P>
      <P><CODE>31    sigsuspend(&amp;zeromask);</CODE></P>
      <P><CODE>32   mqflag = 0; /* сброс флага */</CODE></P>
      <P><CODE>33   Mq_notify(mqd, &amp;sigev); /* перерегистрируемся */</CODE></P>
      <P><CODE>34   while ((n = mq_receive(mqd, buff, attr.mq_msgsize, NULL)) &gt;= 0) {</CODE></P>
      <P><CODE>35    printf("read $ld bytes\n", (long) n);</CODE></P>
      <P><CODE>36   }</CODE></P>
      <P><CODE>37   if (errno != EAGAIN)</CODE></P>
      <P><CODE>38    err_sys("mq_receive error");</CODE></P>
      <P><CODE>39   Sigprocmask(SIG_UNBLOCK, &amp;newmask, NULL); /* разблокируем SIGUSR1 */</CODE></P>
      <P><CODE>40  }</CODE></P>
      <P><CODE>41  exit(0);</CODE></P>
      <P><CODE>42 }</CODE></P>
      <BR>
      <P><CODE>43 static void</CODE></P>
      <P><CODE>44 sig_usr1(int signo)</CODE></P>
      <P><CODE>45 {</CODE></P>
      <P><CODE>46  mqflag = 1;</CODE></P>
      <P><CODE>47  return;</CODE></P>
      <P><CODE>48 }</CODE></P>
      <H2><a name=label152 style="border:none;"></a>Открытие очереди сообщений в режиме<STRONG> отключенной блокировки</STRONG></H2>
      <P>15-18 Первое изменение в программе: при открытии очереди сообщений указывается флаг O_NONBLOCK.</P>
      <H2><a name=label153 style="border:none;"></a>Считывание всех сообщений из очереди</H2>
      <P>34-38 Другое изменение: mq_receive вызывается в цикле, считывая все сообщения в очереди, пока не будет возвращена ошибка с кодом EAGAIN, означающая отсутствие сообщений в очереди. </P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label154 style="border:none;"></a>Пример: уведомление с использованием sigwait вместо обработчика</P>
      </H1>
      <P>Хотя программа из предыдущего примера работает правильно, можно повысить ее эффективность. Программа использует sigsuspend для блокировки в ожидании прихода сообщения. При помещении сообщения в пустую очередь вызывается сигнал, основной поток останавливается, запускается обработчик, который устанавливает флаг mqflag, затем снова запускается главный поток, он обнаруживает, что значение mqflag отлично от нуля, и считывает сообщение. Более простой и эффективный подход заключается в блокировании в функции, ожидающей получения сигнала, что не требует вызова обработчика только для установки флага. Эта возможность предоставляется функцией sigwait:</P>
      <P><CODE>#include &lt;signal.h&gt;</CODE></P>
      <P><CODE>int sigwait(const sigset_t <EM>*set,</EM> int <EM>*sig</EM>);</CODE></P>
      <P><CODE>/* Возвращает 0 в случае успешного завершения, –1 – в случае ошибки */</CODE></P>
      <P>Перед вызовом sigwait мы блокируем некоторые сигналы. Набор блокируемых сигналов указывается в качестве аргумента set. Функция sigwait блокируется, пока не придет по крайней мере один из этих сигналов. Когда он будет получен, функция возвратит его. Значение этого сигнала сохраняется в указателе <EM>sig,</EM> а функция возвращает значение 0. Это называется <EM>синхронным ожиданием асинхронного события:</EM> мы используем сигнал, но не пользуемся асинхронным обработчиком сигнала.</P>
      <P>В листинге 5.11 приведен текст программы, использующей mq_notifу и sigwait.</P>
      <H2><a name=label155 style="border:none;"></a>Листинг 5.11. Использование mq_notify совместно с sigwait</H2>
      <P><CODE>//pxmsg/mqnotifysig4.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int signo;</CODE></P>
      <P><CODE>6   mqd_t mqd;</CODE></P>
      <P><CODE>7   void *buff;</CODE></P>
      <P><CODE>8   ssize_t n;</CODE></P>
      <P><CODE>9   sigset_t newmask;</CODE></P>
      <P><CODE>10  struct mq_attr attr;</CODE></P>
      <P><CODE>11  struct sigevent sigev;</CODE></P>
      <P><CODE>12  if (argc != 2)</CODE></P>
      <P><CODE>13   err_quit("usage: mqnotifysig4 &lt;name&gt;");</CODE></P>
      <P><CODE>14  /* открытие очереди, получение атрибутов, выделение буфера */</CODE></P>
      <P><CODE>15  mqd = Mq_open(argv[1], O_RDONLY | O_NONBLOCK);</CODE></P>
      <P><CODE>16  Mq_getattr(mqd, &amp;attr);</CODE></P>
      <P><CODE>17  buff = Malloc(attr.mq_msgsize);</CODE></P>
      <P><CODE>18  Sigemptyset(&amp;newmask);</CODE></P>
      <P><CODE>19  Sigaddset(&amp;newmask, SIGUSR1);</CODE></P>
      <P><CODE>20  Sigprocmask(SIG_BLOCK, &amp;newmask, NULL); /* блокируем SIGUSR1 */</CODE></P>
      <P><CODE>21  /* установка обработчика, включение уведомления */</CODE></P>
      <P><CODE>22  sigev.sigev_notify = SIGEV_SIGNAL;</CODE></P>
      <P><CODE>23  sigev.sigev_signo = SIGUSR1;</CODE></P>
      <P><CODE>24  Mq_notify(mqd, &amp;sigev);</CODE></P>
      <P><CODE>25  for (;;) {</CODE></P>
      <P><CODE>26   Sigwait(&amp;newmask, &amp;signo);</CODE></P>
      <P><CODE>27   if (signo == SIGUSR1) {</CODE></P>
      <P><CODE>28    Mq_notify(mqd, &amp;sigev); /* перерегистрируемся */</CODE></P>
      <P><CODE>29    while ((n = mq_receive(mqd, buff, attr.mq_msgsize, NULL)) &gt;= 0) {</CODE></P>
      <P><CODE>30     printf("read %ld bytes\n", (long) n);</CODE></P>
      <P><CODE>31    }</CODE></P>
      <P><CODE>32    if (errno != EAGAIN)</CODE></P>
      <P><CODE>33     err_sys("mq_receive error");</CODE></P>
      <P><CODE>34   }</CODE></P>
      <P><CODE>35  }</CODE></P>
      <P><CODE>36  exit(0);</CODE></P>
      <P><CODE>37 }</CODE></P>
      <H2><a name=label156 style="border:none;"></a>Инициализация набора сигналов и блокировка SIGUSR1</H2>
      <P>18-20 Инициализируется один набор сигналов, содержащий только SIGUSR1, а затем этот сигнал блокируется sigprocmask.</P>
      <H2><a name=label157 style="border:none;"></a>Ожидание сигнала</H2>
      <P>26-34 Мы блокируем выполнение программы и ждем прихода сигнала, вызвав sigwait. При получении сигнала SIGUSR1 мы перерегистрируемся на уведомление и считываем все доступные сообщения.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Функция sigwait часто используется в многопоточных процессах. Действительно, глядя на прототип функции, мы можем заметить, что возвращаемое значение будет 0 или одной из ошибок Еххх, что весьма похоже на функции Pthread. Однако в многопоточном процессе нельзя пользоваться sigprocmask — вместо нее следует вызывать pthread_ sigmask, которая изменяет маску сигналов только для вызвавшего ее потока. Аргументы pthread_sigmask совпадают с аргументами sigprocmask.</P>
       <P>Существуют два варианта функции sigwait: sigwaitinfo возвращает структуру siginfo_t (которая будет определена в следующем разделе) и предназначена для использования с надежными сигналами; функция sigtimedwait также возвращает структуру siginfo_t и позволяет вызывающему процессу установить ограничение по времени на ожидание.</P>
       <P>Большая часть книг о многопоточном программировании, таких как [3], рекомендуют пользоваться sigwait для обработки всех сигналов в многопоточном процессе и не использовать асинхронные обработчики. </P>
      </DIV>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label158 style="border:none;"></a>Пример: очереди сообщений Posix и функция select</P>
      </H1>
      <P>Дескриптор очереди сообщений (переменная типа mqd_t) не является «обычным» дескриптором и не может использоваться с функциями select и poll (глава 6 [24]). Тем не менее их можно использовать вместе с каналом и функцией mq_notify. (Аналогичный метод применен в разделе 6.9 для очередей System V, где создается дочерний процесс и канал связи.) Прежде всего обратите внимание, что, согласно табл. 5.1, функция write принадлежит к группе async-signal-safe, поэтому она может вызываться из обработчика сигналов. Программа приведена в листинге 5.12.</P>
      <H2><a name=label159 style="border:none;"></a>Листинг 5.12. Использование уведомления с помощью сигнала и канала</H2>
      <P><CODE>//pxmsg/mqnotifysig5.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  int pipefd[2];</CODE></P>
      <P><CODE>3  static void sig_usr1(int);</CODE></P>
      <BR>
      <P><CODE>4  int</CODE></P>
      <P><CODE>5  main(int argc, char **argv)</CODE></P>
      <P><CODE>6  {</CODE></P>
      <P><CODE>7   int nfds;</CODE></P>
      <P><CODE>8   char c;</CODE></P>
      <P><CODE>9   fd_set rset;</CODE></P>
      <P><CODE>10  mqd_t mqd;</CODE></P>
      <P><CODE>11  void *buff;</CODE></P>
      <P><CODE>12  ssize_t n;</CODE></P>
      <P><CODE>13  struct mq_attr attr;</CODE></P>
      <P><CODE>14  struct sigevent sigev;</CODE></P>
      <P><CODE>15  if (argc != 2)</CODE></P>
      <P><CODE>16   err_quit("usage: mqnotifysig5 &lt;name&gt;");</CODE></P>
      <P><CODE>17  /* открытие очереди, получение атрибутов, выделение буфера */</CODE></P>
      <P><CODE>18  mqd = Mq_open(argv[1], O_RDONLY | O_NONBLOCK);</CODE></P>
      <P><CODE>19  Mq_getattr(mqd, &amp;attr);</CODE></P>
      <P><CODE>20  buff = Malloc(attr.mq_msgsize);</CODE></P>
      <P><CODE>21  Pipe(pipefd);</CODE></P>
      <P><CODE>22  /* установка обработчика, включение уведомления */</CODE></P>
      <P><CODE>23  Signal(SIGUSR1, sig_usr1);</CODE></P>
      <P><CODE>24  sigev.sigev_notify = SIGEV_SIGNAL;</CODE></P>
      <P><CODE>25  sigev.sigev_signo = SIGUSR1;</CODE></P>
      <P><CODE>26  Mq_notify(mqd, &amp;sigev);</CODE></P>
      <P><CODE>27  FD_ZERO(&amp;rset);</CODE></P>
      <P><CODE>28  for (;;) {</CODE></P>
      <P><CODE>29   FD_SET(pipefd[0], &amp;rset);</CODE></P>
      <P><CODE>30   nfds = Select(pipefd[0] + 1, &amp;rset, NULL, NULL, NULL);</CODE></P>
      <P><CODE>31   if (FD_ISSET(pipefd[0], &amp;rset)) {</CODE></P>
      <P><CODE>32    Read(pipefd[0], &amp;c, 1);</CODE></P>
      <P><CODE>33    Mq_notify(mqd, &amp;sigev); /* перерегистрируемся */</CODE></P>
      <P><CODE>34    while ((n = mq_receive(mqd, buff, attr.mq_msgsize, NULL)) &gt;= 0) {</CODE></P>
      <P><CODE>35     printf("read %ld bytes\n", (long) n);</CODE></P>
      <P><CODE>36    }</CODE></P>
      <P><CODE>37    if (errno != EAGAIN)</CODE></P>
      <P><CODE>38     err_sys("mq_receive error");</CODE></P>
      <P><CODE>39   }</CODE></P>
      <P><CODE>40  }</CODE></P>
      <P><CODE>41  exit(0);</CODE></P>
      <P><CODE>42 }</CODE></P>
      <BR>
      <P><CODE>43 static void</CODE></P>
      <P><CODE>44 sig_usr1(int signo)</CODE></P>
      <P><CODE>45 {</CODE></P>
      <P><CODE>46  Write(pipefd[1], "", 1); /* один байт – 0 */</CODE></P>
      <P><CODE>47  return;</CODE></P>
      <P><CODE>48 }</CODE></P>
      <H2><a name=label160 style="border:none;"></a>Создание канала</H2>
      <P>21 Мы создаем канал, в который обработчик сигнала произведет запись, когда будет получено уведомление о поступлении сообщения в очередь. Это пример использования канала внутри одного процесса.</P>
      <H2><a name=label161 style="border:none;"></a>Вызов select</H2>
      <P>27-40 Мы инициализируем набор дескрипторов rset и при каждом проходе цикла включаем бит, соответствующий дескриптору pipefd[0] (открытый на считывание конец канала). Затем мы вызываем функцию select, ожидая получения единственного дескриптора, хотя в типичном приложении именно здесь осуществлялось бы размножение дескрипторов одного из концов канала. Когда появляется возможность читать из канала, мы перерегистрируемся на уведомление и считываем все доступные сообщения.</P>
      <H2><a name=label162 style="border:none;"></a>Обработчик сигнала</H2>
      <P>43-48 Единственное, что делает обработчик сигнала, — записывает в канал 1 байт. Как мы уже отмечали, эта операция относится к разрешенным для асинхронных обработчиков.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label163 style="border:none;"></a>Пример: запуск нового потока</P>
      </H1>
      <P>Альтернативой снятию блокировки сигналом является присваивание sigev_notify значения SIGEV_THREAD, что приводит к созданию нового потока. Функция, указанная в <EM>sigev_notify_function,</EM> вызывается с параметром sigev_value. Атрибуты нового канала указываются переменной sigev_notify_attributes, которая может быть и нулевым указателем, если нас устраивают устанавливаемые по умолчанию атрибуты. Текст программы приведен в листинге 5.13.</P>
      <H2><a name=label164 style="border:none;"></a>Листинг 5.13. Функция mq_notify, запускающая новый программный поток</H2>
      <P><CODE>//pxmsg/mqnotifythread1.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  mqd_t mqd;</CODE></P>
      <P><CODE>3  struct mq_attr attr;</CODE></P>
      <P><CODE>4  struct sigevent sigev;</CODE></P>
      <P><CODE>5  static void notify_thread(union sigval); /* наш поток */</CODE></P>
      <BR>
      <P><CODE>6  int</CODE></P>
      <P><CODE>7  main(int argc, char **argv)</CODE></P>
      <P><CODE>8  {</CODE></P>
      <P><CODE>9   if (argc != 2)</CODE></P>
      <P><CODE>10   err_quit("usage: mqnotifythread1 &lt;name&gt;");</CODE></P>
      <P><CODE>11  mqd = Mq_open(argv[1], O_RDONLY | O_NONBLOCK);</CODE></P>
      <P><CODE>12  Mq_getattr(mqd, &amp;attr);</CODE></P>
      <P><CODE>13  sigev.sigev_notify = SIGEV_THREAD;</CODE></P>
      <P><CODE>14  sigev.sigev_value.sival_ptr = NULL;</CODE></P>
      <P><CODE>15  sigev.sigev_notify_function = notify_thread;</CODE></P>
      <P><CODE>16  sigev.sigev_notify_attributes = NULL;</CODE></P>
      <P><CODE>17  Mq_notify(mqd, &amp;sigev);</CODE></P>
      <P><CODE>18  for (;;)</CODE></P>
      <P><CODE>19   pause(); /* новый поток делает все */</CODE></P>
      <P><CODE>20  exit(0);</CODE></P>
      <P><CODE>21 }</CODE></P>
      <BR>
      <P><CODE>22 static void</CODE></P>
      <P><CODE>23 notify_thread(union sigval arg)</CODE></P>
      <P><CODE>24 {</CODE></P>
      <P><CODE>25  ssize_t n;</CODE></P>
      <P><CODE>26  void *buff;</CODE></P>
      <P><CODE>27  printf("notify_thread started\n");</CODE></P>
      <P><CODE>28  buff = Malloc(attr.mq_msgsize);</CODE></P>
      <P><CODE>29  Mq_notify(mqd, &amp;sigev); /* перерегистрируемся */</CODE></P>
      <P><CODE>30  while ((n = mq_receive(mqd, buff, attr.mq_msgsize, NULL)) &gt;= 0) {</CODE></P>
      <P><CODE>31   printf("read %ld bytes\n", (long) n);</CODE></P>
      <P><CODE>32  }</CODE></P>
      <P><CODE>33  if (errno != EAGAIN)</CODE></P>
      <P><CODE>34   err_sys("mq_receive error");</CODE></P>
      <P><CODE>35  free(buff);</CODE></P>
      <P><CODE>36  pthread_exit(NULL);</CODE></P>
      <P><CODE>37 }</CODE></P>
      <P>Мы задаем нулевой указатель в качестве аргумента нового потока (sigev_value), поэтому функции start нового потока ничего не передается. Мы могли бы передать указатель на дескриптор, вместо того чтобы декларировать его как глобальный, но новому потоку все равно нужно получать атрибуты очереди сообщений и структуру sigev (для перерегистрации). Мы также указываем нулевой указатель в качестве атрибутов нового потока, поэтому используются установки по умолчанию. Новые потоки создаются как неприсоединенные (detached threads).</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>К сожалению, ни одна из использовавшихся для проверки примеров систем (Solaris 2.6 и Digital Unix 4.0B) не поддерживает SIGEV_THREAD. Обе они допускают только два значения sigev_notify: SIGEV_NONE и SIGEV_SIGNAL.</P>
      </DIV>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label165 style="border:none;"></a>5.7. Сигналы реального времени Posix</P>
     </H1>
     <DIV class=section>
      <P>За прошедшие годы сигналы в Unix много раз претерпевали революционные изменения.</P>
      <P>1. Модель сигналов, предлагавшаяся в Unix Version 7 (1978), была ненадежной. Сигналы могли быть потеряны, и процессу было трудно отключить отдельные сигналы при выполнении отдельных участков кода.</P>
      <P>2. В версии 4.3BSD (1986) надежные сигналы были добавлены.</P>
      <P>3. Версия System V Release 3.0 (1986) также добавила надежные сигналы, хотя и иначе, чем BSD.</P>
      <P>4. Стандарт Posix.1 (1990) увековечил модель надежных сигналов BSD, и эта модель подробно описана в главе 10 [21].</P>
      <P>5. Posix.1 (1996) добавил к модели Posix сигналы реального времени. Это произросло из расширений реального времени Posix.1b (которые были названы Posix.4).</P>
      <P>Почти все системы Unix в настоящее время поддерживают надежные сигналы, а новейшие системы предоставляют также и сигналы реального времени стандарта Posix. (Следует различать надежные сигналы и сигналы реального времени.) О сигналах реального времени следует поговорить подробнее, поскольку мы уже столкнулись с некоторыми структурами, определяемыми этим расширением стандарта, в предыдущем разделе (структуры sigval и sigevent).</P>
      <P>Сигналы могут быть отнесены к двум группам:</P>
      <P>1. Сигналы реального времени, которые могут принимать значения между SIGRTMIN и SIGRTMAX включительно. Posix требует, чтобы предоставлялось по крайней мере RTSIG_MAX сигналов, и минимальное значение этой константы равно 8.</P>
      <P>2. Все прочие сигналы: SIGALRM, SIGINT, SIGKILL и пр.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>В Solaris 2.6 обычные сигналы Unix нумеруются с 1 по 37, а 8 сигналов реального времени имеют номера с 38 по 45. В Digital Unix 4.0B обычные сигналы нумеруются с 1 по 32, а 16 сигналов реального времени имеют номера с 33 по 48. Обе реализации определяют SIGRTMIN и SIGRTMAX как макросы, вызывающие sysconf, что позволяет изменять их значения.</P>
      </DIV>
      <P>Далее все зависит от того, установлен ли процессом, получившим сигнал, флаг SA_SIGINFO при вызове sigaction. В итоге получаются четыре возможных сценария, приведенных в табл. 5.2.</P>
      <BR>
      <P>Таблица 5.2. Поведение сигналов Posix в реальном времени в зависимости от SA_SIGINFO </P>
      <TABLE>
       <TR ALIGN=left >
        <TH ALIGN=left VALIGN=top >Сигнал</TH>
        <TH ALIGN=left VALIGN=top >Флаг SA_SIGINFO указан</TH>
        <TH ALIGN=left VALIGN=top >Флаг SA_SIGINFO не указан</TH>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >От SIGRTMIN до SIGRTMAX</TD>
        <TD ALIGN=left VALIGN=top >Гарантируются характеристики реального времени</TD>
        <TD ALIGN=left VALIGN=top >Характеристики реального времени не обязательны</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >Все прочие сигналы</TD>
        <TD ALIGN=left VALIGN=top >Характеристики реального времени не обязательны</TD>
        <TD ALIGN=left VALIGN=top >Характеристики реального времени не обязательны</TD>
       </TR>
      </TABLE>
      <P>Смысл фразы «характеристики реального времени не обязательны» следующий: некоторые реализации могут обрабатывать эти сигналы как сигналы реального времени, но это не обязательно. Если мы хотим, чтобы сигналы обрабатывались как сигналы реального времени, мы должны использовать сигналы с номерами от SIGRTMIN до SIGRTMAX и должны указать флаг SA_SIGINFO при вызове sigaction при установке обработчика сигнала.</P>
      <P>Термин «характеристики реального времени» подразумевает следующее:</P>
      <P>■ Сигналы помещаются в очередь. Если сигнал будет порожден трижды, он будет трижды получен адресатом. Более того, повторения одного и того же сигнала доставляются в порядке очереди (FIFO). Мы вскоре покажем пример очереди сигналов. Если же сигналы в очередь не помещаются, трижды порожденный сигнал будет получен лишь один раз.</P>
      <P>■ Когда в очередь помещается множество неблокируемых сигналов в диапазоне SIGRTMIN—SIGRTMAX, сигналы с меньшими номерами доставляются раньше сигналов с большими номерами. То есть сигнал с номером SIGRTMIN имеет «больший приоритет», чем сигнал с номером SIGRTMIN+1, и т.д.</P>
      <P>■ При отправке сигнала, не обрабатываемого как сигнал реального времени, единственным аргументом обработчика является номер сигнала. Сигналы реального времени несут больше информации, чем прочие сигналы. Обработчик для сигнала реального времени, устанавливаемый с флагом SA_SIGINFO, объявляется как</P>
      <P><CODE>void func(int <EM>signo,</EM> siginfo_t <EM>*info,</EM> void <EM>*context</EM>);</CODE></P>
      <P>где <EM>signo—</EM> номер сигнала, a siginfo_t — структура, определяемая как</P>
      <P><CODE>typedef struct {</CODE></P>
      <P><CODE> int si_signo; /* то же, что и signo */</CODE></P>
      <P><CODE> int si_code; /* SI_{USER,QUEUE,TIMER,ASYNCIO,MESGQ} */</CODE></P>
      <P><CODE> union sigval si_value; /* целое или указатель от отправителя */</CODE></P>
      <P><CODE>} siginfo_t;</CODE></P>
      <P>На что указывает <EM>context</EM> — зависит от реализации.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Обработчик сигналов, не являющихся сигналами реального времени, вызывается с единственным аргументом. Во многих системах существует старое соглашение о вызове обработчиков сигналов с тремя аргументами, которое предшествовало стандарту реального времени Posix.</P>
       <P>Тип siginfo_t является единственной структурой Posix, определяемой оператором typedef с именем, оканчивающимся на _t. В листинге 5.14 мы объявляем указатели на эти структуры как siginfo_t * без слова struct. </P>
      </DIV>
      <P>■ Для работы с сигналами реального времени добавлено несколько новых функций. Например, для отправки сигнала какому-либо процессу используется функция sigqueue вместо kill. Новая функция позволяет отправить вместе с сигналом структуру sigval.</P>
      <P>Сигналы реального времени порождаются нижеследующими функциями Posix.1, определяемыми значением si_code, которое хранится в структуре siginfo_t, передаваемой обработчику сигнала.</P>
      <P>■ SI_ASYNCIO — сигнал был порожден по завершении асинхронного запроса на ввод или вывод одной из функций Posix aio_XXX, которые мы не рассматриваем;</P>
      <P>■ SI_MESGQ — сигнал был порожден при помещении сообщения в пустую очередь сообщений (как в разделе 5.6); </P>
      <P>■ SI_QUEUE — сигнал был отправлен функцией sigqueue. Пример будет вскоре приведен;</P>
      <P>■ SI_TIMER — сигнал был порожден по истечении установленного функцией timer_settime времени. Эту функцию мы не описываем;</P>
      <P>■ SI_USER — сигнал был отправлен функцией kill.</P>
      <P>Если сигнал был порожден каким-либо другим событием, si_code будет иметь значение, отличающееся от приведенных выше. Значение поля si_value структуры siginfo_t актуально только в том случае, если si_code имеет одно из следующих значений: SI_ASYNCIO, SI_MESGQ, SI_QUEUE и SI_TIMER.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label166 style="border:none;"></a>Пример</P>
      </H1>
      <P>В листинге 5.14 приведен пример программы, демонстрирующей использование сигналов реального времени. Программа вызывает fork, дочерний процесс блокирует три сигнала реального времени, родительский процесс отправляет девять сигналов (три раза отсылается каждый из заблокированных сигналов), затем дочерний процесс разблокирует сигналы и мы смотрим, сколько раз будет получен каждый из них и в каком порядке они придут.</P>
      <H2><a name=label167 style="border:none;"></a>Листинг 5.14. Тестовая программа, иллюстрирующая работу с сигналами реального времени</H2>
      <P><CODE>//rtsignals/test1.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  static void sig_rt(int, siginfo_t *, void *);</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int i, j;</CODE></P>
      <P><CODE>7   pid_t pid;</CODE></P>
      <P><CODE>8   sigset_t newset;</CODE></P>
      <P><CODE>9   union sigval val;</CODE></P>
      <P><CODE>10  printf("SIGRTMIN = %d, SIGRTMAX = %d\n", (int) SIGRTMIN, (int) SIGRTMAX);</CODE></P>
      <P><CODE>11  if ((pid = Fork()) == 0) {</CODE></P>
      <P><CODE>12   /* дочерний процесс блокирует 3 сигнала */</CODE></P>
      <P><CODE>13   Sigemptyset(&amp;newset);</CODE></P>
      <P><CODE>14   Sigaddset(&amp;newset, SIGRTMAX);</CODE></P>
      <P><CODE>15   Sigaddset(&amp;newset, SIGRTMAX – 1);</CODE></P>
      <P><CODE>16   Sigaddset(&amp;newset, SIGRTMAX – 2);</CODE></P>
      <P><CODE>17   Sigprocmask(SIG_BLOCK, &amp;newset, NULL);</CODE></P>
      <P><CODE>18   /* установка обработчика с флагом SA_SIGINFO */</CODE></P>
      <P><CODE>19   Signal_rt(SIGRTMAX, sig_rt);</CODE></P>
      <P><CODE>20   Signal_rt(SIGRTMAX – 1, sig_rt);</CODE></P>
      <P><CODE>21   Signal_rt(SIGRTMAX – 2, sig_rt);</CODE></P>
      <P><CODE>22   sleep(6); /* родительский процесс посылает все сигналы */</CODE></P>
      <P><CODE>23   Sigprocmask(SIG UNBLOCK, &amp;newset, NULL); /* разблокируемся */</CODE></P>
      <P><CODE>24   sleep(3); /* получаем сигналы */</CODE></P>
      <P><CODE>25   exit(O);</CODE></P>
      <P><CODE>26  }</CODE></P>
      <P><CODE>27  /* родительский процесс отправляет сигналы */</CODE></P>
      <P><CODE>28  sleep(3); /* дочерний процесс блокирует сигналы */</CODE></P>
      <P><CODE>29  for (i = SIGRTMAX; i &gt;= SIGRTMAX – 2; i--) {</CODE></P>
      <P><CODE>30   for (j = 0; j &lt;= 2; j++) {</CODE></P>
      <P><CODE>31    val.sival_int = j;</CODE></P>
      <P><CODE>32    Sigqueue(pid, i, val);</CODE></P>
      <P><CODE>33    printf("sent signal %d, val = %d\n", i, j);</CODE></P>
      <P><CODE>34   }</CODE></P>
      <P><CODE>35  }</CODE></P>
      <P><CODE>36  exit(0);</CODE></P>
      <P><CODE>37 }</CODE></P>
      <BR>
      <P><CODE>38 static void</CODE></P>
      <P><CODE>39 sig_rt(int signo, siginfo_t *info, void *context)</CODE></P>
      <P><CODE>40 {</CODE></P>
      <P><CODE>41  printf(received signal #%d, code = %d, ival = %d\n",</CODE></P>
      <P><CODE>42   signo.info-&gt;si_code, info-&gt;si_value.sival_int);</CODE></P>
      <P><CODE>43 }</CODE></P>
      <H2><a name=label168 style="border:none;"></a>Вывод номеров сигналов реального времени</H2>
      <P>10 Мы печатаем наибольший и наименьший номера сигналов реального времени, чтобы узнать, сколько их предоставляется в данной реализации. Мы преобразуем обе константы к типу integer, поскольку в некоторых реализациях они определяются как макросы, требующие вызова sysconf, например:</P>
      <P><CODE>#define SIGRTMAX (sysconf(_SC_RTSIG_MAX))</CODE></P>
      <P>и функция sysconf возвращает целое типа long (см. упражнение 5.4).</P>
      <H2><a name=label169 style="border:none;"></a>Вызов fork и блокирование трех сигналов реального времени</H2>
      <P>11-17 Запускается дочерний процесс, который вызывает sigprocmask для блокировки трех используемых сигналов реального времени: SIGRTMAX, SIGRTMAX-1 и SIGRTMAX-2.</P>
      <H2><a name=label170 style="border:none;"></a>Установка обработчика сигнала</H2>
      <P>18-21 Мы вызываем функцию signal_rt (приведенную в листинге 5.15) для установки функции sig_rt в качестве обработчика трех указанных выше сигналов реального времени. Функция устанавливает флаг SA_SIGINFO, и поскольку эти три сигнала являются сигналами реального времени, мы можем ожидать, что они будут обрабатываться соответствующим образом. Эта функция также устанавливает маску сигналов, блокируемых на время выполнения обработчика.</P>
      <H2><a name=label171 style="border:none;"></a>Ожидание порождения сигналов родительским процессом, разблокирование сигналов</H2>
      <P>22-25 Дочерний процесс ждет 6 секунд, пока родительский породит девять сигналов. Затем вызывается sigprocmask для разблокирования трех сигналов реального времени. Это позволяет всем помещенным в очередь сигналам достичь адресата. Затем делается пауза еще на три секунды, чтобы обработчик успел вызвать printf девять раз, после чего дочерний процесс завершает свою работу.</P>
      <H2><a name=label172 style="border:none;"></a>Родительский процесс отправляет девять сигналов</H2>
      <P>27-36 Родительский процесс ждет три секунды, пока дочерний не заблокирует все требуемые сигналы. Затем родительский процесс порождает три экземпляра каждого из трех сигналов реального времени: i принимает 3 значения, a j принимает значения 0, 1 и 2 для каждого из значений i. Мы преднамеренно порождаем сигналы начиная с наибольшего номера, поскольку ожидаем, что они будут получены начиная с наименьшего. Мы также отсылаем с каждым из сигналов новое значение sigval_int, чтобы проверить, что копии одного и того же сигнала доставляются в том же порядке, в каком они были отправлены, то есть очередь действительно является очередью.</P>
      <H2><a name=label173 style="border:none;"></a>Обработчик сигнала</H2>
      <P>38-43 Обработчик сигнала просто выводит информацию о полученном сигнале.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Из табл. 5.1 следует, что функция printf не относится к функциям типа async-signal-safe и не должна вызываться из обработчика сигналов. Здесь мы используем ее исключительно в качестве проверочного средства в маленькой тестовой программе. </P>
      </DIV>
      <P>Запустим эту программу в Solaris 2.6. Результат будет не тем, которого мы ожидали:</P>
      <P><CODE>solaris % <STRONG>test1</STRONG></CODE></P>
      <P><CODE>SIGRTMIN = 38, SIGRTMAX = 45 <EM>8 сигналов реального времени</EM></CODE></P>
      <P><CODE><EM>                             трехсекундная пауза</EM></CODE></P>
      <P><CODE>sent signal 45, val = 0</CODE></P>
      <P><CODE>sent signal 45, val = 1</CODE></P>
      <P><CODE>sent signal 45, val = 2</CODE></P>
      <P><CODE>sent signal 44, val = 0</CODE></P>
      <P><CODE>sent signal 44, val = 1</CODE></P>
      <P><CODE>sent signal 44, val = 2</CODE></P>
      <P><CODE>sent signal 43, val = 0</CODE></P>
      <P><CODE>sent signal 43, val = 1</CODE></P>
      <P><CODE>sent signal 43, val = 2</CODE></P>
      <P><CODE>solaris % <EM>родительский процесс завершил работу, пауза 3 секунды,</EM></CODE></P>
      <P><CODE><EM>          пока дочерний процесс не разблокирует сигналы</EM></CODE></P>
      <P><CODE>received signal #45, code = –2, ival = 2 <EM>дочерний процесс получает сигналы</EM></CODE></P>
      <P><CODE>received signal #45, code = –2, ival = 1</CODE></P>
      <P><CODE>received signal #45, code = –2, ival = 0</CODE></P>
      <P><CODE>received signal #44, code = –2, ival = 2</CODE></P>
      <P><CODE>received signal #44, code = –2, ival = 1</CODE></P>
      <P><CODE>received signal #44, code = –2, ival = 0</CODE></P>
      <P><CODE>received signal #43, code = –2, ival = 2</CODE></P>
      <P><CODE>received signal #43, code = –2, ival = 1</CODE></P>
      <P><CODE>received signal #43, code = –2, ival = 0</CODE></P>
      <P>В очередь помещаются девять сигналов, но первыми принимаются сигналы с большими номерами (а мы ожидали получить сигналы с меньшими номерами). </P>
      <P>Кроме того, сигналы с одинаковым номером приходят в порядке LIFO, а не FIFO. Код si_code = –2 соответствует SI_QUEUE.</P>
      <P>Запустив программу в Digital Unix 4.0B, мы получим именно тот результат, которого ожидали:</P>
      <P><CODE>alpha % <STRONG>test1</STRONG></CODE></P>
      <P><CODE>SIGRTMIN = 33, SIGRTMAX = 48 <EM>16 сигналов реального времени</EM></CODE></P>
      <P><CODE><EM>                             трех секундная пауза</EM></CODE></P>
      <P><CODE>sent signal 48, val = 0</CODE></P>
      <P><CODE>sent signal 48, val = 1</CODE></P>
      <P><CODE>sent signal 48, val = 2</CODE></P>
      <P><CODE>sent signal 47, val = 0</CODE></P>
      <P><CODE>sent signal 47, val = 1</CODE></P>
      <P><CODE>sent signal 47, val = 2</CODE></P>
      <P><CODE>sent signal 46, val = 0</CODE></P>
      <P><CODE>sent signal 46, val = 1</CODE></P>
      <P><CODE>sent signal 46, val = 2</CODE></P>
      <P><CODE>alpha % <EM>родительский процесс завершил работу, пауза 3 секунды.</EM></CODE></P>
      <P><CODE><EM>        пока дочерний процесс не разблокируетсигналы</EM></CODE></P>
      <P><CODE>received signal #46, code – –1, ival = 0 <EM>дочерний процесс получает сигналы</EM></CODE></P>
      <P><CODE>received signal #46, code = –1, ival = 1</CODE></P>
      <P><CODE>received signal #46, code = –1, ival = 2</CODE></P>
      <P><CODE>received signal #47, code – –1, ival = 0</CODE></P>
      <P><CODE>received signal #47, code = –1, ival = 1</CODE></P>
      <P><CODE>received signal #47, code = –1, ival = 2</CODE></P>
      <P><CODE>received signal #48, code = –1, ival = 0</CODE></P>
      <P><CODE>received signal #48, code = –1, ival = 1</CODE></P>
      <P><CODE>received signal #48, code = –1, ival = 2</CODE></P>
      <P>Девять сигналов помещаются в очередь и получаются адресатом в ожидаемом порядке: первым приходит сигнал с меньшим номером, а копии сигнала приходят в порядке FIFO.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Похоже, что в реализации Solaris 2.6 есть ошибка.</P>
      </DIV>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label174 style="border:none;"></a>Функция signal<STRONG>_rt</STRONG></P>
      </H1>
      <P>В книге [24, с. 120] мы привели пример собственной функции signal, вызывавшей функцию sigaction стандарта Posix для установки обработчика сигнала, обеспечивающего надежную семантику Posix. Изменим эту функцию, чтобы обеспечить поддержку реального времени. Новую функцию мы назовем signal_rt; ее текст приведен в листинге 5.15.</P>
      <H2><a name=label175 style="border:none;"></a>Листинг 5.15. Функция signal_rt с поддержкой реального времени</H2>
      <P><CODE>//lib/signal_rt.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  Sigfunc_rt *</CODE></P>
      <BR>
      <P><CODE>3  signal_rt(int signo, Sigfunc_rt *func)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   struct sigaction act, oact;</CODE></P>
      <P><CODE>6   act.sa_sigaction = func; /* сохраняем адрес функции */</CODE></P>
      <P><CODE>7   sigemptyset(&amp;act.sa_mask);</CODE></P>
      <P><CODE>8   act.sa_flags = SA_SIGINFO; /* гарантирует режим реального времени */</CODE></P>
      <P><CODE>9   if (signo == SIGALRM) {</CODE></P>
      <P><CODE>10 #ifdef SA_INTERRUPT</CODE></P>
      <P><CODE>11   act.sa_flags |= SA_INTERRUPT; /* SunOS 4.x */</CODE></P>
      <P><CODE>12 #endif</CODE></P>
      <P><CODE>13  } else {</CODE></P>
      <P><CODE>14 #ifdef SA_RESTART</CODE></P>
      <P><CODE>15   act.sa_flags |= SA_RESTART; /* SVR4, 44BSD */</CODE></P>
      <P><CODE>16 #endif</CODE></P>
      <P><CODE>17  }</CODE></P>
      <P><CODE>18  if (sigaction(signo, &amp;act, &amp;oact) &lt; 0)</CODE></P>
      <P><CODE>19   return((Sigfunc_rt *) SIG_ERR);</CODE></P>
      <P><CODE>20  return(oact.sa_sigaction);</CODE></P>
      <P><CODE>21 }</CODE></P>
      <H2><a name=label176 style="border:none;"></a>Упрощение прототипа функции с использованием typedef</H2>
      <P>1-3 В нашем заголовочном файле unpiрс.h (листинг В.1) мы определяем Sigfunc_rt как</P>
      <P><CODE>typedef void Sigfunc_rt(int, siginfo_t*, void*);</CODE></P>
      <P>Ранее в этом разделе мы говорили о том, что это прототип функции для обработчика сигнала, устанавливаемого с флагом SA_SIGINFO.</P>
      <H2><a name=label177 style="border:none;"></a>Указание функции-обработчика</H2>
      <P>Структура sigaction претерпела изменения с добавлением поддержки сигна-5-7 лов реального времени: к ней было добавлено новое поле sa_sigaction:</P>
      <P><CODE>struct sigaction {</CODE></P>
      <P><CODE> void (*sa_handler)(); /* SIG_DFL, SIG_IGN или адрес обработчика сигнала */</CODE></P>
      <P><CODE> sigset_t sa_mask; /* дополнительные блокируемые сигналы */</CODE></P>
      <P><CODE> int sa_flags; /* параметры сигналов: SA_XXX */</CODE></P>
      <P><CODE> void (*sa_sigaction)(int, siginfo_t, void *);</CODE></P>
      <P><CODE>};</CODE></P>
      <P>Правила действуют следующие:</P>
      <P>■ Если в поле sa_flags установлен флаг SA_SIGINFO, поле sa_sigaction указывает адрес функции-обработчика сигнала.</P>
      <P>■ Если флаг SA_SIGINFO не установлен, поле sa_handler указывает адрес функции-обработчика сигнала.</P>
      <P>■ Чтобы сопоставить сигналу действие по умолчанию или игнорировать его, следует установить sa_handler равным либо SIG_DFL, либо SIG_IGN и не устанавливать флаг SA_SIGINFO.</P>
      <H2><a name=label178 style="border:none;"></a>Установка SA_SIGINFO</H2>
      <P>8-17 Мы всегда устанавливаем флаг SA_SIGINFO и указываем флаг SA_RESTART, если перехвачен какой-либо другой сигнал, кроме SIGALRM.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label179 style="border:none;"></a>5.8. Реализация с использованием отображения в память</P>
     </H1>
     <DIV class=section>
      <P>Теперь рассмотрим реализацию очередей сообщений Posix с использованием отображения в память, взаимных исключений и условных переменных Posix. </P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Взаимные исключения и условные переменные описаны в главе 7, а ввод-вывод с отображением в память — в главах 12 и 13. Вы можете отложить данный раздел до ознакомления с этими главами.</P>
      </DIV>
      <P>На рис. 5.2 приведена схема структур данных, которыми мы пользуемся для реализации очереди сообщений Posix. Изображенная очередь может содержать до четырех сообщений по 7 байт каждое.</P>
      <P>В листинге 5.16 приведен заголовочный файл mqueue.h, определяющий основные структуры, используемые в этой реализации.</P>
      <H2><a name=label180 style="border:none;"></a>Тип mqd_t</H2>
      <P>Дескриптор нашей очереди сообщений является просто указателем на структуру mq_infо. Каждый вызов mq_open выделяет память под одну такую структуру, а вызвавшему возвращается указатель на нее. Повторим, что дескриптор очереди сообщений не обязательно является небольшим целым числом, как дескриптор файла — единственное ограничение, накладываемое Posix, заключается в том, что этот тип данных не может быть массивом.</P>
      <H2><a name=label181 style="border:none;"></a>Листинг 5.16. Заголовочный файл mqueue.h</H2>
      <P><CODE>//my_pxmsg_mmap/mqueue.h</CODE></P>
      <P><CODE>1  typedef struct mymq_info *mymqd_t;</CODE></P>
      <BR>
      <P><CODE>2  struct mymq_attr {</CODE></P>
      <P><CODE>3   long mq_flags; /* флаг очереди : O_NONBLOCK */</CODE></P>
      <P><CODE>4   long mq_maxmsg; /* максимальное количество сообщений в очереди */</CODE></P>
      <P><CODE>5   long mq_msgsize; /* максимальный размер сообщения в байтах */</CODE></P>
      <P><CODE>6   long mq_curmsgs; /* количество сообщений в очереди */</CODE></P>
      <P><CODE>7  };</CODE></P>
      <BR>
      <P><CODE>8  /* одна структура mymq_hdr{} на очередь, в начале отображаемого файла */</CODE></P>
      <P><CODE>9  struct mymq_hdr {</CODE></P>
      <P><CODE>10  struct mymq_attr mqh_attr; /* атрибуты очереди */</CODE></P>
      <P><CODE>11  long mqh_head; /* индекс первого сообщения*/</CODE></P>
      <P><CODE>12  long mqh_free; /* индекс первого пустого сообщения */</CODE></P>
      <P><CODE>13  long mqh_nwait; /* количество заблокированных mq_receive() потоков */</CODE></P>
      <P><CODE>14  pid_t mqh_pid; /* ненулевой PID. если включено уведомление */</CODE></P>
      <P><CODE>15  struct sigevent mqh_event; /* для mq_notify() */</CODE></P>
      <P><CODE>16  pthread_mutex_t mqh_lock; /* блокировка: mutex*/</CODE></P>
      <P><CODE>17  pthread_cond_t mqh_wait; /* и условная переменная */</CODE></P>
      <P><CODE>18 };</CODE></P>
      <BR>
      <P><CODE>19 /* один mymsg_hdr{} в начале каждого сообщения */</CODE></P>
      <P><CODE>20 struct mymsg_hdr {</CODE></P>
      <P><CODE>21  long msg_next; /* индекс следующего сообщения в списке */</CODE></P>
      <P><CODE>22                 /* msg_next должно быть первым полем в структуре */</CODE></P>
      <P><CODE>23  ssize_t msg_len; /* реальная длина */</CODE></P>
      <P><CODE>24  unsigned int msg_prio; /* приоритет */</CODE></P>
      <P><CODE>25 };</CODE></P>
      <BR>
      <P><CODE>26 /* одна mymq_info{} выделяется при каждом mq_open() */</CODE></P>
      <P><CODE>27 struct mymq_info {</CODE></P>
      <P><CODE>28  struct mymq_hdr *mqi_hdr; /* начало отображаемого файла */</CODE></P>
      <P><CODE>29  long mqi_magic; /* магическое значение после инициализации */</CODE></P>
      <P><CODE>30  int mqi_flags; /* флаги для данного процесса */</CODE></P>
      <P><CODE>31 };</CODE></P>
      <P><CODE>32 #define MQI_MAGIC 0x98765432</CODE></P>
      <P><CODE>33 /* размер сообщения округляется для подгонки */</CODE></P>
      <P><CODE>34 #define MSGSIZE(i) ((((i) + sizeof(long)-1) / sizeof(long)) * sizeof(long))</CODE> </P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader113" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 5.2. Схема структур данных, используемых при реализации очередей сообщений posix через отображаемый в память файл </P>
      <BR>
      <H2><a name=label182 style="border:none;"></a>Структура mq_hdr</H2>
      <P>8-18 Эта структура хранится в самом начале отображаемого файла и содержит всю информацию об очереди. Поле mq_flags структуры mqh_attr не используется, поскольку флаги (единственный определенный флаг используется для отключения блокировки) должны обрабатываться для каждого открывающего очередь процесса в отдельности, а не для очереди в целом. Поэтому флаги хранятся в структуре mq_info. О прочих полях этой структуры мы будем говорить в связи с их использованием различными функциями.</P>
      <P>Обратите внимание, что все переменные, называемые нами индексными (поля этой структуры mqh_head и mqh_free, а также поле msg_next следующей структуры), содержат индексы байтов относительно начала отображаемого в память файла. Например, размер структуры mq_hdr в системе Solaris 2.6 — 96 байт, поэтому индекс первого сообщения, располагающегося сразу за заголовком, имеет значение 96. Каждое сообщение на рис. 5.2 занимает 20 байт (12 байт на структуру msg_hdr и 8 байт на данные), поэтому индексы следующих трех сообщений имеют значения 116, 136 и 156, а размер отображаемого в память файла — 176 байт. Индексы используются для обработки двух связных списков, хранящихся в этом файле: в одном из списков (mqh_head) хранятся все сообщения, имеющиеся в данный момент в очереди, а в другом (mqh_free) — все незаполненные сообщения. Мы не можем использовать настоящие указатели на области памяти (адреса) при работе со списком, поскольку отображаемый файл может находиться в произвольной области памяти для каждого из процессов, работающих с ним (как показано в листинге 13.5).</P>
      <H2><a name=label183 style="border:none;"></a>Структура msg_hdr</H2>
      <P>19-25 Эта структура располагается в начале каждого сообщения в отображаемом файле. Любое сообщение может принадлежать либо к списку заполненных, либо к списку свободных сообщений, и поле msg_next содержит индекс следующего сообщения в этом списке (или 0, если сообщение является в этом списке последним). Переменная msg_len хранит реальную длину данных в сообщении, которая в нашем примере с рис. 5.2 может иметь значение от 0 до 7 байт включительно. В переменную msg_prio отправителем помещается значение приоритета сообщения.</P>
      <H2><a name=label184 style="border:none;"></a>Структура mq_info</H2>
      <P>26-32 Экземпляр такой структуры динамически создается функцией mq_open при открытии очереди и удаляется mq_close. Поле mqi_hdr указывает на отображаемый файл (адрес начала файла возвращается mmap). Указатель на эту структуру имеет основной в нашей реализации тип mqd_t, он принимает значение, возвращаемое mq_open.</P>
      <P>Поле mqi_magiс принимает значение MQI_MAGIC в момент инициализации структуры. Это значение проверяется всеми функциями, которым передается указатель типа mqd_t, что дает им возможность удостовериться, что указатель действительно указывает на структуру типа mq_infо. mqi_flags содержит флаг отключения блокировки для открывшего очередь процесса.</P>
      <H2><a name=label185 style="border:none;"></a>Макрос MSGSIZE</H2>
      <P>33-34 В целях выравнивания содержимого файла (alignment) мы располагаем начало каждого сообщения так, чтобы его индекс был кратен размеру длинного целого. Следовательно, если максимальный размер сообщения не допускает такого выравнивания, мы добавляем к нему от 1 до 3 байт, как показано на рис. 5.2. При этом предполагается, что размер длинного целого — 4 байт (что верно для Solaris 2.6). Если размер длинного целого 8 байт (в Digital Unix 4.0B), нам придется добавлять к каждому сообщению от 1 до 7 байт.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label186 style="border:none;"></a>Функция mq_open</P>
      </H1>
      <P>В листинге 5.17 приведен текст первой части функции mq_open, создающей новую очередь сообщений или открывающей существующую.</P>
      <H2><a name=label187 style="border:none;"></a>Листинг 5.17. Функция mq_open: первая часть</H2>
      <P><CODE>//my_pxmsg._mmap/mq_open. с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "mqueue.h"</CODE></P>
      <P><CODE>3  #include &lt;stdarg.h&gt;</CODE></P>
      <P><CODE>4  #define MAX_TRIES 10</CODE></P>
      <P><CODE>5  struct mymq_attr defattr =</CODE></P>
      <P><CODE>6   { 0, 128, 1024, 0 };</CODE></P>
      <BR>
      <P><CODE>7  mymqd_t</CODE></P>
      <P><CODE>8  mymq_open(const char *pathname, int oflag, …)</CODE></P>
      <P><CODE>9  {</CODE></P>
      <P><CODE>10  int i, fd, nonblock, created, save_errno;</CODE></P>
      <P><CODE>11  long msgsize, filesize, index;</CODE></P>
      <P><CODE>12  va_list ap;</CODE></P>
      <P><CODE>13  mode_t mode;</CODE></P>
      <P><CODE>14  int8_t *mptr;</CODE></P>
      <P><CODE>15  struct stat statbuff;</CODE></P>
      <P><CODE>16  struct mymq_hdr *mqhdr;</CODE></P>
      <P><CODE>17  struct mymsg_hdr *msghdr;</CODE></P>
      <P><CODE>18  struct mymq_attr *attr;</CODE></P>
      <P><CODE>19  struct mymq_info *mqinfo;</CODE></P>
      <P><CODE>20  pthread_mutexattr_t mattr;</CODE></P>
      <P><CODE>21  pthread_condattr_t cattr;</CODE></P>
      <P><CODE>22  created = 0;</CODE></P>
      <P><CODE>23  nonblock = oflag &amp; O_NONBLOCK;</CODE></P>
      <P><CODE>24  oflag &amp;= ~O_NONBLOCK;</CODE></P>
      <P><CODE>25  mptr = (int8_t *) MAP_FAILED;</CODE></P>
      <P><CODE>26  mqinfo = NULL;</CODE></P>
      <P><CODE>27 again:</CODE></P>
      <P><CODE>28  if (oflag &amp; O_CREAT) {</CODE></P>
      <P><CODE>29   va_start(ap, oflag); /* ар инициализируется последним аргументом */</CODE></P>
      <P><CODE>30   mode = va_arg(ap, va_mode_t) &amp; ~S_IXUSR;</CODE></P>
      <P><CODE>31   attr = va_arg(ap, struct mymq_attr *);</CODE></P>
      <P><CODE>32   va_end(ap);</CODE></P>
      <P><CODE>33   /* открытие с установкой бита user-execute */</CODE></P>
      <P><CODE>34   fd = open (pathname, oflag | O_EXCL | O_RDWR, mode | S_IXUSR);</CODE></P>
      <P><CODE>35   if (fd &lt; 0) {</CODE></P>
      <P><CODE>36    if (errno == EEXIST &amp;&amp; (oflag &amp; O_EXCL) == 0)</CODE></P>
      <P><CODE>37     goto exists; /* уже существует, OK */</CODE></P>
      <P><CODE>38    else</CODE></P>
      <P><CODE>39     return((mymqd_t) –1);</CODE></P>
      <P><CODE>40   }</CODE></P>
      <P><CODE>41   created = 1;</CODE></P>
      <P><CODE>42   /* при создании файла он инициализируется */</CODE></P>
      <P><CODE>43   if (attr == NULL)</CODE></P>
      <P><CODE>44    attr = &amp;defattr;</CODE></P>
      <P><CODE>45   else {</CODE></P>
      <P><CODE>46    if (attr-&gt;mq_maxmsg &lt;– 0 || attr-&gt;mq_msgsize &lt;= 0) {</CODE></P>
      <P><CODE>47     errno = EINVAL;</CODE></P>
      <P><CODE>48     goto err;</CODE></P>
      <P><CODE>49    }</CODE></P>
      <P><CODE>50   }</CODE></P>
      <H2><a name=label188 style="border:none;"></a>Обработка списка аргументов переменного размера</H2>
      <P>29-32 Функция может быть вызвана либо с двумя, либо с четырьмя аргументами в зависимости от того, указан ли флаг O_CREAT. Если флаг указан, третий аргумент имеет тип mode_t, а это простой системный тип, являющийся одним из целых типов. При этом мы столкнемся с проблемой в BSD/OS, где этот тип данных определен как unsigned short (16 бит). Поскольку целое в этой реализации занимает 32 бита, компилятор С увеличивает аргумент этого типа с 16 до 32 бит, потому что все короткие целые в списке аргументов увеличиваются до обычных целых. Но если мы укажем mode_t при вызове va_arg, он пропустит 16 бит аргумента в стеке, если этот аргумент был увеличен до 32 бит. Следовательно, мы должны определить свой собственный тип данных, va_mode_t, который будет целым в BSD/OS и типом mode_t в других системах. Эту проблему с переносимостью решают приведенные ниже строки нашего заголовка unpipc.h (листинг В.1):</P>
      <P><CODE>#ifdef __bsdi__</CODE></P>
      <P><CODE>#define va_mode_t int</CODE></P>
      <P><CODE>#else</CODE></P>
      <P><CODE>#define va_mode_t mode_t</CODE></P>
      <P><CODE>#endif</CODE></P>
      <P>30 Мы сбрасываем бит user-execute (S_IXUSR) в переменной mode по причинам, которые будут вскоре раскрыты.</P>
      <H2><a name=label189 style="border:none;"></a>Создание новой очереди сообщений</H2>
      <P>33-34 Создается обычный файл с именем, указанным при вызове функции, и устанавливается бит user-execute. </P>
      <H2><a name=label190 style="border:none;"></a>Обработка потенциальной ситуации гонок</H2>
      <P>35-40 Если бы при указании флага O_CREAT мы просто открыли файл, отобразили его содержимое в память и проинициализировали отображенный файл (как будет описано ниже), у нас возникла бы ситуация гонок. Очередь сообщений инициализируется mq_open только в том случае, если вызывающий процесс указывает флаг O_CREAT и очередь сообщений еще не существует. Это означает, что нам нужно каким-то образом определять, существует она или нет. Для этого при открытии файла для последующего отображения в память мы всегда указываем флаг O_EXCL. Возвращение ошибки EEXIST функцией open является ошибкой для mq_open только в том случае, если при вызове был указан флаг O_EXCL. В противном случае при возвращении функцией open ошибки EEXIST мы делаем вывод, что файл уже существует, и переходим к листингу 5.19, как если бы флаг O_CREAT вовсе не был указан.</P>
      <P>Ситуация гонок может возникнуть потому, что использование отображаемого в память файла для реализации очереди сообщений требует двух шагов при инициализации очереди: сначала файл должен быть создан функцией open, а затем его содержимое должно быть проинициализировано. Проблема возникает, если два потока (одного или различных процессов) вызывают mq_open приблизительно одновременно. Один из потоков может создать файл, после чего управление будет передано системой второму потоку, прежде чем первый завершит инициализацию файла. Второй поток обнаружит, что файл уже существует (вызвав open с флагом O_EXCL), и приступит к использованию очереди сообщений.</P>
      <P>Мы используем бит user-execute для указания того, был ли проинициализирован файл с очередью сообщений. Этот бит устанавливается только тем потоком, который создает этот файл (флаг O_EXCL позволяет определить этот поток); этот поток инициализирует файл с очередью сообщений, а затем сбрасывает бит user-execute.</P>
      <P>Аналогичная ситуация может возникнуть в листингах 10.28 и 10.37.</P>
      <H2><a name=label191 style="border:none;"></a>Проверка атрибутов</H2>
      <P>42-50 Если при вызове в качестве последнего аргумента передан нулевой указатель, очередь сообщений инициализируется со значениями атрибутов по умолчанию: 128 сообщений в очереди и 1024 байта на сообщение. Если атрибуты указаны явно, мы проверяем, что mq_maxmsg и mq_msgsize имеют положительные значения.</P>
      <P>Вторая часть функции mq_open приведена в листинге 5.18. Она завершает инициализацию новой очереди сообщений.</P>
      <H2><a name=label192 style="border:none;"></a>Листинг 5.18. Вторая часть функции mq_open: инициализация новой очереди</H2>
      <P><CODE>//my_pxmsg_mmap/mq_open.с</CODE></P>
      <P><CODE>51    /* вычисление и установка размера файла */</CODE></P>
      <P><CODE>52    msgsize = MSGSIZE(attr-&gt;mq_msgsize);</CODE></P>
      <P><CODE>53    filesize = sizeof(struct mymq_hdr) + (attr-&gt;mq_maxmsg *</CODE></P>
      <P><CODE>54     (sizeof(struct mymsg_hdr) + msgsize));</CODE></P>
      <P><CODE>55    if (lseek(fd, filesize – 1, SEEK_SET) == –1)</CODE></P>
      <P><CODE>56     goto err;</CODE></P>
      <P><CODE>57    if (write(fd, "", 1) == –1)</CODE></P>
      <P><CODE>58     goto err;</CODE></P>
      <P><CODE>59    /* отображение файла в память */</CODE></P>
      <P><CODE>60    mptr = mmap(NULL, filesize, PROT_READ | PROT_WRITE,</CODE></P>
      <P><CODE>61     MAP_SHARED, fd, 0);</CODE></P>
      <P><CODE>62    if (mptr == MAP_FAILED)</CODE></P>
      <P><CODE>63     goto err;</CODE></P>
      <P><CODE>64    /* выделение структуры mymq_info{} для очереди */</CODE></P>
      <P><CODE>65    if ((mqinfo = mallос (sizeof (struct mymq_info))) == NULL)</CODE></P>
      <P><CODE>66     goto err;</CODE></P>
      <P><CODE>67    mqinfo-&gt;mqi_hdr = mqhdr = (struct mymq_hdr *) mptr;</CODE></P>
      <P><CODE>68    mqinfo-&gt;mqi_magic = MQI_MAGIC;</CODE></P>
      <P><CODE>69    mqinfo-&gt;mqi_flags = nonblock;</CODE></P>
      <P><CODE>70    /* инициализация заголовка в начале файла */</CODE></P>
      <P><CODE>71    /* создание списка пустых сообщений */</CODE></P>
      <P><CODE>72    mqhdr-&gt;mqh_attr.mq_flags = 0;</CODE></P>
      <P><CODE>73    mqhdr-&gt;mqh_attr.mq_maxmsg = attr-&gt;mq_maxmsg;</CODE></P>
      <P><CODE>74    mqhdr-&gt;mqh_attr.mq_msgsize = attr-&gt;mq_msgsize;</CODE></P>
      <P><CODE>75    mqhdr-&gt;mqh_attr.mq_curmsgs = 0;</CODE></P>
      <P><CODE>76    mqhdr-&gt;mqh_nwait = 0;</CODE></P>
      <P><CODE>77    mqhdr-&gt;mqh_pid = 0;</CODE></P>
      <P><CODE>78    mqhdr-&gt;mqh_head = 0;</CODE></P>
      <P><CODE>79    index = sizeof(struct mymq_hdr);</CODE></P>
      <P><CODE>80    mqhdr-&gt;mqh_free = index;</CODE></P>
      <P><CODE>81    for (i = 0; i &lt; attr-&gt;mq_maxmsg – 1; i++) {</CODE></P>
      <P><CODE>82     msghdr = (struct mymsg_hdr *) &amp;mptr[index];</CODE></P>
      <P><CODE>83     index += sizeof(struct mymsg_hdr) + msgsize;</CODE></P>
      <P><CODE>84     msghdr-&gt;msg_next = index;</CODE></P>
      <P><CODE>85    }</CODE></P>
      <P><CODE>86    msghdr = (struct mymsg_hdr *) &amp;mptr[index];</CODE></P>
      <P><CODE>87    msghdr-&gt;msg_next = 0; /* конец списка пустых сообщений */</CODE></P>
      <P><CODE>88    /* инициализация взаимного исключения и условной переменной */</CODE></P>
      <P><CODE>89    if ((i = pthread_mutexattr_init(&amp;mattr)) != 0)</CODE></P>
      <P><CODE>90     goto pthreaderr;</CODE></P>
      <P><CODE>91    pthread_mutexattr_setpshared(&amp;mattr, PTHREAD_PROCESS_SHARED);</CODE></P>
      <P><CODE>92    i = pthread_mutex_init(&amp;mqhdr-&gt;mqh_lock, &amp;mattr);</CODE></P>
      <P><CODE>93    pthread_mutexattr_destroy(&amp;mattr); /* обязательно нужно удалить */</CODE></P>
      <P><CODE>94    if (i != 0)</CODE></P>
      <P><CODE>95     goto pthreaderr:</CODE></P>
      <P><CODE>96    if ((i = pthread_condattr_init(&amp;cattr)) != 0)</CODE></P>
      <P><CODE>97     goto pthreaderr;</CODE></P>
      <P><CODE>98    pthread_condattr_setpshared(&amp;cattr, PTHREAD_PROCESS_SHARED);</CODE></P>
      <P><CODE>99    i = pthread_cond_init(&amp;mqhdr-&gt;mqh_wait, &amp;cattr);</CODE></P>
      <P><CODE>100   pthread_condattr_destroy(&amp;cattr); /* обязательно нужно удалить */</CODE></P>
      <P><CODE>101   if (i != 0)</CODE></P>
      <P><CODE>102    goto pthreaderr;</CODE></P>
      <P><CODE>103   /* инициализация завершена, снимаем бит user-execute */</CODE></P>
      <P><CODE>104   if (fchmod(fd, mode) == –1)</CODE></P>
      <P><CODE>105    goto err;</CODE></P>
      <P><CODE>106   close(fd);</CODE></P>
      <P><CODE>107   return((mymqd_t) mqinfo);</CODE></P>
      <P><CODE>108  }</CODE></P>
      <H2><a name=label193 style="border:none;"></a>Установка размера файла</H2>
      <P>51-58 Вычисляется размер сообщения, который затем округляется до кратного размеру длинного целого. Также в файле отводится место для структуры mq_hdr в начале файла и msghdr в начале каждого сообщения (рис. 5.2). Размер вновь созданного файла устанавливается функцией lseek и записью одного байта со значением 0. Проще было бы вызвать ftruncate (раздел 13.3), но у нас нет гарантий, что это сработало бы для увеличения размера файла.</P>
      <H2><a name=label194 style="border:none;"></a>Отображение файла в память</H2>
      <P>59-63 Файл отображается в память функцией mmap.</P>
      <H2><a name=label195 style="border:none;"></a>Выделение памяти под структуру mq_info</H2>
      <P>64-66 При каждом вызове mq_open создается отдельный экземпляр mq_infо. Эта структура после создания инициализируется.</P>
      <H2><a name=label196 style="border:none;"></a>Инициализация структуры mq_hdr</H2>
      <P>67-87 Инициализируется структура mq_hdr. Заголовок связного списка сообщений (mqh_head) инициализируется нулем, а все сообщения в очереди добавляются к списку свободных (mqh_frее).</P>
      <H2><a name=label197 style="border:none;"></a>Инициализация взаимного исключения и условной переменной</H2>
      <P>88-102 Поскольку очереди сообщений Posix могут использоваться совместно произвольным количеством процессов, которые знают имя очереди и имеют соответствующие разрешения, нам нужно инициализировать взаимное исключение и условную переменную с атрибутом PTHREAD_PROCESS_SHARED. Для этого мы сначала инициализируем атрибуты вызовом pthread_mutexattr_init, а затем устанавливаем значение атрибута совместного использования процессами, вызвав pthread_mutexattr_setpshared. После этого взаимное исключение инициализируется вызовом pthread_mutex_init. Аналогичные действия выполняются для условной переменной. Мы должны аккуратно удалить взаимное исключение и условную переменную даже при возникновении ошибки, поскольку вызовы pthread_ mutexattr_init и pthread_condattr_init выделяют под них память (упражнение 7.3).</P>
      <H2><a name=label198 style="border:none;"></a>Сброс бита user-execute</H2>
      <P>103-107 После инициализации очереди сообщений мы сбрасываем бит user-execute. Это говорит другим процессам о том, что очередь была проинициализирована. Мы также закрываем файл вызовом close, поскольку он был успешно отображен в память и держать его открытым больше нет необходимости.</P>
      <P>В листинге 5.19 приведен конец функции mq_open, в котором осуществляется открытие существующей очереди сообщений.</P>
      <H2><a name=label199 style="border:none;"></a>Листинг 5.19. Третья часть функции mq_open: открытие существующей очереди сообщений</H2>
      <P><CODE>//my_pxmsg_mmap/mq_open<STRONG>.</STRONG>с</CODE></P>
      <P><CODE>109 exists:</CODE></P>
      <P><CODE>110  /* открытие файла и отображение его в память */</CODE></P>
      <P><CODE>111  if ((fd = open(pathname, O_RDWR)) &lt; 0) {</CODE></P>
      <P><CODE>112   if (errno == ENOENT &amp;&amp; (oflag &amp; O_CREAT))</CODE></P>
      <P><CODE>113    goto again;</CODE></P>
      <P><CODE>114  goto err;</CODE></P>
      <P><CODE>115  }</CODE></P>
      <P><CODE>116  /* проверяем, что инициализация завершена */</CODE></P>
      <P><CODE>117  for (i = 0; i &lt; MAX TRIES; i++) {</CODE></P>
      <P><CODE>118   if (stat(pathname, &amp;statbuff) == –1) {</CODE></P>
      <P><CODE>119    if (errno == ENOENT &amp;&amp; (oflag &amp; O_CREAT)) {</CODE></P>
      <P><CODE>120     close(fd);</CODE></P>
      <P><CODE>121     goto again;</CODE></P>
      <P><CODE>122    }</CODE></P>
      <P><CODE>123    goto err;</CODE></P>
      <P><CODE>124   }</CODE></P>
      <P><CODE>125   if ((statbuff.st_mode &amp; S_IXUSR) == 0)</CODE></P>
      <P><CODE>126   break;</CODE></P>
      <P><CODE>127   sleep(1);</CODE></P>
      <P><CODE>128  }</CODE></P>
      <P><CODE>129  if (i == MAX_TRIES) {</CODE></P>
      <P><CODE>130   errno = ETIMEDOUT;</CODE></P>
      <P><CODE>131   goto err;</CODE></P>
      <P><CODE>132  }</CODE></P>
      <P><CODE>133  filesize = statbuff.st_size;</CODE></P>
      <P><CODE>134  mptr = mmap(NULL, filesize, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</CODE></P>
      <P><CODE>135  if (mptr == MAP_FAILED)</CODE></P>
      <P><CODE>136   goto err;</CODE></P>
      <P><CODE>137  close(fd);</CODE></P>
      <P><CODE>138  /* выделяем одну mymq_info{} для каждого вызова open */</CODE></P>
      <P><CODE>139  if ((mqinfo = malloc(sizeof(struct mymq_info))) == NULL)</CODE></P>
      <P><CODE>140   goto err;</CODE></P>
      <P><CODE>141  rnqinfo-&gt;mqi_hdr = (struct mymq_hdr *) mptr;</CODE></P>
      <P><CODE>142  mqinfo-&gt;mqi_magic = MQI_MAGIC;</CODE></P>
      <P><CODE>143  mqinfo-&gt;mqi_flags = nonblock;</CODE></P>
      <P><CODE>144  return((mymqd_t) mqinfo);</CODE></P>
      <P><CODE>145 pthreaderr:</CODE></P>
      <P><CODE>146  errno = i;</CODE></P>
      <P><CODE>147 err:</CODE></P>
      <P><CODE>148  /* не даем следующим вызовам изменить errno */</CODE></P>
      <P><CODE>149  save_errno = errno;</CODE></P>
      <P><CODE>150  if (created)</CODE></P>
      <P><CODE>151   unlink(pathname);</CODE></P>
      <P><CODE>152  if (mptr != MAP_FAILED)</CODE></P>
      <P><CODE>153   munmap(mptr, filesize);</CODE></P>
      <P><CODE>154  if (mqinfo != NULL)</CODE></P>
      <P><CODE>155   free(mqinfo);</CODE></P>
      <P><CODE>156  close(fd);</CODE></P>
      <P><CODE>157  errno = save_errno;</CODE></P>
      <P><CODE>158  return((mymqd_t) –1);</CODE></P>
      <P><CODE>159 }</CODE></P>
      <H2><a name=label200 style="border:none;"></a>Открытие существующей очереди сообщений</H2>
      <P>109-115 Здесь мы завершаем работу, если флаг O_CREAT не был указан или если он был указан, но очередь уже существовала. В любом случае, мы открываем существующую очередь сообщений. Для этого мы открываем для чтения и записи файл, в котором она содержится, функцией open и отображаем его содержимое в адресное пpocтрaнcтвo процесса (mmap).</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Наша реализация сильно упрощена в том, что касается режима открытия файла. Даже если вызвавший процесс указывает флаг O_RDONLY, мы должны дать возможность доступа для чтения и записи при открытии файла командой open и при отображении его в память командой mmap, поскольку невозможно считать сообщение из очереди, не изменив содержимое файла. Аналогично невозможно записать сообщение в очередь, не имея доступа на чтение. Обойти эту проблему можно, сохранив режим открытия (O_RDONLY, O_WRONLY, O_RDWR) в структуре mq_info и проверяя этот режим в каждой из функций. Например, mq_receive должна возвращать ошибку, если в mq_info хранится значение O_WRONLY.</P>
      </DIV>
      <H2><a name=label201 style="border:none;"></a>Проверка готовности очереди</H2>
      <P>116-132 Нам необходимо дождаться, когда очередь будет проинициализирована (в случае, если несколько потоков сделают попытку открыть ее приблизительно одновременно). Для этого мы вызываем stat и проверяем разрешения доступа к файлу (поле st_mode структуры stat). Если бит user-execute сброшен, очередь уже проинициализирована.</P>
      <P>Этот участок кода обрабатывает другую возможную ситуацию гонок. Предположим, что два потока разных процессов попытаются открыть очередь приблизительно одновременно. Первый поток создает файл и блокируется при вызове lseek в листинге 5.18. Второй поток обнаруживает, что файл уже существует, и переходит к метке exists, где он вновь открывает файл функцией open и при этом блокируется. Затем продолжается выполнение первого потока, но его вызов mmap в листинге 5.18 не срабатывает (возможно, он превысил лимит использования памяти), поэтому он переходит на метку err и удаляет созданный файл вызовом unlink. Продолжается выполнение второго потока, но если бы мы вызывали fstat вместо stat, он бы вышел по тайм-ауту в цикле for, ожидая инициализации файла. Вместо этого мы вызываем stat, которая возвращает ошибку, если файл не существует, и, если флаг O_CREAT был указан при вызове mq_open, мы переходим на метку again (листинг 5.17) для повторного создания файла. Эта ситуация гонок заставляет нас также проверять, не возвращается ли при вызове open ошибка ENOENT.</P>
      <H2><a name=label202 style="border:none;"></a>Отображение файла в память; создание и инициализация структуры mq_info</H2>
      <P>133-144 Файл отображается в память, после чего его дескриптор может быть закрыт. Затем мы выделяем место под структуру mq_infо и инициализируем ее. Возвращаемое значение представляет собой указатель на эту структуру.</P>
      <H2><a name=label203 style="border:none;"></a>Обработка ошибок</H2>
      <P>145-148 При возникновении ошибок происходит переход к метке err, а переменной errno присваивается значение, которое должно быть возвращено функцией mq_open. Мы аккуратно вызываем функции для очистки памяти от выделенных объектов, чтобы переменная errno не изменила свое значение в случае возникновения ошибки в этих функциях.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label204 style="border:none;"></a>Функция mq_close</P>
      </H1>
      <P>В листинге 5.20 приведен текст нашей функции mq_close.</P>
      <H2><a name=label205 style="border:none;"></a>Листинг 5.20. Функция mq_close</H2>
      <P><CODE>//my_pxmsg_mmap/mq_close.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "mqueue.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  mymq_close(mymqd_t mqd)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   long msgsize, filesize:</CODE></P>
      <P><CODE>7   struct mymq_hdr *mqhdr;</CODE></P>
      <P><CODE>8   struct mymq_attr *attr;</CODE></P>
      <P><CODE>9   struct mymq_info *mqinfo;</CODE></P>
      <P><CODE>10  mqinfo = mqd;</CODE></P>
      <P><CODE>11  if (mqinfo-&gt;mqi_magic != MQI_MAGIC) {</CODE></P>
      <P><CODE>12   errno = EBADF;</CODE></P>
      <P><CODE>13   return(-1);</CODE></P>
      <P><CODE>14  }</CODE></P>
      <P><CODE>15  mqhdr = mqinfo-&gt;mqi_hdr;</CODE></P>
      <P><CODE>16  attr = &amp;mqhdr-&gt;mqh_attr;</CODE></P>
      <P><CODE>17  if (mymq_notify(mqd, NULL) != 0) /* снятие вызвавшего процесса с регистрации */</CODE></P>
      <P><CODE>18   return(-1);</CODE></P>
      <P><CODE>19  msgsize = MSGSIZE(attr-&gt;mq_msgsize);</CODE></P>
      <P><CODE>20  filesize = sizeof(struct mymq_hdr) + (attr-&gt;mq_maxmsg *</CODE></P>
      <P><CODE>21   (sizeof(struct mymsg_hdr) + msgsize));</CODE></P>
      <P><CODE>22  if (munmap(mqinfo-&gt;mqi_hdr, filesize) == –1)</CODE></P>
      <P><CODE>23   return(-1);</CODE></P>
      <P><CODE>24  mqinfo-&gt;mqi_magic = 0; /* на всякий случай */</CODE></P>
      <P><CODE>25  free(mqinfo);</CODE></P>
      <P><CODE>26  return(0);</CODE></P>
      <P><CODE>27 }</CODE></P>
      <H2><a name=label206 style="border:none;"></a>Получение указателей на структуры</H2>
      <P>10-16 Проверяется правильность переданных аргументов, после чего получаются указатели на область, занятую отображенным в память файлом (mqhdr), и атрибуты (в структуре mq_hdr).</P>
      <H2><a name=label207 style="border:none;"></a>Сброс регистрации вызвавшего процесса</H2>
      <P>17-18 Для сброса регистрации на уведомление вызвавшего процесса мы вызываем mq_notify. Если процесс был зарегистрирован, он будет снят с уведомления, но если нет — ошибка не возвращается.</P>
      <H2><a name=label208 style="border:none;"></a>Отключение отображения файла и освобождение памяти</H2>
      <P>19-25 Мы вычисляем размер файла для вызова munmap и освобождаем память, используемую структурой mqinfo. На случай, если вызвавший процесс будет продолжать использовать дескриптор очереди сообщений, до того как область памяти будет вновь задействована вызовом malloc, мы устанавливаем значение mq_magiс в ноль, чтобы наши функции для работы с очередью сообщений обнаруживали ошибку.</P>
      <P>Обратите внимание, что если процесс завершает работу без вызова mq_close, эти же операции выполняются автоматически: отключается отображение в память, а память освобождается.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label209 style="border:none;"></a>Функция mq_unlink</P>
      </H1>
      <P>Текст функции mqunlink приведен в листинге 5.21. Она удаляет файл, связанный с очередью сообщений, вызывая функцию unlink.</P>
      <H2><a name=label210 style="border:none;"></a>Листинг 5.21. Функция mq_unlink</H2>
      <P><CODE>//my_pxmsg_mmap/mq_unlink.с</CODE></P>
      <P><CODE>1 #include "unpipc.h"</CODE></P>
      <P><CODE>2 #include "mqueue.h"</CODE></P>
      <BR>
      <P><CODE>3 int</CODE></P>
      <P><CODE>4 mymq_unlink(const char *pathname)</CODE></P>
      <P><CODE>5 {</CODE></P>
      <P><CODE>6  if (unlink(pathname) == –1)</CODE></P>
      <P><CODE>7   return(-1);</CODE></P>
      <P><CODE>8  return(0);</CODE></P>
      <P><CODE>9 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label211 style="border:none;"></a>Функция mq_getattr</P>
      </H1>
      <P>В листинге 5.22 приведен текст функции mq_getattr, которая возвращает текущее значение атрибутов очереди.</P>
      <H2><a name=label212 style="border:none;"></a>Листинг 5.22. Функция mq_getattr</H2>
      <P><CODE>//my_pxmsg_mmap/mq_getattr.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "mqueue.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  mymq_getattr(mymqd_t mqd, struct mymq_attr *mqstat)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int n;</CODE></P>
      <P><CODE>7   struct mymq_hdr *mqhdr;</CODE></P>
      <P><CODE>8   struct mymq_attr *attr;</CODE></P>
      <P><CODE>9   struct mymq_info *mqinfo;</CODE></P>
      <P><CODE>10  mqinfo = mqd;</CODE></P>
      <P><CODE>11  if (mqinfo-&gt;mqi_magic != MQI_MAGIC) {</CODE></P>
      <P><CODE>12   errno = EBADF;</CODE></P>
      <P><CODE>13   return(-1);</CODE></P>
      <P><CODE>14  }</CODE></P>
      <P><CODE>15  mqhdr = mqinfo-&gt;mqi_hdr;</CODE></P>
      <P><CODE>16  attr = &amp;mqhdr-&gt;mqh_attr;</CODE></P>
      <P><CODE>17  if ((n = pthread_mutex_lock(&amp;mqhdr-&gt;mqh_lock)) != 0) {</CODE></P>
      <P><CODE>18   errno = n;</CODE></P>
      <P><CODE>19   return (-1);</CODE></P>
      <P><CODE>20  }</CODE></P>
      <P><CODE>21  mqstat-&gt;mq_flags = mqinfo-&gt;mqi_flags; /* для каждого open */</CODE></P>
      <P><CODE>22  mqstat-&gt;mq_maxmsg = attr-&gt;mq_maxmsg; /* оставшиеся три – для очереди */</CODE></P>
      <P><CODE>23  mqstat-&gt;mq_msgsize = attr-&gt;mq_msgsize;</CODE></P>
      <P><CODE>24  mqstat-&gt;mq_curmsgs = attr-&gt;mq_curmsgs;</CODE></P>
      <P><CODE>25  pthread_mutex_unlock(&amp;mqhdr-&gt;mqh_lock);</CODE></P>
      <P><CODE>26  return(0);</CODE></P>
      <P><CODE>27 }</CODE></P>
      <H2><a name=label213 style="border:none;"></a>Блокирование взаимного исключения</H2>
      <P>17-20 Мы должны заблокировать соответствующее взаимное исключение для работы с очередью, в частности для получения атрибутов, поскольку какой-либо другой поток может в это время их изменить.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label214 style="border:none;"></a>Функция mq_setattr</P>
      </H1>
      <P>В листинге 5.23 приведен текст функции mq_setattr, которая устанавливает значение атрибутов очереди.</P>
      <H2><a name=label215 style="border:none;"></a>Считывание текущих атрибутов</H2>
      <P>22-27 Если третий аргумент представляет собой ненулевой указатель, мы возвращаем предыдущее значение атрибутов перед внесением каких-либо изменений.</P>
      <H2><a name=label216 style="border:none;"></a>Изменение mq_flags</H2>
      <P>28-31 Единственный атрибут, который можно менять с помощью нашей функции, — mq_flags, хранящийся в структуре mq_infо.</P>
      <H2><a name=label217 style="border:none;"></a>Листинг 5.23. Функция mq_setattr</H2>
      <P><CODE>//my_pxmsg_mniap/mq_setattr.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "mqueue.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  mymq_setattr(mymqd_t mqd. const struct mymq_attr *mqstat,</CODE></P>
      <P><CODE>5   struct mymq attr *omqstat)</CODE></P>
      <P><CODE>6  {</CODE></P>
      <P><CODE>7   int n;</CODE></P>
      <P><CODE>8   struct mymq_hdr *mqhdr;</CODE></P>
      <P><CODE>9   struct mymq_attr *attr;</CODE></P>
      <P><CODE>10  struct mymq_info *mqinfo;</CODE></P>
      <P><CODE>11  mqinfo = mqd;</CODE></P>
      <P><CODE>12  if (mqinfo-&gt;mqi_magic != MQI_MAGIC) {</CODE></P>
      <P><CODE>13   errno = EBADF;</CODE></P>
      <P><CODE>14   return(-1);</CODE></P>
      <P><CODE>15  }</CODE></P>
      <P><CODE>16  mqhdr = mqinfo-&gt;mqi_hdr;</CODE></P>
      <P><CODE>17  attr = &amp;mqhdr-&gt;mqh_attr;</CODE></P>
      <P><CODE>18  if ((n = pthread_mutex_lock(&amp;mqhdr-&gt;mqh_lock)) ! = 0) {</CODE></P>
      <P><CODE>19   errno = n;</CODE></P>
      <P><CODE>20   return(-1);</CODE></P>
      <P><CODE>21  }</CODE></P>
      <P><CODE>22  if (omqstat != NULL) {</CODE></P>
      <P><CODE>23   omqstat-&gt;mq_flags = mqinfo-&gt;mqi_flags; /* исходные атрибуты */</CODE></P>
      <P><CODE>24   omqstat-&gt;mq_maxmsg = attr-&gt;mq_maxmsg;</CODE></P>
      <P><CODE>25   omqstat-&gt;mq_msgsize = attr-&gt;mq_msgsize;</CODE></P>
      <P><CODE>26   omqstat-&gt;mq_curmsgs = attr-&gt;mq_curmsgs; /* текущий статус */</CODE></P>
      <P><CODE>27  }</CODE></P>
      <P><CODE>28  if (mqstat-&gt;mq_flags &amp; O_NONBLOCK)</CODE></P>
      <P><CODE>29   mqinfo-&gt;mqi flags |= O_NONBLOCK;</CODE></P>
      <P><CODE>30  else</CODE></P>
      <P><CODE>31   mqinfo-&gt;ntqi_flags &amp;= ~O_NONBLOCK;</CODE></P>
      <P><CODE>32  pthread_mutex_unlock(&amp;mqhdr-&gt;mqh_lock);</CODE></P>
      <P><CODE>33  return(0);</CODE></P>
      <P><CODE>34 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label218 style="border:none;"></a>Функция mq_notify</P>
      </H1>
      <P>Функция mq_notify, текст которой приведен в листинге 5.24, позволяет регистрировать процесс на уведомление для текущей очереди и снимать его с регистрации. Информация о зарегистрированных процессах (их идентификаторы) хранится в поле mqh_pid структуры mq_hdr. Только один процесс может быть зарегистрирован на уведомление в любой момент времени. При регистрации процесса мы сохраняем его структуру sigevent в структуре mqh_event.</P>
      <H2><a name=label219 style="border:none;"></a>Листинг 5.24. Функция mq_notify</H2>
      <P><CODE>//my_pxmsg_mmap/mq_notify.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "mqueue.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  mymq_notify(mymqd_t mqd, const struct sigevent *notification)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int n;</CODE></P>
      <P><CODE>7   pid_t pid;</CODE></P>
      <P><CODE>8   struct mymq_hdr *mqhdr;</CODE></P>
      <P><CODE>9   struct mymq_info *mqinfo;</CODE></P>
      <P><CODE>10  mqinfo = mqd;</CODE></P>
      <P><CODE>11  if (mqinfo-&gt;mqi magic != MQI_MAGIC) {</CODE></P>
      <P><CODE>12   errno = EBADF;</CODE></P>
      <P><CODE>13   return(-1);</CODE></P>
      <P><CODE>14  }</CODE></P>
      <P><CODE>15  mqhdr = mqinfo-&gt;mqi_hdr;</CODE></P>
      <P><CODE>16  if ((n = pthread_mutex_lock(&amp;mqhdr-&gt;mqh_lock)) != 0) {</CODE></P>
      <P><CODE>17   errno = n;</CODE></P>
      <P><CODE>18   return(-1);</CODE></P>
      <P><CODE>19  }</CODE></P>
      <P><CODE>20  pid = getpid();</CODE></P>
      <P><CODE>21  if (notification == NULL) {</CODE></P>
      <P><CODE>22   if (mqhdr-&gt;mqh_pid == pid) {</CODE></P>
      <P><CODE>23    mqhdr-&gt;mqh_pid = 0; /* снятие вызвавшего процесса с регистрации */</CODE></P>
      <P><CODE>24   } /* если вызвавший процесс не зарегистрирован – 61К */</CODE></P>
      <P><CODE>25  } else {</CODE></P>
      <P><CODE>26   if (mqhdr-&gt;mqh_pid != 0) {</CODE></P>
      <P><CODE>27    if (kill(mqhdr-&gt;mqh_pid, 0) != –1 || errno != ESRCH) {</CODE></P>
      <P><CODE>28     errno = EBUSY;</CODE></P>
      <P><CODE>29     goto err;</CODE></P>
      <P><CODE>30    }</CODE></P>
      <P><CODE>31   }</CODE></P>
      <P><CODE>32   mqhdr-&gt;mqh_pid = pid;</CODE></P>
      <P><CODE>33   mqhdr-&gt;mqh_event = *notification;</CODE></P>
      <P><CODE>34  }</CODE></P>
      <P><CODE>35  pthread_mutex_unlock(&amp;mqhdr-&gt;mqh_lock);</CODE></P>
      <P><CODE>36  return(0);</CODE></P>
      <P><CODE>37 err:</CODE></P>
      <P><CODE>38  pthread_mutex_unlock(&amp;mqhdr-&gt;mqh_lock);</CODE></P>
      <P><CODE>39  return(-1);</CODE></P>
      <P><CODE>40 }</CODE></P>
      <H2><a name=label220 style="border:none;"></a>Снятие процесса с регистрации</H2>
      <P>20-24 Если второй аргумент представляет собой нулевой указатель, вызвавший процесс снимается с регистрации. Если он не зарегистрирован, никакой ошибки не возвращается.</P>
      <H2><a name=label221 style="border:none;"></a>Регистрация вызвавшего процесса</H2>
      <P>25-34 Если какой-либо процесс уже зарегистрирован, мы проверяем, существует ли он, отправкой ему сигнала с кодом 0 (называемого нулевым сигналом — null signal). Это обычная проверка на возможность ошибки, на самом деле при этом никакого сигнала процессу не отправляется, но при его отсутствии возвращается ошибка с кодом ESRCH. Если какой-либо процесс уже зарегистрирован на уведомление, функция возвращает ошибку EBUSY. В противном случае сохраняется идентификатор процесса вместе с его структурой sigevent.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Наш метод проверки существования вызвавшего процесса не идеален. Процесс мог завершить работу, а его идентификатор мог быть использован другим процессом.</P>
      </DIV>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label222 style="border:none;"></a>Функция mq_send</P>
      </H1>
      <P>В листинге 5.25 приведен текст первой половины нашей функции mqsend.</P>
      <H2><a name=label223 style="border:none;"></a>Инициализация</H2>
      <P>14-29 Мы получаем указатели на используемые структуры и блокируем взаимное исключение для данной очереди. Проверяем, не превышает ли размер сообщения максимально допустимый для данной очереди.</P>
      <H2><a name=label224 style="border:none;"></a>Проверка очереди на пустоту и отправка уведомления</H2>
      <P>30-38 Если мы помещаем первое сообщение в пустую очередь, нужно проверить, не зарегистрирован ли какой-нибудь процесс на уведомление об этом событии и нет ли потоков, заблокированных в вызове mq_receive. Для проверки второго условия мы воспользуемся сохраняемым функцией mq_receive счетчиком mqh_nwait, содержащим количество потоков, заблокированных в вызове mq_receive. Если этот счетчик имеет ненулевое значение, мы не отправляем уведомление зарегистрированному процессу. Для отправки сигнала SIGEV_SIGNAL используется функция sigqueue. Затем процесс снимается с регистрации.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Вызов sigqueue для отправки сигнала приводит к передаче сигнала SI_QUEUE обработчику сигнала в структуре типа siginfo_t (раздел 5.7), что неправильно. Отправка правильного значения si_code (а именно SI_MESGQ) из пользовательского процесса осуществляется в зависимости от реализации. На с. 433 стандарта IEEE 1996 [8] отмечается, что для отправки этого сигнала из пользовательской библиотеки необходимо воспользоваться скрытым интерфейсом механизма отправки сигналов. </P>
      </DIV>
      <H2><a name=label225 style="border:none;"></a>Проверка заполненности очереди</H2>
      <P>39-48 Если очередь переполнена и установлен флаг O_NONBLOCK, мы возвращаем ошибку с кодом EAGAIN. В противном случае мы ожидаем сигнала по условной переменной mqh_wait, который, как мы увидим, отправляется функцией mq_receive при считывании сообщения из переполненной очереди.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Наша реализация упрощает ситуацию с возвращением ошибки EINTR при прерывании вызова mq_send сигналом, перехватываемым вызвавшим процессом. Проблема в том, что функция pthread_cond_wait не возвращает ошибки при возврате из обработчика сигнала: она может вернуть либо 0 (что рассматривается как ложное пробуждение), либо вообще не завершить работу. Все эти проблемы можно обойти, но это непросто. </P>
      </DIV>
      <P>В листинге 5.26 приведена вторая половина функции mq_send. К моменту ее выполнения мы уже знаем о наличии в очереди свободного места для нашего сообщения.</P>
      <H2><a name=label226 style="border:none;"></a>Листинг 5.25. Функция mq_send: первая половина</H2>
      <P><CODE>//my_pxmsg_mmap/mq_send.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "mqueue.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  mymq_send(mymqd_t mqd, const char *ptr, size_t len, unsigned int prio)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int n;</CODE></P>
      <P><CODE>7   long index, freeindex;</CODE></P>
      <P><CODE>8   int8_t *mptr;</CODE></P>
      <P><CODE>9   struct sigevent *sigev;</CODE></P>
      <P><CODE>10  struct mymq_hdr *mqhdr;</CODE></P>
      <P><CODE>11  struct mymq_attr *attr;</CODE></P>
      <P><CODE>12  struct mymsg_hdr *msghdr, *nmsghdr, *pmsghdr;</CODE></P>
      <P><CODE>13  struct mymq_info *mqinfo;</CODE></P>
      <P><CODE>14  mqinfo = mqd;</CODE></P>
      <P><CODE>15  if (mqinfo-&gt;mqi_magic != MQI_MAGIC) {</CODE></P>
      <P><CODE>16   errno = EBADF;</CODE></P>
      <P><CODE>17   return(-1);</CODE></P>
      <P><CODE>18  }</CODE></P>
      <P><CODE>19  mqhdr = mqinfo-&gt;mqi_hdr; /* указатель типа struct */</CODE></P>
      <P><CODE>20  mptr = (int8_t *) mqhdr; /* указатель на байт */</CODE></P>
      <P><CODE>21  attr = &amp;mqhdr-&gt;mqh_attr;</CODE></P>
      <P><CODE>22  if ((n = pthread_mutex_lock(&amp;mqhdr-&gt;mqh_lock)) != 0) {</CODE></P>
      <P><CODE>23   errno = n;</CODE></P>
      <P><CODE>24   return(-1);</CODE></P>
      <P><CODE>25  }</CODE></P>
      <P><CODE>26  if (len &gt; attr-&gt;mq_msgsize) {</CODE></P>
      <P><CODE>27   errno = EMSGSIZE;</CODE></P>
      <P><CODE>28   goto err;</CODE></P>
      <P><CODE>29  }</CODE></P>
      <P><CODE>30  if (attr-&gt;mq_curmsgs == 0) {</CODE></P>
      <P><CODE>31   if (mqhdr-&gt;mqh_pid != 0 &amp;&amp; mqhdr-&gt;mqh_nwait == 0) {</CODE></P>
      <P><CODE>32    sigev = &amp;mqhdr-&gt;mqh_event;</CODE></P>
      <P><CODE>33    if (sigev-&gt;sigev_notify == SIGEV_SIGNAL) {</CODE></P>
      <P><CODE>34     sigqueue(mqhdr-&gt;mqh_pid, sigev-&gt;sigev_signo,</CODE></P>
      <P><CODE>35      sigev-&gt;sigev_value);</CODE></P>
      <P><CODE>36    }</CODE></P>
      <P><CODE>37    mqhdr-&gt;mqh_pid = 0; /* снятие с регистрации */</CODE></P>
      <P><CODE>38   }</CODE></P>
      <P><CODE>39  } else if (attr-&gt;mq_curmsgs &gt;= attr-&gt;mq_maxmsg) {</CODE></P>
      <P><CODE>40   /* 4queue is full */</CODE></P>
      <P><CODE>41   if (mqinfo-&gt;mqi_flags &amp; O_NONBLOCK) {</CODE></P>
      <P><CODE>32    errno = EAGAIN;</CODE></P>
      <P><CODE>43    goto err;</CODE></P>
      <P><CODE>44   }</CODE></P>
      <P><CODE>45   /* ожидание освобождения места в очереди */</CODE></P>
      <P><CODE>46   while (attr-&gt;mq_curmsgs &gt;= attr-&gt;mq_maxmsg)</CODE></P>
      <P><CODE>47    pthread_cond_wait(&amp;mqhdr-&gt;mqh_wait, &amp;mqhdr-&gt;mqh_lock);</CODE></P>
      <P><CODE>48  }</CODE></P>
      <H2><a name=label227 style="border:none;"></a>Листинг 5.25. Функция mq_send: вторая половина</H2>
      <P><CODE><CODE>//my_pxmsg_mmap/mq_send.с</CODE></CODE></P>
      <P><CODE>49  /* nmsghdr будет указывать на новое сообщение*/</CODE></P>
      <P><CODE>50  if ((freeindex = mqhdr-&gt;mqh_free) == 0)</CODE></P>
      <P><CODE>51   err_dump("mymq_send: curmsgs = %ld; free = 0", attr-&gt;mq_curmsgs);</CODE></P>
      <P><CODE>52  nmsghdr = (struct mymsg_hdr *) &amp;mptr[freeindex];</CODE></P>
      <P><CODE>53  nmsghdr-&gt;msg_prio = prio;</CODE></P>
      <P><CODE>54  nmsghdr-&gt;msg_len = len;</CODE></P>
      <P><CODE>55  memcpy(nmsghdr + 1, ptr, len); /* копирование сообщения в очередь */</CODE></P>
      <P><CODE>56  mqhdr-&gt;mqh_free = nmsghdr-&gt;msg_next; /* новое начало списка пустых сообщений */</CODE></P>
      <P><CODE>57  /* поиск места в списке для нового сообщения */</CODE></P>
      <P><CODE>58  index = mqhdr-&gt;mqh_head;</CODE></P>
      <P><CODE>59  pmsghdr = (struct mymsg_hdr *) &amp;(mqhdr-&gt;mqh_head);</CODE></P>
      <P><CODE>60  while (index != 0) {</CODE></P>
      <P><CODE>61   msghdr = (struct mymsg_hdr *) &amp;mptr[index];</CODE></P>
      <P><CODE>62   if (prio &gt; msghdr-&gt;msg_prio) {</CODE></P>
      <P><CODE>63    nmsghdr-&gt;msg_next = index;</CODE></P>
      <P><CODE>64    pmsghdr-&gt;msg_next = freeindex;</CODE></P>
      <P><CODE>65    break;</CODE></P>
      <P><CODE>66   }</CODE></P>
      <P><CODE>67   index = msghdr-&gt;msg_next;</CODE></P>
      <P><CODE>68   pmsghdr = msghdr;</CODE></P>
      <P><CODE>69  }</CODE></P>
      <P><CODE>70  if (index == 0) {</CODE></P>
      <P><CODE>71   /* очередь была пуста или новое письмо добавлено к концу списка */</CODE></P>
      <P><CODE>72   pmsghdr-&gt;msg_next = freeindex;</CODE></P>
      <P><CODE>73   nmsghdr-&gt;msg_next = 0;</CODE></P>
      <P><CODE>74  }</CODE></P>
      <P><CODE>75  /* запускаем любой из процессов, заблокированных в mq_receive */</CODE></P>
      <P><CODE>76  if (attr-&gt;mq_curmsgs == 0)</CODE></P>
      <P><CODE>77   pthread_cond_signal(&amp;mqhdr-&gt;mqh_wait);</CODE></P>
      <P><CODE>78  attr-&gt;mq_curmsgs++;</CODE></P>
      <P><CODE>79  pthread_mutex_unlock(&amp;mqhdr-&gt;mqh_lock);</CODE></P>
      <P><CODE>80  return(0);</CODE></P>
      <P><CODE>81 err:</CODE></P>
      <P><CODE>82  pthread_mutex_unlock(&amp;mqhdr-&gt;mqh lock);</CODE></P>
      <P><CODE>83  return(-1);</CODE></P>
      <P><CODE>84 }</CODE></P>
      <H2><a name=label228 style="border:none;"></a>Получение индекса свободного блока</H2>
      <P>50-52 Поскольку количество свободных сообщений при создании очереди равно mq_maxmsg, ситуация, в которой mq_curmsgs будет меньше mq_maxmsg для пустого списка свободных сообщений, возникнуть не может.</P>
      <H2><a name=label229 style="border:none;"></a>Копирование сообщения</H2>
      <P>53-56 Указатель nmsghdr хранит адрес области памяти, в которую помещается сообщение. Приоритет и длина сообщения сохраняются в структуре msg_hdr, а затем в память копируется содержимое сообщения, переданного вызвавшим процессом.</P>
      <H2><a name=label230 style="border:none;"></a>Помещение нового сообщения в соответствующее место связного списка</H2>
      <P>57-74 Порядок сообщений в нашем списке зависит от их приоритета: они расположены в порядке его убывания. При добавлении нового сообщения мы проверяем, существуют ли сообщения с тем же приоритетом; в этом случае сообщение добавляется после последнего из них. Используя такой метод упорядочения, мы гарантируем, что mq_receive всегда будет возвращать старейшее сообщение с наивысшим приоритетом. По мере продвижения по списку мы сохраняем в pmsghdr адрес предыдущего сообщения, поскольку именно это сообщение будет хранить индекс нового сообщения в поле msg_next.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Наша схема может оказаться медленной в случае наличия в очереди большого количества сообщений, поскольку каждый раз при добавлении нового придется просматривать их значительную часть. Можно хранить отдельно индексы последних сообщений со всеми имеющимися значениями приоритета. </P>
      </DIV>
      <H2><a name=label231 style="border:none;"></a>Пробуждение любого процесса, заблокированного в вызове mq_receive</H2>
      <P>75-77 Если очередь была пуста в момент помещения в нее нового сообщения, мы вызываем pthread_cond_signal, чтобы разблокировать любой из процессов, ожидающих сообщения.</P>
      <P>78 Увеличиваем на единицу количество сообщений в очереди mq_curmsgs.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label232 style="border:none;"></a>Функция mq_receive</P>
      </H1>
      <P>В листинге 5.27 приведен текст первой половины функции mq_receive, которая получает необходимые указатели, блокирует взаимное исключение и проверяет объем буфера вызвавшего процесса, который должен быть достаточным для помещения туда сообщения максимально возможной длины.</P>
      <H2><a name=label233 style="border:none;"></a>Проверка полноты очереди</H2>
      <P>30-40 Если очередь пуста и установлен флаг O_NONBLOCK, возвращается ошибка с кодом EAGAIN. В противном случае увеличивается значение счетчика mqh_nwait, который проверяется функцией mq_send (листинг 5.25) в случае, если очередь пуста и есть процессы, ожидающие уведомления. Затем мы ожидаем сигнала по условной переменной, который будет передан функцией mq_send (листинг 5.26).</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Наша реализация mq_receive, как и реализация mq_send, упрощает ситуацию с ошибкой EINTR, возвращаемой при прерывании ожидания сигналом, перехватываемым вызвавшим процессом.</P>
      </DIV>
      <P>В листинге 5.28 приведен текст второй половины функции mq_receive. Мы уже знаем, что в очереди есть сообщение, которое можно будет возвратить вызвавшему процессу.</P>
      <H2><a name=label234 style="border:none;"></a>Листинг 5.27.Функция mq_receive: первая половина</H2>
      <P><CODE>//my_pxmsg_mmap/mq_receive.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "mqueue.h"</CODE></P>
      <BR>
      <P><CODE>3  ssize_t</CODE></P>
      <P><CODE>4  mymq_receive(mymqd_t mqd, char *ptr, size_t maxlen, unsigned int *priop)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int n;</CODE></P>
      <P><CODE>7   long index;</CODE></P>
      <P><CODE>8   int8_t *mptr;</CODE></P>
      <P><CODE>9   ssize_t len;</CODE></P>
      <P><CODE>10  struct mymq_hdr *mqhdr;</CODE></P>
      <P><CODE>11  struct mymq_attr *attr;</CODE></P>
      <P><CODE>12  struct mymsg_hdr *msghdr;</CODE></P>
      <P><CODE>13  struct mymq_info *mqinfo;</CODE></P>
      <P><CODE>14  mqinfo = mqd;</CODE></P>
      <P><CODE>15  if (mqinfo-&gt;mqi_magic != MQI_MAGIC) {</CODE></P>
      <P><CODE>16   errno = EBADF;</CODE></P>
      <P><CODE>17   return(-1);</CODE></P>
      <P><CODE>18  }</CODE></P>
      <P><CODE>19  mqhdr = mqinfo-&gt;mqi_hdr; /* указатель struct */</CODE></P>
      <P><CODE>20  mptr = (int8_t *) mqhdr; /* указатель на байт */</CODE></P>
      <P><CODE>21  attr = &amp;mqhdr-&gt;mqh_attr;</CODE></P>
      <P><CODE>22  if ((n = pthread_mutex_lock(&amp;mqhdr-&gt;mqh_lock)) != 0) {</CODE></P>
      <P><CODE>23   errno = n;</CODE></P>
      <P><CODE>24   return(-1);</CODE></P>
      <P><CODE>25  }</CODE></P>
      <P><CODE>26  if (maxlen &lt; attr-&gt;mq_msgsize) {</CODE></P>
      <P><CODE>27   errno = EMSGSIZE;</CODE></P>
      <P><CODE>28   goto err;</CODE></P>
      <P><CODE>29  }</CODE></P>
      <P><CODE>30  if (attr-&gt;mq_curmsgs = 0) { /* очередь пуста */</CODE></P>
      <P><CODE>31   if (mqinfo-&gt;mqi_flags &amp; O_NONBLOCK) {</CODE></P>
      <P><CODE>32    errno = EAGAIN;</CODE></P>
      <P><CODE>33    goto err;</CODE></P>
      <P><CODE>34   }</CODE></P>
      <P><CODE>35   /* ожидаем помещения сообщения в очередь */</CODE></P>
      <P><CODE>36   mqhdr-&gt;mqh_nwait++;</CODE></P>
      <P><CODE>37   while (attr-&gt;mq_curmsgs == 0)</CODE></P>
      <P><CODE>38    pthread_cond_wait(&amp;mqhdr-&gt;mqh_wait, &amp;mqhdr-&gt;mqh_lock);</CODE></P>
      <P><CODE>39   mqhdr-&gt;mqh_nwait--;</CODE></P>
      <P><CODE>40  }</CODE></P>
      <H2><a name=label235 style="border:none;"></a>Листинг 5.28. Функция mq_receive: вторая половина</H2>
      <P><CODE>//my_pxmsg_mmap/mq_receive.c</CODE></P>
      <P><CODE><CODE>41  </CODE>if ((index = mqhdr-&gt;mqh_head) == 0)</CODE></P>
      <P><CODE>42   err_dump("mymq_receive: curmsgs = %ld; head = 0", attr-&gt;mq_curmsgs);</CODE></P>
      <P><CODE>43  msghdr = (struct mymsg_hdr *) &amp;mptr[index];</CODE></P>
      <P><CODE>44  mqhdr-&gt;mqh_head = msghdr-&gt;msg_next; /* новое начало списка */</CODE></P>
      <P><CODE>45  len = msghdr-&gt;msg_len;</CODE></P>
      <P><CODE>46  memcpy(ptr, msghdr + 1, len); /* копирование самого сообщения */</CODE></P>
      <P><CODE>47  if (priop != NULL)</CODE></P>
      <P><CODE>48   *priop = msghdr-&gt;msg_prio;</CODE></P>
      <P><CODE>49  /* только что считанное сообщение становится первым в списке пустых */</CODE></P>
      <P><CODE>50  msghdr-&gt;msg_next = mqhdr-&gt;mqr_free;</CODE></P>
      <P><CODE>51  mqhdr-&gt;mqh_free = index;</CODE></P>
      <P><CODE>52  /* запуск любого процесса, заблокированного в вызове mq_send */</CODE></P>
      <P><CODE>53  if (attr-&gt;mq_curmsgs == attr-&gt;mq_maxmsg)</CODE></P>
      <P><CODE>54   pthread_cond_signal(&amp;mqhdr-&gt;mqh_wait);</CODE></P>
      <P><CODE>55  attr-&gt;mq_curmsgs--;</CODE></P>
      <P><CODE>56  pthread_mutex_unlock(&amp;mqhdr-&gt;mqh_lock);</CODE></P>
      <P><CODE>57  return(len);</CODE></P>
      <P><CODE>58 err:</CODE></P>
      <P><CODE>59  pthread_mutex_unlock(&amp;mqhdr-&gt;mqh_lock);</CODE></P>
      <P><CODE>60  return(-1);</CODE></P>
      <P><CODE>61 }</CODE></P>
      <H2><a name=label236 style="border:none;"></a>Возвращение сообщения вызвавшему процессу</H2>
      <P>43-51 msghdr указывает на msg_hdr первого сообщения в очереди, которое мы и возвратим. Освободившееся сообщение становится первым в списке свободных. </P>
      <H2><a name=label237 style="border:none;"></a>Разблокирование процесса, заблокированного в вызове mq_send</H2>
      <P>52-54 Если очередь была полной в момент считывания сообщения, мы вызываем pthread_cond_signal для отправки сообщения любому из процессов, заблокированных в вызове mq_send.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label238 style="border:none;"></a>5.9. Резюме</P>
     </H1>
     <P>Очереди сообщений Posix просты в использовании: новая очередь создается (или существующая открывается) функцией mq_open; закрываются очереди вызовом mq_close, а удаляются mq_unlink. Поместить сообщение в очередь можно функцией mq_send, а считать его оттуда можно с помощью mq_receive. Атрибуты очереди можно считать и установить с помощью функций mq_getattr и mq_setattr, а функция mq_notify позволяет зарегистрировать процесс на уведомление о помещении нового сообщения в пустую очередь. Каждое сообщение в очереди обладает приоритетом (небольшое целое число), и функция mq_receive всегда возвращает старейшее сообщение с наивысшим приоритетом.</P>
     <P>Изучая mq_notify, мы познакомились с сигналами реального времени стандарта Posix, которые обладают номерами от SIGMIN до SIGMAX. При установке обработчика для этих сигналов с флагом SA_SIGINFO они будут помещаться в очередь, доставляться в порядке очереди и сопровождаться двумя дополнительными аргументами (при вызове обработчика).</P>
     <P>Наконец, мы реализовали большую часть возможностей очереди сообщений Posix в приблизительно 500 строках кода на языке С, используя отображаемые в память файлы, взаимные исключения и условные переменные Posix. Эта реализация иллюстрирует обработку ситуации гонок при создании новой очереди; еще раз нам придется столкнуться с такой ситуацией в главе 10 при реализации семафоров Posix.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label239 style="border:none;"></a>Упражнения</P>
     </H1>
     <P>1.  Говоря о листинге 5.4, мы отметили, что атрибут <EM>attr</EM> функции mq_open при создании новой очереди является ненулевым; следует указать оба поля: mq_maxmsg и mq_msgsize. Как можно было бы указать только одно из них, не указывая второе, для которого использовать значения атрибутов по умолчанию?</P>
     <P>2. Измените листинг 5.8 так, чтобы при получении сигнала не вызывалась функция mq_notify. Затем поместите в очередь два сообщения и убедитесь, что для второго из них сигнал порожден не будет. Почему?</P>
     <P>3. Измените листинг 5.8 так, чтобы сообщение из очереди при получении сигнала не считывалось. Вместо этого просто вызовите mq_notify и напечатайте сообщение о получении сигнала. Затем отправьте два сообщения и убедитесь, что для второго из них сигнал не порождается. Почему?</P>
     <P>4. Что произойдет, если мы уберем преобразование двух констант к целому типу в первом вызове printf в листинге 5.14? </P>
     <P>5. Измените листинг 5.4 следующим образом: перед вызовом mq_open напечатайте сообщение и подождите 30 секунд (sleep). После возвращения из mq_open выведите еще одно сообщение и подождите еще 30 секунд, а затем вызовите mq_close. Откомпилируйте программу и запустите ее, указав большое количество сообщений (несколько сотен тысяч) и максимальный размер сообщения, скажем, в 10 байт. Задача заключается в том, чтобы создать большую очередь и проверить, используются ли в реализации отображаемые в память файлы. В течение 30-секундной паузы запустите программу типа ps и посмотрите на занимаемый программой объем памяти. Сделайте это еще раз после возвращения из mq_open. Можете ли вы объяснить происходящее?</P>
     <P>6. Что произойдет при вызове memcpy в листинге 5.26, если вызвавший процесс укажет нулевую длину сообщения?</P>
     <P>7. Сравните очередь сообщений с двусторонними каналами, описанными в разделе 4.4. Сколько очередей нужно для двусторонней связи между родительским и дочерним процессами?</P>
     <P>8. Почему мы не удаляем взаимное исключение и условную переменную в листинге 5.20?</P>
     <P>9. Стандарт Posix утверждает, что дескриптор очереди сообщений не может иметь тип массива. Почему? </P>
     <P>10. В каком состоянии проводит большую часть времени функция main из листинга 5.12? Что происходит каждый раз при получении сигнала? Как мы обрабатываем эту ситуацию?</P>
     <P>11. Не все реализации поддерживают атрибут PTHREAD_PROCESS_SHARED для взаимных исключений и условных переменных. Переделайте реализацию очередей сообщений из раздела 5.8 так, чтобы использовать семафоры Posix (глава 10) вместо взаимных исключений и условных переменных.</P>
     <P>12. Расширьте реализацию очередей сообщений Posix из раздела 5.8 так, чтобы она поддерживала SIGEV_THREAD. </P>
    </DIV>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label240 style="border:none;"></a>ГЛАВА 6</P>
     <P>Очереди сообщений System V</P>
    </H1>
    <DIV class=section>
     <H1>
      <P><a name=label241 style="border:none;"></a>6.1. Введениеы</P>
     </H1>
     <P>Каждой очереди сообщений System V сопоставляется свой <EM>идентификатор очереди сообщений.</EM> Любой процесс с соответствующими привилегиями (раздел 3.5) может поместить сообщение в очередь, и любой процесс с другими соответствующими привилегиями может сообщение из очереди считать. Как и для очередей сообщений Posix, для помещения сообщения в очередь System V не требуется наличия подключенного к ней на считывание процесса.</P>
     <P>Ядро хранит информацию о каждой очереди сообщений в виде структуры, определенной в заголовочном файле &lt;sys/msg.h&gt;:</P>
     <P><CODE>struct msqid_ds {</CODE></P>
     <P><CODE> struct ipc_perm msg_perm; /* Разрешения чтения и записи: раздел 3.3 */</CODE></P>
     <P><CODE> struct msg *msg_first; /* указатель на первое сообщение в очереди */</CODE></P>
     <P><CODE> struct msg *msg_last; /* указатель на последнее сообщение в очереди */</CODE></P>
     <P><CODE> msglen_t msg_cbytes; /* размер очереди в байтах */</CODE></P>
     <P><CODE> msgqnum_t msg_qnum;  /* количество сообщений в очереди */</CODE></P>
     <P><CODE> msglen_t msg_qbytes; /* максимальный размер очереди в байтах */</CODE></P>
     <P><CODE> pid_t msg_lspid;  /* идентификатор (pid) последнего процесса, вызвавшего msgsnd(); */</CODE></P>
     <P><CODE> pid_t msg_lrpid;  /* pid последнего msgrcv(); */</CODE></P>
     <P><CODE> time_t msg_stime; /* время отправки последнего сообщения */</CODE></P>
     <P><CODE> time_t msg_rtime; /* время последнего считывания сообщения */</CODE></P>
     <P><CODE> time_t msg_ctime; /* время последнего вызова msgctl(), изменившего одно из полей структуры */</CODE></P>
     <P><CODE>};</CODE></P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Unix 98 не требует наличия полей msg_first, msg_last и msg_cbytes. Тем не менее они имеются в большинстве существующих реализаций, производных от System V. Естественно, ничто не заставляет реализовывать очередь сообщений через связный список, который неявно предполагается при наличии полей msg_first и msg_last. Эти два указателя обычно указывают на участки памяти, принадлежащие ядру, и практически бесполезны для приложения.</P>
     </DIV>
     <P>Мы можем изобразить конкретную очередь сообщений, хранимую ядром как связный список, — рис. 6.1. В этой очереди три сообщения длиной 1, 2 и 3 байта с <EM>типами</EM> 100, 200 и 300 соответственно.</P>
     <P>В этой главе мы рассмотрим функции, используемые для работы с очередями сообщений System V, и реализуем наш пример файлового сервера из раздела 4.2 с использованием очередей сообщений. </P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader123" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 6.1. Структура очереди system V в ядре</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label242 style="border:none;"></a>6.2. Функция msgget</P>
     </H1>
     <P>Создать новую очередь сообщений или получить доступ к существующей можно с помощью функции msgget:</P>
     <P><CODE>#include &lt;sys/msg.h&gt;</CODE></P>
     <P><CODE>int msgget(key_t <EM>key,</EM> int <EM>oflag</EM>);</CODE></P>
     <P><CODE>/* Возвращает неотрицательный идентификатор в случае успешного завершения, –1 в случае ошибки */</CODE></P>
     <P>Возвращаемое значение представляет собой целочисленный идентификатор, используемый тремя другими функциями msg для обращения к данной очереди. Идентификатор вычисляется на основе указанного <EM>ключа,</EM> который может быть получен с помощью функции ftok или может представлять собой константу IPC_PRIVATE, как показано на рис. 3.1.</P>
     <P>Флаг <EM>oflag</EM> представляет собой комбинацию разрешений чтения-записи, показанную в табл. 3.3. К разрешениям можно добавить флаги IPC_CREAT или IPC_CREAT | IPC_EXCL с помощью логического сложения, как уже говорилось в связи с рис. 3.2.</P>
     <P>При создании новой очереди сообщений инициализируются следующие поля структуры msqid_ds:</P>
     <P>■ полям uid и cuid структуры msg_perm присваивается значение действующего идентификатора пользователя вызвавшего процесса, а полям gid и cgid — действующего идентификатора группы;</P>
     <P>■ разрешения чтения-записи, указанные в oflag, помещаются в msg_perm.mode;</P>
     <P>■ значения msg_qnum, msg_lspid, msg_lrpid, msg_stime и msg_rtime устанавливаются в 0;</P>
     <P>■ в msg_ctime записывается текущее время;</P>
     <P>■ в msg_qbytes помещается системное ограничение на размер очереди.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label243 style="border:none;"></a>6.3. Функция msgsnd</P>
     </H1>
     <P>После открытия очереди сообщений с помощью функции msgget можно помещать сообщения в эту очередь с помощью msgsnd.</P>
     <P><CODE>#include &lt;sys/msg.h&gt;</CODE></P>
     <P><CODE>int msgsnd(int <EM>msqid,</EM> const void <EM>*ptr,</EM> size_t <EM>length,</EM> int <EM>flag</EM>); </CODE></P>
     <P><CODE>/* Возвращает 0 в случае успешного завершения; –1 – в случае ошибки */</CODE></P>
     <P>Здесь <EM>msqid</EM> представляет собой идентификатор очереди, возвращаемый msgget. Указатель <EM>ptr</EM> указывает на структуру следующего шаблона, определенного в &lt;sys/ msg.h&gt;:</P>
     <P><CODE>struct msgbuf {</CODE></P>
     <P><CODE> long mtype; /* тип сообщения, должен быть &gt; 0 */</CODE></P>
     <P><CODE> char mtext[1]; /* данные */</CODE></P>
     <P><CODE>};</CODE></P>
     <P>Тип сообщения должен быть больше нуля, поскольку неположительные типы используются в качестве специальной команды функции msgrcv, о чем рассказывается в следующем разделе.</P>
     <P>Название mtext в структуре msgbuf употреблено не вполне правильно; данные в сообщении совсем не обязательно должны быть текстом. Разрешена передача любых типов данных как в двоичном, так и в текстовом формате. Ядро никак не интерпретирует содержимое сообщения.</P>
     <P>Для описания структуры мы используем термин «шаблон», поскольку <EM>ptr</EM> указывает на целое типа long, представляющее собой тип сообщения, за которым непосредственно следует само сообщение (если его длина больше 0 байт). Большинство приложений не пользуются этим определением структуры msgbuf, поскольку установленного в ней количества данных (1 байт) обычно недостаточно для прикладных задач. На количество данных в сообщении никаких ограничений при компиляции не накладывается (как правило, оно может быть изменено системным администратором), поэтому вместо объявления структуры с большим объемом данных (большим, чем поддерживается текущей реализацией) определяется этот шаблон. Большинство приложений затем определяют собственную структуру сообщений, в которой передаваемые данные зависят от нужд этих приложений.</P>
     <P>Например, если приложению нужно передавать сообщения, состоящие из 16-разрядного целого, за которым следует 8-байтовый массив символов, оно может определить свою собственную структуру так:</P>
     <P><CODE>#define MY_DATA 8</CODE></P>
     <P><CODE>typedef struct my_msgbuf {</CODE></P>
     <P><CODE> long mtype; /* тип сообщения */</CODE></P>
     <P><CODE> int16_t mshort; /* начало данных */</CODE></P>
     <P><CODE> char mchar[MY_DATA]; </CODE></P>
     <P><CODE>} Message;</CODE></P>
     <P>Аргумент <EM>length</EM> функции msgsnd указывает длину сообщения в байтах. Это длина пользовательских данных, следующих за типом сообщения (целое типа long). Длина может быть и 0. В указанном выше примере длина может быть вычислена как sizeof(Message) – sizeof(long).</P>
     <P>Аргумент <EM>flag</EM> может быть либо 0, либо IPC_NOWAIT. В последнем случае он отключает блокировку для msgsnd: если для нового сообщения недостаточно места в очереди, возврат из функции происходит немедленно. Это может произойти, если:</P>
     <P>■ в данной очереди уже имеется слишком много данных (значение msg_qbytes в структуре msqid_ds);</P>
     <P>■ во всей системе имеется слишком много сообщений.</P>
     <P>Если верно одно из этих условий и установлен флаг IPC_NOWAIT, функция msgsnd возвращает ошибку с кодом EAGAIN. Если флаг IPC_NOWAIT не указан, а одно из этих условий выполняется, поток приостанавливается до тех пор, пока не произойдет одно из следующего:</P>
     <P>■ для сообщения освободится достаточно места;</P>
     <P>■ очередь с идентификатором <EM>msqid</EM> будет удалена из системы (в этом случае возвращается ошибка с кодом EIDRM);</P>
     <P>■ вызвавший функцию поток будет прерван перехватываемым сигналом (в этом случае возвращается ошибка с кодом EINTR).</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label244 style="border:none;"></a>6.4. Функция msgrcv</P>
     </H1>
     <P>Сообщение может быть считано из очереди с помощью функции msgrcv.</P>
     <P><CODE>#include &lt;sys/msg.h&gt;</CODE></P>
     <P><CODE>ssize_t msgrcv(int <EM>msqid,</EM> void <EM>*ptr,</EM> size_t <EM>length,</EM> long <EM>type,</EM> int <EM>flag</EM>);</CODE></P>
     <P><CODE>/* Возвращает количество данных в сообщении, –1 – в случае ошибки */</CODE></P>
     <P>Аргумент <EM>ptr</EM> указывает, куда следует помещать принимаемые данные. Как и для msgsnd, он указывает на поле данных типа long (рис. 4.13), которое непосредственно предшествует полезным данным.</P>
     <P>Аргумент <EM>length</EM> задает размер относящейся к полезным данным части буфера, на который указывает <EM>ptr.</EM> Это максимальное количество данных, которое может быть возвращено функцией. Поле типа long не входит в эту длину.</P>
     <P>Аргумент <EM>type</EM> определяет тип сообщения, которое нужно считать из очереди:</P>
     <P>■ если значение <EM>type</EM> равно 0, возвращается первое сообщение в очереди (то есть при указании типа 0 возвращается старейшее сообщение);</P>
     <P>■ если тип больше 0, возвращается первое сообщение, тип которого равен указанному;</P>
     <P>■ если тип меньше нуля, возвращается первое сообщение с наименьшим типом, значение которого меньше либо равно модулю аргумента <EM>type.</EM></P>
     <P>Рассмотрим пример очереди сообщений, изображенный на рис. 6.1. В этой очереди имеются три сообщения:</P>
     <P>■ первое сообщение имеет тип 100 и длину 1;</P>
     <P>■ второе сообщение имеет тип 200 и длину 2;</P>
     <P>■ третье сообщение имеет тип 300 и длину 3.</P>
     <P>Таблица 6.1 показывает, какое сообщение будет возвращено при различных значениях аргумента <EM>type.</EM></P>
     <BR>
     <P>Таблица 6.1. Возвращаемое сообщение в зависимости от аргумента type </P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >type</TH>
       <TH ALIGN=left VALIGN=top >Тип возвращаемого сообщения</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >0</TD>
       <TD ALIGN=left VALIGN=top >100</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >100</TD>
       <TD ALIGN=left VALIGN=top >100</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >200</TD>
       <TD ALIGN=left VALIGN=top >200</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >300</TD>
       <TD ALIGN=left VALIGN=top >300</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >-100</TD>
       <TD ALIGN=left VALIGN=top >100</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >-200</TD>
       <TD ALIGN=left VALIGN=top >100</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >-300</TD>
       <TD ALIGN=left VALIGN=top >100 </TD>
      </TR>
     </TABLE>
     <P>Аргумент <EM>flag </EM>указывает, что делать, если в очереди нет сообщения с запрошенным типом. Если установлен бит IPC_NOWAIT, происходит немедленный возврат из функции msgrcv с кодом ошибки ENOMSG. В противном случае вызвавший процесс блокируется до тех пор, пока не произойдет одно из следующего:</P>
     <P>■ появится сообщение с запрошенным типом;</P>
     <P>■ очередь с идентификатором <EM>msqid</EM> будет удалена из системы (в этом случае будет возвращена ошибка с кодом EIDRM);</P>
     <P>■ вызвавший поток будет прерван перехватываемым сигналом (в этом случае возвращается ошибка EINTR).</P>
     <P>В аргументе <EM>flag</EM> можно указать дополнительный бит MSG_NOERROR. При установке этого бита данные, превышающие объем буфера (аргумент <EM>length),</EM> будут просто обрезаться до его размера без возвращения кода ошибки. Если этот флаг не указать, при превышении объемом сообщения аргумента <EM>length</EM> будет возвращена ошибка E2BIG.</P>
     <P>В случае успешного завершения работы msgrcv возвращает количество байтов в принятом сообщении. Оно не включает байты, нужные для хранения типа сообщения (long), который также возвращается через указатель <EM>ptr.</EM></P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label245 style="border:none;"></a>6.5. Функция msgctl</P>
     </H1>
     <DIV class=section>
      <P>Функция msgctl позволяет управлять очередями сообщений:</P>
      <P><CODE>#include &lt;sys/msg.h&gt;</CODE></P>
      <P><CODE>int msgctl(int <EM>msqid,</EM> int <EM>cmd,</EM> struct msqid_ds <EM>*buff</EM>);</CODE></P>
      <P><CODE>/* Возвращает 0 в случае успешного завершения, –1 в случае ошибки */</CODE></P>
      <P>Команд (аргумент <EM>cmd)</EM> может быть три:</P>
      <P>■ IPC_RMID — удаление очереди с идентификатором <EM>msqidиз</EM> системы. Все сообщения, имеющиеся в этой очереди, будут утеряны. Мы уже видели пример действия этой функции в листинге 3.2. Для этой команды третий аргумент функции игнорируется.</P>
      <P>■ IPC_SET — установка значений четырех полей структуры msqid_ds данной очереди равными значениям соответствующих полей структуры, на которую указывает аргумент <EM>buff:</EM> msg_perm.uid, msg_perm.gid, msg_perm.mode, msg_qbytes.</P>
      <P>■ IPC_STAT — возвращает вызвавшему процессу (через аргумент <EM>buff)</EM> текущее содержимое структуры msqid_ds для указанной очереди.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label246 style="border:none;"></a>Пример</P>
      </H1>
      <P>Программа в листинге 6.1 создает очередь сообщений, помещает в нее сообщение с 1 байтом информации, вызывает функцию msgctl с командой IPC_STAT, выполняет команду ipcs, используя функцию system, а затем удаляет очередь, вызвав функцию msgctl с командой IPC_RMID.</P>
      <H2><a name=label247 style="border:none;"></a>Листинг 6.1.<A HREF="#n_1" onmouseover="ShowBookNote('n_1')" onmouseout="HideBookNote('n_1')"><SUP>[1]</SUP></A> Пример использования функции msgctl с командой IPC_STAT</H2>
      <P><CODE>//svmsg/ctl.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int msqid;</CODE></P>
      <P><CODE>6   struct msqid_ds info;</CODE></P>
      <P><CODE>7   struct msgbuf buf;</CODE></P>
      <P><CODE>8   msqid = Msgget(IPC_PRIVATE, SVMSG_MODE | IPC_CREAT);</CODE></P>
      <P><CODE>9   buf.mtype = 1;</CODE></P>
      <P><CODE>10  buf.mtext[0] = 1;</CODE></P>
      <P><CODE>11  Msgsnd(msqid, &amp;buf, 1, 0);</CODE></P>
      <P><CODE>12  Msgctl(msqid, IPC_STAT, &amp;info);</CODE></P>
      <P><CODE>13  printf("read-write: *03o, cbytes = %lu, qnum = %lu, qbytes = %lu\n",</CODE></P>
      <P><CODE>14   info.msg_perm.mode &amp; 0777, (ulong_t) info.msg_cbytes,</CODE></P>
      <P><CODE>15   (ulong_t) info.msg_qnum, (ulong_t) info.msg_qbytes);</CODE></P>
      <P><CODE>16  system("ipcs –q");</CODE></P>
      <P><CODE>17  Msgctl(msqid, IPC_RMID, NULL);</CODE></P>
      <P><CODE>18  exit(0);</CODE></P>
      <P><CODE>19 }</CODE></P>
      <P>Мы собираемся отправить сообщение размером 1 байт, поэтому можно просто воспользоваться стандартным определением структуры msgbuf из &lt;sys/msg.h&gt;. Выполнение этой программы приведет к следующему результату:</P>
      <P><CODE>solaris %<STRONG>ctl</STRONG></CODE></P>
      <P><CODE>read-write: 664, cbytes = 1, qnum = 1, qbytes = 4096</CODE></P>
      <P><CODE>IPC status from &lt;running system&gt; as of MOn Oct 20 15:36:49 1997</CODE></P>
      <P><CODE>T ID   Key      MODE       OWNER    GROUP</CODE></P>
      <P><CODE>Message Queues:</CODE></P>
      <P><CODE>q 1150 00000000 –rw-rw-r-- rstevens other1</CODE></P>
      <P>Выведенные значения соответствуют ожидаемым. Нулевое значение ключа обычно соответствует IPC_PRIVATE, как мы отмечали в разделе 3.2. В этой системе на очередь сообщений накладывается ограничение по объему в 4096 байт. Поскольку мы записали сообщение с 1 байтом данных и msg_cbytes имеет значение 1, это ограничение накладывается на объем полезных данных и не включает тип сообщения (long), указываемый для каждого сообщения.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label248 style="border:none;"></a>6.6. Простые примеры</P>
     </H1>
     <DIV class=section>
      <P>Поскольку очереди сообщений System V обладают живучестью ядра, мы можем написать несколько отдельных программ для работы с этими очередями и изучить их действие.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label249 style="border:none;"></a>Программа msgcreate</P>
      </H1>
      <P>В листинге 6.2 приведена программа msgcreate, создающая очередь сообщений.</P>
      <P>9-12 Параметр командной строки –e позволяет указать флаг IPC_EXCL.</P>
      <P>16 Полное имя файла, являющееся обязательным аргументом командной строки, передается функции ftok. Получаемый ключ преобразуется в идентификатор функцией msgget.</P>
      <H2><a name=label250 style="border:none;"></a>Листинг 6.2. Создание очереди сообщений System V</H2>
      <P><CODE>//svmsg/msgcreate.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int c, oflag, mqid;</CODE></P>
      <P><CODE>6   oflag = SVMSG_MODE | IPC_CREAT;</CODE></P>
      <P><CODE>7   while ((c = Getopt(argc, argv, "e")) != –1) {</CODE></P>
      <P><CODE>8    switch (c) {</CODE></P>
      <P><CODE>9    case 'e':</CODE></P>
      <P><CODE>10    oflag |= IPC_EXCL;</CODE></P>
      <P><CODE>11    break;</CODE></P>
      <P><CODE>12   }</CODE></P>
      <P><CODE>13  }</CODE></P>
      <P><CODE>14  if (optind != argc – 1)</CODE></P>
      <P><CODE>15   err_quit("usage: msgcreate [ –e ] &lt;pathname&gt;");</CODE></P>
      <P><CODE>16  mqid = Msgget(Ftok(argv[optind], 0), oflag);</CODE></P>
      <P><CODE>17  exit(0);</CODE></P>
      <P><CODE>18 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label251 style="border:none;"></a>Программа msgsnd</P>
      </H1>
      <P>Программа msgsnd приведена в листинге 6.3. Она помещает в очередь одно сообщение заданной длины и типа.</P>
      <P>Мы создаем указатель на структуру msgbuf общего вида, а затем выделяем место под реальную структуру (буфер записи) соответствующего размера, вызвав calloc. Эта функция инициализирует буфер нулем.</P>
      <H2><a name=label252 style="border:none;"></a>Листинг 6.3. Помещение сообщения в очередь System V</H2>
      <P><CODE>//svmsg/msgsnd.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int mqid;</CODE></P>
      <P><CODE>6   size_t len;</CODE></P>
      <P><CODE>7   long type;</CODE></P>
      <P><CODE>8   struct msgbuf *ptr;</CODE></P>
      <P><CODE>9   if (argc != 4)</CODE></P>
      <P><CODE>10   err_quit("usage: msgsnd &lt;pathname&gt; &lt;#bytes&gt; &lt;type&gt;");</CODE></P>
      <P><CODE>11  len = atoi(argv[2]);</CODE></P>
      <P><CODE>12  type = atoi(argv[3]);</CODE></P>
      <P><CODE>13  mqid = Msgget(Ftok(argv[1], 0), MSG_W);</CODE></P>
      <P><CODE>14  ptr = Calloc(sizeof(long) + len, sizeof(char));</CODE></P>
      <P><CODE>15  ptr-&gt;mtype = type;</CODE></P>
      <P><CODE>16  Msgsnd(mqid, ptr, len, 0);</CODE></P>
      <P><CODE>17  exit(0);</CODE></P>
      <P><CODE>18 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label253 style="border:none;"></a>Программа msgrcv</P>
      </H1>
      <P>В листинге 6.4 приведен текст программы msgrcv, считывающей сообщение из очереди. В командной строке может быть указан параметр –n, отключающий блокировку, а параметр –t может быть использован для указания типа сообщения в функции msgrcv.</P>
      <P>2 Не существует простого способа определить максимальный размер сообщения (об этом и других ограничениях мы поговорим в разделе 6.10), поэтому мы определим свою собственную константу.</P>
      <H2><a name=label254 style="border:none;"></a>Листинг 6.4. Считывание сообщения из очереди System V</H2>
      <P><CODE>//svmsg/msgrcv.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #define MAXMSG (8192 + sizeof(long))</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int c, flag, mqid;</CODE></P>
      <P><CODE>7   long type;</CODE></P>
      <P><CODE>8   ssize_t n;</CODE></P>
      <P><CODE>9   struct msgbuf *buff;</CODE></P>
      <P><CODE>10  type = flag = 0;</CODE></P>
      <P><CODE>11  while ((c = Getopt(argc, argv, "nt:")) != –1) {</CODE></P>
      <P><CODE>12   switch (c) {</CODE></P>
      <P><CODE>13   case 'n':</CODE></P>
      <P><CODE>14    flag |= IPC_NOWAIT;</CODE></P>
      <P><CODE>15    break;</CODE></P>
      <P><CODE>16   case 't':</CODE></P>
      <P><CODE>17    type = atol(optarg);</CODE></P>
      <P><CODE>18    break;</CODE></P>
      <P><CODE>19   }</CODE></P>
      <P><CODE>20  }</CODE></P>
      <P><CODE>21  if (optind != argc – 1)</CODE></P>
      <P><CODE>22   err_quit("usage: msgrcv [ –n ] [ –t type ] &lt;pathname&gt;");</CODE></P>
      <P><CODE>23  mqid = Msgget(Ftok(argv[optind], 0), MSG_R);</CODE></P>
      <P><CODE>24  buff = Malloc(MAXMSG);</CODE></P>
      <P><CODE>25  n = Msgrcv(mqid, buff, MAXMSG, type, flag);</CODE></P>
      <P><CODE>26  printf("read %d bytes, type = %ld\n", n, buff-&gt;mtype);</CODE></P>
      <P><CODE>27  exit(0);</CODE></P>
      <P><CODE>28 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label255 style="border:none;"></a>Программа msgrmid</P>
      </H1>
      <P>Для удаления очереди сообщений мы вызываем функцию msgctl с командой IPC_RMID, как показано в листинге 6.5.</P>
      <H2><a name=label256 style="border:none;"></a>Листинг 6.5. Удаление очереди сообщений System V</H2>
      <P><CODE>//svmsg/msgrmid.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int mqid;</CODE></P>
      <P><CODE>6   if (argc != 2)</CODE></P>
      <P><CODE>7    err_quit("usage: msgrmid &lt;pathname&gt;");</CODE></P>
      <P><CODE>8   mqid = Msgget(Ftok(argv[1], 0), 0);</CODE></P>
      <P><CODE>9   Msgctl(mqid, IPC_RMID, NULL);</CODE></P>
      <P><CODE>10  exit(0);</CODE></P>
      <P><CODE>11 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label257 style="border:none;"></a>Примеры</P>
      </H1>
      <P>Теперь воспользуемся четырьмя только что написанными программами. Создадим очередь и поместим в нее три сообщения:</P>
      <P><CODE>solaris % <STRONG>msgcreate /tmp/no/such/file</STRONG></CODE></P>
      <P><CODE>ftok error for pathname "tmp/no/such/file" and id 0: No such file or directory</CODE></P>
      <P><CODE>solaris % <STRONG>touch /trap/test1</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>msgcreate /tmp/test1</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>msgsnd /tmp/test1 1 100</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>msgsnd /tmp/test1 2 200</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>msgsnd /tmp/test1 3 300</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>ipcs –qo</STRONG></CODE></P>
      <P><CODE>IPC status from &lt;running system&gt; as of Sat Jan 10 11:25:45 1998</CODE></P>
      <P><CODE>T ID  KEY        MODE       OWNER    GROUP  CBYTES QNUM</CODE></P>
      <P><CODE>Message Queues:</CODE></P>
      <P><CODE>q 100 0х0000113e –rw-r--r-- rstevens other1 6      3</CODE></P>
      <P>Сначала мы пытаемся создать очередь, используя имя несуществующего файла. Пример показывает, что файл, указываемый в качестве аргумента ftok, обязательно должен существовать. Затем мы создаем файл /tmp/test1 и используем его имя при создании очереди сообщений. После этого в очередь помещаются три сообщения длиной 1, 2 и 3 байта со значениями типа 100, 200 и 300 (вспомните рис. 6.1). Программа ipcs показывает, что в очереди находятся 3 сообщения общим объемом 6 байт.</P>
      <P>Теперь продемонстрируем использование аргумента type при вызове msgrcv для считывания сообщений в произвольном порядке:</P>
      <P><CODE>solaris % <STRONG>msgrcv –t 200 /tmp/test1</STRONG></CODE></P>
      <P><CODE>read 2 bytes, type = 200</CODE></P>
      <P><CODE>solaris % <STRONG>msgrcv –t -300 /tmp/test1</STRONG></CODE></P>
      <P><CODE>read 1 bytes, type = 100</CODE></P>
      <P><CODE>solaris % <STRONG>msgrcv /tmp/test1</STRONG></CODE></P>
      <P><CODE>read 3 bytes, type = 300</CODE></P>
      <P><CODE>solaris % <STRONG>msgrcv –n /tmp/test1</STRONG></CODE></P>
      <P><CODE>msgrcv error: No message of desired type</CODE></P>
      <P>В первом примере запрашивается сообщение с типом 200, во втором примере — сообщение с наименьшим значением типа, не превышающим 300, а в третьем — первое сообщение в очереди. Последний запуск msgrcv иллюстрирует действие флага IPC_NOWAIT.</P>
      <P>Что произойдет, если мы укажем положительное значение типа, а сообщений с таким типом в очереди не обнаружится?</P>
      <P><CODE>solaris % <STRONG>ipcs –qo</STRONG></CODE></P>
      <P><CODE>IPC status from &lt;running system&gt; as of Sat Jan 10 11:37:01 1998</CODE></P>
      <P><CODE>T ID  KEY        MODE       OWNER    GROUP  CBYTES QNUM</CODE></P>
      <P><CODE>Message Queues:</CODE></P>
      <P><CODE>q 100 0x0000113e –rw-r--r-- rstevens other1 0      0</CODE></P>
      <P><CODE>solaris % <STRONG>msgsnd /tmp/test1 1 100</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>msgrcv –t 999 /temp/test1</STRONG></CODE></P>
      <P><CODE>^? <EM>нажали клавишу прерывания выполнения программы</EM></CODE></P>
      <P><CODE>solaris % <STRONG>msgrcv –n –t999/tmp/test1</STRONG></CODE></P>
      <P><CODE>msgrcv error: No message of desired type</CODE></P>
      <P><CODE>solaris % <STRONG>grep desired /usr/include/sys/errno.h</STRONG></CODE></P>
      <P><CODE>#define ENOMSG 35 /* No message of desired type */</CODE></P>
      <P><CODE>solaris % <STRONG>msgrmid /tmp/test1</STRONG></CODE></P>
      <P>Сначала мы вызываем ipcs, чтобы убедиться, что очередь пуста, а затем помещаем в нее сообщение длиной 1 байт с типом 100. Затем мы запрашиваем сообщение с типом 999, и программа блокируется (при вызове msgrcv), ожидая помещения в очередь сообщения с указанным типом. Мы прерываем ожидание нажатием клавиши. Затем мы запускаем программу с флагом –n, предотвращающим блокировку, и видим, что в этом случае возвращается ошибка с кодом ENOMSG. После этого мы удаляем очередь с помощью программы msgrmid. Мы могли бы удалить очередь и с помощью системной команды</P>
      <P><CODE>solaris % <STRONG>ipcrm –q 100</STRONG></CODE></P>
      <P>в которой указывается идентификатор очереди, или с помощью той же команды в другом формате</P>
      <P><CODE>solaris % <STRONG>ipcrm –Q 0x113e</STRONG></CODE></P>
      <P>где указывается ключ очереди сообщений.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label258 style="border:none;"></a>Программа msgrcvid</P>
      </H1>
      <P>Покажем теперь, что для получения доступа к очереди сообщений System V не обязательно вызывать msgget: все, что нужно, — это знать идентификатор очереди сообщений, который легко получить с помощью ipcs, и считать разрешения доступа для очереди. В листинге 6.6 приведен упрощенный вариант программы msgrcv из листинга 6.4.</P>
      <P>Здесь мы уже не используем msgget. Вместо этого используется идентификатор очереди сообщений, являющийся обязательным аргументом командной строки.</P>
      <H2><a name=label259 style="border:none;"></a>Листинг 6.6. Считывание из очереди сообщений System V с известным идентификатором</H2>
      <P><CODE>//svmsg/msgrcvid.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #define MAXMSG (8192 + sizeof(long))</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int mqid;</CODE></P>
      <P><CODE>7   ssize_t n;</CODE></P>
      <P><CODE>8   struct msgbuf *buff;</CODE></P>
      <P><CODE>9   if (argc != 2)</CODE></P>
      <P><CODE>10   err_quit("usage: msgrcvid &lt;mqid&gt;");</CODE></P>
      <P><CODE>11  mqid = atoi(argv[1]);</CODE></P>
      <P><CODE>12  buff = Maloc(MAXMSG);</CODE></P>
      <P><CODE>13  n = Msgrcv(mqid, buff, MAXMSG, 0, 0);</CODE></P>
      <P><CODE>14  printf("read %d bytes, type = %ld\n", n, buff-&gt;mtype);</CODE></P>
      <P><CODE>15  exit(0);</CODE></P>
      <P><CODE>16 }</CODE></P>
      <P>Вот пример использования этой программы:</P>
      <P><CODE>solaris % <STRONG>touch /tmp/testid</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>msgcreate /tmp/testid</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>msgsnd /tmp/testid4 400</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>ipcs –qo</STRONG></CODE></P>
      <P><CODE>IPC status from &lt;running system&gt; as of Wed Mar 25 09:48:28 1998</CODE></P>
      <P><CODE>T ID  KEY        MODE       OWNER    GROUP  CBYTES QNUM</CODE></P>
      <P><CODE>Message Queues:</CODE></P>
      <P><CODE>q 150 0x0000118a –rw-r--r-- rstevens other1 4      1</CODE></P>
      <P><CODE>solaris % <STRONG>msgrcvid 150</STRONG></CODE></P>
      <P><CODE>read 4 bytes, type = 400</CODE></P>
      <P>Идентификатор очереди (150) мы узнали с помощью ipcs, его мы и предоставляем программе msgrcvid в качестве аргумента командной строки.</P>
      <P>Этот же метод можно использовать для семафоров System V (упражнение 11.1) и разделяемой памяти System V (упражнение 14.1).</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label260 style="border:none;"></a>6.7. Пример программы клиент-сервер</P>
     </H1>
     <P>Перепишем наш пример программы типа клиент-сервер из раздела 4.2 с использованием двух очередей сообщений. Одна из очередей предназначена для передачи сообщений от клиента серверу, а другая — в обратную сторону.</P>
     <P>Заголовочный файл svmsg.h приведен в листинге 6.7. Мы подключаем наш стандартный заголовочный файл и определяем ключи для каждой из очередей сообщений.</P>
     <H2><a name=label261 style="border:none;"></a>Листинг 6.7. Заголовочный файл svmsg.h для программы клиент-сервер, использующей очереди сообщений</H2>
     <P><CODE>//svmsgcliserv/svmsg.h</CODE></P>
     <P><CODE>1 #include "unpipc.h"</CODE></P>
     <P><CODE>2 #define MQ_KEY1 1234L</CODE></P>
     <P><CODE>3 #define MQ_KEY2 2345L</CODE></P>
     <P>Функция main для сервера приведена в листинге 6.8. Программа создает обе очереди сообщений, и не беда, если какая-нибудь из них уже существует, потому что мы не указываем флаг IPC_EXCL. Функция server дана в листинге 4.16. Она вызывает наши собственные функции mesgsend и mesgrecv, новые версии которых будут приведены ниже.</P>
     <H2><a name=label262 style="border:none;"></a>Листинг 6.8. Функция main программы-сервера, использующей очереди сообщений</H2>
     <P><CODE>//svmsgcliserv/server_main.с</CODE></P>
     <P><CODE>1  #include "svmsg.h"</CODE></P>
     <BR>
     <P><CODE>2  void server(int, int);</CODE></P>
     <P><CODE>3  int</CODE></P>
     <P><CODE>4  main(int argc, char **argv)</CODE></P>
     <P><CODE>5  {</CODE></P>
     <P><CODE>6   int readid, writeid;</CODE></P>
     <P><CODE>7   readid = Msgget(MQ_KEY1, SVMSG_MODE | IPC_CREAT);</CODE></P>
     <P><CODE>8   writeid = Msgget(MQ_KEY2, SVMSG_MODE | IPC_CREAT);</CODE></P>
     <P><CODE>9   server(readid, writeid);</CODE></P>
     <P><CODE>10  exit(0);</CODE></P>
     <P><CODE>11 }</CODE></P>
     <H2><a name=label263 style="border:none;"></a>Листинг 6.9. Функция main программы-клиента, использующей очереди сообщений</H2>
     <P><CODE>//svmsgcliserv/client_main.с</CODE></P>
     <P><CODE>1  #include "svmsg.h"</CODE></P>
     <P><CODE>2  void client(int, int);</CODE></P>
     <BR>
     <P><CODE>3  int</CODE></P>
     <P><CODE>4  main(int argc, char **argv)</CODE></P>
     <P><CODE>5  {</CODE></P>
     <P><CODE>6   int readid, writeid;</CODE></P>
     <P><CODE>7   /* assumes server has created the queues */</CODE></P>
     <P><CODE>8   writeid = Msgget(MQ_KEY1, 0);</CODE></P>
     <P><CODE>9   readid = Msgget(MQ_KEY2, 0);</CODE></P>
     <P><CODE>10  client(readid, writeid);</CODE></P>
     <P><CODE>11  /* now we can delete the queues */</CODE></P>
     <P><CODE>12  Msgctl(readid, IPC_RMID. NULL);</CODE></P>
     <P><CODE>13  Msgctl(writeid, IPC_RMID, NULL);</CODE></P>
     <P><CODE>14  exit(0);</CODE></P>
     <P><CODE>15 }</CODE></P>
     <P>В листинге 6.9 приведен текст функции main программы-клиента. Программа открывает две очереди сообщений и вызывает функцию client из листинга 4.15. Эта функция использует две другие: mesg_send и mesg_recv, которые будут приведены ниже.</P>
     <P>И функция client, и функция server используют формат сообщений, изображенный в листинге 4.12. Для передачи и приема сообщений они используют функции mesg_send и mesg_recv. Старые версии этих функций, приведенные в листингах 4.13 и 4.14, вызывали write и read и работали с программными каналами и FIFO, так что нам придется переписать их для использования очередей сообщений. В листингах 6.10 и 6.11 приведены новые версии этих функций. Обратите внимание, что аргументы функций не изменились, поскольку первый целочисленный аргумент может содержать как целочисленный дескриптор программного канала или FIFO, так и целочисленный дескриптор очереди сообщений.</P>
     <H2><a name=label264 style="border:none;"></a>Листинг 6.10. Функция mesg_send, работающая с очередью сообщений System V</H2>
     <P><CODE>//svmsgcliserv/mesg_send.с</CODE></P>
     <P><CODE>1 #include "mesg.h"</CODE></P>
     <BR>
     <P><CODE>2 ssize_t</CODE></P>
     <P><CODE>3 mesg_send(int id, struct mymesg *mptr)</CODE></P>
     <P><CODE>4 {</CODE></P>
     <P><CODE>5  return(msgsnd(id, &amp;(mptr-&gt;mesg_type), mptr-&gt;mesg_len, 0));</CODE></P>
     <P><CODE>6 }</CODE></P>
     <H2><a name=label265 style="border:none;"></a>Листинг 6.11. Функция mesg_recv, работающая с очередью сообщений System V</H2>
     <P><CODE>//svmsgcliserv/mesg_recv.с</CODE></P>
     <P><CODE>1 #include "mesg.h"</CODE></P>
     <BR>
     <P><CODE>2 ssize_t</CODE></P>
     <P><CODE>3 mesg_recv(int id, struct mymesg *mptr)</CODE></P>
     <P><CODE>4 {</CODE></P>
     <P><CODE>5  ssize_t n;</CODE></P>
     <P><CODE>6  n = msgrcv(id, &amp;(mptr-&gt;mesg_type), MAXMESGDATA, mptr-&gt;mesg_type, 0);</CODE></P>
     <P><CODE>7  mptr-&gt;mesg_len = n; /* количество возвращаемых данных */</CODE></P>
     <P><CODE>8  return(n); /* –1 в случае ошибки, 0 – конец файла, иначе – &gt;0 */</CODE></P>
     <P><CODE>9 }</CODE></P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label266 style="border:none;"></a>6.8. Мультиплексирование сообщений</P>
     </H1>
     <DIV class=section>
      <P>Наличие поля type у каждого сообщения в очереди предоставляет две интересные возможности:</P>
      <P>1. Поле type может использоваться для идентификации сообщений, позволяя нескольким процессам <EM>мультиплексировать</EM> сообщения в одной очереди. Например, все сообщения от клиентов серверу имеют одно и то же значение типа, тогда как сообщения сервера клиентам имеют различные значения типов, уникальные для каждого клиента. Естественно, в качестве значения типа сообщения, гарантированно уникального для каждого клиента, можно использовать идентификатор процесса клиента.</P>
      <P>2. Поле type может использоваться для установки приоритета сообщений. Это позволяет получателю считывать сообщения в порядке, отличном от обычного для очередей (FIFO). В программных каналах и FIFO данные могли приниматься только в том порядке, в котором они были отправлены. Очереди System V позволяют считывать сообщения в произвольном порядке в зависимости от значений типа сообщений. Более того, можно вызывать msgrcv с флагом IPC_NOWAIT для считывания сообщений с конкретным типом и немедленного возвращения управления процессу в случае отсутствия таких сообщений.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label267 style="border:none;"></a>Пример: одна очередь на приложение</P>
      </H1>
      <P>Вспомните наш простой пример с одним процессом-сервером и одним процессом-клиентом. Если применять программные каналы или FIFO, необходимо наличие двух каналов IPC для передачи данных в обоих направлениях, поскольку эти типы IPC являются однонаправленными. Очереди сообщений позволяют передавать данные в обоих направлениях, причем поле type может использоваться для указания адресата (клиента или сервера).</P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader129" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 6.2. Мультиплексирование сообщений между несколькими клиентами и одним сервером</P>
      <BR>
      <P>Рассмотрим усложненный вариант: один сервер и несколько клиентов. В этом случае можно использовать значение типа 1, например, для обозначения сообщений от любого клиента серверу. Если клиент передаст серверу свой идентификатор процесса в качестве части сообщения, сервер сможет отсылать клиенту сообщения, используя его идентификатор в качестве значения типа сообщения. Каждый клиент будет использовать свой PID в качестве аргумента <EM>type</EM> при вызове msgrcv. На рис. 6.2 приведен пример использования очереди для мультиплексирования этих сообщений между несколькими клиентами и одним сервером.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>При использовании одного канала IPC одновременно клиентами и сервером всегда существует потенциальная возможность зависания (deadlock). Клиенты могут (в этом примере) заполнить очередь своими сообщениями, не давая серверу возможности отправить ответ. В этому случае клиенты заблокируются при вызове msgsnd, как и сервер. Одно из соглашений, исключающих возможность такой взаимной блокировки, заключается в том, что сервер должен всегда отключать блокировку записи в очередь сообщений.</P>
      </DIV>
      <P>Теперь мы можем переделать наш пример с клиентом и сервером, используя одну очередь сообщений с различными типами для разных адресатов. Эти программы используют следующее соглашение: сообщения с типом 1 адресованы серверу, а все остальные сообщения имеют тип, соответствующий идентификатору процесса адресата. При этом запрос клиента должен содержать его PID вместе с полным именем запрашиваемого файла, аналогично программе в разделе 4.8.</P>
      <P>В листинге 6.12 приведен текст функции main сервера. Заголовочный файл svmsg.h был приведен в листинге 6.7. Создается единственная очередь сообщений (если она существует, ошибки не возникнет). Идентификатор этой очереди сообщений используется в качестве обоих аргументов при вызове функции server.</P>
      <H2><a name=label268 style="border:none;"></a>Листинг 6.12. Функция main сервера</H2>
      <P><CODE>//svmsgmpx1q/server_main.с</CODE></P>
      <P><CODE>1  #include "svmsg.h"</CODE></P>
      <P><CODE>2  void server(int, int);</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int msqid;</CODE></P>
      <P><CODE>7   msqid = Msgget(MQ_KEY1, SVMSG_MODE | IPC_CREAT);</CODE></P>
      <P><CODE>8   server(msqid, msqid); /* одна очередь в обе стороны */</CODE></P>
      <P><CODE>9   exit(0);</CODE></P>
      <P><CODE>10 }</CODE></P>
      <P>Функция server обеспечивает работу сервера. Ее текст приведен в листинге 6.13. Эта функция представляет собой комбинацию листинга 4.10 — нашего сервера FIFO, считывавшего команды, состоявшие из идентификатора процесса и полного имени файла, — и листинга 4.16, в котором использовались функции mesg_send и mesg_recv. Обратите внимание, что идентификатор процесса, отправляемый клиентом, используется в качестве типа для всех сообщений, отправляемых сервером этому клиенту. Эта функция представляет собой бесконечный цикл, в котором считываются запросы клиентов и отсылаются запрошенные файлы. Этот сервер является последовательным (см. раздел 4.9).</P>
      <P>В листинге 6.14 приведен текст функции main клиента. Клиент открывает очередь сообщений, которая должна была быть создана сервером заранее.</P>
      <P>Функция client, текст которой дан в листинге 6.15, обеспечивает всю обработку со стороны клиента. Эта функция представляет собой комбинацию программ из листингов 4.11 и 4.15. В первой программе клиент отсылал свой идентификатор и полное имя файла, а во второй программе использовались функции mesg_send и mesg_recv. Обратите внимание, что тип сообщений, запрашиваемых функцией mesg_recv, совпадает с идентификатором процесса клиента.</P>
      <P>Функции client и server используют функции mesg_send и mesg_recv из листингов 6.9 и 6.11.</P>
      <H2><a name=label269 style="border:none;"></a>Листинг 6.13. Функция server</H2>
      <P><CODE>//svmsgmpx1q/server.c</CODE></P>
      <P><CODE>1  #include "mesg.h"</CODE></P>
      <BR>
      <P><CODE>2  void</CODE></P>
      <P><CODE>3  server(int readfd, int writefd)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   FILE *fp;</CODE></P>
      <P><CODE>6   char *ptr;</CODE></P>
      <P><CODE>7   pid_t pid;</CODE></P>
      <P><CODE>8   ssize_t n;</CODE></P>
      <P><CODE>9   struct mymesg mesg;</CODE></P>
      <P><CODE>10  for (;;) {</CODE></P>
      <P><CODE>11   /* считывание полного имени из канала IPC */</CODE></P>
      <P><CODE>12   mesg.mesg_type = 1:</CODE></P>
      <P><CODE>13   if ((n = Mesg_recv(readfd, &amp;mesg)) == 0) {</CODE></P>
      <P><CODE>14    err_msg("pathname missing");</CODE></P>
      <P><CODE>15    continue;</CODE></P>
      <P><CODE>16   }</CODE></P>
      <P><CODE>17   mesg.mesg_data[n] = '\0'; /* полное имя */</CODE></P>
      <P><CODE>18   if ((ptr = strchr(mesg.mesg_data, ' ')) == NULL) {</CODE></P>
      <P><CODE>19    err_msg("bogus request: %s", mesg.mesg_data);</CODE></P>
      <P><CODE>20    continue;</CODE></P>
      <P><CODE>21   }</CODE></P>
      <P><CODE>22   *ptr++ =0; /* ptr = полное имя */</CODE></P>
      <P><CODE>23   pid = atol(mesg.mesg_data);</CODE></P>
      <P><CODE>24   mesg.mesg_type = pid; /* для обратных сообщений */</CODE></P>
      <P><CODE>25   if ((fp = fopen(ptr, "r")) == NULL) {</CODE></P>
      <P><CODE>26    /* 4error: must tell client */</CODE></P>
      <P><CODE>27    snprintf(mesg.mesg_data + n, sizeof(mesg.mesg_data) – n,</CODE></P>
      <P><CODE>28     ": can't open. %s\n", strerror(errno));</CODE></P>
      <P><CODE>29    mesg.mesg_len – strlen(ptr);</CODE></P>
      <P><CODE>30    memmove(mesg.mesg_data, ptr, mesg.mesg_len);</CODE></P>
      <P><CODE>31    Mesg_send(writefd, &amp;mesg);</CODE></P>
      <P><CODE>32   } else {</CODE></P>
      <P><CODE>33    /* файл открыт, копируем клиенту */</CODE></P>
      <P><CODE>34    while (Fgets(mesg.mesg_data, MAXMESGDATA, fp) != NULL) {</CODE></P>
      <P><CODE>35     mesg.mesg_len = strlen(mesg.mesg_data);</CODE></P>
      <P><CODE>36     Mesg_send(writefd, &amp;mesg);</CODE></P>
      <P><CODE>37    }</CODE></P>
      <P><CODE>38    Fclose(fp);</CODE></P>
      <P><CODE>39   }</CODE></P>
      <P><CODE>40   /* сообщение нулевой длины заканчивает связь */</CODE></P>
      <P><CODE>41   mesg.mesg_len = 0;</CODE></P>
      <P><CODE>42   Mesg_send(writefd, &amp;mesg);</CODE></P>
      <P><CODE>43  }</CODE></P>
      <P><CODE>44 }</CODE></P>
      <H2><a name=label270 style="border:none;"></a>Листинг 6.14. Функция main клиента</H2>
      <P><CODE>//svmsgmpx1q/client_main.c</CODE></P>
      <P><CODE>1  #include "svmsg.h"</CODE></P>
      <P><CODE>2  void client(int, int);</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int msqid;</CODE></P>
      <P><CODE>7   /* сервер должен был создать очередь */</CODE></P>
      <P><CODE>8   msqid = Msgget(MQ_KEY1, 0);</CODE></P>
      <P><CODE>9   client(msqid, msqid); /* одна очередь в обе стороны */</CODE></P>
      <P><CODE>10  exit(0);</CODE></P>
      <P><CODE>11 }</CODE></P>
      <H2><a name=label271 style="border:none;"></a>Листинг 6.15. Функция client</H2>
      <P><CODE>//svmsgmpx1q/client.с</CODE></P>
      <P><CODE>1  #include "mesg.h"</CODE></P>
      <BR>
      <P><CODE>2  void</CODE></P>
      <P><CODE>3  client(int readfd, int writefd)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   size_t len;</CODE></P>
      <P><CODE>6   ssize_t n;</CODE></P>
      <P><CODE>7   char *ptr;</CODE></P>
      <P><CODE>8   struct mymesg mesg;</CODE></P>
      <P><CODE>9   /* инициализируем буфер идентификатором процесса и пробелом */</CODE></P>
      <P><CODE>10  snprintf(mesg.mesg_data, MAXMESGDATA. "%ld ", (long) getpid());</CODE></P>
      <P><CODE>11  len = strlen(mesg.mesg_data);</CODE></P>
      <P><CODE>12  ptr = mesg.mesg_data + len;</CODE></P>
      <P><CODE>13  /* считываем полное имя файла */</CODE></P>
      <P><CODE>14  Fgets(ptr, MAXMESGDATA – len, stdin);</CODE></P>
      <P><CODE>15  len = strlen(mesg.mesg_data);</CODE></P>
      <P><CODE>16  if (mesg.mesg_data[len-1] == '\n')</CODE></P>
      <P><CODE>17   len--; /* удаляем перевод строки fgets() */</CODE></P>
      <P><CODE>18  mesg.mesg_len = len;</CODE></P>
      <P><CODE>19  mesg.mesg_type = 1;</CODE></P>
      <P><CODE>20  /* записываем PID и имя файла в канал IPC */</CODE></P>
      <P><CODE>21  Mesg_send(writefd, &amp;mesg);</CODE></P>
      <P><CODE>22  /* считываем из канала IPC, записываем в stdout */</CODE></P>
      <P><CODE>23  mesg.mesg_type = getpid();</CODE></P>
      <P><CODE>24  while ((n = Mesg_recv(readfd, &amp;mesg)) &gt; 0)</CODE></P>
      <P><CODE>25   Write(STDOUT_FILENO, mesg.mesg_data, n);</CODE></P>
      <P><CODE>26 }</CODE> </P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label272 style="border:none;"></a>Пример: одна очередь для каждого клиента</P>
      </H1>
      <P>Изменим теперь предыдущий пример таким образом, чтобы все запросы клиентов передавались по одной очереди, но для отправки ответов использовалась бы отдельная очередь для каждого клиента. На рис. 6.3 изображена схема такого приложения. </P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader131" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 6.3. Одна очередь для сервера и по одной для каждого клиента</P>
      <BR>
      <P>Ключ очереди сервера должен быть известен клиентам, а сами клиенты создают свои очереди с ключом IPC_PRIVATE. Вместо передачи серверу идентификатора процесса клиенты сообщают ему идентификатор своей очереди, в которую сервер направляет свой ответ. Этот сервер является параллельным: для каждого нового клиента порождается отдельный процесс.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>При такой схеме может возникнуть проблема в случае «гибели» клиента, потому что тогда сообщения останутся в его очереди навсегда (по крайней мере до перезагрузки ядра или явного удаления очереди другим процессом).</P>
      </DIV>
      <P>Нижеследующие заголовочные файлы и функции не претерпевают изменений по сравнению с предыдущими версиями:</P>
      <P>■ mesg.h (листинг 4.12);</P>
      <P>■ svmsg.h (листинг 6.7);</P>
      <P>■ функция main сервера (листинг 6.12);</P>
      <P>■ функция mesg_send (листинг 4.13).</P>
      <P>Функция main клиента приведена в листинге 6.16; она слегка изменилась по сравнению с листингом 6.14. Мы открываем очередь сервера с известным ключом (MQ_KEY1) и создаем нашу собственную очередь с ключом IPC_PRIVATE. Два идентификатора этих очередей становятся аргументами функции client (листинг 6.17). После завершения работы клиента его персональная очередь удаляется.</P>
      <H2><a name=label273 style="border:none;"></a>Листинг 6.16. Функция main клиента</H2>
      <P><CODE>//svmsgmpxnq/client_main.с</CODE></P>
      <P><CODE>1  #include "svmsg.h"</CODE></P>
      <BR>
      <P><CODE>2  void client(int, int);</CODE></P>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int readid, writeid;</CODE></P>
      <P><CODE>7   /* сервер должен создать свою очередь */</CODE></P>
      <P><CODE>8   writeid = Msgget(MQ_KEY1, 0);</CODE></P>
      <P><CODE>9   /* мы создаем свою собственную очередь */</CODE></P>
      <P><CODE>10  readid = Msgget(IPC_PRIVATE, SVMSG_MODE | IPC_CREAT);</CODE></P>
      <P><CODE>11  client(readid, writeid);</CODE></P>
      <P><CODE>12  /* и удаляем нашу собственную очередь */</CODE></P>
      <P><CODE>13  Msgctl(readid, IPC_RMID, NULL);</CODE></P>
      <P><CODE>14  exit(0);</CODE></P>
      <P><CODE>15 }</CODE></P>
      <H2><a name=label274 style="border:none;"></a>Листинг 6.17. Функция client</H2>
      <P><CODE>//svmsgmpxnq/client.с</CODE></P>
      <P><CODE>1  #include "mesg.h"</CODE></P>
      <BR>
      <P><CODE>2  void</CODE></P>
      <P><CODE>3  client(int readid, int writeid)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   size_t len;</CODE></P>
      <P><CODE>6   ssize_t n;</CODE></P>
      <P><CODE>7   char *ptr;</CODE></P>
      <P><CODE>8   struct mymesg mesg;</CODE></P>
      <P><CODE>9   /* инициализируем буфер идентификатором очереди и пробелом */</CODE></P>
      <P><CODE>10  snprintf(mesg.mesg_data, MAXMESGDATA, "%d ", readid);</CODE></P>
      <P><CODE>11  len = strlen(mesg.mesg_data);</CODE></P>
      <P><CODE>12  ptr = mesg.mesg_data + len;</CODE></P>
      <P><CODE>13  /* считываем имя файла */</CODE></P>
      <P><CODE>14  Fgets(ptr, MAXMESGDATA – len, stdin);</CODE></P>
      <P><CODE>15  len = strlen(mesg.mesg_data);</CODE></P>
      <P><CODE>16  if (mesg.mesg_data[len-1] == '\n')</CODE></P>
      <P><CODE>17   len--; /* удаляем перевод строки fgets() */</CODE></P>
      <P><CODE>18  mesg.mesg_len = len;</CODE></P>
      <P><CODE>19  mesg.mesg_type = 1;</CODE></P>
      <P><CODE>20  /* отправляем идентификатор очереди и имя файла серверу */</CODE></P>
      <P><CODE>21  Mesg_send(writeid, &amp;mesg);</CODE></P>
      <P><CODE>22  /* считываем ответ из нашей очереди и записываем его в stdout */</CODE></P>
      <P><CODE>23  while ((n = Mesg_recv(readid, &amp;mesg)) &gt; 0)</CODE></P>
      <P><CODE>24   Write(STDOUT_FILENO, mesg.mesg_data, n);</CODE></P>
      <P><CODE>25 }</CODE></P>
      <P>В листинге 6.17 приведен текст функции client. Эта функция практически идентична функции из листинга 6.15, но вместо передачи идентификатора процесса клиента на сервер направляется идентификатор очереди клиента. Тип сообщения в структуре mesg остается равным 1, поскольку это значение устанавливается для сообщений, передаваемых в обе стороны.</P>
      <P>В листинге 6.19 приведена функция server. Главное отличие от листинга 6.13 в том, что эта функция представляет собой бесконечный цикл, в котором для каждого нового клиента вызывается fork.</P>
      <H2><a name=label275 style="border:none;"></a>Установка обработчика сигнала для SIGCHLD</H2>
      <P>10 Поскольку для каждого клиента порождается отдельный процесс, нужно позаботиться о процессах-зомби. В разделах 5.9 и 5.10 [24] об этом говорится подробно. Здесь мы просто установим обработчик для сигнала SIGCHLD, и наша функция sig_chld (листинг 6.18) будет вызываться при завершении работы дочернего процесса.</P>
      <P>12-18 Породивший процесс сервера блокируется в вызове mesg_recv, ожидая появления сообщения от очередного клиента.</P>
      <P>25-45 Вызовом fork порождается новый процесс, который производит попытку открыть запрошенный файл и отправляет клиенту либо сообщение об ошибке, либо содержимое файла. Мы преднамеренно поместили вызов fopen в дочерний процесс, а не в родительский, поскольку если файл находится в удаленной файловой системе, его открытие может занять довольно много времени в случае наличия проблем с сетью.</P>
      <P>Функция-обработчик для SIGCHLD приведена в листинге 6.18. Она скопирована с листинга 5.11 [24].</P>
      <H2><a name=label276 style="border:none;"></a>Листинг 6.18. Обработчик сигнала SIGCHLD, вызывающий waitpid</H2>
      <P><CODE>//svmsgmpxnq/sigchldwaitpid.с</CODE></P>
      <P><CODE>1 #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2 void</CODE></P>
      <P><CODE>3 sig_chld(int signo)</CODE></P>
      <P><CODE>4 {</CODE></P>
      <P><CODE>5  pid_t pid;</CODE></P>
      <P><CODE>6  int stat;</CODE></P>
      <P><CODE>7  while ((pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0);</CODE></P>
      <P><CODE>8  return;</CODE></P>
      <P><CODE>9 }</CODE></P>
      <P>Каждый раз при вызове обработчика происходит циклический вызов waitpid для получения статуса завершения работы всех дочерних процессов, которые могли завершить работу. Затем происходит возврат из обработчика сигнала. При этом может возникнуть проблема, поскольку родительский процесс проводит большую часть времени в заблокированном состоянии (при вызове mesg_recv, листинг 6.9). При возвращении из обработчика этот вызов msgrcv прерывается. Функция возвращает ошибку с кодом EINTR, как рассказывается в разделе 5.9 [24]. </P>
      <P>Нам нужно обработать такой возврат из вызванной функции, поэтому мы пишем новую функцию-обертку Mesg_recv, приведенную в листинге 6.20. Эта программа допускает возвращение ошибки с кодом EINTR функцией mesg_recv (которая просто вызывает msgrcv), и, если это происходит, мы просто еще раз вызываем mesg_recv.</P>
      <H2><a name=label277 style="border:none;"></a>Листинг 6.19. Функция server</H2>
      <P><CODE>//svmsgmpxnq/server.c</CODE></P>
      <P><CODE>1  #include "mesg.h"</CODE></P>
      <BR>
      <P><CODE>2  void</CODE></P>
      <P><CODE>3  server(int readid, int writeid)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   FILE *fp;</CODE></P>
      <P><CODE>6   char *ptr;</CODE></P>
      <P><CODE>7   ssize_t n;</CODE></P>
      <P><CODE>8   struct mymesg mesg;</CODE></P>
      <P><CODE>9   void sig_chld(int);</CODE></P>
      <P><CODE>10  Signal(SIGCHLD, sig_chld);</CODE></P>
      <P><CODE>11  for (;;) {</CODE></P>
      <P><CODE>12   /* считывание имени файла из очереди */</CODE></P>
      <P><CODE>13   mesg.mesg_type = 1;</CODE></P>
      <P><CODE>14   if ((n = Mesg_recv(readid, &amp;mesg)) == 0) {</CODE></P>
      <P><CODE>15    err_msg("pathname missing");</CODE></P>
      <P><CODE>16    continue;</CODE></P>
      <P><CODE>17   }</CODE></P>
      <P><CODE>18   mesg.mesg_data[n] = 40'; /* имя файла */</CODE></P>
      <P><CODE>19   if ((ptr = strchr(mesg.mesg_data, ' ')) = NULL) {</CODE></P>
      <P><CODE>20    err_msg("bogus request: %s", mesg.mesg_data);</CODE></P>
      <P><CODE>21    continue;</CODE></P>
      <P><CODE>22   }</CODE></P>
      <P><CODE>23   *ptr++ = 0; /* ptr = имя файла */</CODE></P>
      <P><CODE>24   writeid = atoi(mesg.mesg_data);</CODE></P>
      <P><CODE>25   if (Fork() == 0) { /* дочерний процесс */</CODE></P>
      <P><CODE>26    if ((fp = fopen(ptr, "r")) == NULL) {</CODE></P>
      <P><CODE>27     /* ошибка: нужно сообщить клиенту */</CODE></P>
      <P><CODE>28     snprintf(mesg.mesg_data + n, sizeof(mesg.mesg_data) – n,</CODE></P>
      <P><CODE>29      ": can't open, %s\n", strerror(errno));</CODE></P>
      <P><CODE>30     mesg.mesg_len = strlen(ptr);</CODE></P>
      <P><CODE>31     memmove(mesg.mesg_data, ptr, mesg.mesg_len);</CODE></P>
      <P><CODE>32     Mesg_send(writeid, &amp;mesg);</CODE></P>
      <P><CODE>33    } else {</CODE></P>
      <P><CODE>34     /* файл открыт, копируем клиенту */</CODE></P>
      <P><CODE>35     while (Fgets(mesg.mesg_data, MAXMESGDATA, fp) != NULL) {</CODE></P>
      <P><CODE>36      mesg.mesg_len = strlen(mesg.mesg_data);</CODE></P>
      <P><CODE>37      Mesg_send(writeid, &amp;mesg);</CODE></P>
      <P><CODE>38     }</CODE></P>
      <P><CODE>39     Fclose(fp);</CODE></P>
      <P><CODE>40    }</CODE></P>
      <P><CODE>41    /* отправка сообщения нулевой длины, указывающего конец файла */</CODE></P>
      <P><CODE>42    mesg.mesg_len = 0;</CODE></P>
      <P><CODE>43    Mesg_send(writeid, &amp;mesg);</CODE></P>
      <P><CODE>44    exit(0); /* завершение дочернего процесса */</CODE></P>
      <P><CODE>45   }</CODE></P>
      <P><CODE>46   /* родительский процесс просто зациклен */</CODE></P>
      <P><CODE>47  }</CODE></P>
      <P><CODE>48 }</CODE></P>
      <H2><a name=label278 style="border:none;"></a>Листинг 6.20. Функция-обертка Mesg_recv, обрабатывающая прерванный системный вызов</H2>
      <P><CODE>//svmsgmpxnq/mesg_recv.с</CODE></P>
      <P><CODE>10 ssize_t</CODE></P>
      <P><CODE>11 Mesg_recv(int id, struct mymesg *mptr)</CODE></P>
      <P><CODE>12 {</CODE></P>
      <P><CODE>13  ssize_t n;</CODE></P>
      <P><CODE>14  do {</CODE></P>
      <P><CODE>15   n = mesg_recv(id, mptr);</CODE></P>
      <P><CODE>16  } while (n == –1 &amp;&amp; errno == EINTR);</CODE></P>
      <P><CODE>17  if (n == –1)</CODE></P>
      <P><CODE>18   err_sys("mesg_recv error");</CODE></P>
      <P><CODE>19  return(n);</CODE></P>
      <P><CODE>20 }</CODE></P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label279 style="border:none;"></a>6.9. Использование select и poll с очередями сообщений</P>
     </H1>
     <P>Одним из недостатков очередей сообщений System V является то, что они идентифицируются не дескрипторами, а идентификаторами. Поэтому с ними нельзя использовать функции select и poll (глава 6 [24]).</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>На самом деле одна из версий Unix, а именно AIX (созданная IBM), позволяет использовать select с очередями сообщений System V, а не только с дескрипторами. Но эта возможность имеется только в AIX.</P>
     </DIV>
     <P>Этот недостаток часто всплывает, когда возникает необходимость написать сервер, работающий одновременно с сетевыми соединениями и с IPC. Сетевые соединения с использованием интерфейса сокетов или XTI ([24]) используют дескрипторы, что позволяет вызывать select или poll. Программные каналы и FIFO также идентифицируются дескрипторами, поэтому для них тоже допустимо использование этих функций.</P>
     <P>Одним из решений этой проблемы является следующее: сервер должен создать канал и породить процесс, который будет заблокирован при вызове msgrcv. При получении сообщения произойдет возврат из msgrcv, дочерний процесс получит это сообщение из очереди и запишет его в канал. Затем родительский процесс может использовать функцию select для канала совместно с сетевыми соединениями. Недостаток этого подхода в том, что сообщения обрабатываются трижды: при считывании дочерним процессом с помощью msgrcv, при отправке в канал и при считывании из канала родительским процессом. Для ускорения обработки порожденный процесс может создать сегмент совместно используемой с породившим процессом памяти, а канал использовать как флаг (упражнение 12.5).</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>В листинге 5.12 мы привели решение с использованием очередей сообщений Posix, которое не требовало вызова fork. Для очередей сообщений Posix можно было обойтись одним процессом, поскольку они предусматривают уведомление о появлении нового сообщения с помощью сигнала. Для очередей System V такая возможность не предусмотрена, поэтому приходится порождать процесс, который будет блокироваться при вызове msgrcv.</P>
     </DIV>
     <P>Другим недостатком очередей сообщений System V по сравнению с сетевым интерфейсом является невозможность считывания сообщений из оперативной памяти (возможность, предоставляемая флагом MSG_PEEK для функций recv, recvfrom, recvmsg [24, с. 356]). Если бы такая возможность имелась, в предложенной только что схеме клиент-сервер (для обхода проблемы с select) можно было бы сделать работу более эффективной, указав флаг peek при вызове msgrcv дочерним процессом и записав 1 байт в канал при приходе сообщения, а родительский процесс тогда просто считывал бы сообщение из очереди.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label280 style="border:none;"></a>6.10. Ограничения, накладываемые на очереди сообщений</P>
     </H1>
     <DIV class=section>
      <P>Как отмечалось в разделе 3.8, на очереди сообщений часто накладываются системные oгрaничeния. В табл. 6.2 приведены значения этих oгрaничeний для двух конкретных реализаций. Первая колонка представляет собой традиционное имя System V для переменной ядра, хранящей это ограничение.</P>
      <BR>
      <P>Таблица 6.2. Характерные значения ограничений для очередей сообщений</P>
      <TABLE>
       <TR ALIGN=left >
        <TH ALIGN=left VALIGN=top >Имя</TH>
        <TH ALIGN=left VALIGN=top >Описание</TH>
        <TH ALIGN=left VALIGN=top >DUnix 4.0B</TH>
        <TH ALIGN=left VALIGN=top >Solaris 2.6</TH>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >msgmax</TD>
        <TD ALIGN=left VALIGN=top >Максимальное количество байтов в сообщении</TD>
        <TD ALIGN=left VALIGN=top >8192</TD>
        <TD ALIGN=left VALIGN=top >2048</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >msgmnb</TD>
        <TD ALIGN=left VALIGN=top >Максимальное количество байтов в очереди сообщений</TD>
        <TD ALIGN=left VALIGN=top >16384</TD>
        <TD ALIGN=left VALIGN=top >4096</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >msgmni</TD>
        <TD ALIGN=left VALIGN=top >Максимальное количество очередей сообщений в системе</TD>
        <TD ALIGN=left VALIGN=top >64</TD>
        <TD ALIGN=left VALIGN=top >50</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >msgtlq</TD>
        <TD ALIGN=left VALIGN=top >Максимальное количество сообщений в системе</TD>
        <TD ALIGN=left VALIGN=top >40</TD>
        <TD ALIGN=left VALIGN=top >40 </TD>
       </TR>
      </TABLE>
      <P>В этом разделе мы хотели показать типичные значения ограничений, чтобы помочь в планировании переносимых программ. При выполнении приложений, активно использующих очереди сообщений, обычно требуется настройка этих (или аналогичных) параметров ядра (что описано в разделе 3.8).</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label281 style="border:none;"></a>Пример</P>
      </H1>
      <P>В листинге 6.21 приведен текст программы, которая определяет четыре ограничения, показанные в табл. 6.2.</P>
      <H2><a name=label282 style="border:none;"></a>Листинг 6.21. Определение системных ограничений для очередей сообщений System V</H2>
      <P><CODE>//svmsg/limits.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #define MAX_DATA 64*1024</CODE></P>
      <P><CODE>3  #define MAX_NMESG 4096</CODE></P>
      <P><CODE>4  #define MAX_NIDS 4096</CODE></P>
      <P><CODE>5  int max_mesg;</CODE></P>
      <BR>
      <P><CODE>6  struct mymesg {</CODE></P>
      <P><CODE>7   long type;</CODE></P>
      <P><CODE>8   char data[MAX_DATA];</CODE></P>
      <P><CODE>9  } mesg;</CODE></P>
      <BR>
      <P><CODE>10 int</CODE></P>
      <P><CODE>11 main(int argc, char **argv)</CODE></P>
      <P><CODE>12 {</CODE></P>
      <P><CODE>13  int i, j, msqid, qid[MAX_NIDS];</CODE></P>
      <P><CODE>14  /* определение максимального размера сообщения */</CODE></P>
      <P><CODE>15  msqid = Msgget(IPC_PRIVATE, SVMSG_MODE | IPC_CREAT);</CODE></P>
      <P><CODE>16  mesg.type = 1;</CODE></P>
      <P><CODE>17  for (i = MAX_DATA; i &gt; 0; i –= 128) {</CODE></P>
      <P><CODE>18   if (msgsnd(msqid, &amp;mesg, i, 0) == 0) {</CODE></P>
      <P><CODE>19    printf("maximum amount of data per message = %d\n", i);</CODE></P>
      <P><CODE>20    max_mesg = i;</CODE></P>
      <P><CODE>21    break;</CODE></P>
      <P><CODE>22   }</CODE></P>
      <P><CODE>23   if (errno != EINVAL)</CODE></P>
      <P><CODE>24    err_sys("msgsnd error for length %d", i);</CODE></P>
      <P><CODE>25  }</CODE></P>
      <P><CODE>26  if (i == 0)</CODE></P>
      <P><CODE>27   err_quit("i == 0");</CODE></P>
      <P><CODE>28  Msgct(lmsqid, IPC_RMID, NULL);</CODE></P>
      <P><CODE>29  /* количество сообщений в очереди */</CODE></P>
      <P><CODE>30  mesg.type = 1;</CODE></P>
      <P><CODE>31  for (i = 8; i &lt;= max_mesg; i *= 2) {</CODE></P>
      <P><CODE>32   msqid = Msgget(IPC_PRIVATE, SVMSG_MODE | IPC_CREAT);</CODE></P>
      <P><CODE>33   for (j = 0; j &lt; MAX_NMESG; j++) {</CODE></P>
      <P><CODE>34    if (msgsnd(msqid, &amp;mesg, i, IPC_NOWAIT) != 0) {</CODE></P>
      <P><CODE>35     if (errno == EAGAIN)</CODE></P>
      <P><CODE>36      break;</CODE></P>
      <P><CODE>37     err_sys("msgsnd error, i = %d, j = %d", i, j);</CODE></P>
      <P><CODE>38     break;</CODE></P>
      <P><CODE>39    }</CODE></P>
      <P><CODE>40   }</CODE></P>
      <P><CODE>41   printf("%d %d-byte messages were placed onto queue,", j, i);</CODE></P>
      <P><CODE>42   printf(" %d bytes total\n". i*j);</CODE></P>
      <P><CODE>43   Msgctl(msqid, IPC_RMID, NULL);</CODE></P>
      <P><CODE>44  }</CODE></P>
      <P><CODE>45  /* максимальное количество идентификаторов */</CODE></P>
      <P><CODE>46  mesg.type = 1;</CODE></P>
      <P><CODE>47  for (i = 0; i &lt;= MAX_NIDS; i++) {</CODE></P>
      <P><CODE>48   if ((qid[i] = msgget(IPC_PRIVATE, SVMSG_MODE | IPC_CREAT)) == –1) {</CODE></P>
      <P><CODE>49    printf("%d identifiers open at once\n", i);</CODE></P>
      <P><CODE>50    break;</CODE></P>
      <P><CODE>51   }</CODE></P>
      <P><CODE>52  }</CODE></P>
      <P><CODE>53  for (j = 0; j &lt; i; j++)</CODE></P>
      <P><CODE>54   Msgctl(qid[j], IPC_RMID, NULL);</CODE></P>
      <P><CODE>55  exit(0);</CODE></P>
      <P><CODE>56 }</CODE></P>
      <H2><a name=label283 style="border:none;"></a>Определение максимального размера сообщения</H2>
      <P>14-28 Для определения максимально возможного размера сообщения мы пытаемся послать сообщение, в котором будет 65 536 байт данных, и если эта попытка оказывается неудачной, уменьшаем этот объем до 65 408, и т.д., пока вызов msgsnd не окажется успешным.</P>
      <H2><a name=label284 style="border:none;"></a>Сколько сообщений различного размера может быть помещено в очередь?</H2>
      <P>29-44 Теперь мы начинаем с 8-байтовых сообщений и смотрим, сколько их поместится в очередь. После определения этого ограничения мы удаляем очередь (сбрасывая все эти сообщения) и повторяем процедуру с 16-байтовыми сообщениями. Мы повторяем это до тех пор, пока не будет достигнут максимальный размер сообщения из первого пункта. Ожидается, что небольшие сообщения будут превышать ограничение по количеству сообщений в очереди, а большие — ограничение по количеству байтов.</P>
      <H2><a name=label285 style="border:none;"></a>Сколько идентификаторов может быть открыто одновременно?</H2>
      <P>45-54 Обычно есть системное ограничение на количество одновременно открытых идентификаторов. Оно определяется непосредственно созданием очередей до тех пор, пока не произойдет ошибка при вызове msgget.</P>
      <P>Запустим эту программу сначала в Solaris 2.6, а затем в Digital Unix 4.0B, и результаты подтвердят приведенные в табл. 6.2 величины:</P>
      <P><CODE>solaris % <STRONG>limits</STRONG></CODE></P>
      <P><CODE>maximum amount of data per message = 2048</CODE></P>
      <P><CODE>40 8-byte messages were placed on queue, 320 bytes total</CODE></P>
      <P><CODE>40 16-byte messages were placed on queue, 640 bytes total</CODE></P>
      <P><CODE>40 32-byte messages were placed on queue, 1280 bytes total</CODE> </P>
      <P><CODE>40 64-byte messages were placed on queue, 2560 bytes total</CODE></P>
      <P><CODE>32 128-byte messages were placed on queue, 4096 bytes total</CODE></P>
      <P><CODE>16 256-byte messages were placed on queue, 4096 bytes total</CODE></P>
      <P><CODE>8 512-byte messages were placed on queue, 4096 bytes total</CODE></P>
      <P><CODE>4 1024-byte messages were placed on queue, 4096 bytes total</CODE></P>
      <P><CODE>2 2048-byte messages were placed on queue, 4096 bytes total</CODE></P>
      <P><CODE>50 identifiers open at once</CODE></P>
      <BR>
      <P><CODE>alpha % <STRONG>limits</STRONG></CODE></P>
      <P><CODE>maximum amount of data per message = 8192</CODE></P>
      <P><CODE>40 8-byte messages were placed on queue, 320 bytes total</CODE></P>
      <P><CODE>40 16-byte messages were placed on queue, 640 bytes total</CODE></P>
      <P><CODE>40 32-byte messages were placed on queue, 1280 bytes total</CODE></P>
      <P><CODE>40 64-byte messages were placed on queue, 2560 bytes total</CODE></P>
      <P><CODE>40 128-byte messages were placed on queue, 5120 bytes total</CODE></P>
      <P><CODE>40 256-byte messages were placed on queue, 10240 bytes total</CODE></P>
      <P><CODE>32 512-byte messages were placed on queue, 16384 bytes total</CODE></P>
      <P><CODE>16 1024-byte messages were placed on queue, 16384 bytes total</CODE></P>
      <P><CODE>8 2048-byte messages were placed on queue, 16384 bytes total</CODE></P>
      <P><CODE>4 4096-byte messages were placed on queue, 16384 bytes total</CODE></P>
      <P><CODE>2 8192-byte messages were placed on queue, 16384 bytes total</CODE></P>
      <P><CODE>63 identifiers at once</CODE></P>
      <P>Причина, по которой в Digital Unix 4.0В получился результат 63 идентификатора, а не 64, как в табл. 6.2, заключается в том, что один идентификатор всегда используется системным демоном.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label286 style="border:none;"></a>6.11.Резюме</P>
     </H1>
     <P>Очереди сообщений System V аналогичны очередям сообщений Posix. При создании новых приложений следует рассмотреть возможность использования очередей сообщений Posix, но большое количество существующих программ использует очереди сообщений System V. Тем не менее переписать их для использования очередей Posix вместо очередей System V не должно быть слишком сложно. Главный недостаток очередей Posix заключается в невозможности считывания сообщений с произвольным приоритетом. Ни один из типов очередей не использует обычные дескрипторы, что делает сложным применение функций select и poll для очередей сообщений.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label287 style="border:none;"></a>Упражнения</P>
     </H1>
     <P>1. Почему на рис. 6.2 для сообщений, передаваемых серверу, используется тип 1?</P>
     <P>2. Что произойдет с программой с рис. 6.2, если злоумышленник отправит на сервер множество сообщений, но не будет считывать ответы? Что в такой же ситуации произойдет с программой с рис. 6.3?</P>
     <P>3. Переделайте реализацию очередей сообщений Posix из раздела 5.8 для использования очередей сообщений System V вместо отображения в память. </P>
    </DIV>
   </DIV>
  </DIV>
  <DIV class=section>
   <H1>
    <P><a name=label288 style="border:none;"></a>ЧАСТЬ 3</P>
    <P>СИНХРОНИЗАЦИЯ</P>
   </H1>
   <DIV class=section>
    <H1>
     <P><a name=label289 style="border:none;"></a>ГЛАВА 7</P>
     <P>Взаимные исключения и условные переменные</P>
    </H1>
    <DIV class=section>
     <H1>
      <P><a name=label290 style="border:none;"></a>7.1. Введение</P>
     </H1>
     <P>Эта глава начинается с обсуждения синхронизации — принципов синхронизации действий нескольких программных потоков или процессов. Обычно это требуется для предоставления нескольким потокам или процессам совместного доступа к данным. Взаимные исключения (mutual exclusion — mutex) и условные переменные (conditional variables) являются основными средствами синхронизации.</P>
     <P>Взаимные исключения и условные переменные появились в стандарте Posix.1 для программных потоков, и всегда могут быть использованы для синхронизации отдельных потоков одного процесса. Стандарт Posix также разрешает использовать взаимное исключение или условную переменную и для синхронизации нескольких процессов, если это исключение или переменная хранится в области памяти, совместно используемой процессами.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Эта возможность является дополнительной согласно Posix, но обязательной в Unix 98 (см. табл. 1.3).</P>
     </DIV>
     <P>В этой главе мы разберем классическую схему производитель-потребитель, используя взаимные исключения и условные переменные. В примере будут использоваться программные потоки, а не процессы, поскольку предоставить потокам общий буфер данных, предполагаемый в этой задаче, легко, а вот создать буфер данных между процессами можно только с помощью одной из форм разделяемой памяти (которая будет описана только в четвертой части книги). Еще одно решение этой задачи, уже с использованием семафоров, появится в главе 10.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label291 style="border:none;"></a>7.2. Взаимные исключения: установка и снятие блокировки</P>
     </H1>
     <P>Взаимное исключение (mutex) является простейшей формой синхронизации. Оно используется для защиты критической области (critical region), предотвращая одновременное выполнение участка кода несколькими потоками (если взаимное исключение используется потоками) или процессами (если взаимное исключение используется несколькими процессами). Выглядит это обычно следующим образом:</P>
     <P><CODE>блокировать_mutex(…);</CODE></P>
     <P><CODE>критическая область</CODE></P>
     <P><CODE>разблокировать_mutex(…);</CODE></P>
     <P>Поскольку только один поток может заблокировать взаимное исключение в любой момент времени, это гарантирует, что только один поток будет выполнять код, относящийся к критической области.</P>
     <P>Взаимные исключения по стандарту Posix объявлены как переменные с типом pthread_mutex_t. Если переменная-исключение выделяется статически, ее можно инициализировать константой PTHREAD_MUTEX_INITIALIZER:</P>
     <P><CODE>static pthread_mutex_t lock=PTHREAD_MUTEX_INITIALIZER;</CODE></P>
     <P>При динамическом выделении памяти под взаимное исключение (например, вызовом mallос) или при помещении его в разделяемую память мы должны инициализировать эту переменную во время выполнения, вызвав функцию pthread_ mutex_init, как показано в разделе 7.7.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Вам может попасться код, в котором взаимные исключения не инициализируются, поскольку в реализации инициализирующая константа имеет значение 0, а статические переменные автоматически инициализируются этим значением. Однако такой код некорректен.</P>
     </DIV>
     <P>Следующие три функции используются для установки и снятия блокировки взаимного исключения:</P>
     <P><CODE>#include &lt;pthread.h&gt;</CODE></P>
     <P><CODE>int pthread_mutex_lock(pthread_mutex_t <EM>*mptr</EM>);</CODE></P>
     <P><CODE>int pthread_mutex_trylock(pthread_mutex_t <EM>*mptr</EM>);</CODE></P>
     <P><CODE>int pthread_mutex_unlock(pthread_mutex_t <EM>*mptr</EM>);</CODE></P>
     <P><CODE>/* Все три возвращают 0 в случае успешного завершения, положительное значение Еххх – случае ошибки */</CODE></P>
     <P>При попытке заблокировать взаимное исключение, которое уже заблокировано другим потоком, функция pthread_mutex_lock будет ожидать его разблокирования, a pthread_mutex_trylock (неблокируемая функция) вернет ошибку с кодом EBUSY.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Если несколько процессов ожидают освобождения взаимного исключения, какой из них начнет выполняться первым? Одна из возможностей, добавленных стандартом 1003.1b-1993, заключается в установке приоритета потоков. Мы не будем углубляться в эту область, отметим лишь, что разным потокам могут быть присвоены разные значения приоритета и функции синхронизации (работающие с взаимными исключениями, блокировками чтения-записи и семафорами) будут передавать управление заблокированному потоку с наивысшим значением приоритета. Раздел 5.5 книги [3] описывает возможности планирования выполнения в Posix.1 более подробно.</P>
     </DIV>
     <P>Хотя мы говорим о защите критической области кода программы, на самом деле речь идет о защите данных, с которыми работает эта часть кода. То есть взаимное исключение обычно используется для защиты совместно используемых несколькими потоками или процессами данных.</P>
     <P>Взаимные исключения представляют собой блокировку коллективного пользования. Это значит, что если совместно используемые данные представляют собой, например, связный список, то все потоки, работающие с этим списком, должны блокировать взаимное исключение. Ничто не может помешать потоку работать со списком, не заблокировав взаимное исключение. Взаимные исключения предполагают добровольное сотрудничество потоков.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label292 style="border:none;"></a>7.3. Схема производитель-потребитель</P>
     </H1>
     <P>Одна из классических задач на синхронизацию называется задачей производителя и потребителя. Она также известна как задача ограниченного буфера. Один или несколько производителей (потоков или процессов) создают данные, которые обрабатываются одним или несколькими потребителями. Эти данные передаются между производителями и потребителями с помощью одной из форм IPC.</P>
     <P>С этой задачей мы регулярно сталкиваемся при использовании каналов Unix. Команда интерпретатора, использующая канал</P>
     <P><CODE>grep pattern chapters.* | wc -l</CODE></P>
     <P>является примером такой задачи. Программа grep выступает как производитель (единственный), a wc — как потребитель (тоже единственный). Канал используется как форма IPC. Требуемая синхронизация между производителем и потребителем обеспечивается ядром, обрабатывающим команды write производителя и read покупателя. Если производитель опережает потребителя (канал переполняется), ядро приостанавливает производителя при вызове write, пока в канале не появится место. Если потребитель опережает производителя (канал опустошается), ядро приостанавливает потребителя при вызове read, пока в канале не появятся данные.</P>
     <P>Такой тип синхронизации называется неявным; производитель и потребитель не знают о том, что синхронизация вообще осуществляется. Если бы мы использовали очередь сообщений Posix или System V в качестве средства IPC между производителем и потребителем, ядро снова взяло бы на себя обеспечение синхронизации.</P>
     <P>При использовании разделяемой памяти как средства IPC производителя и потребителя, однако, требуется использование какого-либо вида явной синхронизации. Мы продемонстрируем это на использовании взаимного исключения. Схема рассматриваемого примера изображена на рис. 7.1.</P>
     <P>В одном процессе у нас имеется несколько потоков-производителей и один поток-потребитель. Целочисленный массив buff содержит производимые и потребляемые данные (данные совместного пользования). Для простоты производители просто устанавливают значение buff[0] в 0, buff [1] в 1 и т.д. Потребитель перебирает элементы массива, проверяя правильность записей.</P>
     <P>В этом первом примере мы концентрируем внимание на синхронизации между отдельными потоками-производителями. Поток-потребитель не будет запущен, пока все производители не завершат свою работу. В листинге 7.1 приведена функция main нашего примера.</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader137" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 7.1. Производители и потребитель</P>
     <BR>
     <H2><a name=label293 style="border:none;"></a>Листинг 7.1.<A HREF="#n_1" onmouseover="ShowBookNote('n_1')" onmouseout="HideBookNote('n_1')"><SUP>[1]</SUP></A> Функция main</H2>
     <P><CODE>//mutex/prodcons2.с</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #define MAXNITEMS 1000000</CODE></P>
     <P><CODE>3  #define MAXNTHREADS 100</CODE></P>
     <P><CODE>4  int nitems; /* только для чтения потребителем и производителем */</CODE></P>
     <BR>
     <P><CODE>5  struct {</CODE></P>
     <P><CODE>6   pthread_mutex_t mutex;</CODE></P>
     <P><CODE>7   int buff[MAXNITEMS];</CODE></P>
     <P><CODE>8   int nput;</CODE></P>
     <P><CODE>9   int nval;</CODE></P>
     <P><CODE>10 } shared = {</CODE></P>
     <P><CODE>11  PTHREAD_MUTEX_INITIALIZER</CODE></P>
     <P><CODE>12 };</CODE></P>
     <BR>
     <P><CODE>13 void *produce(void *), *consume(void *);</CODE></P>
     <BR>
     <P><CODE>14 int</CODE></P>
     <P><CODE>15 main(int argc, char **argv)</CODE></P>
     <P><CODE>16 {</CODE></P>
     <P><CODE>17  int i, nthreads, count[MAXNTHREADS];</CODE></P>
     <P><CODE>18  pthread_t tid_produce[MAXNTHREADS], tid_consume;</CODE></P>
     <P><CODE>19  if (argc != 3)</CODE></P>
     <P><CODE>20   err_quit("usage: prodcons2 &lt;#items&gt; &lt;#threads&gt;");</CODE></P>
     <P><CODE>21  nitems = min(atoi(argv[1]), MAXNITEMS);</CODE></P>
     <P><CODE>22  nthreads = min(atoi(argv[2]), MAXNTHREADS);</CODE></P>
     <P><CODE>23  Set_concurrency(nthreads);</CODE></P>
     <P><CODE>24  /* запуск всех потоков-производителей */</CODE></P>
     <P><CODE>25  for (i = 0; i &lt; nthreads; i++) {</CODE></P>
     <P><CODE>26   count[i] = 0;</CODE></P>
     <P><CODE>27   Pthread_create(&amp;tid_produce[i], NULL, produce, &amp;count[i]);</CODE></P>
     <P><CODE>28  }</CODE></P>
     <P><CODE>29  /* ожидание завершения всех производителей */</CODE></P>
     <P><CODE>30  for (i = 0; i &lt; nthreads; i++) {</CODE></P>
     <P><CODE>31   Pthread_join(tid_produce[i], NULL);</CODE></P>
     <P><CODE>32   printf("count[%d] = %d\n", i, count[i]);</CODE></P>
     <P><CODE>33  }</CODE></P>
     <P><CODE>34  /* запуск и ожидание завершения потока-потребителя */</CODE></P>
     <P><CODE>35  Pthread_create(&amp;tid_consume, NULL, consume, NULL);</CODE></P>
     <P><CODE>36  Pthread_join(tid_consume, NULL);</CODE></P>
     <P><CODE>37  exit(0);</CODE></P>
     <P><CODE>38 }</CODE></P>
     <H2><a name=label294 style="border:none;"></a>Совместное использование глобальных переменных потоками</H2>
     <P>4-12 Эти переменные совместно используются потоками. Мы объединяем их в структуру с именем shared вместе с взаимным исключением, чтобы подчеркнуть, что доступ к ним можно получить только вместе с ним. Переменная nput хранит индекс следующего элемента массива buff, подлежащего обработке, a nval содержит следующее значение, которое должно быть в него помещено (0, 1, 2 и т.д.). Мы выделяем память под эту структуру и инициализируем взаимное исключение, используемое для синхронизации потоков-производителей.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Мы всегда будем стараться размещать совместно используемые данные вместе со средствами синхронизации, к ним относящимися (взаимными исключениями, условными переменными, семафорами), в одной структуре, как мы сделали в этом примере. Это хороший стиль программирования. Однако во многих случаях совместно используемые данные являются динамическими, представляя собой, например, связный список. Мы, наверное, сможем поместить в структуру первый элемент списка вместе со средствами синхронизации (как в структуре mq_hdr в листинге 5.16), но оставшаяся часть списка в структуру не попадет. Следовательно, это решение не всегда является идеальным.</P>
     </DIV>
     <H2><a name=label295 style="border:none;"></a>Аргументы командной строки</H2>
     <P>19-22 Первый аргумент командной строки указывает количество элементов, которые будут произведены производителями, а второй — количество запускаемых потоков-производителей.</P>
     <H2><a name=label296 style="border:none;"></a>Установка уровня параллельности</H2>
     <P>23 Функция set_concurrency (наша собственная) указывает подсистеме потоков количество одновременно выполняемых потоков. В Solaris 2.6 она просто вызывает thr_setconcurrency, причем ее запуск необходим, если мы хотим, чтобы у нескольких процессов-производителей была возможность начать выполняться. Если мы не сделаем этого вызова в системе Solaris, будет запущен только первый поток. В Digital Unix 4.0B наша функция set_concurrency не делает ничего, поскольку в этой системе по умолчанию все потоки процесса имеют равные права на вычислительные ресурсы.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Unix 98 требует наличия функции pthread_setconcurrency, выполняющей это же действие. Эта функция требуется для тех реализаций, которые мультиплексируют пользовательские потоки (создаваемые функцией pthread_create) на небольшое множество выполняемых потоков ядра. Такие реализации часто называются «многие-к-немногим» (many-to-few), «двухуровневые» (two-level) или «М-на-N» (M-to-N). В разделе 5.6 книги [3] отношения между пользовательскими потоками и потоками ядра рассматриваются более подробно.</P>
     </DIV>
     <H2><a name=label297 style="border:none;"></a>Создание процессов-производителей</H2>
     <P>24-28 Создаются потоки-производители, каждый из которых вызывает функцию produce. Идентификаторы потоков хранятся в массиве tid_produce. Аргументом каждого потока-производителя является указатель на элемент массива count. Счетчики инициализируются значением 0, и каждый поток увеличивает значение своего счетчика на 1 при помещении очередного элемента в буфер. Содержимое массива счетчиков затем выводится на экран, так что мы можем узнать, сколько элементов было помещено в буфер каждым из потоков.</P>
     <H2><a name=label298 style="border:none;"></a>Ожидание завершения работы производителей, запуск потребителя</H2>
     <P>29-36 Мы ожидаем завершения работы всех потоков-производителей, выводя содержимое счетчика для каждого потока, а затем запускаем единственный процесс-потребитель. Таким образом (на данный момент) мы исключаем необходимость синхронизации между потребителем и производителями. Мы ждем завершения работы потребителя, а затем завершаем работу процесса. В листинге 7.2 приведен текст функций produce и consume.</P>
     <H2><a name=label299 style="border:none;"></a>Листинг 7.2. Функции produce и consume</H2>
     <P><CODE>//mutex/prodcons2.с</CODE></P>
     <P><CODE>39 void *</CODE></P>
     <P><CODE>40 produce(void *arg)</CODE></P>
     <P><CODE>41 {</CODE></P>
     <P><CODE>42  for (;;) {</CODE></P>
     <P><CODE>43   Pthread_mutex_lock(&amp;shared.mutex);</CODE></P>
     <P><CODE>44   if (shared.nput &gt;= nitems) {</CODE></P>
     <P><CODE>45    Pthread_mutex_unlock(&amp;shared.mutex);</CODE></P>
     <P><CODE>46    return(NULL); /* массив полный, готово */</CODE></P>
     <P><CODE>47   }</CODE></P>
     <P><CODE>48   shared.buff[shared.nput] = shared.nval;</CODE></P>
     <P><CODE>49   shared.nput++;</CODE></P>
     <P><CODE>50   shared.nval++;</CODE></P>
     <P><CODE>51   Pthread_mutex_unlock(&amp;shared.mutex);</CODE></P>
     <P><CODE>52   *((int *) arg) += 1;</CODE></P>
     <P><CODE>53  }</CODE></P>
     <P><CODE>54 }</CODE></P>
     <BR>
     <P><CODE>55 void *</CODE></P>
     <P><CODE>56 consume(void *arg)</CODE></P>
     <P><CODE>57 {</CODE></P>
     <P><CODE>58  int i;</CODE></P>
     <P><CODE>59  for (i = 0; i &lt; nitems; i++) {</CODE></P>
     <P><CODE>60   if (shared.buff[i] != i)</CODE></P>
     <P><CODE>61    printf("buff[%d] = %d\n", i, shared.buff[i]);</CODE></P>
     <P><CODE>62  }</CODE></P>
     <P><CODE>63  return(NULL);</CODE></P>
     <P><CODE>64 }</CODE></P>
     <H2><a name=label300 style="border:none;"></a>Формирование данных</H2>
     <P>42-53 Критическая область кода производителя состоит из проверки на достижение конца массива (завершение работы)</P>
     <P><CODE>if (shared.nput &gt;= nitems)</CODE></P>
     <P>и трех строк, помещающих очередное значение в массив:</P>
     <P><CODE>shared.buff[shared.nput] = shared.nval;</CODE></P>
     <P><CODE>shared.nput++;</CODE></P>
     <P><CODE>shared.nval++;</CODE></P>
     <P>Мы защищаем эту область с помощью взаимного исключения, не забыв разблокировать его после завершения работы. Обратите внимание, что увеличение элемента count (через указатель arg) не относится к критической области, поскольку у каждого потока счетчик свой (массив count в функции main). Поэтому мы не включаем эту строку в блокируемую взаимным исключением область. Один из принципов хорошего стиля программирования заключается в минимизации объема кода, защищаемого взаимным исключением.</P>
     <H2><a name=label301 style="border:none;"></a>Потребитель проверяет содержимое массива</H2>
     <P>59-62 Потребитель проверяет правильность значений всех элементов массива и выводит сообщение в случае обнаружения ошибки. Как уже говорилось, эта функция запускается в единственном экземпляре и только после того, как все потоки-производители завершат свою работу, так что надобность в синхронизации отсутствует.</P>
     <P>При запуске только что описанной программы с пятью процессами-производителями, которые должны вместе создать один миллион элементов данных, мы получим следующий результат:</P>
     <P><CODE>solaris % <STRONG>prodcons2 1000000 5</STRONG></CODE></P>
     <P><CODE>count[0] = 167165</CODE></P>
     <P><CODE>count[1] = 249891</CODE></P>
     <P><CODE>count[2] = 194221</CODE></P>
     <P><CODE>count[3] = 191815</CODE></P>
     <P><CODE>count[4] = 196908</CODE></P>
     <P>Как мы отмечали ранее, если убрать вызов set_concurrency, в системе Solaris 2.6 значение count[0] будет 1000000, а все остальные счетчики будут нулевыми.</P>
     <P>Если убрать из этого примера блокировку с помощью взаимного исключения, он перестанет работать, как и предполагается. Потребитель обнаружит множество элементов buff[i], значения которых будут отличны от i. Также мы можем убедиться, что удаление блокировки ничего не изменит, если будет выполняться только один поток.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label302 style="border:none;"></a>7.4. Блокировка и ожидание</P>
     </H1>
     <P>Продемонстрируем теперь, что взаимные исключения предназначены для блокирования, но не для ожидания. Изменим наш пример из предыдущего раздела таким образом, чтобы потребитель запускался сразу же после запуска всех производителей. Это даст возможность потребителю обрабатывать данные по мере их формирования производителями в отличие от пpoгрaммы в листинге 7.1, в которой потребитель не запускался до тех пор, пока все производители не завершали свою работу. Теперь нам придется синхронизовать потребителя с производителями, чтобы первый обрабатывал только данные, уже сформированные последними.</P>
     <P>В листинге 7.3 приведен текст функции main. Начало кода (до объявления функции main) не претерпело никаких изменений по сравнению с листингом 7.1.</P>
     <H2><a name=label303 style="border:none;"></a>Листинг 7.3. Функция main: запуск потребителя сразу после запуска производителей</H2>
     <P><CODE>//mutex/prodcons3.c</CODE></P>
     <P><CODE>14 int</CODE></P>
     <P><CODE>15 main(int argc, char **argv)</CODE></P>
     <P><CODE>16 {</CODE></P>
     <P><CODE>17  int i, nthreads, count[MAXNTHREADS];</CODE></P>
     <P><CODE>18  pthread_t tid_produce[MAXNTHREADS], tid_consume;</CODE></P>
     <P><CODE>19  if (argc != 3)</CODE></P>
     <P><CODE>20   err_quit("usage: prodcons3 &lt;#items&gt; &lt;#threads&gt;");</CODE></P>
     <P><CODE>21  nitems = min(atoi(argv[1]), MAXNITEMS);</CODE></P>
     <P><CODE>22  nthreads = min(atoi(argv[2]), MAXNTHREADS);</CODE></P>
     <P><CODE>23  /* создание всех производителей и одного потребителя */</CODE></P>
     <P><CODE>24  Set_concurrency(nthreads + 1);</CODE></P>
     <P><CODE>25  for (i = 0; i &lt; nthreads; i++) {</CODE></P>
     <P><CODE>26   count[i] = 0;</CODE></P>
     <P><CODE>27   Pthread_create(&amp;tid_produce[i], NULL, produce, &amp;count[i]);</CODE></P>
     <P><CODE>28  }</CODE></P>
     <P><CODE>29  Pthread_create(&amp;tid_consume, NULL, consume, NULL);</CODE></P>
     <P><CODE>30  /* ожидание завершения производителей и потребителя */</CODE></P>
     <P><CODE>31  for (i = 0; i &lt; nthreads; i++) {</CODE></P>
     <P><CODE>32   Pthread_join(tid_produce[i], NULL);</CODE></P>
     <P><CODE>33   printf("count[%d] = %d\n", i, count[i]);</CODE></P>
     <P><CODE>34  }</CODE></P>
     <P><CODE>35  Pthread_join(tid_consume, NULL);</CODE></P>
     <P><CODE>36  exit(0);</CODE></P>
     <P><CODE>37 }</CODE></P>
     <P>24 Мы увеличиваем уровень параллельного выполнения на единицу, чтобы учесть поток-потребитель, выполняемый параллельно с производителями.</P>
     <P>25-29 Поток-потребитель создается сразу же после создания потоков-производителей.</P>
     <P>Функция produce по сравнению с листингом 7.2 не изменяется. В листинге 7.4 приведен текст функции consume, вызывающей новую функцию consume_wait. </P>
     <H2><a name=label304 style="border:none;"></a>Листинг 7.4. Функции consume и consume_wait</H2>
     <P><CODE>//mutex/prodcons3.с</CODE></P>
     <P><CODE>54 void</CODE></P>
     <P><CODE>55 consume wait(int i)</CODE></P>
     <P><CODE>56 {</CODE></P>
     <P><CODE>57  for (;;) {</CODE></P>
     <P><CODE>58   Pthread_mutex_lock(&amp;shared.mutex);</CODE></P>
     <P><CODE>59   if (i &lt; shared.nput) {</CODE></P>
     <P><CODE>60    Pthread_mutex_unlock(&amp;shared.mutex);</CODE></P>
     <P><CODE>61    return; /* элемент готов */</CODE></P>
     <P><CODE>62   }</CODE></P>
     <P><CODE>63   Pthread_mutex_unlock(&amp;shared.mutex);</CODE></P>
     <P><CODE>64  }</CODE></P>
     <P><CODE>65 }</CODE></P>
     <BR>
     <P><CODE>66 void *</CODE></P>
     <P><CODE>67 consume(void *arg)</CODE></P>
     <P><CODE>68 {</CODE></P>
     <P><CODE>69  int i;</CODE></P>
     <P><CODE>70  for (i = 0; i &lt; nitems; i++) {</CODE></P>
     <P><CODE>71   consume_wait(i);</CODE></P>
     <P><CODE>72   if (shared.buff[i] != i)</CODE></P>
     <P><CODE>73    printf("buff[%d] = %d\n", i, shared.buff[i]);</CODE></P>
     <P><CODE>74  }</CODE></P>
     <P><CODE>75  return(NULL);</CODE></P>
     <P><CODE>76 }</CODE></P>
     <H2><a name=label305 style="border:none;"></a>Потребитель должен ждать</H2>
     <P>71 Единственное изменение в функции consume заключается в добавлении вызова consume_wait перед обработкой следующего элемента массива.</P>
     <H2><a name=label306 style="border:none;"></a>Ожидание производителей</H2>
     <P>57-64 Наша функция consume_wait должна ждать, пока производители не создадут i-й элемент. Для проверки этого условия производится блокировка взаимного исключения и значение i сравнивается с индексом производителя nput. Блокировка необходима, поскольку значение nput может быть изменено одним из производителей в момент его проверки.</P>
     <P>Главная проблема — что делать, если нужный элемент еще не готов. Все, что нам остается и что мы делаем в листинге 7.4, — это повторять операции в цикле, устанавливая и снимая блокировку и проверяя значение индекса. Это называется опросом (spinning или polling) и является лишней тратой времени процессора.</P>
     <P>Мы могли бы приостановить выполнение процесса на некоторое время, но мы не знаем, на какое. Что нам действительно нужно — это использовать какое-то другое средство синхронизации, позволяющее потоку или процессу приостанавливать работу, пока не произойдет какое-либо событие.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label307 style="border:none;"></a>7.5. Условные переменные: ожидание и сигнализация</P>
     </H1>
     <DIV class=section>
      <P>Взаимное исключение используется для блокирования, а условная переменная — для ожидания. Это два различных средства синхронизации, и оба они нужны. Условная переменная представляет собой переменную типа pthread_cond_t. Для работы с такими переменными предназначены две функции:</P>
      <P><CODE>#include &lt;pthread.h&gt;</CODE></P>
      <P><CODE>int pthread_cond_wait(pthread_cond_t <EM>*cptr,</EM> pthread_m_tex_t <EM>*mptr</EM>);</CODE></P>
      <P><CODE>int pthread_cond_signal(pthread_cond_t <EM>*cptr</EM>);</CODE></P>
      <P><CODE>/* Обе функции возвращают 0 в случае успешного завершения, положительное значение Еххх – в случае ошибки */</CODE></P>
      <P>Слово signal в имени второй функции не имеет никакого отношения к сигналам Unix SIGxxx.</P>
      <P>Мы определяем условие, уведомления о выполнении которого будем ожидать.</P>
      <P>Взаимное исключение всегда связывается с условной переменной. При вызове pthread_cond_wait для ожидания выполнения какого-либо условия мы указываем адрес условной переменной и адрес связанного с ней взаимного исключения.</P>
      <P>Мы проиллюстрируем использование условных переменных, переписав пример из предыдущего раздела. В листинге 7.5 объявляются глобальные переменные.</P>
      <H2><a name=label308 style="border:none;"></a>Переменные производителя и взаимное исключение объединяются в структуру</H2>
      <P>7-13 Две переменные nput и rival ассоциируются с mutex, и мы объединяем их в структуру с именем put. Эта структура используется производителями.</P>
      <P>14-20 Другая структура, nready, содержит счетчик, условную переменную и взаимное исключение. Мы инициализируем условную переменную с помощью PTHREAD_ COND_INITIALIZER.</P>
      <P>Функция main по сравнению с листингом 7.3 не изменяется.</P>
      <H2><a name=label309 style="border:none;"></a>Листинг 7.5. Глобальные переменные: использование условной переменной</H2>
      <P><CODE>//mutex/prodcons6.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #define MAXNITEMS 1000000</CODE></P>
      <P><CODE>3  #define MAXNTHREADS 100</CODE></P>
      <BR>
      <P><CODE>4  /* глобальные переменные для всех потоков */</CODE></P>
      <P><CODE>5  int nitems; /* только для чтения потребителем и производителем */</CODE></P>
      <P><CODE>6  int buff[MAXNITEMS];</CODE></P>
      <BR>
      <P><CODE>7  struct {</CODE></P>
      <P><CODE>8   pthread_mutex_t mutex;</CODE></P>
      <P><CODE>9   int nput; /* следующий сохраняемый элемент */</CODE></P>
      <P><CODE>10  int nval; /* следующее сохраняемое значение */</CODE></P>
      <P><CODE>11 } put = {</CODE></P>
      <P><CODE>12  PTHREAD_MUTEX_INITIALIZER</CODE></P>
      <P><CODE>13 };</CODE></P>
      <BR>
      <P><CODE>14 struct {</CODE></P>
      <P><CODE>15  pthread_mutex_t mutex:</CODE></P>
      <P><CODE>16  pthread_cond_t cond;</CODE></P>
      <P><CODE>17  int nready; /* количество готовых для потребителя */</CODE></P>
      <P><CODE>18 } nready = {</CODE></P>
      <P><CODE>19  PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER</CODE></P>
      <P><CODE>20 };</CODE></P>
      <P>Функции produce и consume претерпевают некоторые изменения. Их текст дан в листинге 7.6.</P>
      <H2><a name=label310 style="border:none;"></a>Листинг 7.6. Функции produce и consume</H2>
      <P><CODE>//mutex/prodcons6.c</CODE></P>
      <P><CODE>46 void *</CODE></P>
      <P><CODE>47 produce(void *arg)</CODE></P>
      <P><CODE>48 {</CODE></P>
      <P><CODE>49  for (;;) {</CODE></P>
      <P><CODE>50   Pthread_mutex_lock(&amp;put.mutex);</CODE></P>
      <P><CODE>51   if (put.nput &gt;= nitems) {</CODE></P>
      <P><CODE>52    Pthread_mutex_unlock(&amp;put.mutex);</CODE></P>
      <P><CODE>53    return(NULL); /* массив заполнен, готово */</CODE></P>
      <P><CODE>54   }</CODE></P>
      <P><CODE>55   buff[put.nput] = put.nval;</CODE></P>
      <P><CODE>56   put.nput++;</CODE></P>
      <P><CODE>57   put.nval++;</CODE></P>
      <P><CODE>58   Pthread_mutex_unlock(&amp;put.mutex);</CODE></P>
      <P><CODE>59   Pthread_mutex_lock(&amp;nready.mutex):</CODE></P>
      <P><CODE>60   if (nready.nready == 0)</CODE></P>
      <P><CODE>61    Pthread_cond_signal(&amp;nready.cond);</CODE></P>
      <P><CODE>62   nready.nready++;</CODE></P>
      <P><CODE>63   Pthread_mutex_unlock(&amp;nready.mutex);</CODE></P>
      <P><CODE>64   *((int *) arg) += 1;</CODE></P>
      <P><CODE>65  }</CODE></P>
      <P><CODE>66 }</CODE></P>
      <BR>
      <P><CODE>67 void*</CODE></P>
      <P><CODE>68 consume(void *arg)</CODE></P>
      <P><CODE>69 {</CODE></P>
      <P><CODE>70  int i;</CODE></P>
      <P><CODE>71  for (i = 0; i &lt; nitems; i++) {</CODE></P>
      <P><CODE>72   Pthread_mutex_lock(&amp;nready.mutex);</CODE></P>
      <P><CODE>73   while (nready.nready == 0)</CODE></P>
      <P><CODE>74    Pthread_cond_wait(&amp;nready.cond, &amp;nready.mutex);</CODE></P>
      <P><CODE>75   nready.nready--;</CODE></P>
      <P><CODE>76   Pthread_mutex_unlock(&amp;nready.mutex);</CODE></P>
      <P><CODE>77   if (buff[i] != i)</CODE></P>
      <P><CODE>78    printf("buff[%d] = *d\n", i, buff[i]);</CODE></P>
      <P><CODE>79  }</CODE></P>
      <P><CODE>80  return(NULL);</CODE></P>
      <P><CODE>81 }</CODE></P>
      <H2><a name=label311 style="border:none;"></a>Помещение очередного элемента в массив</H2>
      <P>50-58 Для блокирования критической области в потоке-производителе теперь используется исключение put.mutex. </P>
      <H2><a name=label312 style="border:none;"></a>Уведомление потребителя</H2>
      <P>59-64 Мы увеличиваем счетчик nready.nready, в котором хранится количество элементов, готовых для обработки потребителем. Перед его увеличением мы проверяем, не было ли значение счетчика нулевым, и если да, то вызывается функция pthread_cond_signal, позволяющая возобновить выполнение всех потоков (в данном случае потребителя), ожидающих установки ненулевого значения этой переменной. Теперь мы видим, как взаимодействуют взаимное исключение и связанная с ним условная переменная. Счетчик используется совместно потребителем и производителями, поэтому доступ к нему осуществляется с блокировкой соответствующего взаимного исключения (nready.mutex). Условная переменная используется для ожидания и передачи сигнала.</P>
      <H2><a name=label313 style="border:none;"></a>Потребитель ждет, пока значение nready.nready не станет отличным от нуля</H2>
      <P>72-76 Потребитель просто ждет, пока значение счетчика nready. nready не станет отличным от нуля. Поскольку этот счетчик используется совместно с производителями, его значение можно проверять только при блокировке соответствующего взаимного исключения. Если при проверке значение оказывается нулевым, мы вызываем pthread_cond_wait для приостановки процесса. При этом выполняются два атомарных действия:</P>
      <P>1. Разблокируется nready.mutex.</P>
      <P>2. Выполнение потока приостанавливается, пока какой-нибудь другой поток не вызовет pthread_cond_signal для этой условной переменной.</P>
      <P>Перед возвращением управления потоку функция pthread_cond_wait блокирует nready.mutex. Таким образом, если после возвращения из функции мы обнаруживаем, что счетчик имеет ненулевое значение, мы уменьшаем этот счетчик (зная, что взаимное исключение заблокировано) и разблокируем взаимное исключение. Обратите внимание, что после возвращения из pthread_cond_wait мы всегда заново проверяем условие, поскольку может произойти ложное пробуждение при отсутствии выполнения условия. Различные реализации стремятся уменьшить количество ложных пробуждений, но они все равно происходят.</P>
      <P>Код, передающий сигнал условной переменной, выглядит следующим образом:</P>
      <P><CODE>struct {</CODE></P>
      <P><CODE> pthread_mutex_t mutex;</CODE></P>
      <P><CODE> pthread_cond_t cond;</CODE></P>
      <P><CODE> переменные, для которых устанавливается условие</CODE></P>
      <P><CODE>} var = { PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, … };</CODE></P>
      <BR>
      <P><CODE>Pthread_mutex_lock(&amp;var.mutex);</CODE></P>
      <P><CODE>установка истинного значения условия</CODE></P>
      <P><CODE>Pthread_cond_signal(&amp;var.cond);</CODE></P>
      <P><CODE>Pthread_mutex_unlock(&amp;var.mutex);</CODE></P>
      <P>В нашем примере переменная, для которой устанавливалось условие, представляла собой целочисленный счетчик, а установка условия означала просто увеличение счетчика. Мы оптимизировали программу, посылая сигнал только при изменении значения счетчика с 0 на 1.</P>
      <P>Код, проверяющий условие и приостанавливающий процесс, если оно не выполняется, обычно выглядит следующим образом:</P>
      <P><CODE>Pthread_mutex_lock(&amp;var.mutex);</CODE></P>
      <P><CODE>while (условие ложно)</CODE></P>
      <P><CODE> Pthread_cond_wait(&amp;var.cond, &amp;var.mutex);</CODE></P>
      <P><CODE>изменение условия</CODE></P>
      <P><CODE>Pthread_mutex_unlock(&amp;var.mutex);</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label314 style="border:none;"></a>Исключение конфликтов блокировок</P>
      </H1>
      <P>В приведенном выше фрагменте кода, как и в листинге 7.6, функция pthread_cond_signal вызывалась потоком, блокировавшим взаимное исключение, относящееся к условной переменной, для которой отправлялся сигнал. Мы можем представить себе, что в худшем варианте система немедленно передаст управление потоку, которому направляется сигнал, и он начнет выполняться и немедленно остановится, поскольку не сможет заблокировать взаимное исключение. Альтернативный код, помогающий этого избежать, для листинга 7.6 будет иметь следующий вид:</P>
      <P><CODE>int dosignal;</CODE></P>
      <P><CODE>Pthread_mutex_lock(nready.mutex);</CODE></P>
      <P><CODE>dosignal = (nready.nready == 0);</CODE></P>
      <P><CODE>nready.nready++;</CODE></P>
      <P><CODE>Pthread_mutex_unlock(&amp;nready.mutex);</CODE></P>
      <P><CODE>if (dosignal)</CODE></P>
      <P><CODE> Pthread_cond_signal(&amp;nready.cond);</CODE></P>
      <P>Здесь мы отправляем сигнал условной переменной только после разблокирования взаимного исключения. Это разрешено стандартом Posix: поток, вызывающий pthread_cond_signal, не обязательно должен в этот момент блокировать связанное с переменной взаимное исключение. Однако Posix говорит, что если требуется предсказуемое поведение при одновременном выполнении потоков, это взаимное исключение должно быть заблокировано процессом, вызывающим pthread_cond_signal.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label315 style="border:none;"></a>7.6. Условные переменные: время ожидания и широковещательная передача</P>
     </H1>
     <P>В обычной ситуации pthread_cond_signal запускает выполнение одного потока, ожидающего сигнал по соответствующей условной переменной. В некоторых случаях поток знает, что требуется пробудить несколько других процессов. Тогда можно воспользоваться функцией pthread_cond_broadcast для пробуждения всех процессов, заблокированных в ожидании сигнала данной условной переменной.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Пример ситуации, в которой требуется возобновление выполнения нескольких процессов, появится в главе 8, когда мы будем обсуждать задачу с несколькими считывающими и записывающими процессами. Когда записывающий процесс снимает блокировку, он должен разбудить все ждущие считывающие процессы, поскольку одновременное считывание в данном случае разрешено.</P>
      <P>Альтернативным (и более безопасным) методом является использование широковещательной передачи во всех тех случаях, когда требуется использование сигналов. Сигнал является оптимизацией для тех случаев, когда известно, что все ожидающие процессы правильно написаны и требуется разбудить только один из них, и какой именно будет разбужен, значения не имеет. Во всех других ситуациях следует использовать широковещательную передачу. </P>
     </DIV>
     <P><CODE>#include &lt;pthread.h&gt;</CODE></P>
     <P><CODE>int pthread_cond_broadcast(pthread_cond_t <EM>*cptr</EM>);</CODE></P>
     <P><CODE>int pthread_cond_timedwait(pthread_cond_t <EM>*cptr,</EM> pthread_mutex_t <EM>*mptr,</EM> const struct timespec <EM>*abstime</EM>);</CODE></P>
     <P><CODE>/* Функции возвращают 0 в случае успешного завершения, положительный код Еххх — в случае ошибки */</CODE></P>
     <P>Функция pthread_cond_timedwait позволяет установить ограничение на время блокирования процесса. Аргумент <EM>abstime</EM> представляет собой структуру timespec:</P>
     <P><CODE>struct timespec {</CODE></P>
     <P><CODE> time_t tv_sec; /* секунды */</CODE></P>
     <P><CODE> long tv_nsec; /* наносекунды */</CODE></P>
     <P><CODE>};</CODE></P>
     <P>Эта структура задает конкретный момент системного времени, в который происходит возврат из функции, даже если сигнал по условной переменной еще не будет получен. В этом случае возвращается ошибка с кодом ETIMEDOUT.</P>
     <P>Эта величина представляет собой абсолютное значение времени, а не промежуток. Аргумент <EM>abstime</EM> задает таким образом количество секунд и наносекунд с 1 января 1970 UTC до того момента времени, в который должен произойти возврат из функции. Это отличает функцию от select, pselect и poll (глава 6 [24]), которые в качестве аргумента принимают некоторое количество долей секунды, спустя которое должен произойти возврат. (Функция select принимает количество микросекунд, pselect — наносекунд, a poll — миллисекунд.) Преимущество использования абсолютного времени заключается в том, что если функция возвратится до ожидаемого момента (например, при перехвате сигнала), ее можно будет вызвать еще раз, не изменяя содержимого структуры timespec.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label316 style="border:none;"></a>7.7. Атрибуты взаимных исключений и условных переменных</P>
     </H1>
     <DIV class=section>
      <P>В наших примерах в этой главе мы хранили взаимные исключения и условные переменные как глобальные данные всего процесса, поскольку они использовались для синхронизации потоков внутри него. Инициализировали мы их с помощью двух констант: PTHREAD_MUTEX_INITIALIZER и PTHREAD_COND_INTIALIZER. Инициализируемые таким образом исключения и условные переменные приобретали значения атрибутов по умолчанию, но мы можем инициализировать их и с другими значениями атрибутов.</P>
      <P>Прежде всего инициализировать и удалять взаимное исключение и условную переменную можно с помощью функций</P>
      <P><CODE>#include &lt;pthread.h&gt;</CODE></P>
      <P><CODE>int pthread_mutex_imt(pthread_mutex_t *<EM>mptr</EM>, const pthread_mutexattr_t *<EM>attr</EM>);</CODE></P>
      <P><CODE>int pthread_mutex_destroy(pthread_mutex_t *<EM>mptr</EM>);</CODE></P>
      <P><CODE>int pthread_cond_init(pthread_cond_t *<EM>cрtr</EM>, const pthread_condattr_t *<EM>attr</EM>);</CODE></P>
      <P><CODE>int pthread_cond_destroy(pthread_cond_t *<EM>cptr</EM>);</CODE></P>
      <P><CODE>/* Все четыре функции возвращают 0 в случае успешного завершения работы, положительное значение Еххх – в случае ошибки */</CODE></P>
      <P>Рассмотрим, например, взаимное исключение. Аргумент mptr должен указывать на переменную типа pthread_mutex_t, для которой должна быть уже выделена память, и тогда функция pthread_mutex_init инициализирует это взаимное исключение. Значение типа pthread_mutexattr_t, на которое указывает второй аргумент функции pthread_mutex_init(<EM>attr</EM> ), задает атрибуты этого исключения. Если этот аргумент представляет собой нулевой указатель, используются значения атрибутов по умолчанию.</P>
      <P>Атрибуты взаимного исключения имеют тип pthread_mutexattr_t, а условной переменной — pthread_condattr_t, и инициализируются и уничтожаются с помощью следующих функций:</P>
      <P><CODE>#include &lt;pthread.h&gt;</CODE></P>
      <P><CODE>int pthread_mutexattr_init(pthread_mutexattr_t *<EM>attr</EM>);</CODE></P>
      <P><CODE>int pthread_mutexattr_destroy(pthread_mutexattr_t *<EM>attr</EM>);</CODE></P>
      <P><CODE>int pthread_condattr_init(pthread_condattr_t *<EM>attr</EM>);</CODE></P>
      <P><CODE>int pthread_condattr_destroy(pthread_condattr_t *<EM>attr</EM>);</CODE></P>
      <P><CODE>/* Все четыре функции возвращают 0 в случае успешного завершения, положительное значение Еххх – в случае ошибки */</CODE></P>
      <P>После инициализации атрибутов взаимного исключения или условной переменной для включения или выключения отдельных атрибутов используются отдельные функции. Например, один из атрибутов позволяет использовать данное взаимное исключение или условную переменную нескольким процессам (а не потокам одного процесса). Этот атрибут мы будем использовать в последующих главах. Его значение можно узнать и изменить с помощью следующих функций:</P>
      <P><CODE>#include &lt;pthread.h&gt;</CODE></P>
      <P><CODE>int pthread_mutexattr_getpshared(const pthread_mutexattr_t *attr, int *<EM>valptr</EM>);</CODE></P>
      <P><CODE>int pthread_mutexattr_setpshared(pthread_mutexattr_t *<EM>attr,</EM> int <EM>value</EM>);</CODE></P>
      <P><CODE>int pthread_condattr_getpshared(const pthread_condattr_t *<EM>attr</EM>, int *<EM>valptr</EM>);</CODE></P>
      <P><CODE>int pthread_condattr_setpshared(pthread_condattr_t *<EM>attr,</EM> int <EM>value</EM>);</CODE></P>
      <P><CODE>/* Все четыре функции возвращают 0 в случае успешного завершения, положительное значение Еххх – в случае ошибки */</CODE></P>
      <P>Две функции get возвращают текущее значение атрибута через целое, на которое указывает valptr, а две функции set устанавливают значение атрибута равным значению value. Значение value может быть либо PTHREAD_PROCESS_PRIVATE, либо PTHREAD_PROCESS_SHARED. Последнее также называется атрибутом совместного использования процессами. </P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Эта возможность поддерживается только в том случае, если константа _POSIX_THREAD_PROCESS_SHARED определена в заголовочном файле &lt;unistd.h&gt;. Она является дополнительной согласно Posix.1 и обязательной по Unix 98 (табл. 1.3). </P>
      </DIV>
      <P>Нижеследующий фрагмент кода показывает, как нужно инициализировать взаимное исключение, чтобы его можно было совместно использовать нескольким процессам:</P>
      <P><CODE>pthread_mutex_t *mptr; /* указатель на взаимное исключение, находящееся в разделяемой памяти */</CODE></P>
      <P><CODE>pthread_mutexattr_t mattr; /* атрибуты взаимного исключения */</CODE></P>
      <P><CODE>…</CODE></P>
      <P><CODE>mptr = /* некоторое значение, указывающее на разделяемую память */</CODE></P>
      <P><CODE>Pthread_mutexattr_init(&amp;mattr);</CODE></P>
      <P><CODE>#ifdef _POSIX_THREAD_PROCESS_SHARED</CODE></P>
      <P><CODE> Pthread_mutexattr_setpshared(&amp;mattr, PTHREAD_PROCESS_SHARED);</CODE></P>
      <P><CODE>#else</CODE></P>
      <P><CODE> # error Эта реализация не поддерживает _POSIX_THREAD_PROCESS_SHARED</CODE></P>
      <P><CODE>#endif</CODE></P>
      <P><CODE>Pthread_mutex_init(mptr, &amp;mattr);</CODE></P>
      <P>Мы объявляем переменную mattr типа pthread_mutexattr_t, инициализируем ее значениями атрибутов по умолчанию, а затем устанавливаем атрибут PTHREAD_PROCESS_SHARED, позволяющий совместно использовать взаимное исключение нескольким процессам. Затем pthread_mutex_init инициализирует само исключение с соответствующими атрибутами. Количество разделяемой памяти, которое следует выделить под взаимное исключение, равно sizeof(pthread_mutex_t).</P>
      <P>Практически такая же последовательность команд (с заменой mutex на cond) позволяет установить атрибут PTHREAD_PROCESS_SHARED для условной переменной, хранящейся в разделяемой несколькими процессами памяти.</P>
      <P>Пример совместно используемых несколькими процессами взаимных исключений и условных переменных был приведен в листинге 5.18.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label317 style="border:none;"></a>Завершение процесса, заблокировавшего ресурс</P>
      </H1>
      <P>Когда взаимное исключение используется совместно несколькими процессами, всегда существует возможность, что процесс будет завершен (возможно, принудительно) во время работы с заблокированным им ресурсом. Не существует способа заставить систему автоматически снимать блокировку во время завершения процесса. Мы увидим, что это свойственно и блокировкам чтения-записи, и семафорам Posix. Единственный тип блокировок, автоматически снимаемых системой при завершении процесса, — блокировки записей fcntl (глава 9). При использовании семафоров System V можно специально указать ядру, следует ли автоматически снимать блокировки при завершении работы процесса (функция SEM_UNDO, о которой будет говориться в разделе 11.3).</P>
      <P>Поток также может быть завершен в момент работы с заблокированным ресурсом, если его выполнение отменит (cancel) другой поток или он сам вызовет pthread_exit. Последнему варианту не следует уделять много внимания, поскольку поток должен сам знать, блокирует ли он взаимное исключение в данный момент или нет, и в зависимости от этого вызывать pthread_exit. На случай отмены другим потоком можно предусмотреть обработчик сигнала, вызываемый при отмене потока, что продемонстрировано в разделе 8.5. Если же для потока возникают фатальные условия, это обычно приводит к завершению работы всего процесса. Например, если поток делает некорректную операцию с указателем, что приводит к отправке сигнала SIGSEGV, это приводит к остановке всего процесса, если сигнал не перехватывается, и мы возвращаемся к предыдущей ситуации с гибелью процесса, заблокировавшего ресурс.</P>
      <P>Даже если бы система автоматически разблокировала ресурсы после завершения процесса, это не всегда решало бы проблему. Блокировка защищала критическую область, в которой, возможно, изменялись какие-то данные. Если процесс был завершен посреди этой области, что стало с данными? Велика вероятность того, что возникнут несоответствия, если, например, новый элемент будет не полностью добавлен в связный список. Если бы ядро просто разблокировало взаимное исключение при завершении процесса, следующий процесс, обратившийся к списку, обнаружил бы, что тот поврежден.</P>
      <P>В некоторых случаях автоматическое снятие блокировки (или счетчика — для семафора) при завершении процесса не вызывает проблем. Например, сервер может использовать семафор System V (с функцией SEM_UNDO) для подсчета количества одновременно обслуживаемых клиентов. Каждый раз при порождении процесса вызовом fork он увеличивает значение семафора на единицу, уменьшая его при завершении работы дочернего процесса. Если дочерний процесс завершит работу досрочно, ядро само уменьшит значение семафора. Пример, в котором автоматическое снятие блокировки ядром (а не уменьшение счетчика, как в вышеописанной ситуации) также не вызывает проблем, приведен в разделе 9.7. Демон блокирует один из файлов данных при записи в него и не снимает эту блокировку до завершения работы. Если кто-то попробует запустить копию демона, она завершит работу досрочно, когда обнаружит наличие блокировки на запись. Это гарантирует работу единственного экземпляра демона. Если же демон досрочно завершит работу, ядро само снимет блокировку, что позволит запустить копию демона.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label318 style="border:none;"></a>7.8. Резюме</P>
     </H1>
     <P>Взаимные исключения (mutual exclusion — mutex) используются для защиты критических областей кода, запрещая его одновременное выполнение несколькими потоками. В некоторых случаях потоку, заблокировавшему взаимное исключение, требуется дождаться выполнения какого-либо условия для выполнения последующих действий. В этом случае используется ожидание сигнала по условной переменной. Условная переменная всегда связывается с каким-либо взаимным исключением. Функция pthread_cond_wait, приостанавливающая работу процесса, разблокирует взаимное исключение перед остановкой работы и заново блокирует его при возобновлении работы процесса спустя некоторое время. Сигнал по условной переменной передается каким-либо другим потоком, и этот поток может разбудить либо только один произвольный поток из множества ожидающих (pthread_cond_signal), либо все их одновременно (pthread_cond_broadcast).</P>
     <P>Взаимные исключения и условные переменные могут быть статическими. В этом случае они инициализируются также статически. Они могут быть и динамическими, что требует динамической инициализации. Динамическая инициализация дает возможность указать атрибуты, в частности атрибут совместного использования несколькими процессами, что действенно, если взаимное исключение или условная переменная находится в разделяемой этими процессами памяти.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label319 style="border:none;"></a>Упражнения</P>
     </H1>
     <P>1. Удалите взаимное исключение из листинга 7.2 и убедитесь, что программа работает неправильно, если одновременно запущено более одного производителя.</P>
     <P>2. Что произойдет с листингом 7.1, если убрать вызов Pthread_join для потока-потребителя?</P>
     <P>3. Напишите пpoгрaммy, вызывающую pthread_mutexatt_init и pthread_condattr_init в бесконечном цикле. Следите за используемой этим процессом памятью с помощью какой-нибудь программы, например ps. Что происходит? Теперь добавьте вызовы pthread_mutexattr_destroy и pthread_condattr_destroy и убедитесь, что утечки памяти нет.</P>
     <P>4. В программе из листинга 7.6 производитель вызывает pthread_cond_signal только при изменении nready.nready с 0 на 1. Чтобы убедиться в эффективности этой оптимизации, вызывайте pthread_cond_signal каждый раз, когда nready.nready увеличивается на 1, и выведите его значение в главном потоке после завершения работы потребителя. </P>
    </DIV>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label320 style="border:none;"></a>ГЛАВА 8</P>
     <P>Блокировки чтения-записи</P>
    </H1>
    <DIV class=section>
     <H1>
      <P><a name=label321 style="border:none;"></a>8.1. Введение</P>
     </H1>
     <P>Взаимное исключение используется для предотвращения одновременного доступа нескольких потоков к критической области. Критическая область кода обычно содержит операции считывания или изменения данных, используемых потоками совместно. В некоторых случаях можно провести различие между считыванием данных и их изменением.</P>
     <P>В этой главе описываются блокировки чтения-записи, причем существует различие между получением такой блокировки для считывания и для записи. Правила действуют следующие:</P>
     <P>1. Любое количество потоков могут заблокировать ресурс для считывания, если ни один процесс не заблокировал его на запись.</P>
     <P>2. Блокировка чтения-записи может быть установлена на запись, только если ни один поток не заблокировал ресурс для чтения или для записи.</P>
     <P>Другими словами, произвольное количество потоков могут считывать данные, если ни один поток не изменяет их в данный момент. Данные могут быть изменены, только если никто другой их не считывает и не изменяет.</P>
     <P>В некоторых приложениях данные считываются чаще, чем изменяются, поэтому такие приложения выиграют в быстродействии, если при их реализации будут использованы блокировки чтения-записи вместо взаимных исключений. Возможность совместного считывания данных произвольным количеством процессов позволит выполнять операции параллельно, и при этом данные все равно будут защищены от других потоков на время изменения их данным потоком.</P>
     <P>Такой вид совместного доступа к ресурсу также носит название совместно-исключающей блокировки (shared-exclusive), поскольку тип используемой блокировки на чтение называется совместной блокировкой (shared lock), а тип используемой блокировки на запись называется исключающей блокировкой (exclusive lock). Существует также специальное название для данной задачи (несколько считывающих процессов и один записывающий): задача читателей и писателей (readers and writers problem), и говорят также о блокировке читателей и писателя (readers-writer lock). В последнем случае слово «читатель» специально употреблено во множественном числе, а «писатель» — в единственном, чтобы подчеркнуть сущность задачи.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Обычным примером, иллюстрирующим необходимость использования блокировок чтения-записи, является банковский счет. Считывать баланс со счета могут несколько потоков одновременно, но если какой-либо поток захочет изменить данные, ему придется подождать, пока считывающие потоки не закончат свои операции, и только после этого ему будет разрешено вносить изменения. До окончания процесса записи никакие другие процессы не должны получить доступа к счету.</P>
      <P>Функции, описываемые в этой главе, определены стандартом Unix 98, поскольку блокировки чтения-записи не были частью стандарта Posix.1 1996 года. Эти функции были разработаны группой производителей Unix, известной под названием Aspen Group, в 1995 году вместе с другими расширениями, которые еще не были определены Posix.1. Рабочая группа Posix (1003.1j) в настоящее время разрабатывает набор расширений Pthreads, включающий блокировки чтения-записи, который, хочется верить, совпадет с описываемым в этой главе.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label322 style="border:none;"></a>8.2. Получение и сброс блокировки чтения-записи</P>
     </H1>
     <P>Блокировка чтения-записи имеет тип pthread_rwlock_t. Если переменная этого типа является статической, она может быть проинициализирована присваиванием значения константы PTHREAD_RWLOCK_INITIALIZER.</P>
     <P>Функция pthread_rwlock_rdlock позволяет заблокировать ресурс для чтения, причем вызвавший процесс будет заблокирован, если блокировка чтения-записи уже установлена записывающим процессом. Функция pthread_rwlock_wrlock позволяет заблокировать ресурс для записи, причем вызвавший процесс будет заблокирован, если блокировка чтения-записи уже установлена каким-либо другим процессом (считывающим или записывающим). Функция pthread_rwlock_unlock снимает блокировку любого типа (чтения или записи):</P>
     <P>#include &lt;pthread.h&gt;</P>
     <P><CODE>int pthread_rwlock_rdlock(pthread_rwlock_t <EM>*rwptr</EM>);</CODE></P>
     <P><CODE>int pthread_rwlock_wrlock(pthread_rwlock_t <EM>*rwptr</EM>);</CODE></P>
     <P><CODE>int pthread_rwlock_unlock(pthread_rwlock_t <EM>*rwptr</EM> );</CODE></P>
     <P><CODE>/* Все функции возвращают 0 в случае успешного завершения, положительное значение Еххх – в случае ошибки */</CODE></P>
     <P>Следующие две функции производят попытку заблокировать ресурс для чтения или записи, но если это невозможно, возвращают ошибку с кодом EBUSY, вместо того чтобы приостановить выполнение вызвавшего процесса:</P>
     <P><CODE>#include &lt;pthread.h&gt;</CODE></P>
     <P><CODE>int pthread_rwlock_tryrdlock(pthread_rwlock_t <EM>*rwptr</EM>);</CODE></P>
     <P><CODE>int pthread_rwlock_trywrlock(pthread_rwlock_t <EM>*rwptr</EM>);</CODE></P>
     <P><CODE>/* Обе функции возвращают 0 в случае успешного завершения, положительное значение Еххх – в случае ошибки */</CODE></P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label323 style="border:none;"></a>8.3. Атрибуты блокировки чтения-записи</P>
     </H1>
     <P>Мы уже отмечали, что статическая блокировка может быть проинициализирована присваиванием ей значения PTHREAD_RWLOCK_INITIALIZER. Эти переменные могут быть проинициализированы и динамически путем вызова функции pthread_rwlock_init. </P>
     <P>Когда поток перестает нуждаться в блокировке, он может вызвать pthread_rwlock_ destroy:</P>
     <P><CODE>#include &lt;pthread.h&gt;</CODE></P>
     <P><CODE>int pthread_rwlock_init(pthread_rwlock_t <EM>*rwptr,</EM> const pthread_rwlockattr_t <EM>*attr</EM>);</CODE></P>
     <P><CODE>int pthread_rwlock_destroy(pthread_rwlock_t <EM>*rwptr</EM>);</CODE></P>
     <P><CODE>/* Обе функции возвращают 0 в случае успешного завершения, положительное значение Еххх – в случае ошибки */</CODE></P>
     <P>Если при инициализации блокировки чтения-записи <EM>attr</EM> представляет собой нулевой указатель, атрибутам присваиваются значения по умолчанию. Для присваивания атрибутам других значений следует воспользоваться двумя нижеследующими функциями:</P>
     <P><CODE>#include &lt;pthread.h&gt;</CODE></P>
     <P><CODE>int pthread_rwlockattr_init(pthread_rwlockattr_t <EM>*attr</EM>);</CODE></P>
     <P><CODE>int pthread_rwlockattr_destroy(pthread_rwlockattr_t <EM>*attr</EM>);</CODE></P>
     <P><CODE>/* Обе функции возвращают 0 в случае успешного завершения, положительное значение Еххх – в случае ошибки */</CODE></P>
     <P>После инициализации объекта типа pthread_rwlockattr_t для установки или сброса отдельных атрибутов используются специальные функции. Единственный определенный на настоящее время атрибут — PTHREAD_PROCESS_SHARED, который указывает на то, что блокировка используется несколькими процессами, а не отдельными потоками одного процесса. Две приведенные ниже функции используются для получения и установки значения этого атрибута:</P>
     <P><CODE>#include &lt;pthread.h&gt;</CODE></P>
     <P><CODE>int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t <EM>*attr,</EM> int <EM>*valptr</EM>);</CODE></P>
     <P><CODE>int pthread_rwlockattr_setpshared(pthread_rwlockattr_t <EM>*attr,</EM> int <EM>value</EM> );</CODE></P>
     <P><CODE>/* Обе функции возвращают 0 в случае успешного завершения, положительное значение Еххх – в случае ошибки */</CODE></P>
     <P>Первая функция возвращает текущее значение в целом, на которое указывает аргумент <EM>valptr.</EM> Вторая функция устанавливает значение этого атрибута равным <EM>value,</EM> которое может быть либо PTHREAD_PROCESS_PRIVATE, либо PTHREAD_ PROCESS_SHARED.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label324 style="border:none;"></a>8.4. Реализация с использованием взаимных исключений и условных переменных</P>
     </H1>
     <DIV class=section>
      <P>Для реализации блокировок чтения-записи достаточно использовать взаимные исключения и условные переменные. В этом разделе мы рассмотрим одну из возможных реализаций, в которой предпочтение отдается ожидающим записи потокам. Это не является обязательным; возможны альтернативы.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Этот и последующие разделы данной главы содержат усложненный материал, который можно при первом чтении пропустить.</P>
       <P>Другие реализации блокировок чтения записи заслуживают отдельного изучения. В разделе 7.1.2 книги [3] представлена реализация, в которой приоритет имеют ожидающие записи потоки и предусмотрена обработка отмены выполнения потока (о которой мы вскоре будем говорить подробнее). В разделе В.18.2.3.1 стандарта IEEE 1996 [8] представлена другая реализация, в которой предпочтение имеют ожидающие записи потоки и в которой также предусмотрена обработка отмены. В главе 14 книги [12] также приводится возможная реализация, в которой приоритет имеют ожидающие записи процессы. Реализация, приведенная в этом разделе, взята из пакета АСЕ (http://www.cs.wustl.edu/~schmidt/ACE.html), автором которого является Дуг Шмидт (Doug Schmidt). Аббревиатура АСЕ означает Adaptive Communications Environment. Во всех четырех реализациях используются взаимные исключения и условные переменные. </P>
      </DIV>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label325 style="border:none;"></a>Тип данных pthread_rwlock_t</P>
      </H1>
      <P>В листинге 8.1<A HREF="#n_1" onmouseover="ShowBookNote('n_1')" onmouseout="HideBookNote('n_1')"><SUP>[1]</SUP></A> приведен текст заголовочного файла pthread_rwlock .h, в котором определен основной тип pthread_rwlock_t и прототипы функций, работающих с блокировками чтения и записи. Обычно все это находится в заголовочном файле &lt;pthread.h&gt;.</P>
      <H2><a name=label326 style="border:none;"></a>Листинг 8.1. Определение типа данных pthread_rwlock_t</H2>
      <P><CODE>//my_rwlock/pthread_rwlock.h</CODE></P>
      <P><CODE>1  #ifndef __pthread_rwlock_h</CODE></P>
      <P><CODE>2  #define __pthread_rwlock_h</CODE></P>
      <BR>
      <P><CODE>3  typedef struct {</CODE></P>
      <P><CODE>4   pthread_mutex_t rw_mutex; /* блокировка для структуры */</CODE></P>
      <P><CODE>5   pthread_cond_t rw_condreaders; /* для ждущих читающих потоков */</CODE></P>
      <P><CODE>6   pthread_cond_t rw_condwriters; /* для ждущих пишущих потоков */</CODE></P>
      <P><CODE>7   int rw_magic; /* для проверки ошибок */</CODE></P>
      <P><CODE>8   int rw_nwaitreaders;/* число ожидающих */</CODE></P>
      <P><CODE>9   int rw_nwaitwriters;/* число ожидающих */</CODE></P>
      <P><CODE>10  int rw_refcount;</CODE></P>
      <P><CODE>11  /* –1, если блокировка на запись, иначе – количество блокировок на чтение */</CODE></P>
      <P><CODE>12 } pthread_rwlock_t;</CODE></P>
      <BR>
      <P><CODE>13 #define RW_MAGIC 0x19283746</CODE></P>
      <P><CODE>14 /* порядок должен быть такой же, как у элементов структуры */</CODE></P>
      <P><CODE>15 #define PTHREAD_RWLOCK_INITIALIZER { PTHREAD_MUTEX_INITIALIZER, \</CODE></P>
      <P><CODE>16  PTHREAD_COND_INITIALIZER, PTHREAD_COND_INITIALIZER, \</CODE></P>
      <P><CODE>17  RW_MAGIC, 0, 0, 0 }</CODE></P>
      <BR>
      <P><CODE>18 typedef int pthread_rwlockattr_t; /* не поддерживается */</CODE></P>
      <BR>
      <P><CODE>19 /* прототипы функций */</CODE></P>
      <P><CODE>20 int pthread_rwlock_destroy(pthread_rwlock_t *);</CODE></P>
      <P><CODE>21 int pthread_rwlock_init(pthread_rwlock_t *, pthread_rwlockattr_t *);</CODE></P>
      <P><CODE>22 int pthread_rwlock_rdlock(pthread_rwlock_t *);</CODE></P>
      <P><CODE>23 int pthread_rwlock_tryrdlock(pthread_rwlock_t *);</CODE></P>
      <P><CODE>24 int pthread_rwlock_trywrlock(pthread_rwlock_t *);</CODE></P>
      <P><CODE>25 int pthread_rwlock_unlock(pthread_rwlock_t *);</CODE></P>
      <P><CODE>26 int pthread_rwlock_wrlock(pthread_rwlock_t *);</CODE></P>
      <BR>
      <P><CODE>27 /* и наши функции-обертки */</CODE></P>
      <P><CODE>28 void pthread_rwlock_destroy(pthread_rwlock_t *);</CODE></P>
      <P><CODE>29 void pthread_rwlock_init(pthread_rwlock_t*, pthread_rwlockattr_t *);</CODE></P>
      <P><CODE>30 void Pthread_rwlock_rdlock(pthread_rwlock_t *);</CODE></P>
      <P><CODE>31 int Pthread_rwlock_tryrdlock(pthread_rwlock_t *);</CODE></P>
      <P><CODE>32 int pthread_rwlock_trywrlock(pthread_rwlock_t *);</CODE></P>
      <P><CODE>33 void pthread_rwlock_unlock(pthread_rwlock_t *);</CODE></P>
      <P><CODE>34 void pthread_rwlock_wrlock(pthread_rwlock_t *);</CODE></P>
      <BR>
      <P><CODE>35 #endif __pthread_rwlock_h</CODE></P>
      <P>3-13 Наш тип pthread_rwlock_t содержит одно взаимное исключение, две условные переменные, один флаг и три счетчика. Мы увидим, для чего все это нужно, когда будем разбираться с работой функций нашей программы. При просмотре или изменении содержимого этой структуры мы должны устанавливать блокировку rw_mutex. После успешной инициализации структуры полю rw_magic присваивается значение RW_MAGIC. Значение этого поля проверяется всеми функциями — таким образом гарантируется, что вызвавший поток передал указатель на проинициализированную блокировку. Оно устанавливается в 0 после уничтожения блокировки.</P>
      <P>Обратите внимание, что в счетчике rw_refcount всегда хранится текущий статус блокировки чтения-записи: –1 обозначает блокировку записи (и только одна такая блокировка может существовать в любой момент времени), 0 обозначает, что блокировка доступна и может быть установлена, а любое положительное значение соответствует количеству установленных блокировок на чтение.</P>
      <P>14-17 Мы также определяем константу для статической инициализации нашей структуры.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label327 style="border:none;"></a>Функция pthread_rwlock_init</P>
      </H1>
      <P>Первая функция, pthread_rwlock_init, динамически инициализирует блокировку чтения-записи. Ее текст приведен в листинге 8.2.</P>
      <P>7-8 Присваивание атрибутов с помощью этой функции не поддерживается, поэтому мы проверяем, чтобы указатель attr был нулевым.</P>
      <P>9-19 Мы инициализируем взаимное исключение и две условные переменные, которые содержатся в нашей структуре. Все три счетчика устанавливаются в 0, а полю rw_magiс присваивается значение, указывающее на то, что структура была проинициализирована.</P>
      <P>20-25 Если при инициализации взаимного исключения или условной переменной возникает ошибка, мы аккуратно уничтожаем проинициализированные объекты и возвращаем код ошибки.</P>
      <H2><a name=label328 style="border:none;"></a>Листинг 8.2. Функция pthread_rwlock_init: инициализация блокировки чтения-записи</H2>
      <P><CODE>//my_rwlock/pthread_rwlock_init.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "pthread_rwlock.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  pthread_rwlock_init(pthread_rwlock_t *rw, pthread_rwlockattr_t *attr)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int result;</CODE></P>
      <P><CODE>7   if (attr != NULL)</CODE></P>
      <P><CODE>8    return(EINVAL); /* not supported */</CODE></P>
      <P><CODE>9   if ((result = pthread_mutex_init(&amp;rw-&gt;rw_mutex, NULL)) != 0)</CODE></P>
      <P><CODE>10   goto err1;</CODE></P>
      <P><CODE>11  if ((result = pthread_cond_init(&amp;rw-&gt;rw_condreaders, NULL)) != 0)</CODE></P>
      <P><CODE>12   goto err2;</CODE></P>
      <P><CODE>13  if ((result = pthread_cond_init(&amp;rw-&gt;rw_condwriters, NULL)) != 0)</CODE></P>
      <P><CODE>14   goto err3;</CODE></P>
      <P><CODE>15  rw-&gt;rw_nwaitreaders = 0;</CODE></P>
      <P><CODE>16  rw-&gt;rw_nwaitwriters = 0;</CODE></P>
      <P><CODE>17  rw-&gt;rw_refcount = 0;</CODE></P>
      <P><CODE>18  rw-&gt;rw_magic = RW_MAGIC;</CODE></P>
      <P><CODE>19  return(0);</CODE></P>
      <P><CODE>20 err3:</CODE></P>
      <P><CODE>21  pthread_cond_destroy(&amp;rw-&gt;rw_condreaders);</CODE></P>
      <P><CODE>22 err2;</CODE></P>
      <P><CODE>23  pthread_mutex_destroy(&amp;rw-&gt;rw_mutex);</CODE></P>
      <P><CODE>24 err1:</CODE></P>
      <P><CODE>25  return(result); /* значение errno */</CODE></P>
      <P><CODE>26 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label329 style="border:none;"></a>Функция pthread_rwlock destroy</P>
      </H1>
      <P>В листинге 8.3 приведена функция pthread_rwlock_destroy, уничтожающая блокировку чтения записи после окончания работы с ней.</P>
      <P>8-13 Прежде всего проверяется, не используется ли блокировка в данный момент, а затем вызываются соответствующие функции для уничтожения взаимного исключения и двух условных переменных.</P>
      <H2><a name=label330 style="border:none;"></a>Листинг 8.З. Функция pthread_rwlock_destroy: уничтожение блокировки чтения-записи</H2>
      <P><CODE>//my_rwlock/pthread_rwlock_destroy.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "pthread_rwlock.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  pthread_rwlock_destroy(pthread_rwlock_t *rw)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   if (rw-&gt;rw_magic != RW_MAGIC)</CODE></P>
      <P><CODE>7    return(EINVAL);</CODE></P>
      <P><CODE>8   if (rw-&gt;rw_refcount != 0 ||</CODE></P>
      <P><CODE>9    rw-&gt;rw_nwaitreaders != 0 || rw-&gt;rw_nwaitwriters != 0)</CODE></P>
      <P><CODE>10   return(EBUSY);</CODE></P>
      <P><CODE>11  pthread_mutex_destroy(&amp;rw-&gt;rw_mutex);</CODE></P>
      <P><CODE>12  pthread_cond_destroy(&amp;rw-&gt;rw_condreaders);</CODE></P>
      <P><CODE>13  pthread_cond_destroy(&amp;rw-&gt;rw_condwriters);</CODE></P>
      <P><CODE>14  rw-&gt;rw_magic = 0;</CODE></P>
      <P><CODE>15  return(0);</CODE></P>
      <P><CODE>16 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label331 style="border:none;"></a>Функция pthread_rwlock_rdlock</P>
      </H1>
      <P>Текст функции pthread_rwlock_rdlock приведен в листинге 8.4.</P>
      <H2><a name=label332 style="border:none;"></a>Листинг 8.4. Функция pthread_rwlock_rdlock: получение блокировки на чтение</H2>
      <P><CODE>//my_rwlock/pthread_rwlock_rdlock.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "pthread_rwlock.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  pthread_rwlock_rdlock(pthread_rwlock_t *rw)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int result;</CODE></P>
      <P><CODE>7   if (rw-&gt;rw_magic != RW_MAGIC)</CODE></P>
      <P><CODE>8    return(EINVAL);</CODE></P>
      <P><CODE>9   if ((result = pthread_mutex_lock(&amp;rw-&gt;rw_mutex)) != 0)</CODE></P>
      <P><CODE>10   return(result);</CODE></P>
      <P><CODE>11  /* предпочтение отдается ожидающим разрешения на запись процессам */</CODE></P>
      <P><CODE>12  while (rw-&gt;rw_refcount &lt; 0 || rw-&gt;rw_nwaitwriters &gt; 0) {</CODE></P>
      <P><CODE>13   rw-&gt;rw_nwaitreaders++;</CODE></P>
      <P><CODE>14   result = pthread_cond_wait(&amp;rw-&gt;rw_condreaders, &amp;rw-&gt;rw_mutex);</CODE></P>
      <P><CODE>15   rw-&gt;rw_nwaitreaders--;</CODE></P>
      <P><CODE>16   if (result != 0)</CODE></P>
      <P><CODE>17    break;</CODE></P>
      <P><CODE>18  }</CODE></P>
      <P><CODE>19  if (result == 0)</CODE></P>
      <P><CODE>20   rw-&gt;rw_refcount++; /* блокировка на чтение уже кем-то установлена */</CODE></P>
      <P><CODE>21  pthread_mutex_unlock(&amp;rw-&gt;rw_mutex);</CODE></P>
      <P><CODE>22  return (result);</CODE></P>
      <P><CODE>23 }</CODE></P>
      <P>9-10 При работе со структурой pthread_rwl ock_t всегда устанавливается блокировка на rw_mutex, являющееся ее полем.</P>
      <P>11-18 Нельзя получить блокировку на чтение, если rw_refcount имеет отрицательное значение (блокировка установлена на запись) или имеются потоки, ожидающие возможности получения блокировки на запись (rw_nwaitwriters больше 0). Если одно из этих условий верно, мы увеличиваем значение rw_nwaitreaders и вызываем pthread_cond_wait для условной переменной rw_condreaders. Вскоре мы увидим, что при разблокировании ресурса прежде всего проверяется наличие процессов, ожидающих возможности установить блокировку на запись, и если таковых не существует, проверяется наличие ожидающих возможности считывания. Если они имеются, для условной переменной rw_condreaders передается широковещательный сигнал.</P>
      <P>19-20 При получении блокировки на чтение мы увеличиваем значение rw_refcount. Блокировка взаимного исключения после этого снимается.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>В этой функции есть проблема: если вызвавший поток будет заблокирован в функции pthread_cond_wait и после этого его выполнение будет отменено, он завершит свою работу, не разблокировав взаимное исключение, и значение rw_nwaitreaders окажется неверным. Та же проблема есть и в функции pthread_rwlock_wrlock в листинге 8.6. Эти проблемы будут исправлены в разделе 8.5.</P>
      </DIV>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label333 style="border:none;"></a>Функция pthread_rwlock_tryrdlock</P>
      </H1>
      <P>В листинге 8.5 показана наша реализация функции pthread_rwlock_tryrdlock, которая не вызывает приостановления вызвавшего ее потока.</P>
      <H2><a name=label334 style="border:none;"></a>Листинг 8.5. Функция pthread_rwlock_tryrdlock: попытка заблокировать ресурс для чтения</H2>
      <P><CODE>//my_rwlock/pthread_rwlock_tryrdlock.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "pthread_rwlock.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  pthread_rwlock_tryrdlock(pthread_rwlock_t *rw)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int result;</CODE></P>
      <P><CODE>7   if (rw-&gt;rwjnagic != RW_MAGIC)</CODE></P>
      <P><CODE>8    return(EINVAL);</CODE></P>
      <P><CODE>9   if ((result = pthread_mutex_lock(&amp;rw-&gt;rw_mutex)) != 0)</CODE></P>
      <P><CODE>10   return(result);</CODE></P>
      <P><CODE>11  if (rw-&gt;rw_refcount &lt; 0 || rw-&gt;rw_nwaitwriters &gt; 0)</CODE></P>
      <P><CODE>12   result = EBUSY; /* блокировка установлена пишущим потоком или есть пишущие потоки, ожидающие освобождения ресурса */</CODE></P>
      <P><CODE>13  else</CODE></P>
      <P><CODE>14   rw-&gt;rw_refcount++; /* увеличение количества блокировок на чтение */</CODE></P>
      <P><CODE>15  pthread_mutex_unlock(&amp;rw-&gt;rw_mutex);</CODE></P>
      <P><CODE>16  return(result);</CODE></P>
      <P><CODE>17 }</CODE></P>
      <P>11-14 Если блокировка в данный момент установлена на запись или есть процессы, ожидающие возможности установить ее на запись, возвращается ошибка с кодом EBUSY. В противном случае мы устанавливаем блокировку, увеличивая значение счетчика rw_refcount.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label335 style="border:none;"></a>Функция pthread_rwlock_wrlock</P>
      </H1>
      <P>Текст функции pthread_rwlock_wrlock приведен в листинге 8.6.</P>
      <P>11-17 Если ресурс заблокирован на считывание или запись (значение rw_refcount отлично от 0), мы приостанавливаем выполнение потока. Для этого мы увеличиваем rw_nwaitwriters и вызываем pthread_cond_wait с условной переменной rw_condwriters. Для этой переменной посылается сигнал при снятии блокировки чтения-записи, если имеются ожидающие разрешения на запись процессы.</P>
      <P>18-19 После получения блокировки на запись мы устанавливаем значение rw_refcount в –1.</P>
      <H2><a name=label336 style="border:none;"></a>Листинг 8.6. Функция pthread_rwlock_wrlock: получение блокировки на запись</H2>
      <P><CODE>//my_rwlock/pthread_rwlock_wrlock.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "pthread_rwlock.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  pthread_rwlock_wrlock(pthread_rwlock_t *rw)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int result;</CODE></P>
      <P><CODE>7   if (rw-&gt;rw_magic != RW_MAGIC)</CODE></P>
      <P><CODE>8    return(EINVAL);</CODE></P>
      <P><CODE>9   if ((result = pthread_mutex_lock(&amp;rw-&gt;rw_mutex)) != 0)</CODE></P>
      <P><CODE>10   return(result);</CODE></P>
      <P><CODE>11  while (rw-&gt;rw_refcount != 0) {</CODE></P>
      <P><CODE>12   rw-&gt;rw_nwaitwriters++;</CODE></P>
      <P><CODE>13   result = pthread_cond_wait(&amp;rw-&gt;rw_condwriters, &amp;rw-&gt;rw_mutex);</CODE></P>
      <P><CODE>14   rw-&gt;rw_nwaitwriters--;</CODE></P>
      <P><CODE>15   if (result != 0)</CODE></P>
      <P><CODE>16    break;</CODE></P>
      <P><CODE>17  }</CODE></P>
      <P><CODE>18  if (result == 0)</CODE></P>
      <P><CODE>19   rw-&gt;rw_refcount = –1;</CODE></P>
      <P><CODE>20  pthread_mutex_unlock(&amp;rw-&gt;rw_mutex);</CODE></P>
      <P><CODE>21  return(result);</CODE></P>
      <P><CODE>22 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label337 style="border:none;"></a>Функция pthread_rwlock_trywrlock</P>
      </H1>
      <P>Неблокируемая функция pthread_rwlock_trywrlock показана в листинге 8.7.</P>
      <P>11-14 Если значение счетчика rw_refcount отлично от нуля, блокировка в данный момент уже установлена считывающим или записывающим процессом (это безразлично) и мы возвращаем ошибку с кодом EBUSY. В противном случае мы устанавливаем блокировку на запись, присвоив переменной rw_refcount значение –1.</P>
      <H2><a name=label338 style="border:none;"></a>Листинг 8.7. Функция pthread_rwlock_trywrlock: попытка получения блокировки на запись</H2>
      <P><CODE>//my_rwlock/pthread_rwlock_trywrlock.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "pthread_rwlock.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  pthread_rwlock_trywrlock(pthread_rwlock_t *rw)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int result;</CODE></P>
      <P><CODE>7   if (rw-&gt;rw_magic != RW_MAGIC)</CODE></P>
      <P><CODE>8    return(EINVAL);</CODE></P>
      <P><CODE>9   if ((result = pthread_mutex_lock(&amp;rw-&gt;rw_mutex)) != 0)</CODE></P>
      <P><CODE>10   return(result);</CODE></P>
      <P><CODE>11  if (rw-&gt;rw_refcount != 0)</CODE></P>
      <P><CODE>12   result = EBUSY; /* заблокирован пишущим потоком или ожидающим возможности записи */</CODE></P>
      <P><CODE>13  else</CODE></P>
      <P><CODE>14   rw-&gt;rw_refcount = –1; /* доступна */</CODE></P>
      <P><CODE>15  pthread_mutex_unlock(&amp;rw-&gt;rw_mutex);</CODE></P>
      <P><CODE>16  return(result);</CODE></P>
      <P><CODE>17 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label339 style="border:none;"></a>Функция pthread<STRONG>_rwlock_unlock</STRONG></P>
      </H1>
      <P>Последняя функция, pthread_rwlock_unlock, приведена в листинге 8.8.</P>
      <H2><a name=label340 style="border:none;"></a>Листинг 8.8. Функция pthread_rwlock_unlock: разблокирование ресурса</H2>
      <P><CODE>//my_rwlock/pthread_rwlock_unlock.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "pthread_rwlock.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  pthread_rwlock_unlock(pthread_rwlock_t *rw)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int result;</CODE></P>
      <P><CODE>7   if (rw-&gt;rw_magic != RW_MAGIC)</CODE></P>
      <P><CODE>8    return(EINVAL);</CODE></P>
      <P><CODE>9   if ((result = pthread_mutex_lock(&amp;rw-&gt;rw_mutex)) != 0)</CODE></P>
      <P><CODE>10   return(result);</CODE></P>
      <P><CODE>11  if (rw-&gt;rw_refcount &gt; 0)</CODE></P>
      <P><CODE>12   rw-&gt;rw_refcount--; /* снятие блокировки на чтение */</CODE></P>
      <P><CODE>13  else if (rw-&gt;rw_refcount == –1)</CODE></P>
      <P><CODE>14   rw-&gt;rw_refcount = 0; /* снятие блокировки на запись */</CODE></P>
      <P><CODE>15  else</CODE></P>
      <P><CODE>16   err_dump("rw_refcount = %d", rw-&gt;rw_refcount);</CODE></P>
      <P><CODE>17  /* преимущество отдается ожидающим возможности записи потокам */</CODE></P>
      <P><CODE>18  if (rw-&gt;rw_nwaitwriters &gt; 0) {</CODE></P>
      <P><CODE>19   if (rw-&gt;rw_refcount == 0)</CODE></P>
      <P><CODE>20    result = pthread_cond_signal(&amp;rw-&gt;rw_condwriters);</CODE></P>
      <P><CODE>21  } else if (rw-&gt;rw_nwaitreaders &gt; 0)</CODE></P>
      <P><CODE>22   result = pthread_cond_broadcast(&amp;rw-&gt;rw_condreaders);</CODE></P>
      <P><CODE>23  pthread_mutex_unlock(&amp;rw-&gt;rw_mutex);</CODE></P>
      <P><CODE>24  return(result);</CODE></P>
      <P><CODE>25 }</CODE></P>
      <P>11-16 Если rw_refcount больше 0, считывающий поток снимает блокировку на чтение. Если rw_refcount равно –1, записывающий поток снимает блокировку на запись.</P>
      <P>17-22 Если имеются ожидающие разрешения на запись потоки, по условной переменной rw_condwriters передается сигнал (если блокировка свободна, то есть значение счетчика rw_refcount равно 0). Мы знаем, что только один поток может осуществлять запись, поэтому используем функцию pthread_cond_signal. Если нет потоков, ожидающих возможности записи, но есть потоки, ожидающие возможности чтения, мы вызываем pthread_cond_broadcast для переменной rw_condreaders, поскольку возможно одновременное считывание несколькими потоками. Обратите внимание, что мы перестаем устанавливать блокировку для считывающих потоков, если появляются потоки, ожидающие возможности записи. В противном случае постоянно появляющиеся потоки с запросами на чтение могли бы заставить поток, ожидающий возможности записи, ждать целую вечность. По этой причине мы используем два отдельных оператора if и не можем написать просто:</P>
      <P><CODE>/* предпочтение отдается записывающим процессам */</CODE></P>
      <P><CODE>if (rw-&gt;rw_nwaitreaders &gt; 0 &amp;&amp; rw-&gt;rw_refcount == 0)</CODE></P>
      <P><CODE> result = pthread_cond_signal(&amp;rw-&gt;rw_condwriters);</CODE></P>
      <P><CODE>else if (rw-&gt;rw_nwaitreaders &gt; 0)</CODE></P>
      <P><CODE> result = pthread_cond_broadcast(&amp;rw-&gt;rw_condreaders);</CODE></P>
      <P>Мы могли бы исключить и проверку rw-&gt;rw_refcount, но это может привести к вызовам pthread_cond_signal даже при наличии блокировок на чтение, что приведет к потере эффективности.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label341 style="border:none;"></a>8.5. Отмена выполнения потоков</P>
     </H1>
     <DIV class=section>
      <P>Обсуждая листинг 8.4, мы обратили внимание на наличие проблемы, возникающей при отмене выполнения потока, заблокированного вызовом pthread_cond_wait. Выполнение потока может быть отменено в том случае, если какой-нибудь другой поток вызовет функцию pthread_cancel, единственным аргументом которой является идентификатор потока, выполнение которого должно быть отменено:</P>
      <P><CODE>#include &lt;pthread.h&gt;</CODE></P>
      <P><CODE>int pthread_cancel(pthread_t <EM>tid</EM>);</CODE></P>
      <P><CODE>/* Возвращает 0 в случае успешного завершения, положительное значение Еххх –в случае ошибки */</CODE></P>
      <P>Отмена выполнения может быть использована в том случае, если несколько потоков начинают работу над какой-то задачей (например, поиск записи в базе данных) и один из них завершает работу раньше всех остальных. Тогда он может отменить их выполнение. Другим примером является обнаружение ошибки одним из одновременно выполняющих задачу потоков, который затем может отменить выполнение и всех остальных.</P>
      <P>Для обработки отмены выполнения поток может установить (push) или снять (pop) обработчик-очиститель (cleanup handler):</P>
      <P><CODE>#include &lt;pthread.h&gt;</CODE></P>
      <P><CODE>void pthread_cleanup_push(void (*<EM>function)</EM> (void *) void <EM>*arg</EM>);</CODE></P>
      <P><CODE>void pthread_cleanup_pop(int <EM>execute</EM>);</CODE></P>
      <P>Эти обработчики представляют собой обычные функции, которые вызываются:</P>
      <P>■ в случае отмены выполнения потока (другим потоком, вызвавшим pthread_ cancel);</P>
      <P>■ в случае добровольного завершения работы (вызовом pthread_exit или выходом из начальной функции потока).</P>
      <P>Обработчики-очистители выполняют всю необходимую работу по восстановлению значений переменных, такую как разблокирование взаимных исключений и семафоров, которые могли быть заблокированы данным потоком.</P>
      <P>Аргумент <EM>function</EM> представляет собой адрес вызываемой функции, а <EM>arg</EM> — ее единственный аргумент. Функция pthread_cleanup_pop всегда удаляет обработчик из верхушки стека и вызывает эту функцию, если значение <EM>execute</EM> отлично от 0.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Мы снова встретимся с проблемой отмены выполнения потоков в связи с листингом 15.26, где может произойти отмена выполнения сервера с дверьми при завершении работы клиента в процессе обработки вызванной им процедуры. </P>
      </DIV>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label342 style="border:none;"></a>Пример</P>
      </H1>
      <P>Легче всего продемонстрировать проблему нашей реализации из предыдущего раздела с помощью примера. На рис. 8.1 изображена временная диаграмма выполнения нашей программы, а текст самой программы приведен в листинге 8.9. </P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader147" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 8.1. Временная диаграмма выполнения программы из листинга 8.9</P>
      <BR>
      <H2><a name=label343 style="border:none;"></a>Создание двух потоков</H2>
      <P>10-13 Создаются два потока, первый из которых выполняет функцию thread1, а второй — thread2. После создания первого делается пауза длительностью в одну секунду, чтобы он успел заблокировать ресурс на чтение. </P>
      <H2><a name=label344 style="border:none;"></a>Ожидание завершения потоков</H2>
      <P>14-23 Мы ожидаем завершения работы второго потока и проверяем, что его статус имеет значение PTHREAD_CANCEL. Затем мы ждем завершения работы первого потока и проверяем, что его статус представляет собой нулевой указатель. Затем мы выводим значение трех счетчиков в структуре pthread_rwlock_t и уничтожаем блокировку.</P>
      <H2><a name=label345 style="border:none;"></a>Листинг 8.9. Тестовая программа, иллюстрирующая отмену выполнения потока</H2>
      <P><CODE>//my_rwlock_cancel/testcancel.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "pthread_rwlock.h"</CODE></P>
      <BR>
      <P><CODE>3  pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;</CODE></P>
      <P><CODE>4  pthread_t tid1, tid2;</CODE></P>
      <P><CODE>5  void *thread1(void *), *thread2(void *);</CODE></P>
      <BR>
      <P><CODE>6  int</CODE></P>
      <P><CODE>7  main(int argc, char **argv)</CODE></P>
      <P><CODE>8  {</CODE></P>
      <P><CODE>9   void *status;</CODE></P>
      <P><CODE>10  Set_concurrency(2);</CODE></P>
      <P><CODE>11  Pthread_create(&amp;tid1, NULL, thread1, NULL);</CODE></P>
      <P><CODE>12  sleep(1); /* даем первому потоку возможность получить блокировку */</CODE></P>
      <P><CODE>13  Pthread_create(&amp;tid2, NULL, thread2, NULL);</CODE></P>
      <P><CODE>14  Pthread_join(tid2, &amp;status);</CODE></P>
      <P><CODE>15  if (status != PTHREAD_CANCELED)</CODE></P>
      <P><CODE>16   printf("thread2 status = %p\n", status);</CODE></P>
      <P><CODE>17  Pthread_join(tid1, &amp;status);</CODE></P>
      <P><CODE>18  if (status != NULL)</CODE></P>
      <P><CODE>19   printf("thread1 status = %p\n", status);</CODE></P>
      <P><CODE>20  printf("rw_refcount = %d, rw_nwaitreaders = %d, rw_nwaitwriters = %d\n",</CODE></P>
      <P><CODE>21   rwlock.rw_refcount, rwlock.rw_nwaitreaders,</CODE></P>
      <P><CODE>22   rwlock.rw_nwaitwriters);</CODE></P>
      <P><CODE>23  Pthread_rwlock_destroy(&amp;rwlock);</CODE></P>
      <P><CODE>24  exit(0);</CODE></P>
      <P><CODE>25 }</CODE></P>
      <BR>
      <P><CODE>26 void *</CODE></P>
      <P><CODE>27 thread1(void *arg)</CODE></P>
      <P><CODE>28 {</CODE></P>
      <P><CODE>29  Pthread_rwlock_rdlock(&amp;rwlock);</CODE></P>
      <P><CODE>30  printf("thread1() got a read lock\n");</CODE></P>
      <P><CODE>31  sleep(3); /* даем второму потоку возможность заблокироваться при вызове pthread_rwlock_wrlock() */</CODE></P>
      <P><CODE>32  pthread_cancel(tid2);</CODE></P>
      <P><CODE>33  sleep(3);</CODE></P>
      <P><CODE>34  Pthread_rwlock_unlock(&amp;rwlock);</CODE></P>
      <P><CODE>35  return(NULL);</CODE></P>
      <P><CODE>36 }</CODE></P>
      <BR>
      <P><CODE>37 void *</CODE></P>
      <P><CODE>38 thread2(void *arg)</CODE></P>
      <P><CODE>39 {</CODE></P>
      <P><CODE>40  printf("thread2() trying to obtain a write lock\n"):</CODE></P>
      <P><CODE>41  Pthread_rwlock_wrlock(&amp;rwlock);</CODE></P>
      <P><CODE>42  printf("thread2() got a write lock\n"); /* не будет выполнено */</CODE></P>
      <P><CODE>43  sleep(1);</CODE></P>
      <P><CODE>44  Pthread_rwlock_unlock(&amp;rwlock);</CODE></P>
      <P><CODE>45  return(NULL);</CODE></P>
      <P><CODE>46 }</CODE></P>
      <H2><a name=label346 style="border:none;"></a>Функция thread1</H2>
      <P>26-36 Поток получает блокировку на чтение и ждет 3 секунды. Эта пауза дает возможность другому потоку вызвать pthread_rwlock_wrlock и заблокироваться при вызове pthread_cond_wait, поскольку блокировка на запись не может быть установлена из-за наличия блокировки на чтение. Затем первый поток вызывает pthread_cancel для отмены выполнения второго потока, ждет 3 секунды, освобождает блокировку на чтение и завершает работу.</P>
      <H2><a name=label347 style="border:none;"></a>Функция thread2</H2>
      <P>37-46 Второй поток делает попытку получить блокировку на запись (которую он получить не может, поскольку первый поток получил блокировку на чтение). Оставшаяся часть функции никогда не будет выполнена.</P>
      <P>При запуске этой программы с использованием функций из предыдущего раздела мы получим следующий результат:</P>
      <P><CODE>solaris % <STRONG>testcancel</STRONG></CODE></P>
      <P><CODE>thread1() got a read lock</CODE></P>
      <P><CODE>thread2() trying to obtain a write lock</CODE></P>
      <P>и мы никогда не вернемся к приглашению интерпретатора. Программа зависнет. Произошло вот что:</P>
      <P>1. Второй поток вызвал pthread_rwlock_wrlock (листинг 8.6), которая была заблокирована в вызове pthread_cond_wait.</P>
      <P>2. Первый поток вернулся из вызова slеер(3) и вызвал pthread_cancel.</P>
      <P>3. Второй поток был отменен и завершил работу. При отмене потока, заблокированного в ожидании сигнала по условной переменной, взаимное исключение блокируется до вызова первого обработчика-очистителя. (Мы не устанавливали обработчик, но взаимное исключение все равно блокируется до завершения потока.) Следовательно, при отмене выполнения второго потока взаимное исключение осталось заблокированным и значение rw_nwaitwriters в листинге 8.6 было увеличено.</P>
      <P>4. Первый поток вызывает pthread_rwlock_unlock и блокируется навсегда при вызове pthread_mutex_lock (листинг 8.8), потому что взаимное исключение все еще заблокировано отмененным потоком.</P>
      <P>Если мы уберем вызов pthread_rwlock_unlock в функции thread1, функция main выведет вот что:</P>
      <P><CODE>rw_refcount = 1, rw_nwaitreaders = 0, rw_nwaitwriters = 1</CODE></P>
      <P><CODE>pthread_rwlock_destroy error: Device busy</CODE> </P>
      <P>Первый счетчик имеет значение 1, поскольку мы удалили вызов pthread_rwlock_ unlock, а последний счетчик имеет значение 1, поскольку он был увеличен вторым потоком до того, как тот был отменен.</P>
      <P>Исправить эту проблему просто. Сначала добавим две строки к функции pthread_rwlock_rdlock в листинге 8.4. Строки отмечены знаком +:</P>
      <P><CODE>  rw-&gt;rw_nwaitreaders++;</CODE></P>
      <P><CODE>+ pthread_cleanup_push(rwlock_cancelrdwait, (void *) rw);</CODE></P>
      <P><CODE>  result = pthread_cond_wait(&amp;rw-&gt;rw_condreaders, &amp;rw-&gt;rw_mutex);</CODE></P>
      <P><CODE>+ pthread_cleanup_pop(0);</CODE></P>
      <P><CODE>  rw-&gt;rw_nwaitreaders++;</CODE></P>
      <P>Первая новая строка устанавливает обработчик-очиститель (функцию rwlock_cancelrdwait), а его единственным аргументом является указатель rw. После возвращения из pthread_cond_wait вторая новая строка удаляет обработчик. Аргумент функции pthread_cleanup_pop означает, что функцию-обработчик при этом вызывать не следует. Если этот аргумент имеет ненулевое значение, обработчик будет сначала вызван, а затем удален.</P>
      <P>Если поток будет отменен при вызове pthread_cond_wait, возврата из нее не произойдет. Вместо этого будут запущены обработчики (после блокирования соответствующего взаимного исключения, как мы отметили в пункте 3 чуть выше).</P>
      <P>В листинге 8.10 приведен текст функции rwlock_cancelrdwait, являющейся обработчиком-очистителем для phtread_rwlock_rdlock.</P>
      <H2><a name=label348 style="border:none;"></a>Листинг 8.10. Функция rwlock_cancelrdwait: обработчик для блокировки чтения</H2>
      <P><CODE>//my_rwlock_cancel/pthread_rwlock_rdlock.с</CODE></P>
      <P><CODE>3  static void</CODE></P>
      <P><CODE>4  rwlock_cancelrdwait(void *arg)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   pthread_rwlock_t *rw;</CODE></P>
      <P><CODE>7   rw = arg;</CODE></P>
      <P><CODE>8   rw-&gt;rw_nwaitreaders--;</CODE></P>
      <P><CODE>9   pthread_mutex_unlock(&amp;rw-&gt;rw_mutex);</CODE></P>
      <P><CODE>10 }</CODE></P>
      <P>8-9 Счетчик rw_nwaitreaders уменьшается, а затем разблокируется взаимное исключение. Это состояние, которое должно быть восстановлено при отмене потока.</P>
      <P>Аналогично мы исправим текст функции pthread_rwlock_wrlock из листинга 8.6. Сначала добавим две новые строки рядом с вызовом pthread_cond_wait:</P>
      <P><CODE>  rw-&gt;rw_nwaitreaders++;</CODE></P>
      <P><CODE>+ pthread_cleanup_push(rwlock_cancelrwrwait, (void*) rw);</CODE></P>
      <P><CODE>  result = pthread_cond_wait(&amp;rw-&gt;rw_condwriters, &amp;rw-&gt;rw_mutex);</CODE></P>
      <P><CODE>+ pthread_cleanup_pop(0);</CODE></P>
      <P><CODE>  rw-&gt;rw_nwaitreaders--;</CODE></P>
      <P>В листинге 8.11 приведен текст функции rwlock_cancelwrwait, являющейся обработчиком-очистителем для запроса блокировки на запись.</P>
      <H2><a name=label349 style="border:none;"></a>Листинг 8.11. Функция rwlock_cancelwrwait: обработчик для блокировки записи</H2>
      <P><CODE>//my_rwlock_cancel/pthread_rwlock_wrlock.с</CODE></P>
      <P><CODE>3  static void</CODE></P>
      <P><CODE>4  rwlock_cancelwrwait(void *arg)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   pthread_rwlock_t *rw;</CODE></P>
      <P><CODE>7   rw = arg;</CODE></P>
      <P><CODE>8   rw-&gt;rw_nwaitwriters––;</CODE></P>
      <P><CODE>9   pthread_mutex_unlock(&amp;rw-&gt;rw_mutex);</CODE></P>
      <P><CODE>10 }</CODE></P>
      <P>8-9 Счетчик rw_nwaitwriters уменьшается, и взаимное исключение разблокируется. При запуске нашей тестовой программы из листинга 8.9 с этими новыми функциями мы получим правильные результаты:</P>
      <P><CODE>solaris %<STRONG>testcancel</STRONG></CODE></P>
      <P><CODE>thread1() got a read lock</CODE></P>
      <P><CODE>thread2() trying to obtain a write lock</CODE></P>
      <P><CODE>rw_refcount = 0, rw_nwaitreaders = 0, rw_nwaitwriters = 0</CODE></P>
      <P>Теперь три счетчика имеют правильные значения, первый поток возвращается из вызова pthread_rwlock_unlock, а функция pthread_rwlock_destroy не возвращает ошибку EBUSY.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Этот раздел представляет собой обзор вопросов, связанных с отменой выполнения потоков. Для более детального изучения этих проблем можно обратиться, например, к разделу 5.3 книги [3].</P>
      </DIV>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label350 style="border:none;"></a>8.6. Резюме</P>
     </H1>
     <P>Блокировки чтения-записи позволяют лучше распараллелить работу с данными, чем обычные взаимные исключения, если защищаемые данные чаще считываются, чем изменяются. Функции для работы с этими блокировками определены стандартом Unix 98, их мы и описываем в этой главе. Аналогичные или подобные им функции должны появиться в новой версии стандарта Posix. По виду функции аналогичны функциям для работы со взаимными исключениями (глава 7).</P>
     <P>Блокировки чтения-записи легко реализовать с использованием взаимных исключений и условных переменных. Мы приводим пример возможной реализации. В нашей версии приоритет имеют записывающие потоки, но в некоторых других версиях приоритет может быть отдан и считывающим потокам.</P>
     <P>Потоки могут быть отменены в то время, когда они находятся в заблокированном состоянии, в частности при вызове pthread_cond_wait, и на примере нашей реализации мы убедились, что при этом могут возникнуть проблемы. Решить эту проблему можно путем использования обработчиков-очистителей.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label351 style="border:none;"></a>Упражнения</P>
     </H1>
     <P>1. Измените реализацию в разделе 8.4 таким образом, чтобы приоритет имели считывающие, а не записывающие потоки.</P>
     <P>2. Сравните скорость работы нашей реализации из раздела 8.4 с предоставленной производителем. </P>
    </DIV>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label352 style="border:none;"></a>ГЛАВА 9</P>
     <P>Блокирование записей</P>
    </H1>
    <DIV class=section>
     <H1>
      <P><a name=label353 style="border:none;"></a>9.1. Введение</P>
     </H1>
     <P>Блокировки чтения-записи, описанные в предыдущей главе, представляют собой хранящиеся в памяти переменные типа pthread_rwlock_t. Эти переменные могут использоваться потоками одного процесса (этот режим работы установлен по умолчанию) либо несколькими процессами при условии, что переменные располагаются в разделяемой этими процессами памяти и при их инициализации был установлен атрибут PTHREAD_PROCESS_SHARED,</P>
     <P>В этой главе описан усовершенствованный тип блокировки чтения-записи, который может использоваться родственными и неродственными процессами при совместном доступе к файлу. Обращение к блокируемому файлу осуществляется через его дескриптор, а функция для работы с блокировкой называется fcntl. Такой тип блокировки обычно хранится в ядре, причем информация о владельце блокировки хранится в виде его идентификатора процесса. Таким образом, блокировки записей fcntl могут использоваться только несколькими процессами, но не отдельными потоками одного процесса.</P>
     <P>В этой главе мы в первый раз встретимся с нашим примером на увеличение последовательного номера. Рассмотрим следующую ситуацию, с которой столкнулись, например, разработчики спулера печати для Unix (команда lpr в BSD и lp в System V). Процесс, помещающий задания в очередь печати для последующей их обработки другим процессом, должен присваивать каждому из них уникальный последовательный номер. Идентификатор процесса, уникальный во время его выполнения, не может использоваться как последовательный номер, поскольку задание может просуществовать достаточно долго для того, чтобы этот идентификатор был повторно использован другим процессом. Процесс может также отправить на печать несколько заданий, каждому из которых нужно будет присвоить уникальный номер. Метод, используемый спулерами печати, заключается в том, чтобы хранить очередной порядковый номер задания для каждого принтера в отдельном файле. Этот файл содержит всего одну строку с порядковым номером в формате ASCII. Каждый процесс, которому нужно воспользоваться этим номером, должен выполнить следующие три действия:</P>
     <P>1. Считать порядковый номер из файла.</P>
     <P>2. Использовать этот номер.</P>
     <P>3. Увеличить его на единицу и записать обратно в файл.</P>
     <P>Проблема в том, что пока один процесс выполняет эти три действия, другой процесс может параллельно делать то же самое. В итоге возникнет полный беспорядок с номерами, как мы увидим в следующих примерах.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Описанная выше проблема называется проблемой взаимных исключений. Она может быть решена с использованием взаимных исключений из главы 7 или блокировок чтения-записи из главы 8. Различие состоит в том, что здесь мы предполагаем неродственность процессов, что усложняет использование предложенных выше методов. Мы могли бы использовать разделяемую память (подробно об этом говорится в четвертой части книги), поместив в нее переменную синхронизации одного из этих типов, но для неродственных процессов проще воспользоваться блокировкой fcntl. Другим фактором в данном случае стало то, что проблема со спулерами печати возникла задолго до появления взаимных исключений, условных переменных и блокировок чтения-записи. Блокировка записей была добавлена в Unix в начале 80-х, до того как появились концепции разделяемой памяти и программных потоков.</P>
     </DIV>
     <P>Таким образом, процессу нужно заблокировать файл, чтобы никакой другой процесс не мог получить к нему доступ, пока первый выполняет свои три действия. В листинге 9.2 приведен текст простой программы, выполняющей соответствующие действия. Функции my_lock и my_unlock обеспечивают блокирование и разблокирование файла в соответствующие моменты. Мы приведем несколько возможных вариантов реализации этих функций.</P>
     <P>20 Каждый раз при прохождении цикла мы выводим имя программы (argv[0]) перед порядковым номером, поскольку эта функция main будет использоваться с различными версиями функций блокировки и нам бы хотелось видеть, какая версия программы выводит данную последовательность порядковых номеров.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Вывод идентификатора процесса требует преобразования переменной типа pid_t к типу long и последующего использования строки формата %ld. Проблема тут в том, что идентификатор процесса принадлежит к одному из целых типов, но мы не знаем, к какому именно, поэтому предполагается наиболее вместительный — long. Если бы мы предположили, что идентификатор имеет тип int и использовали бы строку %d, a pid_t на самом деле являлся бы типом long, код мог бы работать неправильно.</P>
     </DIV>
     <P>Посмотрим, что будет, если не использовать блокировку. В листинге 9.1<A HREF="#n_1" onmouseover="ShowBookNote('n_1')" onmouseout="HideBookNote('n_1')"><SUP>[1]</SUP></A> приведены версии функций my_lock и my_unlock, которые вообще ничего не делают.</P>
     <H2><a name=label354 style="border:none;"></a>Листинг 9.1. Функции, не осуществляющие блокировку</H2>
     <P><CODE>//lock/locknone.c</CODE></P>
     <P><CODE>1  void</CODE></P>
     <P><CODE>2  my_lock(int fd)</CODE></P>
     <P><CODE>3  {</CODE></P>
     <P><CODE>4   return;</CODE></P>
     <P><CODE>5  }</CODE></P>
     <BR>
     <P><CODE>6  void</CODE></P>
     <P><CODE>7  my_unlock(int fd)</CODE></P>
     <P><CODE>8  {</CODE></P>
     <P><CODE>9   return;</CODE></P>
     <P><CODE>10 }</CODE></P>
     <H2><a name=label355 style="border:none;"></a>Листинг 9.2. Функция main для примеров с блокировкой файла</H2>
     <P><CODE>//lock/lockmain.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #define SEQFILE "seqno" /* имя файла */</CODE></P>
     <BR>
     <P><CODE>3  void my_lock(int), my_unlock(int);</CODE></P>
     <P><CODE>4  int</CODE></P>
     <P><CODE>5  main(int argc, char **argv)</CODE></P>
     <P><CODE>6  {</CODE></P>
     <P><CODE>7   int fd;</CODE></P>
     <P><CODE>8   long i, seqno;</CODE></P>
     <P><CODE>9   pid_t pid;</CODE></P>
     <P><CODE>10  ssize_t n;</CODE></P>
     <P><CODE>11  char line[MAXLINE + 1];</CODE></P>
     <P><CODE>12  pid = getpid();</CODE></P>
     <P><CODE>13  fd = Open(SEQFILE, O_RDWR, FILE_MODE);</CODE></P>
     <P><CODE>14  for (i = 0; i &lt; 20; i++) {</CODE></P>
     <P><CODE>15   my_lock(fd); /* блокируем файл */</CODE></P>
     <P><CODE>16   Lseek(fd, 0L, SEEK_SET); /* переходим к его началу */</CODE></P>
     <P><CODE>17   n = Read(fd, line, MAXLINE);</CODE></P>
     <P><CODE>18   line[n] = '\0'; /* завершающий 0 для sscanf */</CODE></P>
     <P><CODE>19   n = sscanf(line, "%ld\n", &amp;seqno);</CODE></P>
     <P><CODE>20   printf(%s; pid = %ld, seq# = %ld\n", argv[0], (long) pid, seqno);</CODE></P>
     <P><CODE>21   seqno++; /* увеличиваем порядковый номер */</CODE></P>
     <P><CODE>22   snprintf(line, sizeof(line), "%ld\n", seqno);</CODE></P>
     <P><CODE>23   Lseek(fd, 0L, SEEK_SET); /* переходим на начало перед записью */</CODE></P>
     <P><CODE>24   Write(fd, line, strlen(line));</CODE></P>
     <P><CODE>25   my_unlock(fd); /* разблокируем файл */</CODE></P>
     <P><CODE>26  }</CODE></P>
     <P><CODE>27  exit(0);</CODE></P>
     <P><CODE>28 }</CODE></P>
     <P>Если начальное значение порядкового номера в файле было 1 и был запущен только один экземпляр программы, мы увидим следующий результат:</P>
     <P><CODE>solaris % <STRONG>locknone</STRONG></CODE></P>
     <P><CODE>locknone: pid = 15491, seq# = 1</CODE></P>
     <P><CODE>locknone: pid = 15491, seq# = 2</CODE></P>
     <P><CODE>locknone: pid = 15491, seq# = 3</CODE></P>
     <P><CODE>locknone: pid = 15491, seq# = 4</CODE></P>
     <P><CODE>locknone: pid = 15491. seq# = 5</CODE></P>
     <P><CODE>locknone: pid = 15491, seq# = 6</CODE></P>
     <P><CODE>locknone: pid = 15491, seq# = 7</CODE></P>
     <P><CODE>locknone: pid = 15491, seq# – 8</CODE></P>
     <P><CODE>locknone: pid = 15491, seq# = 9</CODE></P>
     <P><CODE>locknone: pid = 15491, seq# = 10</CODE></P>
     <P><CODE>locknone: pid = 15491, seq# = 11</CODE></P>
     <P><CODE>locknone: pid = 15491, seq# = 12</CODE></P>
     <P><CODE>locknone: pid = 15491, seq# = 13</CODE></P>
     <P><CODE>locknone: pid = 15491, seq# = 14</CODE></P>
     <P><CODE>locknone: pid = 15491, seq# = 15</CODE></P>
     <P><CODE>locknone: pid = 15491, seq# = 16</CODE></P>
     <P><CODE>locknone: pid = 15491, seq# = 17</CODE></P>
     <P><CODE>locknone: pid = 15491, seq# = 18</CODE></P>
     <P><CODE>locknone: pid = 15491, seq# = 19</CODE></P>
     <P><CODE>locknone: pid = 15491, seq# = 20</CODE></P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Обратите внимание, что функция main хранится в файле lockmain.c, но мы компилируем и компонуем эту программу с функциями, не осуществляющими никакой блокировки (листинг 9.1), поэтому мы называем ее locknone. Ниже будут использоваться другие версии функций my_lock и my_unlock, и исполняемый файл будет называться по-другому в соответствии с используемым методом блокировки.</P>
     </DIV>
     <P>Установим значение последовательного номера в файле обратно в единицу и запустим программу в двух экземплярах в фоновом режиме. Результат будет такой:</P>
     <P><CODE>solaris % <STRONG>locknone &amp; locknone&amp;</STRONG></CODE></P>
     <P><CODE>solaris % locknone: pid = 15498, seq# = 1</CODE></P>
     <P><CODE>locknone: pid = 15498, seq# = 2</CODE></P>
     <P><CODE>locknone: pid = 15498, seq# = 3</CODE></P>
     <P><CODE>locknone: pid = 15498, seq# = 4</CODE></P>
     <P><CODE>locknone: pid = 15498, seq# = 5</CODE></P>
     <P><CODE>locknone: pid = 15498, seq# = 6</CODE></P>
     <P><CODE>locknone: pid = 15498, seq# = 7</CODE></P>
     <P><CODE>locknone: pid = 15498, seq# = 8</CODE></P>
     <P><CODE>locknone: pid = 15498, seq# = 9</CODE></P>
     <P><CODE>locknone: pid = 15498, seq# = 10</CODE></P>
     <P><CODE>locknone: pid = 15498, seq# = 11</CODE></P>
     <P><CODE>locknone: pid = 15498, seq# = 12</CODE></P>
     <P><CODE>locknone: pid = 15498, seq# = 13</CODE></P>
     <P><CODE>locknone: pid = 15498, seq# = 14</CODE></P>
     <P><CODE>locknone: pid = 15498, seq# = 15</CODE></P>
     <P><CODE>locknone: pid = 15498, seq# = 16</CODE></P>
     <P><CODE>locknone: pid = 15498, seq# = 17</CODE></P>
     <P><CODE>locknone: pid = 15498, seq# = 18</CODE></P>
     <P><CODE>locknone: pid = 15498, seq# = 19</CODE></P>
     <P><CODE>locknone: pid = 15498, seq# = 20</CODE></P>
     <P><CODE>locknone: pid = 15499, seq# = 1</CODE></P>
     <P><CODE>locknone: pid = 15499, seq# = 2</CODE></P>
     <P><CODE>locknone: pid = 15499, seq# = 3</CODE></P>
     <P><CODE>locknone: pid = 15499, seq# = 4</CODE></P>
     <P><CODE>locknone: pid = 15499, seq# = 5</CODE></P>
     <P><CODE>locknone: pid = 15499, seq# = 6</CODE></P>
     <P><CODE>locknone: pid = 15499, seq# = 7</CODE></P>
     <P><CODE>locknone: pid = 15499, seq# = 8</CODE></P>
     <P><CODE>locknone: pid = 15499, seq# = 9</CODE></P>
     <P><CODE>locknone: pid – 15499, seq# = 10</CODE></P>
     <P><CODE>locknone: pid = 15499, seq# = 11</CODE></P>
     <P><CODE>locknone: pid = 15499, seq# – 12</CODE></P>
     <P><CODE>locknone: pid = 15499, seq# = 13</CODE></P>
     <P><CODE>locknone: pid = 15499, seq# = 14</CODE></P>
     <P><CODE>locknone: pid = 15499, seq# = 15</CODE></P>
     <P><CODE>locknone: pid = 15499, seq# = 16</CODE></P>
     <P><CODE>locknone: pid = 15499, seq# = 17</CODE></P>
     <P><CODE>locknone: pid = 15499, seq# = 18</CODE></P>
     <P><CODE>locknone: pid = 15499, seq# = 19</CODE></P>
     <P><CODE>locknone: pid = 15499, seq# = 20</CODE></P>
     <P>Первое, на что мы обращаем внимание, — подсказка интерпретатора, появившаяся до начала текста, выводимого программой. Это нормально и всегда имеет место при запуске программ в фоновом режиме.</P>
     <P>Первые двадцать строк вывода не содержат ошибок. Они были сформированы первым экземпляром программы (с идентификатором 15 498). Проблема возникает в первой строке, выведенной вторым экземпляром (идентификатор 15499): он напечатал порядковый номер 1. Получилось это, скорее всего, так: второй процесс был запущен ядром, считал из файла порядковый номер (1), а затем управление было передано первому процессу, который работал до завершения. Затем второй процесс снова получил управление и продолжил выполняться с тем значением порядкового номера, которое было им уже считано (1). Это не то, что нам нужно. Каждый процесс считывает значение, увеличивает его и записывает обратно 20 раз (на экран выведено ровно 40 строк), поэтому конечное значение номера должно быть 40.</P>
     <P>Нам нужно каким-то образом предотвратить изменение файла с порядковым номером на протяжении выполнения трех действий одним из процессов. Эти действия должны выполняться как атомарная операция по отношению к другим процессам. Код между вызовами my_lock и my_unlock представляет собой критическую область (глава 7).</P>
     <P>При запуске двух экземпляров программы в фоновом режиме результат на самом деле непредсказуем. Нет никакой гарантии, что при каждом запуске мы будем получать один и тот же результат. Это нормально, если три действия будут выполняться как одна атомарная операция; в этом случае конечное значение порядкового номера все равно будет 40. Однако при неатомарном выполнении конечное значение часто будет отличным от 40, и это нас не устраивает. Например, нам безразлично, будет ли порядковый номер увеличен от 1 до 20 первым процессом и от 21 до 40 вторым или же процессы будут по очереди увеличивать его значение на единицу. Неопределенность не делает результат неправильным, а вот атомарность выполнения операций — делает. Однако неопределенность выполнения усложняет отладку программ.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label356 style="border:none;"></a>9.2. Блокирование записей и файлов</P>
     </H1>
     <DIV class=section>
      <P>Ядро Unix никак не интерпретирует содержимое файла, оставляя всю обработку записей приложениям, работающим с этим файлом. Тем не менее для описания предоставляемых возможностей используется термин «блокировка записей». В действительности приложение указывает диапазон байтов файла для блокирования или разблокирования. Сколько логических записей помещается в этот диапазон — значения не имеет.</P>
      <P>Стандарт Posix определяет один специальный диапазон с началом в 0 (начало файла) и длиной 0 байт, который устанавливает блокировку для всего файла целиком. Мы будем говорить о блокировке записей, подразумевая блокировку файла как частный случай.</P>
      <P>Термин «степень детализации» (granularity) используется для описания минимального размера блокируемого объекта. Для стандарта Posix эта величина составляет 1 байт. Обычно степень детализации связана с максимальным количеством одновременных обращений к файлу. Пусть, например, с некоторым файлом одновременно работают пять процессов, из которых три считывают данные из файла и два записывают в него. Предположим также, что каждый процесс работает со своим набором записей и каждый запрос требует примерно одинакового времени для обработки (1 секунда). Если блокировка осуществляется на уровне файла (самый низкий уровень детализации), три считывающих процесса смогут работать со своими записями одновременно, а двум записывающим придется ждать окончания их работы. Затем запись будет произведена сначала одним из оставшихся процессов, а потом другим. Полное затраченное время будет порядка 3 секунд (это, разумеется, очень грубая оценка). Если же уровень детализации соответствует размеру записи (наилучший уровень детализации), все пять процессов смогут работать одновременно, поскольку они обрабатывают разные записи. При этом на выполнение будет затрачена только одна секунда.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Потомки BSD поддерживают лишь блокировку файла целиком с помощью функции flock. Возможность заблокировать диапазон байтов не предусматривается. </P>
      </DIV>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label357 style="border:none;"></a>История</P>
      </H1>
      <P>За долгие годы было разработано множество методов блокировки файлов и записей. Древние программы вроде UUCP и демонов печати играли на реализации файловой системы (три из них описаны в разделе 9.8). Они работали достаточно медленно и не подходили для баз данных, которые стали появляться в начале 80-х.</P>
      <P>Первый раз возможность блокировать файлы и записи появилась в Version 7, куда она была добавлена Джоном Бассом John Bass) в 1980 году в виде нового системного вызова locking. Это блокирование было обязательным (mandatory locking); его унаследовали многие версии System III и Xenix. (Разница между обязательным и рекомендательным блокированием и между блокированием записей и файлов описана далее в этой главе.)</P>
      <P>Версия 4.2BSD предоставила возможность блокирования файлов (а не записей) функцией flock в 1983. В 1984 году стандарт /usr/group (один из предшественников Х/Open) определил функцию lockf, которая осуществляла только исключающую блокировку (на запись), но не совместную.</P>
      <P>В 1984 году в System V Release 2 была добавлена возможность рекомендательной блокировки записей с помощью fcntl. Функция lockf в этой версии также имелась, но она осуществляла просто вызов fcntl. (Многие нынешние версии также реализуют lockf через вызов fcntl.) В 1986 году в версии System V Release 3 появилась обязательная блокировка записей с помощью fcntl. При этом использовался бит set-group-ID (установка идентификатора группы) — об этом методе рассказано в разделе 9.5.</P>
      <P>В 1988 году стандарт Posix.1 включил в себя рекомендательную и обязательную блокировку файлов и записей с помощью функции fcntl, и это именно то, что является предметом обсуждения данной главы. Стандарт X/Open Portability Guide Issue 3 (XPG3, 1988) также указывает на необходимость осуществления блокировки записей через fcntl.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label358 style="border:none;"></a>9.3. Блокирование записей с помощью fcntl по стандарту Posix</P>
     </H1>
     <DIV class=section>
      <P>Согласно стандарту Posix, интерфейсом для блокировки записей является функция fcntl:</P>
      <P><CODE>#include &lt;fcntl.h&gt;</CODE></P>
      <P><CODE>int fcntl(int <EM>fd,</EM> int <EM>cmd,… /*</EM> struct flock <EM>*arg</EM> */);</CODE></P>
      <P><CODE>/* Возвращает –1 в случае ошибки: результат, возвращаемый в случае успешного завершения, зависит от аргумента <EM>cmd</EM> */</CODE></P>
      <P>Для блокировки записей используются три различных значения аргумента <EM>cmd.</EM> Эти три значения требуют, чтобы третий аргумент, <EM>arg,</EM> являлся указателем на структуру flock:</P>
      <P><CODE>struct flock {</CODE></P>
      <P><CODE> short l_type;   /* F_RDLCK, F_WRLCK, F_UNLCK */</CODE></P>
      <P><CODE> short l_whence; /* SEEK_SET, SEEK_CUR, SEEK_END */</CODE></P>
      <P><CODE> off_t l_start;  /* относительный сдвиг в байтах */</CODE></P>
      <P><CODE> off_t l_len;    /* количество байтов; 0 означает до конца файла */</CODE></P>
      <P><CODE> pid_t l_pid;    /* PID, возвращаемый F_GETLK */</CODE></P>
      <P><CODE>};</CODE></P>
      <P>Вот три возможные команды (значения аргумента <EM>cmd</EM> ):</P>
      <P>■ F_SETLK — получение блокировки (l_type имеет значение либо F_RDLCK, либо F_WRLCK) или сброс блокировки (l_type имеет значение F_UNLCK), свойства которой определяются структурой flock, на которую указывает <EM>arg.</EM> Если процесс не может получить блокировку, происходит немедленный возврат с ошибкой EACCESS или EAGAIN.</P>
      <P>■ F_SETLKW — эта команда идентична предыдущей. Однако при невозможности блокирования ресурса процесс приостанавливается, до тех пор пока блокировка не сможет быть получена (W в конце команды означает «wait»).</P>
      <P>■ F_GETLK — проверка состояния блокировки, на которую указывает <EM>arg.</EM> Если в данный момент блокировка не установлена, поле l_type структуры flock, на которую указывает <EM>arg,</EM> будет иметь значение F_UNLCK. В противном случае в структуре flock, на которую указывает <EM>arg,</EM> возвращается информация об установленной блокировке, включая идентификатор процесса, заблокировавшего ресурс. </P>
      <P>Обратите внимание, что последовательный вызов F_GETLK и F_SETLK не является атомарной операцией. Если мы вызвали F_GETLK и она вернула значение F_UNLCK в поле l_type, это не означает, что немедленный вызов F_SETLK будет успешным. Между этими двумя вызовами другой процесс мог уже заблокировать ресурс.</P>
      <P>Причина, по которой была введена команда F_GETLK, — необходимость получения информации о блокировке в том случае, когда F_SETLK возвращает ошибку. Мы можем узнать, кто и каким образом заблокировал ресурс (на чтение или на запись). Но и в этом случае мы должны быть готовы к тому, что F_GETLK вернет результат F_UNLCK, поскольку между двумя вызовами другой процесс мог освободить ресурс.</P>
      <P>Структура flock описывает тип блокировки (чтение или запись) и блокируемый диапазон. Как и в 1 seek, начальный сдвиг представляет собой сдвиг относительно начала файла, текущего положения или конца файла, и интерпретируется в зависимости от значения поля l_whence (SEEK_SET, SEEK_CUR, SEEK_END).</P>
      <P>Поле l_len указывает длину блокируемого диапазона. Значение 0 соответствует блокированию от l_start до конца файла. Существуют, таким образом, два способа заблокировать файл целиком:</P>
      <P>1. Указать l_whence = SEEK_SET, l_start = 0 и l_len = 0.</P>
      <P>2. Перейти к началу файла с помощью lseek, затем указать l_whence = SEEK_CUR, l_start = 0 и l_len = 0.</P>
      <P>Чаще всего используется первый метод, поскольку он предусматривает единственный вызов (fcntl — см. также упражнение 9.10).</P>
      <P>Блокировка может быть установлена либо на чтение, либо на запись, и для конкретного байта файла может быть задан только один тип блокировки. Более того, на конкретный байт может быть установлено несколько блокировок на чтение, но только одна блокировка на запись. Это соответствует тому, что говорилось о блокировках чтения-записи в предыдущей главе. Естественно, при попытке установить блокировку на чтение для файла, открытого только на запись, будет возвращена ошибка.</P>
      <P>Все блокировки, установленные конкретным процессом, снимаются при закрытии дескриптора файла этим процессом и при завершении его работы. Блокировки не наследуются дочерним процессом при вызове fork.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Снятие блокировок при завершении процесса обеспечивается только для блокировок записей fcntl и (в качестве дополнительной возможности) для семафоров System V. Для других средств синхронизации (взаимных исключений, условных переменных, блокировок чтения-записи и семафоров Posix) автоматическое снятие при завершении процесса не предусматривается. Об этом мы говорили в конце раздела 7.7. </P>
      </DIV>
      <P>Блокировка записей не должна использоваться со стандартной библиотекой ввода-вывода, поскольку функции из этой библиотеки осуществляют внутреннюю буферизацию. С заблокированными файлами следует использовать функции read и write, чтобы не возникало неожиданных проблем. </P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label359 style="border:none;"></a>Пример</P>
      </H1>
      <P>Вернемся к нашему примеру из листинга 9.2 и перепишем функции my_lock и my_unlock из листинга 9.1 так, чтобы воспользоваться блокировкой записей Posix. Текст этих функций приведен в листинге 9.3.</P>
      <H2><a name=label360 style="border:none;"></a>Листинг 9.3. Блокировка записей fcntl по стандарту Posix</H2>
      <P><CODE>//lock/lockfcntl.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  void</CODE></P>
      <P><CODE>3  my_lock(int fd)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   struct flock lock;</CODE></P>
      <P><CODE>6   lock.l_type = F_WRLCK;</CODE></P>
      <P><CODE>7   lock.l_whence = SEEK_SET;</CODE></P>
      <P><CODE>8   lock.l_start = 0;</CODE></P>
      <P><CODE>9   lock.l_len = 0; /* блокирование всего файла на запись */</CODE></P>
      <P><CODE>10  Fcntl(fd, F_SETLKW, &amp;lock);</CODE></P>
      <P><CODE>11 }</CODE></P>
      <BR>
      <P><CODE>12 void</CODE></P>
      <P><CODE>13 my_unlock(int fd)</CODE></P>
      <P><CODE>14 {</CODE></P>
      <P><CODE>15  struct flock lock;</CODE></P>
      <P><CODE>16  lock.l_type = F_UNLCK;</CODE></P>
      <P><CODE>17  lock.l_whence = SEEK_SET;</CODE></P>
      <P><CODE>18  lock.l_start = 0;</CODE></P>
      <P><CODE>19  lock.l_len = 0; /* разблокирование всего файла */</CODE></P>
      <P><CODE>20  Fcntl(fd. F_SETLK, &amp;lock);</CODE></P>
      <P><CODE>21 }</CODE></P>
      <P>Обратите внимание, что мы устанавливаем блокировку на запись, что гарантирует единственность изменяющего данные процесса (см. упражнение 9.4). При получении блокировки мы используем команду F_SETLKW, чтобы приостановить выполнение процесса при невозможности установки блокировки.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Зная определение структуры flock, приведенное выше, мы могли бы проинициализировать структуру my_lock как</P>
       <P><CODE>static struct flock lock = { F_WRLCK, SEEK_SET, 0, 0, 0 };</CODE></P>
       <P>но это неверно. Posix определяет только обязательные поля структуры, а реализации могут менять их порядок и добавлять к ним дополнительные.</P>
      </DIV>
      <P>Мы не приводим результат работы пpoгрaммы, но она, судя по всему, работает правильно. Выполнение этой программы не дает возможности утверждать, что в ней нет ошибок. Если результат оказывается неправильным, то можно сказать с уверенностью, что что-то не так. Но успешное выполнение программы еще ни о чем не говорит. Ядро могло выполнить сначала одну программу, затем другую, и если они не выполнялись параллельно, мы не имеем возможности увидеть ошибку. Увеличить шансы обнаружения ошибки можно, изменив функцию main таким образом, чтобы последовательный номер увеличивался 10000 раз, и запустив 20 экземпляров программы одновременно. Если начальное значение последовательного номера в файле было 1, мы можем ожидать, что после завершения работы всех этих процессов мы увидим в файле число 200001.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label361 style="border:none;"></a>Пример: упрощение с помощью макросов</P>
      </H1>
      <P>В листинге 9.3 установка и снятие блокировки занимали шесть строк кода. Мы должны выделить место под структуру, инициализировать ее и затем вызвать fcntl. Программы можно упростить, если определить следующие семь макросов, которые взяты из раздела 12.3 [21]:</P>
      <P><CODE>#define read_lock(fd, offset, whence, len) \</CODE></P>
      <P><CODE> lock_reg(fd, F_SETLK, F_RDLCK, offset, whence, len)</CODE></P>
      <P><CODE>#define readw_lock(fd, offset, whence, len) \</CODE></P>
      <P><CODE> lock_reg(fd, F_SETLKW, F_RDlCK, offset, whence, len)</CODE></P>
      <P><CODE>#define write_lock(fd, offset, whence, len) \</CODE></P>
      <P><CODE> lock_reg(fd, F_SETLK, F_WRLCK, offset, whence, len)</CODE></P>
      <P><CODE>#define writew_lock(fd, offset, whence, len) \</CODE></P>
      <P><CODE> lock_reg(fd, F_SETLKW, F_WRLCK, offset, whence, len)</CODE></P>
      <P><CODE>#define un_lock(fd, offset, whence, len) \</CODE></P>
      <P><CODE> lock_reg(fd, F_SETLK, F_UNLCK, offset, whence, len)</CODE></P>
      <P><CODE>#define is_read_lockable(fd, offset, whence, len) \</CODE></P>
      <P><CODE> lock_test(fd, F_RDLCK, offset, whence, len)</CODE></P>
      <P><CODE>#define is_write_lockable(fd, offset, whence, len) \</CODE></P>
      <P><CODE> lock_test(fd, F_WRLCK, offset, whence, len)</CODE></P>
      <P>Эти макросы используют наши функции lock_reg и lock_test, текст которых приведен в листингах 9.4 и 9.5. С ними нам уже не нужно заботиться об инициализации структур и вызове функций. Первые три аргумента специально сделаны совпадающими с первыми тремя аргументами функции lseek.</P>
      <P>Мы также определяем две функции-обертки, Lock_reg и Lock_test, завершающие свое выполнение с возвратом ошибки fcntl, и семь макросов с именами, начинающимися с заглавной буквы, чтобы эти функции вызывать.</P>
      <P>С помощью новых макросов мы можем записать функции my_lock и my_unlock из листинга 9.3 как</P>
      <P><CODE>#define my_lock(fd) (Writew_lock(fd, 0, SEEK_SET, 0))</CODE></P>
      <P><CODE>#define my_unlock(fd) (Un_lock(fd, 0, SEEK_SET, 0))</CODE></P>
      <H2><a name=label362 style="border:none;"></a>Листинг 9.4. Вызов fcntl для получения и снятия блокировки</H2>
      <P><CODE>//lib/lock_reg.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  lock_reg(int fd, int cmd, int type, off_t offset, int whence, off_t len)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   struct flock lock;</CODE></P>
      <P><CODE>6   lock.l_type = type; /* F_RDLCK, F_WRLCK, F_UNLCK */</CODE></P>
      <P><CODE>7   lock.l_start = offset; /* сдвиг по отношению к l_whence */</CODE></P>
      <P><CODE>8   lock.l_whence = whence; /* SEEK SET. SEEK CUR, SEEK END */</CODE></P>
      <P><CODE>9   lock.l_len = len; /* количество байтов (0 – до конца файла) */</CODE></P>
      <P><CODE>10  return(fcnt(fd, cmd, &amp;lock)"); /* –1 в случае ошибки */</CODE></P>
      <P><CODE>11 }</CODE></P>
      <H2><a name=label363 style="border:none;"></a>Листинг 9.5. Вызов fcntl для проверки состояния блокировки</H2>
      <P><CODE>//lib/lock_test.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  pid_t</CODE></P>
      <P><CODE>3  lock_test(int fd, int type, off_t offset, int whence, off_t len)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   struct flock lock;</CODE></P>
      <P><CODE>6   lock.l_type = type; /* F_RDLCK or F_WRLCK */</CODE></P>
      <P><CODE>7   lock.l_start = offset; /* сдвиг по отношению к l_whence */</CODE></P>
      <P><CODE>8   lock.l_whence = whence; /* SEEK_SET, SEEK_CUR, SEEK_END */</CODE></P>
      <P><CODE>9                      lock.l_len = len; /* количество байтов. 0 – до конца файла */</CODE></P>
      <P><CODE>10 if (fcntl(fd, F_GETLK, &amp;lock) == –1)</CODE></P>
      <P><CODE>11 return(-1); /* непредвиденная ошибка */</CODE></P>
      <P><CODE>12 if (lock.l_type == F_UNLCK)</CODE></P>
      <P><CODE>13 return(0); /* false, область не заблокирована другим процессом */</CODE></P>
      <P><CODE>14 return(lock.l_pid); /* true, возвращается положительный PID процесса. заблокировавшего ресурс */</CODE></P>
      <P><CODE>15 }</CODE></P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label364 style="border:none;"></a>9.4. Рекомендательная блокировка</P>
     </H1>
     <DIV class=section>
      <P>Блокировка записей по стандарту Posix называется рекомендательной. Ядро хранит информацию обо всех заблокированных различными процессами файлах, но оно не предотвращает запись в заблокированный на чтение процесс. Ядро также не предотвращает чтение из файла, заблокированного на запись. Процесс может игнорировать рекомендательную блокировку (advisory lock) и действовать по своему усмотрению (если у него имеются соответствующие разрешения на чтение и запись).</P>
      <P>Рекомендательные блокировки отлично подходят для сотрудничающих процессов (cooperating processes). Примером сотрудничающих процессов являются сетевые демоны: все они находятся под контролем системного администратора. Пока в файл, содержащий порядковый номер, запрещена запись, никакой процесс не сможет его изменить.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label365 style="border:none;"></a>Пример: несотрудничающие процессы</P>
      </H1>
      <P>Мы можем проиллюстрировать рекомендательный характер блокировок, запустив два экземпляра нашей программы, один из которых (lockfcntl) использует функции из листинга 9.3 и блокирует файл перед увеличением последовательного номера, а другой (locknone) использует функции из листинга 9.1 и не устанавливает никаких блокировок:</P>
      <P><CODE>solaris % <STRONG>lockfcntl &amp; locknone &amp;</STRONG></CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 1</CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 2</CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 3</CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 4</CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 5</CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 6</CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 7</CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 8</CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 9</CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 10</CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 11</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 11</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 12</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 13</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 14</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 15</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 16</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 17</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 18</CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 12</CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 13</CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 14</CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 15</CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 16</CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 17</CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 18</CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 19</CODE></P>
      <P><CODE>lockfcntl: pid = 18816, seq# = 20</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 19</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 20</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 21</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 22</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 23</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 24</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 25</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 26</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 27</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 28</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 29</CODE></P>
      <P><CODE>locknone: pid = 18817, seq# = 30</CODE></P>
      <P>Программа lockfcntl запускается первой, но в тот момент, когда она выполняет три действия для увеличения порядкового номера с 11 до 12 (в этот момент файл заблокирован), ядро переключается на второй процесс и запускает пpoгрaмму locknone. Этот процесс считывает значение 11 из файла с порядковым номером и использует его. Рекомендательная блокировка, установленная для этого файла пpoгрaммoй lockfcntl, никак не влияет на работу программы locknone.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label366 style="border:none;"></a>9.5. Обязательная блокировка</P>
     </H1>
     <DIV class=section>
      <P>Некоторые системы предоставляют возможность установки блокировки другого типа — обязательной (mandatory locking). В этом случае ядро проверяет все вызовы read и write, блокируя их при необходимости. Если для дескриптора установлен флаг O_NONBLOCK, вызов read или write, конфликтующий с установленной блокировкой, вернет ошибку EAGAIN. Если флаг O_NONBLOCK не установлен, выполнение процесса в такой ситуации будет отложено до тех пор, пока ресурс не освободится.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Стандарты Posix.1 и Unix 98 определяют только рекомендательную блокировку. Во многих реализациях, производных от System V, имеется возможность установки как рекомендательной, так и обязательной блокировки. Обязательная блокировка записей впервые появилась в System V Release 3.</P>
      </DIV>
      <P>Для установки обязательной блокировки какого-либо файла требуется выполнение двух условий:</P>
      <P>■ бит group-execute должен быть снят;</P>
      <P>■ бит set-group–ID должен быть установлен.</P>
      <P>Обратите внимание, что установка бита set-user– ID без установки user-execute смысла не имеет; аналогично и с битами set-group-ID и group-execute. Таким образом, добавление возможности обязательной блокировки никак не повлияло на работу используемого программного обеспечения. Не потребовалось и добавлять новые системные вызовы.</P>
      <P>В системах, поддерживающих обязательную блокировку записей, команда ls просматривает файлы на наличие указанной специальной комбинации битов и выводит буквы l или L, указывающие на то, что для данного файла включена обязательная блокировка. Аналогично команда chmod принимает аргумент l, позволяющий включить для указанного файла обязательную блокировку.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label367 style="border:none;"></a>Пример</P>
      </H1>
      <P>На первый взгляд, использование обязательной блокировки должно решить проблему с несотрудничающими процессами, поскольку все операции чтения и записи будут приостановлены до снятия блокировки. К сожалению, проблемы с одновременными обращениями к ресурсу являются гораздо более сложными, чем кажется, что мы можем легко продемонстрировать.</P>
      <P>Чтобы использовать в нашем примере обязательную блокировку, изменим биты разрешений файла seqno. Кроме того, мы будем использовать новую версию функции main, которая принимает количество проходов цикла for в качестве аргумента командной строки (вместо использования константы 20) и не вызывает printf при каждом проходе цикла:</P>
      <P><CODE>solaris % <STRONG>cat &gt; seqno    </STRONG><EM>инициализируем файл единицей</EM></CODE></P>
      <P><CODE><STRONG>1</STRONG></CODE></P>
      <P><CODE><STRONG>^D                      </STRONG><EM>конец файла</EM></CODE></P>
      <P><CODE>solaris % <STRONG>ls –l seqno</STRONG></CODE></P>
      <P><CODE>-rw-r--r-- 1 rstevens other1 2 Oct 7 11:24 seqno</CODE></P>
      <P><CODE>solaris % <STRONG>chmod +l seqno </STRONG><EM>включение обязательной блокировки</EM></CODE></P>
      <P><CODE>solaris % <STRONG>ls -l seqno</STRONG></CODE></P>
      <P><CODE>-rq-r-lr-- 1 rstevens other1 2 Oct 7 11:24 seqno</CODE></P>
      <P>Теперь запустим две программы в качестве фоновых процессов: loopfcntl использует блокировку записей fcntl, а loopnone не использует блокировку вовсе. </P>
      <P>Укажем в командной строке аргумента 10000 — количество последовательных увеличений порядкового номера.</P>
      <P><CODE>solaris % <STRONG>loopfcntl 10000 &amp; loopnone 10000 &amp;</STRONG> <EM>запуск фоновых процессов</EM></CODE></P>
      <P><CODE>solaris % <STRONG>wait</STRONG>                                   <EM>ожидание их завершения</EM></CODE></P>
      <P><CODE>solaris % <STRONG>cat seqno</STRONG>                             <EM>вывод последовательного номера</EM></CODE></P>
      <P><CODE>14378                                            <EM>ошибка, должно быть 20001</EM></CODE></P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader152" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 9.1. Временная диаграмма работы программ loopfcntl и loopnone</P>
      <BR>
      <P>Каждый раз при выполнении этих программ результат будет между 14000 и 16000. Если бы блокировка работала так как надо, он всегда был бы равен 20001. Чтобы понять, где же возникает ошибка, нарисуем временную диaгрaммy выполнения процессов, изображенную на рис. 9.1. </P>
      <P>Предположим, что loopfcntl запускается первой и выполняет первые восемь действий, изображенных на рисунке. Затем ядро передает управление другому процессу в тот момент, когда установлена блокировка на файл с порядковым номером. Запускается процесс loopnone, но он блокируется в первом вызове read, потому что на файл, который он пытается читать, установлена обязательная блокировка. Затем ядро передает управление первому процессу, который выполняет шаги 13-15. Пока все работает именно так, как мы предполагали, — ядро защищает файл от чтения несотрудничающим процессом, когда этот файл заблокирован.</P>
      <P>Дальше ядро передает управление программе loopnone, которая выполняет шаги 17-23. Вызовы read и write разрешены, поскольку файл был разблокирован на шаге 15. Проблема возникает в тот момент, когда программа считывает значение 5 на шаге 23, а ядро в этот момент передает управление другому процессу. Он устанавливает блокировку и также считывает значение 5. Затем он дважды увеличивает это значение (получается 7), и управление передается loopnone на шаге 36. Однако эта программа записывает в файл значение 6. Так и возникает ошибка.</P>
      <P>На этом примере мы видим, что обязательная блокировка предотвращает доступ к заблокированному файлу (шаг 11), но это не решает проблему. Проблема заключается в том, что левый процесс (на рисунке) может обновить содержимое файла (шаги 25-34) в тот момент, когда процесс справа также находится в состоянии обновления данных (шаги 23, 36 и 37). Если файл обновляется несколькими процессами, все они должны сотрудничать, используя некоторую форму блокировки. Один неподчиняющийся процесс может все разрушить.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label368 style="border:none;"></a>9.6. Приоритет чтения и записи</P>
     </H1>
     <DIV class=section>
      <P>В нашей реализации блокировок чтения-записи в разделе 8.4 приоритет предоставлялся ожидающим записи процессам. Теперь мы изучим детали возможного решения задачи читателей и писателей с помощью блокировки записей fcntl. Хочется узнать, как обрабатываются накапливающиеся запросы на блокировку, когда ресурс уже заблокирован. Стандарт Posix этого никак не оговаривает.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label369 style="border:none;"></a>Пример: блокировка на чтение при наличии в очереди блокировки на запись</P>
      </H1>
      <P>Первый вопрос, на который мы попытаемся найти ответ, звучит так: если ресурс заблокирован на чтение и какой-то процесс послал запрос на установление блокировки на запись, будет ли при этом разрешена установка еще одной блокировки на чтение? Некоторые решения задачи читателей и писателей не разрешают установки еще одной блокировки на чтение в случае, если есть ожидающий своей очереди пишущий процесс, поскольку если бы разрешалось непрерывное подключение считывающих процессов, запрос на запись, возможно, никогда бы не был удовлетворен.</P>
      <P>Чтобы проверить, как эта ситуация разрешится при использовании блокировки записей fcntl, напишем тестовую программу, устанавливающую блокировку на чтение для всего файла и затем порождающую два процесса с помощью fork. </P>
      <P>Первый из них пытается установить блокировку на запись (и блокируется, поскольку родительский процесс установил блокировку на чтение для всего файла), а второй процесс секунду спустя пытается получить блокировку на чтение. Временная диаграмма этих запросов изображена на рис. 9.2, а в листинге 9.6 приведен текст нашей программы. </P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader153" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 9.2. Определение возможности установки блокировки на чтение при наличии<STRONG>в</STRONG>очереди блокировки на запись</P>
      <BR>
      <H2><a name=label370 style="border:none;"></a>Листинг 9.6. Определение возможности установки блокировки на чтение при наличии в очереди блокировки на запись</H2>
      <P><CODE>//lock/test2.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int fd;</CODE></P>
      <P><CODE>6   fd = Open("test1.data", O_RDWR | O_CREAT, FILE_MODE);</CODE></P>
      <P><CODE>7   Read_lock(fd, 0, SEEK_SET, 0); /* родительский процесс блокирует весь файл на чтение */</CODE></P>
      <P><CODE>8   printf("%s: parent has read lock\n", Gf_time());</CODE></P>
      <P><CODE>9   if (Fork() == 0) {</CODE></P>
      <P><CODE>10   /* первый дочерний процесс */</CODE></P>
      <P><CODE>11   sleep(1);</CODE></P>
      <P><CODE>12   printf("%s: first child tries to obtain write lock\n", Gf_time());</CODE></P>
      <P><CODE>13   Writew_lock(fd, 0, SEEK_SET, 0); /* здесь он будет заблокирован */</CODE></P>
      <P><CODE>14   printf("%s: first child obtains write lock\n", Gf_time());</CODE></P>
      <P><CODE>15   sleep(2);</CODE></P>
      <P><CODE>16   Un_lock(fd, 0, SEEK_SET, 0);</CODE></P>
      <P><CODE>17   printf("ls: first child releases write lock\n", Gf_time());</CODE></P>
      <P><CODE>18   exit(0);</CODE></P>
      <P><CODE>19  }</CODE></P>
      <P><CODE>20  if (Fork() == 0) {</CODE></P>
      <P><CODE>21   /* второй дочерний процесс */</CODE></P>
      <P><CODE>22   sleep(3);</CODE></P>
      <P><CODE>23   printf("%s: second child tries to obtain read lock\n", Gf_time());</CODE></P>
      <P><CODE>24   Readw_lock(fd, 0, SEEK_SET, 0);</CODE></P>
      <P><CODE>25   printf("%s: second child obtains read lock\n", Gf_time());</CODE></P>
      <P><CODE>26   sleep(4);</CODE></P>
      <P><CODE>27   Un_lock(fd, 0, SEEK_SET, 0);</CODE></P>
      <P><CODE>28   printf("%s: second child releases read lock\n", Gf_time());</CODE></P>
      <P><CODE>29   exit(0);</CODE></P>
      <P><CODE>30  }</CODE></P>
      <P><CODE>31  /* родительский процесс */</CODE></P>
      <P><CODE>32  sleep(5);</CODE></P>
      <P><CODE>33  Un_lock(fd, 0, SEEK_SET, 0);</CODE></P>
      <P><CODE>34  printf("%s: parent releases read lock\n", Gf_time());</CODE></P>
      <P><CODE>35  exit(0);</CODE></P>
      <P><CODE>36 }</CODE></P>
      <H2><a name=label371 style="border:none;"></a>Родительский процесс открывает файл и получает блокировку на чтение</H2>
      <P>6-8 Родительский процесс открывает файл и устанавливает блокировку на чтение для всего файла целиком. Обратите внимание, что мы вызываем read_lock (которая возвращает ошибку в случае недоступности ресурса), а не readw_lock (которая ждет его освобождения), потому что мы ожидаем, что эта блокировка будет установлена немедленно. Мы также выводим значение текущего времени функцией gf_time [24, с. 404], когда получаем блокировку.</P>
      <H2><a name=label372 style="border:none;"></a>Первый дочерний процесс</H2>
      <P>9-19 Порождается первый процесс, который ждет 1 секунду и блокируется в ожидании получения блокировки на запись для всего файла. Затем он устанавливает эту блокировку, ждет 2 секунды, снимает ее и завершает работу.</P>
      <H2><a name=label373 style="border:none;"></a>Второй дочерний процесс</H2>
      <P>20-30 Порождается второй процесс, который ждет 3 секунды, давая возможность первому попытаться установить блокировку на запись, а затем пытается получить блокировку на чтение для всего файла. По моменту возвращения из функции readw_lock мы можем узнать, был ли ресурс предоставлен немедленно или второму процессу пришлось ждать первого. Блокировка снимается через четыре секунды.</P>
      <H2><a name=label374 style="border:none;"></a>Родительский процесс блокирует ресурс 5 секунд</H2>
      <P>31-35 Родительский процесс ждет пять секунд, снимает блокировку и завершает работу.</P>
      <P>На рис. 9.2 приведена временная диаграмма выполнения программы в Solaris 2.6, Digital Unix 4.0B и BSD/OS 3.1. Как видно, блокировка чтения предоставляется второму дочернему процессу немедленно, несмотря на наличие в очереди запроса на блокировку записи. Существует вероятность, что запрос на запись так и не будет выполнен, если будут постоянно поступать новые запросы на чтение. Ниже приведен результат выполнения программы, в который были добавлены пустые строки для улучшения читаемости:</P>
      <P><CODE>alpha % <STRONG>test2</STRONG></CODE></P>
      <P><CODE>16:32:29.674453: parent has read lock</CODE></P>
      <BR>
      <P><CODE>16:32:30.709197: first child tries to obtain write lock</CODE></P>
      <BR>
      <P><CODE>16:32:32.725810: second child tries to obtain read lock</CODE></P>
      <P><CODE>16:32:32.728739: second child obtains read lock</CODE></P>
      <BR>
      <P><CODE>16:32:34.722282: parent releases read lock</CODE></P>
      <BR>
      <P><CODE>16:32:36.729738: second child releases read lock</CODE></P>
      <P><CODE>16:32:36.735597: first child obtains write lock</CODE></P>
      <BR>
      <P><CODE>16:32:38.736938: first child releases write lock</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label375 style="border:none;"></a>Пример: имеют ли приоритет запросы на запись перед запросами на чтение?</P>
      </H1>
      <P>Следующий вопрос, на который мы попытаемся дать ответ, таков: есть ли приоритет у запросов на блокировку записи перед запросами на блокировку чтения, если все они находятся в очереди? Некоторые решения задачи читателей и писателей предусматривают это.</P>
      <P>В листинге 9.7 приведен текст нашей тестовой программы, а на рис. 9.3 — временная диаграмма ее выполнения.</P>
      <H2><a name=label376 style="border:none;"></a>Листинг 9.7. Есть ли у писателей приоритет перед читателями</H2>
      <P><CODE>//lock/test3.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int fd;</CODE></P>
      <P><CODE>6   fd = Open("test1.data", O_RDWR | O_CREAT, FILE_MODE);</CODE></P>
      <P><CODE>7   Write_lock(fd, 0, SEEK_SET, 0); /* родительский процесс блокирует весь файл на запись */</CODE></P>
      <P><CODE>8   printf("ls: parent has write lock\n", Gf_time());</CODE></P>
      <P><CODE>9   if (Fork() == 0) {</CODE></P>
      <P><CODE>10   /* первый дочерний процесс */</CODE></P>
      <P><CODE>11   sleep(1);</CODE></P>
      <P><CODE>12   printf("ls: first child tries to obtain write lock\n", Gf_time());</CODE></P>
      <P><CODE>13   Writew_lock(fd, 0, SEEK_SET, 0); /* здесь процесс будет заблокирован */</CODE></P>
      <P><CODE>14   printf("%s: first child obtains write lock\n", Gf_time());</CODE></P>
      <P><CODE>15   sleep(2);</CODE></P>
      <P><CODE>16   Un_lock(fd, 0, SEEK_LET, 0);</CODE></P>
      <P><CODE>17   printf("ls: first child releases write lock\n", Gf_time());</CODE></P>
      <P><CODE>18   exit(0);</CODE></P>
      <P><CODE>19  }</CODE></P>
      <P><CODE>20  if (Fork() == 0) {</CODE></P>
      <P><CODE>21   /* второй дочерний процесс */</CODE></P>
      <P><CODE>22   sleep(3);</CODE></P>
      <P><CODE>23   printf("ls: second child tries to obtain read lock\n", Gf_time());</CODE></P>
      <P><CODE>24   Readw_lock(fd, 0, SEEK_SET, 0);</CODE></P>
      <P><CODE>25   printf(%s: second child obtains read lock\n", Gf_time());</CODE></P>
      <P><CODE>26   sleep(4);</CODE></P>
      <P><CODE>27   Un_lock(fd, 0, SEEK_SET, 0);</CODE></P>
      <P><CODE>28   printf("ls: second child releases read lock\n", Gf_time());</CODE></P>
      <P><CODE>29   exit(0);</CODE></P>
      <P><CODE>30  }</CODE></P>
      <P><CODE>31  /* родительский процесс */</CODE></P>
      <P><CODE>32  sleep(5);</CODE></P>
      <P><CODE>33  Un_lock(fd, 0, SEEK_SET, 0);</CODE></P>
      <P><CODE>34  printf("ls: parent releases write lock\n", Gf_time());</CODE></P>
      <P><CODE>35  exit(0);</CODE></P>
      <P><CODE>36 }</CODE></P>
      <H2><a name=label377 style="border:none;"></a>Родительский процесс создает файл и устанавливает блокировку на запись</H2>
      <P>6-8 Родительский процесс создает файл и блокирует его целиком на запись.</P>
      <H2><a name=label378 style="border:none;"></a>Первый дочерний процесс</H2>
      <P>9-19 Порождается первый процесс, который ждет одну секунду, а затем запрашивает блокировку на запись для всего файла. Мы знаем, что при этом процесс будет заблокирован, поскольку родительский процесс установил блокировку и снимет ее только через пять секунд, и мы хотим, чтобы этот запрос был помещен в очередь.</P>
      <H2><a name=label379 style="border:none;"></a>Второй дочерний процесс</H2>
      <P>20-30 Порождается второй процесс, который ждет три секунды, а затем запрашивает блокировку на чтение на весь файл. Этот запрос будет также помещен в очередь.</P>
      <P>И в Solaris 2.6, и в Digital Unix 4.0B мы видим, что блокировка на запись предоставляется первому процессу, как изображено на рис. 9.3. Но это еще не означает, что у запросов на запись есть приоритет перед запросами на чтение, поскольку, возможно, ядро предоставляет блокировку в порядке очереди вне зависимости от того, на чтение она или на запись. Чтобы проверить это, мы создаем еще одну тестовую программу, практически идентичную приведенной в листинге 9.7, но в ней блокировка на чтение запрашивается через одну секунду, а блокировка на запись — через три секунды. Эти две программы иллюстрируют, что Solaris и Digital Unix обрабатывают запросы в порядке очереди вне зависимости от типа запроса. Однако в BSD/OS 3.1 приоритет имеют запросы на чтение. </P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader154" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 9.3. Есть ли у писателей приоритет перед читателями</P>
      <BR>
      <P>Вот вывод программы из листинга 9.7, на основании которого была составлена временная диaгрaммa на рис. 9.3:</P>
      <P><CODE>alpha % <STRONG>test3</STRONG></CODE></P>
      <P><CODE>16:34:02.810285: parent has write lock</CODE></P>
      <P><CODE>16:34:03.848166: first child tries to obtain write lock</CODE></P>
      <P><CODE>16:34:05.861082: second child tries to obtain read lock</CODE></P>
      <P><CODE>16:34:07.858393: parent releases write lock</CODE></P>
      <P><CODE>16:34:07.865222: first child obtains write lock</CODE></P>
      <P><CODE>16:34:09.865987: first child releases write lock</CODE></P>
      <P><CODE>16:34:09.872823: second child obtains read lock</CODE></P>
      <P><CODE>16:34:13.873822: second child releases read lock</CODE></P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label380 style="border:none;"></a>9.7. Запуск единственного экземпляра демона</P>
     </H1>
     <P>Часто блокировки записей используются для обеспечения работы какой-либо пpoгрaммы (например, демона) в единственном экземпляре. Фрагмент кода, приведенный в листинге 9.8, должен выполняться при запуске демона.</P>
     <H2><a name=label381 style="border:none;"></a>Листинг 9.8. Гарантия выполнения единственного экземпляра программы</H2>
     <P><CODE>//lock/onedaemon.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #define PATH_PIDFILE "pidfile"</CODE></P>
     <BR>
     <P><CODE>3  int</CODE></P>
     <P><CODE>4  main(int argc, char **argv)</CODE></P>
     <P><CODE>5  {</CODE></P>
     <P><CODE>6   int pidfd;</CODE></P>
     <P><CODE>7   char line[MAXLINE];</CODE></P>
     <P><CODE>8   /* открытие или создание файла с идентификатором процесса */</CODE></P>
     <P><CODE>9   pidfd = Open(PATH_PIDFILE, O_RDWR | O_CREAT, FILE_MODE);</CODE></P>
     <P><CODE>10  /* попытка блокирования всего файла на запись */</CODE></P>
     <P><CODE>11  if (write_lock(pidfd, 0, SEEK_SET, 0) &lt; 0) {</CODE></P>
     <P><CODE>12   if (errno == EACCES || errno == EAGAIN)</CODE></P>
     <P><CODE>13    err_quit("unable to lock %s, is %s already running?",</CODE></P>
     <P><CODE>14     PATH_PIDFILE, argv[0]);</CODE></P>
     <P><CODE>15   else</CODE></P>
     <P><CODE>16    err_sys("unable to lock %s", PATH_PIDFILE):</CODE></P>
     <P><CODE>17  }</CODE></P>
     <P><CODE>18  /* запись идентификатора: файл остается открытым, чтобы он был заблокирован */</CODE></P>
     <P><CODE>19  snprintf(line, sizeof(line), "%ld\n", (long) getpid());</CODE></P>
     <P><CODE>20  Ftruncate(pidfd, 0);</CODE></P>
     <P><CODE>21  Write(pidfd, line, strlen(line));</CODE></P>
     <P><CODE>22  /* основной текст программы демона… */</CODE></P>
     <P><CODE>23  pause();</CODE></P>
     <P><CODE>24 }</CODE></P>
     <H2><a name=label382 style="border:none;"></a>Открытие и блокирование файла</H2>
     <P>8-17 Демон создает однострочный файл, в который записывает свой идентификатор процесса. Этот файл открывается или создается, а затем делается попытка Заблокировать его на запись целиком. Если блокировку установить не удается, мы понимаем, что один экземпляр демона уже запущен, поэтому выводится сообщение об ошибке и программа завершает работу.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Во многих версиях Unix демоны записывают свои идентификаторы в файл. Solaris 2.6 хранит подобные файлы в каталоге /etc, a Digital Unix 4.0B и BSD/OS — в каталоге /var/run.</P>
     </DIV>
     <H2><a name=label383 style="border:none;"></a>Запись идентификатора процесса в файл</H2>
     <P>18-21 Мы укорачиваем файл до 0 байт, а затем записываем в него строку с нашим идентификатором. Причина, по которой нужно укорачивать файл, заключается в том, что у предыдущего экземпляра демона идентификатор мог быть представлен более длинным числом, чем у данного, поэтому в результате в файле может образоваться смесь двух идентификаторов.</P>
     <P>Вот результат работы программы из листинга 9.8:</P>
     <P><CODE>solaris % <STRONG>onedaemon&amp;</STRONG>   <EM>запускаем первый экземпляр</EM></CODE></P>
     <P><CODE>[1] 22388</CODE></P>
     <P><CODE>solaris % <STRONG>cat pidfile </STRONG><EM>проверяем идентификатор</EM></CODE></P>
     <P><CODE>22388</CODE></P>
     <P><CODE>solaris % <STRONG>onedaemon   </STRONG><EM>пытаемся запустить второй экземпляр</EM></CODE></P>
     <P><CODE>unable to lock pidfile, is onedaemon already running?</CODE></P>
     <P>Существуют и другие способы предотвращения запуска нескольких экземпляров демонов, например семафоры. Преимущество данного метода в том, что многим демонам и так приходится записывать в файл свои идентификаторы, а при досрочном завершении работы демона блокировка с файла снимается автоматически.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label384 style="border:none;"></a>9.8. Блокирование файлов</P>
     </H1>
     <P>Стандарт Posix.1 гарантирует, что если функция open вызывается с флагами O_CREAT (создать файл, если он еще не существует) и O_EXCL (исключающее открытие), функция возвращает ошибку, если файл уже существует. Более того, проверка существования файла и его создание (если он еще не существует) должны представлять собой атомарную по отношению к другим процессам операцию. Следовательно, мы можем использовать создаваемый таким методом файл как блокировку. Можно быть уверенным, что только один процесс сможет создать файл (то есть получить блокировку), а для снятия этой блокировки файл можно удалить командой unlink.</P>
     <P>В листинге 9.9 приведен текст наших функций установки и снятия блокировки, использующих этот метод. При успешном выполнении функции open мы считаем, что блокировка установлена, и успешно возвращаемся из функции my_lock. Файл мы закрываем, потому что его дескриптор нам не нужен. О наличии блокировки свидетельствует само существование файла вне зависимости от того, открыт он или нет. Если функция open возвращает ошибку EEXIST, значит, файл существует и мы должны еще раз попытаться открыть его. </P>
     <P>У этого метода есть три недостатка.</P>
     <P>1. Если процесс, установивший блокировку, завершится досрочно, не сняв ее, файл не будет удален. Существуют способы борьбы с этой проблемой, например проверка времени доступа к файлу и удаление его спустя некоторый определенный промежуток времени, — но все они несовершенны. Другое решение заключается в записи в файл идентификатора процесса, чтобы другие процессы могли считать его и проверить, существует ли еще такой процесс. Этот метод также несовершенен, поскольку идентификатор может быть использован повторно.</P>
     <P>В такой ситуации лучше пользоваться блокировкой fcntl, которая автоматически снимается по завершении процесса.</P>
     <P>2. Если файл открыт каким-либо другим процессом, мы должны еще раз вызвать open, повторяя эти вызовы в бесконечном цикле. Это называется опросом и является напрасной тратой времени процессора. Альтернативным методом является вызов sleep на 1 секунду, а затем повторный вызов open (этапроблема обсуждалась в связи с листингом 7.4).</P>
     <P>Эта проблема также исчезает при использовании блокировки fcntl, если использовать команду F_SETLKW. Ядро автоматически приостанавливает выполнение процесса до тех пор, пока ресурс не станет доступен.</P>
     <P>3. Создание и удаление файла вызовом open и unlink приводит к обращению к файловой системе, что обычно занимает существенно больше времени, чем вызов fcntl (обращение производится дважды: один раз для получения блокировки, а второй — для снятия). При использовании fcntl программа выполнила 10000 повторов цикла с увеличением порядкового номера в 75 раз быстрее, чем программа, вызывавшая open и unlink.</P>
     <H2><a name=label385 style="border:none;"></a>Листинг 9.9. Функции блокировки с использованием open с флагами O_CREAT и O_EXCL</H2>
     <P><CODE>//lock/lockopen.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #define LOCKFILE "/tmp/seqno.lock"</CODE></P>
     <BR>
     <P><CODE>3  void</CODE></P>
     <P><CODE>4  my_lock(int fd)</CODE></P>
     <P><CODE>5  {</CODE></P>
     <BR>
     <P><CODE>6   int tempfd;</CODE></P>
     <P><CODE>7   while ((tempfd = open(LOCKFILE, O_RDWR|O_CREAT|O_EXCL, FILE_MODE)) &lt; 0) {</CODE></P>
     <P><CODE>8    if (errno != EEXIST)</CODE></P>
     <P><CODE>9     err_sys("open error for lock file");</CODE></P>
     <P><CODE>10   /* блокировка установлена кем-то другим, повторяем попытку */</CODE></P>
     <P><CODE>11  }</CODE></P>
     <P><CODE>12  Close(tempfd); /* открыли файл, блокировка установлена */</CODE></P>
     <P><CODE>13 }</CODE></P>
     <BR>
     <P><CODE>14 void</CODE></P>
     <P><CODE>15 my_unlock(int fd)</CODE></P>
     <P><CODE>16 {</CODE></P>
     <P><CODE>17  Unlink(LOCKFILE); /* снимаем блокировку удалением файла */</CODE></P>
     <P><CODE>18 }</CODE></P>
     <P>Есть еще две особенности файловой системы Unix, которые использовались для реализации блокировок. Первая заключается в том, что функция link возвращает ошибку, если имя новой ссылки уже существует. Для получения блокировки создается уникальный временный файл, полное имя которого содержит в себе его идентификатор процесса (или комбинацию идентификаторов процесса и потока, если требуется осуществлять блокировку между отдельными потоками). Затем вызывается функция link для создания ссылки на этот файл с каким-либо определенным заранее именем. После успешного создания сам файл может быть удален вызовом unlink. После осуществления работы с блокировкой файл с известным именем удаляется командой unlink. Если link возвращает ошибку EEXIST, поток должен попытаться создать ссылку еще раз (аналогично листингу 9.9). Одно из требований к этому методу — необходимо, чтобы и временный файл, и ссылка находились в одной файловой системе, поскольку большинство версий Unix не допускают создания жестких ссылок (результат вызова link) в разных файловых системах.</P>
     <P>Вторая особенность заключается в том, что функция open возвращает ошибку в случае существования файла, если указан флаг O_TRUNC и запрещен доступ на запись. Для получения блокировки мы вызываем open, указывая флаги O_CREAT | O_WRONLY | O_TRUNC и аргумент <EM>mode</EM> со значением 0 (то есть разрешения на доступ к файлу установлены в 0). Если вызов оказывается успешным, блокировка установлена и мы просто удаляем файл вызовом unlink после завершения работы. Если вызов open возвращает ошибку EACESS, поток должен сделать еще одну попытку (аналогично листингу 9.9). Этот трюк не срабатывает, если поток обладает правами привилегированного пользователя.</P>
     <P>Урок, который можно извлечь из этих примеров, прост: нужно пользоваться блокировкой fcntl. Тем не менее вы можете столкнуться с программой, в которой используются старые методы блокировки, и особенно часто это будет встречаться в программах, написанных до широкого распространения реализации с блокировкой fcntl.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label386 style="border:none;"></a>9.9. Блокирование в NFS</P>
     </H1>
     <P>Аббревиатура NFS расшифровывается как Network File System (сетевая файловая система); эта система подробно обсуждается в главе 29 [22]. Блокировка записей fcntl представляет собой расширение NFS, поддерживаемое большинством ее реализаций. Обслуживается эта блокировка двумя дополнительными демонами: lockd и statd. При вызове fcntl для получения блокировки ядро обнаруживает, что файл находится в файловой системе NFS. Тогда локальный демон lockd посылает демону lockd сервера запрос на получение блокировки. Демон statd хранит информацию о клиентах, установивших блокировку, и взаимодействует с lockd для обеспечения снятия блокировок в случае завершения процессов.</P>
     <P>Установка блокировки записи в NFS должна занимать в среднем больше времени, чем для локального файла, поскольку для установки и снятия блокировки требуется передача информации по сети. Для проверки работы блокировки NFS нужно всего лишь изменить имя файла, определяемое константой SEQFILE в листинге 9.2. Если измерить время, требуемое для выполнения 10000 операций по увеличению порядкового номера новой версией программы, оно окажется примерно в 80 раз больше, чем для локального файла. Однако нужно понимать, что в этом случае происходит передача информации по сети и при операциях чтения и записи (для изменения порядкового номера).</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Блокировка записей в NFS была связана с проблемами в течение многих лет, и большинство проблем были следствием плохой реализации. Несмотря на тот факт, что большинство производителей Unix все-таки доделали эту реализацию, использование блокировки fcntl через NFS все еще далеко от совершенства. Не будем делать безответственных утверждений: блокировка fcntl должна работать и в NFS, но будет ли — зависит от реализации демона и сервера. </P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label387 style="border:none;"></a>9.10. Резюме</P>
     </H1>
     <P>Блокирование записей с помощью fcntl предоставляет возможность установки рекомендательной или обязательной блокировки для файла, указываемого с помощью открытого дескриптора. Эти блокировки предназначены для сотрудничества процессов, но не отдельных потоков одного процесса. Термин «запись» используется не вполне корректно, поскольку ядро не различает отдельные записи в файле. Лучше использовать термин «блокировка диапазона», поскольку при установке блокировки или ее снятии указывается именно диапазон байтов в файле. Практически во всех случаях применения этой блокировки она является рекомендательной и используется при совместной работе сотрудничающих процессов, поскольку даже обязательная блокировка не может исключить повреждения данных.</P>
     <P>При использовании fcntl не гарантируется, что читающие или пишущие процессы имеют приоритет при ожидании (в отличие от того, что мы реализовали в главе 8 с блокировками чтения-записи). Если это важно для приложения, придется реализовать блокировки самостоятельно (как в разделе 8.4) с тем приоритетом, который требуется.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label388 style="border:none;"></a>Упражнения</P>
     </H1>
     <P>1. Создайте программу locknone из листингов 9.2 и 9.1 и выполните ее много раз. Убедитесь, что программа не работает и результат непредсказуем.</P>
     <P>2. Измените листинг 9.2 так, чтобы стандартный поток вывода не буферизовался. Как это повлияет на работу программы?</P>
     <P>3. Продолжайте изменять программу, вызывая putchar для каждого выводимого символа (вместо printf). Как изменится результат?</P>
     <P>4. Измените блокировку в функции my_lock из листинга 9.3 так, чтобы устанавливалась блокировка на чтение, а не на запись. Что произойдет?</P>
     <P>5. Измените вызов open в программе loopmain.c, указав также флаг O_NONBLOCK. Создайте программу loopfcntlnonb и запустите два экземпляра. Что произойдет? </P>
     <P>6. Продолжите предыдущий пример, используя неблокируемую версию loopmain.с для создания программы loopnonenonb (используя файл locknone.c). Включите обязательную блокировку для файла seqno. Запустите один экземпляр этой программы и один экземпляр программы loopfcntlnonb из предыдущего примера одновременно. Что произойдет?</P>
     <P>7. Создайте программу loopfcntl и запустите ее 10 раз в фоновом режиме из сценария интерпретатора команд. Каждому из 10 экземпляров следует указать аргумент 10000. Измерьте скорость работы сценария при использовании обязательной и рекомендательной блокировок. Как влияет обязательная блокировка на производительность?</P>
     <P>8. Почему мы вызывали fork в листингах 9.6 и 9.7 для порождения процессов, вместо того чтобы воспользоваться pthread_create для создания потоков?</P>
     <P>9. В листинге 9.9 мы вызываем ftruncate для установки размера файла в 0 байт. Почему бы нам просто не указать флаг O_TRUNC при открытии файла?</P>
     <P>10. Какой из констант — SEEK_SET, SEEK_CUR или SEEK_END — следует пользоваться при указании блокируемого диапазона при написании многопоточного приложения и почему? </P>
    </DIV>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label389 style="border:none;"></a>ГЛАВА 10</P>
     <P>Семафоры Posix</P>
    </H1>
    <DIV class=section>
     <H1>
      <P><a name=label390 style="border:none;"></a>10.1.Введение</P>
     </H1>
     <P>Семафор представляет собой простейшее средство синхронизации процессов и потоков. Мы рассматриваем три типа семафоров:</P>
     <P>■ именованные семафоры Posix, идентифицируемые именами, соответствующими стандарту Posix для IPC (см. раздел 2.2);</P>
     <P>■ размещаемые в разделяемой памяти семафоры Posix;</P>
     <P>■ семафоры System V (глава 11), обслуживаемые ядром.</P>
     <P>Все три типа семафоров могут использоваться для синхронизации как отдельных процессов, так и потоков одного процесса. Мы начнем с рассмотрения проблем синхронизации между разными процессами с помощью бинарного семафора, то есть такого, который может принимать только значения 0 и 1. Пример подобной схемы приведен на рис. 10.1.</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader157" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 10.1. Два процесса взаимодействуют с помощью бинарного семафора</P>
     <BR>
     <P>На этом рисунке изображен бинарный семафор, хранящийся в ядре (семафор System V).</P>
     <P>Семафоры Posix не обязательно должны обрабатываться ядром. Их особенностью является наличие имен, которые могут соответствовать именам реальных файлов в файловой системе. На рис. 10.2 изображена схема, лучше иллюстрирующая предмет обсуждения данной главы — именованный семафор Posix.</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader159" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 10.2. Два процесса, использующие бинарный именованный семафор Posix</P>
     <BR>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>В отношении рис. 10.2 необходимо сделать одно уточнение: хотя именованные семафоры Posix обладают именами в файловой системе, они не обязательно должны храниться в файлах. Во встроенной системе реального времени значение семафора, скорее всего, будет размещаться в ядре, а имя файла будет использоваться исключительно для идентификации семафора. При реализации с помощью отображения файлов в память (пример такой реализации приведен в разделе 10.15) значение семафора будет действительно храниться в файле, который будет отображаться в адресное пространство всех процессов, использующих семафор. </P>
     </DIV>
     <P>На рис. 10.1 и 10.2 мы указали три операции, которые могут быть применены к семафорам:</P>
     <P>1. Создание семафора. При этом вызвавший процесс должен указать начальное значение (часто 1, но может быть и 0).</P>
     <P>2. Ожидание изменения значения семафора <EM>(wait).</EM> При этом производится проверка его значения и процесс блокируется, если значение оказывается меньшим либо равным 0, а при превышении 0 значение уменьшается на 1. Это может быть записано на псевдокоде как </P>
     <P><CODE>while (semaphore_value &lt;= 0); /* wait: т.е. поток или процесс блокируется */</CODE></P>
     <P><CODE>semaphore_value--; /* семафор разрешает выполнение операций */</CODE></P>
     <P>Основным требованием является атомарность выполнения операций проверки значения в цикле while и последующего уменьшения значения семафора (то есть как одной операции) по отношению к другим потокам (это одна из причин, по которой семафоры System V были реализованы в середине 80-х как часть ядра. Поскольку операции с ними выполнялись с помощью системных вызовов, легко было гарантировать их атомарность по отношению к другим процессам).</P>
     <P>У этой операции есть несколько общеупотребительных имен. Изначально она называлась Р, от голландского proben (проверка, попытка), — это название было введено Эдсгером Дейкстрой. Используются также и термины down (поскольку значение семафора уменьшается) и lock, но мы будем следовать стандарту Posix и говорить об ожидании <EM>(wait).</EM> </P>
     <P>3. Установка значения семафора <EM>(post). </EM>Значение семафора увеличивается одной командой, которая может быть записана на псевдокоде как</P>
     <P><CODE>semaphore_value++;</CODE></P>
     <P>Если в системе имеются процессы, ожидающие изменения значения семафора до величины, превосходящей 0, один из них может быть пробужден. Как и операция ожидания, операция установки значения семафора также должна быть атомарной по отношению к другим процессам, работающим с этим семафором.</P>
     <P>Для этой операции также имеется несколько общеупотребительных терминов. Изначально она называлась V, от голландского verhogen (увеличивать). Называют ее up (значение семафора увеличивается), unlock и signal. Мы, следуя стандарту Posix, называем эту операцию <EM>post.</EM></P>
     <P>Очевидно, что реальный код для работы с семафором будет более сложным, чем приведенный выше. Все процессы, ожидающие изменения какого-либо семафора, должны помещаться в очередь, и один из них должен запускаться при выполнении требуемого условия. К счастью, это обеспечивается реализацией.</P>
     <P>Обратите внимание, что приведенный псевдокод не ограничен в применении только бинарными семафорами. Код работает с семафором, инициализируемым любым неотрицательным значением. Такие семафоры называют также семафорами-счетчиками. Обычно они инициализируются некоторым значением N, которое указывает количество доступных ресурсов (например, буферов). В этой главе есть примеры использования как бинарных семафоров, так и семафоров-счетчиков.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Мы часто проводим различие между бинарными и многозначными семафорами, но делаем это исключительно в образовательных целях. В системной реализации семафоров никакой разницы нет.</P>
     </DIV>
     <P>Бинарный семафор может использоваться в качестве средства исключения (подобно взаимному исключению). В листинге 10.1 приведен пример для сравнения этих средств.</P>
     <H2><a name=label391 style="border:none;"></a>Листинг 10.1. Сравнение бинарных семафоров и взаимных исключений</H2>
     <P><CODE>инициализация взаимного исключения;  инициализация семафора единицей;</CODE></P>
     <P><CODE>pthread_mutex_lock(&amp;mutex);          sem_wait(&amp;sem);</CODE></P>
     <P><CODE>критическая область                  критическая область</CODE></P>
     <P><CODE>pthread_mutex_unlock(&amp;mutex);        sem_post(&amp;sem);</CODE></P>
     <P>Мы инициализируем семафор значением 1. Вызвав sem_wait, мы ожидаем, когда значение семафора окажется больше 0, а затем уменьшаем его на 1. Вызов sem_post увеличивает значение с 0 до 1 и возобновляет выполнение всех потоков, заблокированных в вызове sem_wait для данного семафора.</P>
     <P>Хотя семафоры и могут использоваться в качестве взаимных исключений, они обладают некоторыми особенностями: взаимное исключение должно быть разблокировано именно тем потоком, который его заблокировал, в то время как увеличение значения семафора может быть выполнено другим потоком. Можно привести пример использования этой особенности для решения упрощенной версии задачи потребителей и производителей из главы 7 с двумя бинарными семафорами. На рис. 10.3 приведена схема с одним производителем, помещающим объект в общий буфер, и одним потребителем, изымающим его оттуда. Для простоты предположим, что в буфер помещается ровно один объект. </P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader161" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 10.3. Задача производителя и потребителя с общим буфером</P>
     <BR>
     <P>В листинге 10.2 приведен текст соответствующей программы на псевдокоде.</P>
     <H2><a name=label392 style="border:none;"></a>Листинг 10.2. Псевдокод для задачи производителя и потребителя</H2>
     <P><CODE>Producer                                Consumer</CODE></P>
     <P><CODE>инициализация семафора get значением 0;</CODE></P>
     <P><CODE>инициализация семафора put значением 1;</CODE></P>
     <P><CODE>for (;;) {                              for (;;) {</CODE></P>
     <P><CODE> sem_wait(&amp;put);                         sem_wait(&amp;get);</CODE></P>
     <P><CODE> помещение данных в буфер;               обработка данных в буфере;</CODE></P>
     <P><CODE> sem_post(&amp;get);                         sem_post(&amp;put);</CODE></P>
     <P><CODE>}                                       }</CODE></P>
     <P>Семафор put oгрaничивaeт возможность помещения объекта в общий буфер, а семафор get управляет потребителем при считывании объекта из буфера. Работает эта пpoгрaммa в такой последовательности:</P>
     <P>1. Производитель инициализирует буфер и два семафора.</P>
     <P>2. Пусть после этого запускается потребитель. Он блокируется при вызове sem_wait, поскольку семафор get имеет значение 0.</P>
     <P>3. После этого запускается производитель. При вызове sem_wait значение put уменьшается с 1 до 0, после чего производитель помещает объект в буфер. Вызовом sem_post значение семафора get увеличивается с 0 до 1. Поскольку имеется поток, заблокированный в ожидании изменения значения этого семафора, этот поток помечается как готовый к выполнению. Предположим, тем не менее, что производитель продолжает выполняться. В этом случае он блокируется при вызове sem_wait в начале цикла for, поскольку значение семафора put — 0. Производитель должен подождать, пока потребитель не извлечет данные из буфера.</P>
     <P>4. Потребитель возвращается из sem_wait, уменьшая значение семафора get с 0 до 1. Затем он обрабатывает данные в буфере и вызывает sem_post, увеличивая значение put с 0 до 1. Заблокированный в ожидании изменения значения этого семафора поток-производитель помечается как готовый к выполнению. Предположим опять, что выполнение потребителя продолжается. Тогда он блокируется при вызове sem_wait в начале цикла for, поскольку семафор get имеет значение 0.</P>
     <P>5. Производитель возвращается из sem_wait, помещает данные в буфер, и все повторяется.</P>
     <P>Мы предполагали, что каждый раз при вызове sem_post продолжалось выполнение вызвавшего эту функцию потока, несмотря на то что ожидающий изменения значения семафора поток помечался как готовый к выполнению. Никаких изменений в работе программы не произойдет, если вместо вызвавшего sem_post потока будет выполняться другой, ожидавший изменения состояния семафора (исследуйте такую ситуацию и убедитесь в этом самостоятельно).</P>
     <P>Перечислим три главных отличия семафоров и взаимных исключений в паре с условными переменными:</P>
     <P>1. Взаимное исключение всегда должно разблокироваться тем потоком, который установил блокировку, тогда как увеличение значения семафора не обязательно осуществляется ожидающим его изменения потоком. Это мы только что продемонстрировали на примере.</P>
     <P>2. Взаимное исключение может быть либо заблокировано, либо разблокировано (пара состояний, аналогично бинарному семафору).</P>
     <P>3. Поскольку состояние семафора хранится в определенной переменной, изменение его значения оказывает влияние на процессы, которые вызовут функцию wait уже после этого изменения, тогда как при отправке сигнала по условной переменной в отсутствие ожидающих его потоков сигнал будет утерян. Взгляните на листинг 10.2 и представьте, что при первом проходе цикла производителем потребитель еще не вызвал sem_wait. Производитель сможет поместить объект в буфер, вызвать sem_post для семафора get (увеличивая его значение с 0 до 1), а затем он заблокируется в вызове sem_wait для семафора put. Через некоторое время потребитель дойдет до цикла for и вызовет sem_wait для переменной get, что уменьшит значение этого семафора с 1 до 0, а затем потребитель приступит к обработке содержимого буфера.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>В Обосновании Posix.1 (Rationale) содержится следующий комментарий по поводу добавления семафоров помимо взаимных исключений и условных переменных: «Семафоры включены в стандарт в первую очередь с целью предоставить средства синхронизации выполнения процессов; эти процессы могут и не использовать общий сегмент памяти. Взаимные исключения и условные переменные описаны как средства синхронизации потоков, у которых всегда есть некоторое количество общей памяти. Оба метода широко используются уже много лет. Каждое из этих простейших средств имеет свой предпочтительный круг задач». В разделе 10.15 мы увидим, что для реализации семафоров-счетчиков с живучестью ядра требуется написать около 300 строк кода на С, использующего взаимные исключения и условные переменные. Несмотря на предпочтительность применения семафоров для синхронизации между процессами и взаимных исключений для синхронизации между потоками, и те и другие могут использоваться в обоих случаях. Следует пользоваться тем набором средств, который удобен в данном приложении.</P>
     </DIV>
     <P>Выше мы отмечали, что стандартом Posix описано два типа семафоров: именованные (named) и размещаемые в памяти (memory-based или unnamed). На рис. 10.4 сравниваются функции, используемые обоими типами семафоров.</P>
     <P>Именованный семафор Posix был изображен на рис. 10.2. Неименованный, или размещаемый в памяти, семафор, используемый для синхронизации потоков одного процесса, изображен на рис. 10.5.</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader163" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 10.4. Вызовы для семафоров Posix</P>
     <BR>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader164" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 10.5. Семафор, размещенный в общей памяти двух потоков</P>
     <BR>
     <P>На рис. 10.6 изображен размещенный в разделяемой памяти семафор (часть 4), используемый двумя процессами. Общий сегмент памяти принадлежит адресному пространству обоих процессов.</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader165" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 10.6. Семафор, размещенный в разделяемой двумя процессами памяти</P>
     <BR>
     <P>В этой главе сначала рассматриваются именованные семафоры Posix, а затем — размещаемые в памяти. Мы возвращаемся к задаче производителей и потребителей из раздела 7.3 и расширяем ее, позволяя нескольким производителям работать с одним потребителем, а в конце концов переходим к нескольким производителям и нескольким потребителям. Затем мы покажем, что часто используемый при реализации ввода-вывода метод множественных буферов является частным случаем задачи производителей и потребителей.</P>
     <P>Мы рассмотрим три реализации именованных семафоров Posix: с использованием каналов FIFO, отображаемых в память файлов и семафоров System V. </P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label393 style="border:none;"></a>10.2. Функции sem_open, sem_close и sem_unlink</P>
     </H1>
     <P>Функция sem_open создает новый именованный семафор или открывает существующий. Именованный семафор может использоваться для синхронизации выполнения потоков и процессов:</P>
     <P><CODE>#include &lt;semaphore.h&gt;</CODE></P>
     <P><CODE>sem_t *sem_open(const char <EM>*name,</EM> int <EM>oflag, …</EM></CODE></P>
     <P><CODE> /* mode_t <EM>mode,</EM> unsigned int <EM>value</EM> */);</CODE></P>
     <P><CODE>/* Возвращает указатель на семафор в случае успешного завершения, SEM_FAILED — в случае ошибки */</CODE></P>
     <P>Требования к аргументу <EM>пате</EM> приведены в разделе 2.2.</P>
     <P>Аргумент <EM>oflag</EM> может принимать значения 0, O_CREAT, O_CREAT | O_EXCL, как описано в разделе 2.3. Если указано значение O_CREAT, третий и четвертый аргументы функции являются обязательными. Аргумент <EM>mode</EM> указывает биты разрешений доступа (табл. 2.3), a <EM>value</EM> указывает начальное значение семафора. Это значение не может превышать константу SEM_VALUE_MAX, которая, согласно Posix, должна быть не менее 32767. Бинарные семафоры обычно устанавливаются в 1, тогда как семафоры-счетчики чаще инициализируются большими величинами.</P>
     <P>При указании флага O_CREAT (без O_EXCL) семафор инициализируется только в том случае, если он еще не существует. Если семафор существует, ошибки не возникнет. Ошибка будет возвращена только в том случае, если указаны флаги O_CREAT | O_EXCL.</P>
     <P>Возвращаемое значение представляет собой указатель на тип sem_t. Этот указатель впоследствии передается в качестве аргумента функциям sem_close, sem_wait, sem_trywait, sem_post и sem_getvalue.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Кажется странным возвращать SEM_FAILED в случае ошибки — нулевой указатель был бы более уместен. В ранних версиях стандарта Posix указывалось возвращаемое значение –1, и во многих реализациях константа SEM_FAILED определена как</P>
      <P><CODE>#define SEM_FAILED ((sem_t *)(-1))</CODE></P>
      <P>В Posix.1 мало говорится о битах разрешений, связываемых с семафором при его создании и открытии. Вспомните, мы говорили в связи с табл. 2.2 о том, что для именованных семафоров не нужно даже указывать флаги O_RDONLY, O_WRONLY и O_RDWR. В системах, на которых мы тестируем все программы этой книги (Digital Unix 4.0B и Solaris 2.6), для работы с семафором (его открытия) необходимо иметь к нему доступ как на чтение, так и на запись. Причина, скорее всего, в том, что обе операции, выполняемые с семафором (post и wait), состоят из считывания текущего значения и последующего его изменения. Отсутствие доступа на чтение или запись в этих реализациях приводит к возвращению функцией sem_open ошибки EACCESS ("Permission denied"). </P>
     </DIV>
     <P>Открыв семафор с помощью sem_open, можно потом закрыть его, вызвав sem_close:</P>
     <P><CODE>#include &lt;semaphore.h&gt;</CODE></P>
     <P><CODE>int sem_close(sem_t *<EM>sem</EM>);</CODE></P>
     <P><CODE>/* Возвращает 0 в случае успешного завершения. –1 – в случае ошибки */</CODE> </P>
     <P>Операция закрытия выполняется автоматически при завершении процесса для всех семафоров, которые были им открыты. Автоматическое закрытие осуществляется как при добровольном завершении работы (вызове exit или _exit), так и при принудительном (с помощью сигнала).</P>
     <P>Закрытие семафора не удаляет его из системы. Именованные семафоры Posix обладают по меньшей мере живучестью ядра. Значение семафора сохраняется, даже если ни один процесс не держит его открытым.</P>
     <P>Именованный семафор удаляется из системы вызовом sem_unlink:</P>
     <P><CODE>#include &lt;semaphore.h&gt;</CODE></P>
     <P><CODE>int sem_unlink(const char *<EM>name</EM>);</CODE></P>
     <P><CODE>/* Возвращает 0 в случае успешного завершения, –1 – в случае ошибки */</CODE></P>
     <P>Для каждого семафора ведется подсчет процессов, в которых он является открытым (как и для файлов), и функция sem_unlink действует аналогично unlink для файлов: объект <EM>пате</EM> может быть удален из файловой системы, даже если он открыт какими-либо процессами, но реальное удаление семафора не будет осуществлено до тех пор, пока он не будет окончательно закрыт.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label394 style="border:none;"></a>10.3. Функции sem_wait и sem_trywait</P>
     </H1>
     <P>Функция sem_wait проверяет значение заданного семафора на положительность, уменьшает его на единицу и немедленно возвращает управление процессу. Если значение семафора при вызове функции равно нулю, процесс приостанавливается, до тех пор пока оно снова не станет больше нуля, после чего значение семафора будет уменьшено на единицу и произойдет возврат из функции. Ранее мы отметили, что операция «проверка и уменьшение» должна быть атомарной по отношению к другим потокам, работающим с этим семафором:</P>
     <P><CODE>#include &lt;semaphore.h&gt;</CODE></P>
     <P><CODE>int sem_wait(sem_t *<EM>sem</EM>);</CODE></P>
     <P><CODE>int sem_trywait(sem_t *<EM>sem</EM>);</CODE></P>
     <P><CODE>/* Обе функции возвращают 0 в случае успешного завершения. –1 – в случае ошибки */</CODE></P>
     <P>Разница между sem_wait и sem_trywait заключается в том, что последняя не приостанавливает выполнение процесса, если значение семафора равно нулю, а просто немедленно возвращает ошибку EAGAIN.</P>
     <P>Возврат из функции sem_wait может произойти преждевременно, если будет получен сигнал. При этом возвращается ошибка с кодом EINTR.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label395 style="border:none;"></a>10.4. Функции sem_post и sem_getvalue</P>
     </H1>
     <P>После завершения работы с семафором поток вызывает sem_post. Как мы уже говорили в разделе 10.1, этот вызов увеличивает значение семафора на единицу и возобновляет выполнение любых потоков, ожидающих изменения значения семафора:</P>
     <P><CODE>#include &lt;semaphore.h&gt;</CODE></P>
     <P><CODE>int sem_post(sem_t *<EM>sem</EM>);</CODE></P>
     <P><CODE>int sem_getvalue(sem_t *<EM>sem</EM>, int *<EM>valp</EM>);</CODE></P>
     <P><CODE>/* Обе функции возвращают 0 в случае успешного завершения. –1 – в случае ошибки */</CODE> </P>
     <P>Функция sem_getvalue возвращает текущее значение семафора, помещая его в целочисленную переменную, на которую указывает valp. Если семафор заблокирован, возвращается либо 0, либо отрицательное число, модуль которого соответствует количеству потоков, ожидающих разблокирования семафора.</P>
     <P>Теперь мы ясно видим отличия семафоров от взаимных исключений и условных переменных. Прежде всего взаимное исключение может быть разблокировано только заблокировавшим его потоком. Для семафоров такого ограничения нет: один из потоков может ожидать изменения значения семафора, чтобы потом уменьшить его с 1 до 0 (действие аналогично блокированию семафора), а другой поток может изменить значение семафора с 0 до 1, что аналогично разблокированию семафора.</P>
     <P>Далее, поскольку любой семафор имеет некоторое значение, увеличиваемое операцией <EM>post</EM> и уменьшаемое операцией <EM>wait,</EM> поток может изменить его значение (например, увеличить с 0 до 1), даже если нет потоков, ожидающих его изменения. Если же поток вызывает pthread_cond_signal в отсутствие заблокированных при вызове pthread_cond_wait потоков, сигнал просто теряется.</P>
     <P>Наконец, среди всех функций, работающих со средствами синхронизации — взаимными исключениями, условными переменными, блокировками чтения-записи и семафорами, только одна может быть вызвана из обработчика сигналов: sem_post.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Не следует рассматривать приведенный выше текст как доводы в пользу семафоров. Все средства синхронизации, обсуждаемые в этой книге — взаимные исключения, условные переменные, блокировки чтения-записи, семафоры и блокировка fcntl, обладают своими преимуществами и недостатками. Выбирать средства синхронизации для приложения следует с учетом их многочисленных особенностей. Из нашего сравнительного описания можно сделать вывод, что взаимные исключения больше приспособлены для блокировки, условные переменные — для ожидания, а семафоры — для того и другого, и последнее может привести к излишнему усложнению текста программы.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label396 style="border:none;"></a>10.5. Простые примеры</P>
     </H1>
     <DIV class=section>
      <P>В этом разделе мы напишем несколько простых программ, работающих с именованными семафорами Posix. Эти программы помогут нам узнать особенности функционирования и реализации семафоров. Поскольку именованные семафоры Posix обладают по крайней мере живучестью ядра, для работы с ними мы можем использовать отдельные программы.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label397 style="border:none;"></a>Программа semcreate</P>
      </H1>
      <P>В листинге 10.3 приведен текст программы, создающей именованный семафор. При вызове программы можно указать параметр –е, обеспечивающий исключающее создание (если семафор уже существует, будет выведено сообщение об ошибке), а параметр –i с числовым аргументом позволяет задать начальное значение семафора, отличное от 1. </P>
      <H2><a name=label398 style="border:none;"></a>Листинг 10.3.<A HREF="#n_1" onmouseover="ShowBookNote('n_1')" onmouseout="HideBookNote('n_1')"><SUP>[1]</SUP></A> Создание именованного семафора</H2>
      <P><CODE>//pxsem/semcreate.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int с, flags;</CODE></P>
      <P><CODE>6   sem_t *sem;</CODE></P>
      <P><CODE>7   unsigned int value;</CODE></P>
      <P><CODE>8   flags = O_RDWR | O_CREAT;</CODE></P>
      <P><CODE>9   value = 1;</CODE></P>
      <P><CODE>10  while ((c = Getopt(argc, argv, "ei:")) != –1) {</CODE></P>
      <P><CODE>11   switch (c) {</CODE></P>
      <P><CODE>12   case 'e':</CODE></P>
      <P><CODE>13    flags |= O_EXCL;</CODE></P>
      <P><CODE>14    break;</CODE></P>
      <P><CODE>15   case 'i':</CODE></P>
      <P><CODE>16    value = atoi(optarg);</CODE></P>
      <P><CODE>17    break;</CODE></P>
      <P><CODE>18   }</CODE></P>
      <P><CODE>19  }</CODE></P>
      <P><CODE>20  if (optind != argc – 1)</CODE></P>
      <P><CODE>21   err_quit("usage: semcreate [ –e ] [ –i initialvalue ] &lt;name&gt;");</CODE></P>
      <P><CODE>22  sem = Sem_open(argv[optind], flags, FILE_MODE, value);</CODE></P>
      <P><CODE>23  Sem_close(sem);</CODE></P>
      <P><CODE>24  exit(0);</CODE></P>
      <P><CODE>25 }</CODE></P>
      <H2><a name=label399 style="border:none;"></a>Создание семафора</H2>
      <P>22 Поскольку мы всегда указываем флаг O_CREAT, нам приходится вызывать sem_open с четырьмя аргументами. Последние два используются только в том случае, если семафор еще не существует.</P>
      <H2><a name=label400 style="border:none;"></a>Закрытие семафора</H2>
      <P>23 Мы вызываем sem_close, хотя, если бы мы не сделали этот вызов, семафор все равно закрылся бы автоматически при завершении процесса и ресурсы системы были бы высвобождены.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label401 style="border:none;"></a>Программа semunlink</P>
      </H1>
      <P>Программа в листинге 10.4 удаляет именованный семафор.</P>
      <H2><a name=label402 style="border:none;"></a>Листинг 10.4. Удаление именованного семафора</H2>
      <P><CODE>//pxsem/semunlink.c</CODE></P>
      <P><CODE>1 #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2 int</CODE></P>
      <P><CODE>3 main(int argc, char **argv)</CODE></P>
      <P><CODE>4 {</CODE></P>
      <P><CODE>5  if (argc != 2)</CODE></P>
      <P><CODE>6   err_quit("usage: semunlink &lt;name&gt;");</CODE></P>
      <P><CODE>7  Sem_unlink(argv[1]);</CODE></P>
      <P><CODE>8  exit(0);</CODE></P>
      <P><CODE>9 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label403 style="border:none;"></a>Программа semgetvalue</P>
      </H1>
      <P>В листинге 10.5 приведен текст простейшей программы, которая открывает указанный именованный семафор, получает его текущее значение и выводит его.</P>
      <H2><a name=label404 style="border:none;"></a>Листинг 10.5. Получение и вывод значения семафора</H2>
      <P><CODE>//pxsem/semgetvalue.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   sem_t *sem;</CODE></P>
      <P><CODE>6   int val;</CODE></P>
      <P><CODE>7   if (argc != 2)</CODE></P>
      <P><CODE>8    err_quit("usage: semgetvalue &lt;name&gt;");</CODE></P>
      <P><CODE>9   sem = Sem_open(argv[1], 0);</CODE></P>
      <P><CODE>10  Sem_getvalue(sem, &amp;val);</CODE></P>
      <P><CODE>11  printf("value = %d\n", val);</CODE></P>
      <P><CODE>12  exit(0);</CODE></P>
      <P><CODE>13 }</CODE></P>
      <H2><a name=label405 style="border:none;"></a>Открытие семафора</H2>
      <P>9 Семафор, который мы открываем, должен быть заранее создан другой программой. Вторым аргументом sem_open будет 0: мы не указываем флаг O_CREAT и нам не нужно задавать никаких других параметров открытия 0_ххх.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label406 style="border:none;"></a>Программа semwait</P>
      </H1>
      <P>Программа в листинге 10.6 открывает именованный семафор, вызывает semwait (которая приостанавливает выполнение процесса, если значение семафора меньше либо равно 0, а при положительном значении семафора уменьшает его на 1), получает и выводит значение семафора, а затем останавливает свою работу навсегда при вызове pause.</P>
      <H2><a name=label407 style="border:none;"></a>Листинг 10.6. Ожидание изменения значения семафора и вывод нового значения</H2>
      <P><CODE>//pxsem/semwait.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   sem_t *sem;</CODE></P>
      <P><CODE>6   int val;</CODE></P>
      <P><CODE>7   if (argc != 2)</CODE></P>
      <P><CODE>8    err_quit("usage: semwait &lt;name&gt;");</CODE></P>
      <P><CODE>9   sem = Sem_open(argv[1], 0);</CODE></P>
      <P><CODE>10  Sem_wait(sem);</CODE></P>
      <P><CODE>11  Sem_getvalue(sem, &amp;val);</CODE></P>
      <P><CODE>12  printf("pid %ld has semaphore, value = %d\n", (long) getpid(), val);</CODE></P>
      <P><CODE>13  pause(); /* блокируется, пока не будет удален */</CODE></P>
      <P><CODE>14  exit(0);</CODE></P>
      <P><CODE>15 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label408 style="border:none;"></a>Программа sempost</P>
      </H1>
      <P>В листинге 10.7 приведена программа, которая выполняет операцию <EM>post</EM> для указанного семафора (то есть увеличивает его значение на 1), а затем получает значение этого семафора и выводит его.</P>
      <H2><a name=label409 style="border:none;"></a>Листинг 10.7. Увеличение значения семафора</H2>
      <P><CODE>//pxsem/sempost.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   sem_t *sem;</CODE></P>
      <P><CODE>6   int val;</CODE></P>
      <P><CODE>7   if (argc != 2)</CODE></P>
      <P><CODE>8    err_quit("usage: sempost &lt;name&gt;");</CODE></P>
      <P><CODE>9   sem = Sem_open(argv[1], 0);</CODE></P>
      <P><CODE>10  Sem_post(sem);</CODE></P>
      <P><CODE>11  Sem_getvalue(sem, &amp;val);</CODE></P>
      <P><CODE>12  printf("value = %d\n", val);</CODE></P>
      <P><CODE>13  exit(0);</CODE></P>
      <P><CODE>14 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label410 style="border:none;"></a>Примеры</P>
      </H1>
      <P>Для начала мы создадим именованный семафор в Digital Unix 4.0B и выведем его значение, устанавливаемое по умолчанию при инициализации:</P>
      <P><CODE>alpha % <STRONG>semcreate /tmp/test1</STRONG></CODE></P>
      <P><CODE>alpha % <STRONG>ls-l /tmp/test1</STRONG></CODE></P>
      <P><CODE>-rw-r--r-- 1 rstevens system 264 Nov 13 08:51 /tmp/test1</CODE></P>
      <P><CODE>alpha %<STRONG>semgetvalue /tmp/test1</STRONG></CODE></P>
      <P><CODE>value = 1</CODE></P>
      <P>Аналогично очередям сообщений Posix система создает файл семафора с тем именем, которое мы указали при вызове функции.</P>
      <P>Теперь подождем изменения семафора и прервем работу программы, установившей блокировку:</P>
      <P><CODE>alpha % <STRONG>semwait /tmp/test1</STRONG></CODE></P>
      <P><CODE>pid 9702 has semaphore, value = 0 <EM>значение после возврата из sem_wait</EM></CODE></P>
      <P><CODE><STRONG>^?</STRONG>                                <EM>клавиша прерывания работы в нашей системе</EM></CODE></P>
      <P><CODE>alpha % <STRONG>semgetvalue /tmp/test1</STRONG></CODE></P>
      <P><CODE>value = 0                         <EM>значение остается нулевым</EM></CODE></P>
      <P>Приведенный пример иллюстрирует упомянутые ранее особенности. Во-первых, значение семафора обладает живучестью ядра. Значение 1, установленное при создании семафора, хранится в ядре даже тогда, когда ни одна программа не пользуется этим семафором. Во-вторых, при выходе из программы semwait, заблокировавшей семафор, значение его не изменяется, то есть ресурс остается заблокированным. Это отличает семафоры от блокировок fcntl, описанных в главе 9, которые снимались автоматически при завершении работы процесса.</P>
      <P>Покажем теперь, что в этой реализации отрицательное значение семафора используется для хранения информации о количестве процессов, ожидающих разблокирования семафора:</P>
      <P><CODE>alpha % <STRONG>semgetvalue /tmp/test1</STRONG></CODE></P>
      <P><CODE>value = 0                          <EM>это значение сохранилось с конца предыдущего примера</EM></CODE></P>
      <P><CODE>alpha % <STRONG>semwait /tmp/test1 &amp;</STRONG>      <EM>запуск в фоновом режиме</EM></CODE></P>
      <P><CODE>[1] 9718                           <EM>блокируется в ожидании изменения значения семафора</EM></CODE></P>
      <P><CODE>alpha % <STRONG>semgetvalue /tmp/test1</STRONG></CODE></P>
      <P><CODE>value = –1                         <EM>один процесс ожидает изменения семафора</EM></CODE></P>
      <P><CODE>alpha % <STRONG>semwait /tmp/test1 &amp;</STRONG>       <EM>запуск еще одного процесса в фоновом режиме</EM></CODE></P>
      <P><CODE>[2] 9727                           <EM>он также блокируется</EM></CODE></P>
      <P><CODE>alpha % <STRONG>semgetvalue /tmp/test1</STRONG></CODE></P>
      <P><CODE>value = –2                         <EM>два процесса ожидают изменения семафора</EM></CODE></P>
      <P><CODE>alpha % <STRONG>sempost /tmp/test1</STRONG></CODE></P>
      <P><CODE>value = –1                         <EM>значение после возвращенияиз sem_post</EM></CODE></P>
      <P><CODE>pid 9718 has semaphore, value = –1 <EM>вывод программы semwait</EM></CODE></P>
      <P><CODE>alpha % <STRONG>sempost /tmp/test1</STRONG></CODE></P>
      <P><CODE>value = 0</CODE></P>
      <P><CODE>pid 9727 has semaphore, value = 0  <EM>вывод программы semwait</EM></CODE></P>
      <P>При первом вызове sem_post значение семафора изменилось с –2 на –1 и один из процессов, ожидавших изменения значения семафора, был разблокирован.</P>
      <P>Выполним те же действия в Solaris 2.6, обращая внимание на различия в реализации:</P>
      <P><CODE>solaris % <STRONG>semcreate /test2</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>ls –l /tmp/.*test2*</STRONG></CODE></P>
      <P><CODE>-rw-r--r-- 1 rstevens other1 48 Nov 13 09:11 /tmp/.SEMDtest2</CODE></P>
      <P><CODE>–rw-rw-rw– 1 rstevens other1  0 Nov 13 09:11 /tmp/.SEMLtest2</CODE></P>
      <P><CODE>solaris % <STRONG>semgetvalue /test2</STRONG></CODE></P>
      <P><CODE>value = 1</CODE></P>
      <P>Аналогично очередям сообщений Posix файлы создаются в каталоге /tmp, причем указываемое при вызове имя становится суффиксом имен файлов. Разрешения первого файла соответствуют указанным в вызове sem_open, а второй файл, как можно предположить, используется для блокировки доступа.</P>
      <P>Проверим, что ядро не осуществляет автоматического увеличения значения семафора при завершении работы процесса, установившего блокировку:</P>
      <P><CODE>solaris % <STRONG>semwait /test2</STRONG></CODE></P>
      <P><CODE>pid 4133 has semaphore, value = 0</CODE></P>
      <P><CODE><STRONG>^?</STRONG> <EM>нажимаем клавишу прерывания выполнения</EM></CODE></P>
      <P><CODE>solaris % <STRONG>semgetvalue /test2</STRONG></CODE></P>
      <P><CODE>value = 0</CODE></P>
      <P>Посмотрим теперь, как меняется значение семафора в этой реализации при появлении новых процессов, ожидающих изменения значения семафора:</P>
      <P><CODE>solaris % <STRONG>semgetvalue /test2</STRONG></CODE></P>
      <P><CODE>value = 0                       <EM>значение сохранилось с конца предыдущего примера</EM></CODE></P>
      <P><CODE>solaris % <STRONG>semwait /test2</STRONG>&amp;       <EM>запуск в фоновом режиме</EM></CODE></P>
      <P><CODE>[1] 4257                        <EM>программа блокируется</EM></CODE></P>
      <P><CODE>solaris % <STRONG>semgetvalue /test2</STRONG></CODE></P>
      <P><CODE>value = 0                        <EM>в этой реализации отрицательные значения не используются</EM></CODE></P>
      <P><CODE>solaris % <STRONG>semwait /test2&amp;        </STRONG><EM>еще один фоновый процесс</EM></CODE></P>
      <P><CODE>[2] 4263</CODE></P>
      <P><CODE>solaris % <STRONG>semgetvalue /test2</STRONG></CODE></P>
      <P><CODE>value 0                          <EM>и для двух ожидающих процессов значение остается нулевым</EM></CODE></P>
      <P><CODE>solaris % <STRONG>sempost /test2          </STRONG><EM>выполняем операцию post</EM></CODE></P>
      <P><CODE>pid 4257 has semaphore, value = 0 <EM>вывод программы semwait</EM></CODE></P>
      <P><CODE>value = 0</CODE></P>
      <P><CODE>solaris % <STRONG>sempost /test2</STRONG></CODE></P>
      <P><CODE>pid 4263 has semaphore, value = 0 <EM>вывод программы semwait</EM></CODE></P>
      <P><CODE>value = 0</CODE></P>
      <P>Можно заметить отличие по сравнению с результатами выполнения той же последовательности команд в Digital Unix 4.0B: после изменения значения семафора управление сразу же передается ожидающему изменения семафора процессу.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label411 style="border:none;"></a>10.6. Задача производителей и потребителей</P>
     </H1>
     <DIV class=section>
      <P>В разделе 7.3 мы описали суть задачи производителей и потребителей и привели несколько возможных ее решений, в которых несколько потоков-производителей заполняли массив, который обрабатывался одним потоком-потребителем.</P>
      <P>1. В нашем первом варианте решения (раздел 7.2) потребитель запускался только после завершения работы производителей, поэтому мы могли решить проблему синхронизации, используя единственное взаимное исключение для синхронизации производителей.</P>
      <P>2. В следующем варианте решения (раздел 7.5) потребитель запускался до завершения работы производителей, поэтому требовалось использование взаимного исключения (для синхронизации производителей) вместе с условной переменной и еще одним взаимным исключением (для синхронизации потребителя с производителями).</P>
      <P>Расширим постановку задачи производителей и потребителей, используя общий буфер в качестве циклического: заполнив последнее поле, производитель (buff[NBUFF-1]) возвращается к его началу и заполняет первое поле (buff[0]), и потребитель действует таким же образом. Возникает еще одно требование к синхронизации: потребитель не должен опережать производителя. Мы все еще предполагаем, что производитель и потребитель представляют собой отдельные потоки одного процесса, но они также могут быть и просто отдельными процессами, если мы сможем создать для них общий буфер (например, используя разделяемую память, часть 4).</P>
      <P>При использовании общего буфера в качестве циклического код должен удовлетворять трем требованиям:</P>
      <P>1. Потребитель не должен пытаться извлечь объект из буфера, если буфер пуст.</P>
      <P>2. Производитель не должен пытаться поместить объект в буфер, если последний полон.</P>
      <P>3. Состояние буфера может описываться общими переменными (индексами, счетчиками, указателями связных списков и т.д.), поэтому все операции с буфером, совершаемые потребителями и производителями, должны быть защищены от потенциально возможной ситуации гонок.</P>
      <P>Наше решение использует три семафора:</P>
      <P>1. Бинарный семафор с именем mutex защищает критические области кода: помещение данных в буфер (для производителя) и изъятие данных из буфера (для потребителя). Бинарный семафор, используемый в качестве взаимного исключения, инициализируется единицей. (Конечно, мы могли бы воспользоваться и обычным взаимным исключением вместо двоичного семафора. См. упражнение 10.10.)</P>
      <P>2. Семафор-счетчик с именем nempty подсчитывает количество свободных полей в буфере. Он инициализируется значением, равным объему буфера (NBUFF).</P>
      <P>3. Семафор-счетчик с именем nstored подсчитывает количество заполненных полей в буфере. Он инициализируется нулем, поскольку изначально буфер пуст.</P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader167" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 10.7. Состояние буфера и двух семафоров-счетчиков после инициализации</P>
      <BR>
      <P>На рис. 10.7 показано состояние буфера и двух семафоров-счетчиков после завершения инициализации. Неиспользуемые элементы массива выделены темным.</P>
      <P>В нашем примере производитель помещает в буфер целые числа от 0 до NLOOP-1 (buff[0] = 0, buff[1] = 1), работая с ним как с циклическим. Потребитель считывает эти числа и проверяет их правильность, выводя сообщения об ошибках в стандартный поток вывода.</P>
      <P>На рис. 10.8 изображено состояние буфера и семафоров-счетчиков после помещения в буфер трех элементов, но до изъятия их потребителем.</P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader168" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 10.8. Буфер и семафоры после помещения в буфер трех элементов</P>
      <BR>
      <P>Предположим, что потребитель изъял один элемент из буфера. Новое состояние изображено на рис. 10.9.</P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader169" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 10.9. Буфер и семафоры после удаления первого элемента из буфера</P>
      <BR>
      <P>В листинге 10.8 приведен текст функции main, которая создает три семафора, запускает два потока, ожидает их завершения и удаляет семафоры.</P>
      <H2><a name=label412 style="border:none;"></a>Листинг 10.8. Функция main для решения задачи производителей и потребителей с помощью семафоров</H2>
      <P><CODE>//pxsem/prodcons1.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #define NBUFF 10</CODE></P>
      <P><CODE>3  #define SEM_MUTEX "mutex" /* аргументы px_ipc_name() */</CODE></P>
      <P><CODE>4  #define SEM_NEMPTY "nempty"</CODE></P>
      <P><CODE>5  #define SEM_NSTORED "nstored"</CODE></P>
      <BR>
      <P><CODE>6  int nitems; /* read-only для производителя и потребителя */</CODE></P>
      <P><CODE>7  struct { /* разделяемые производителем и потребителем данные */</CODE></P>
      <P><CODE>8   int buff[NBUFF];</CODE></P>
      <P><CODE>9   sem_t *mutex, *nempty, *nstored;</CODE></P>
      <P><CODE>10 } shared;</CODE></P>
      <P><CODE>11 void *produce(void *), *consume(void *);</CODE></P>
      <BR>
      <P><CODE>12 int</CODE></P>
      <P><CODE>13 main(int argc, char **argv)</CODE></P>
      <P><CODE>14 {</CODE></P>
      <P><CODE>15  pthread_t tid_produce, tid_consume;</CODE></P>
      <P><CODE>16  if (argc != 2)</CODE></P>
      <P><CODE>17   err_quit("usage: prodcons1 &lt;#items&gt;");</CODE></P>
      <P><CODE>18  nitems = atoi(argv[1]);</CODE></P>
      <P><CODE>19  /* создание трех семафоров */</CODE></P>
      <P><CODE>20  shared.mutex = Sem_open(Px_ipc_name(SEM_MUTEX), O_CREAT | O_EXCL,</CODE></P>
      <P><CODE>21   FILE_MODE, 1);</CODE></P>
      <P><CODE>22  shared.nempty = Sem_open(Px_ipc_name(SEM_NEMPTY), 0_CREAT | O_EXCL,</CODE></P>
      <P><CODE>23   FILE_MODE, NBUFF);</CODE></P>
      <P><CODE>24  shared.nstored = Sem_open(Px_ipc_name(SEM_NSTORED), O_CREAT | O_EXCL,</CODE></P>
      <P><CODE>25   FILE_MODE, 0);</CODE></P>
      <P><CODE>26  /* создание одного потока-производителя и одного потока-потребителя */</CODE></P>
      <P><CODE>27  Set_concurrency(2);</CODE></P>
      <P><CODE>28  Pthread_create(&amp;tid_produce, NULL, produce, NULL);</CODE></P>
      <P><CODE>29  Pthread_create(&amp;tid_consume, NULL, consume, NULL);</CODE></P>
      <P><CODE>30  /* ожидание завершения работы потоков */</CODE></P>
      <P><CODE>31  Pthread_join(tid_produce, NULL);</CODE></P>
      <P><CODE>32  Pthread_join(tid_consume, NULL);</CODE></P>
      <P><CODE>33  /* удаление семафоров */</CODE></P>
      <P><CODE>34  Sem_unlink(Px_ipc_name(SEM_MUTEX));</CODE></P>
      <P><CODE>35  Sem_unlink(Px_ipc_name(SEM_NEMPTY));</CODE></P>
      <P><CODE>36  Sem_unlink(Px_ipc_name(SEM_NSTORED));</CODE></P>
      <P><CODE>37  exit(0);</CODE></P>
      <P><CODE>38 }</CODE></P>
      <H2><a name=label413 style="border:none;"></a>Глобальные переменные</H2>
      <P>6-10 Потоки совместно используют буфер, содержащий NBUFF элементов, и три указателя на семафоры. Как говорилось в главе 7, мы объединяем эти данные в структуру, чтобы подчеркнуть, что семафоры используются для синхронизации доступа к буферу.</P>
      <H2><a name=label414 style="border:none;"></a>Создание семафоров</H2>
      <P>19-25 Мы создаем три семафора, передавая их имена функции px_ipc_name. Флаг O_EXCL мы указываем, для того чтобы гарантировать инициализацию каждого семафора правильным значением. Если после преждевременно завершенного предыдущего запуска программы остались неудаленные семафоры, мы обработаем эту ситуацию, вызвав перед их созданием sem_unlink и игнорируя ошибки. Мы могли бы проверять возвращение ошибки EEXIST при вызове sem_open с флагом O_EXCL, а затем вызывать sem_unlink и еще раз sem_open, но это усложнило бы программу. Если нам нужно проверить, что запущен только один экземпляр программы (что следует сделать перед созданием семафоров), можно обратиться к разделу 9.7, где описаны методы решения этой задачи.</P>
      <H2><a name=label415 style="border:none;"></a>Создание двух потоков</H2>
      <P>26-29 Создаются два потока, один из которых является производителем, а другой — потребителем. При запуске никакие аргументы им не передаются.</P>
      <P>30-36 Главный поток ждет завершения работы производителя и потребителя, а затем удаляет три семафора.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Мы могли бы вызвать для каждого семафора sem_close, но это делается автоматически при завершении процесса. А вот удалить имя семафора из файловой системы необходимо явно.</P>
      </DIV>
      <P>В листинге 10.9 приведен текст функций produce и consume.</P>
      <H2><a name=label416 style="border:none;"></a>Листинг 10.9. Функции produce и consume</H2>
      <P><CODE>//pxsem/prodcons1.c</CODE></P>
      <P><CODE>39 void *</CODE></P>
      <P><CODE>40 produce(void *arg)</CODE></P>
      <P><CODE>41 {</CODE></P>
      <P><CODE>42  int i;</CODE></P>
      <P><CODE>43  for (i = 0; i &lt; nitems; i++) {</CODE></P>
      <P><CODE>44   Sem_wait(shared.nempty); /* ожидаем освобождения поля */</CODE></P>
      <P><CODE>45   Sem_wait(shared.mutex);</CODE></P>
      <P><CODE>46   shared.buff[i % NBUFF] = i; /* помещаем i в циклический буфер */</CODE></P>
      <P><CODE>47   Sem_post(shared.mutex);</CODE></P>
      <P><CODE>48   Sem_post(shared.nstored); /* сохраняем еще 1 элемент */</CODE></P>
      <P><CODE>49  }</CODE></P>
      <P><CODE>50  return(NULL);</CODE></P>
      <P><CODE>51 }</CODE></P>
      <BR>
      <P><CODE>52 void *</CODE></P>
      <P><CODE>53 consume(void *arg)</CODE></P>
      <P><CODE>54 {</CODE></P>
      <P><CODE>55  int i;</CODE></P>
      <P><CODE>56  for (i = 0; i &lt; nitems; i++) {</CODE></P>
      <P><CODE>57   Sem_wait(shared.nstored); /* ожидаем появления объекта в буфере */</CODE></P>
      <P><CODE>58   Sem_wait(shared.mutex);</CODE></P>
      <P><CODE>59   if (shared.buff[i % NBUFF] != i)</CODE></P>
      <P><CODE>60    printf("buff[%d] = %d\n", i, shared.buff[i % NBUFF]);</CODE></P>
      <P><CODE>61   Sem_post(shared.mutex);</CODE></P>
      <P><CODE>62   Sem_post(shared.nempty); /* еще одно пустое поле */</CODE></P>
      <P><CODE>63  }</CODE></P>
      <P><CODE>64  return(NULL);</CODE></P>
      <P><CODE>65 }</CODE></P>
      <H2><a name=label417 style="border:none;"></a>Производитель ожидает освобождения места в буфере</H2>
      <P>44 Производитель вызывает sem_wait для семафора nempty, ожидая появления свободного места. В первый раз при выполнении этой команды значение семафора nempty уменьшится с NBUFF до NBUFF-1.</P>
      <H2><a name=label418 style="border:none;"></a>Производитель помещает элемент в буфер</H2>
      <P>45-48 Перед помещением нового элемента в буфер производитель должен установить блокировку на семафор mutex. В нашем примере, где производитель просто сохраняет значение в элементе массива с индексом i <EM>%</EM> NBUFF, для описания состояния буфера не используется никаких разделяемых переменных (то есть мы не используем связный список, который нужно было бы обновлять каждый раз при помещении элемента в буфер). Следовательно, установка и снятие семафора mutex не являются обязательными. Тем не менее мы иллюстрируем эту технику, потому что обычно ее применение является необходимым в задачах такого рода (обновление буфера, разделяемого несколькими потоками).</P>
      <P>После помещения элемента в буфер блокировка с семафора mutex снимается (его значение увеличивается с 0 до 1) и увеличивается значение семафора nstored. Первый раз при выполнении этой команды значение nstored изменится с начального значения 0 до 1.</P>
      <H2><a name=label419 style="border:none;"></a>Потребитель ожидает изменения семафора nstored</H2>
      <P>57-62 Если значение семафора nstored больше 0, в буфере имеются объекты для обработки. Потребитель изымает один элемент из буфера и проверяет правильность его значения, защищая буфер в момент доступа к нему с помощью семафора mutex. Затем потребитель увеличивает значение семафора nempty, указывая производителю на наличие свободных полей.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label420 style="border:none;"></a>Зависание</P>
      </H1>
      <P>Что произойдет, если мы по ошибке поменяем местами вызовы Sem_wait в функции consumer (листинг 10.9)? Предположим, что первым запускается производитель (как в решении, предложенном для упражнения 10.1). Он помещает в буфер NBUFF элементов, уменьшая значение семафора nempty от NBUFF до 0 и увеличивая значение семафора nstored от 0 до NBUFF. Затем производитель блокируется в вызове Sem_wait(shared. nempty), поскольку буфер полон и помещать элементы больше некуда.</P>
      <P>Запускается потребитель и проверяет первые NBUFF элементов буфера. Это уменьшает значение семафора nstored от NBUFF до 0 и увеличивает значение семафора nempty от 0 до NBUFF. Затем потребитель блокируется в вызове Sem_wait(shared, nstored) после вызова Sem_wait(shared, mutex). Производитель мог бы продолжать работу, поскольку значение семафора nempty уже отлично от 0, но он вызвал Sem_wait(shared, mutex) и его выполнение было приостановлено. </P>
      <P>Это называется зависанием программы (deadlock). Производитель ожидает освобождения семафора mutex, а потребитель не снимает с него блокировку, ожидая освобождения семафора nstored. Но производитель не может изменить nstored, пока он не получит семафор mutex. Это одна из проблем, которые часто возникают с семафорами: если в программе сделать ошибку, она будет работать неправильно.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Стандарт Posix позволяет функции sem_wait обнаруживать зависание и возвращать ошибку EDEADLK, но ни одна из систем, использовавшихся для написания примеров (Digital Unix 4.0B и Solaris 2.6), не обнаружила ошибку в данном случае.</P>
      </DIV>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label421 style="border:none;"></a>10.7. Блокирование файлов</P>
     </H1>
     <P>Вернемся к задаче о порядковом номере из главы 9. Здесь мы напишем новые версии функций my_lock и my_unlосk, использующие именованные семафоры Posix. В листинге 10.10 приведен текст этих функций.</P>
     <H2><a name=label422 style="border:none;"></a>Листинг 10.10. Блокирование файла с помощью именованных семафоров Posix</H2>
     <P><CODE>//lock/lockpxsem.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #define LOCK_PATH "pxsemlock"</CODE></P>
     <P><CODE>3  sem_t *locksem;</CODE></P>
     <P><CODE>4  int initflag;</CODE></P>
     <BR>
     <P><CODE>5  void</CODE></P>
     <P><CODE>6  my_lock(int fd)</CODE></P>
     <P><CODE>7  {</CODE></P>
     <P><CODE>8   if (initflag == 0) {</CODE></P>
     <P><CODE>9    locksem = Sem_open(Px_ipc_name(LOCK_PATH), O_CREAT, FILE_MODE, 1);</CODE></P>
     <P><CODE>10   initflag = 1;</CODE></P>
     <P><CODE>11  }</CODE></P>
     <P><CODE>12  Sem_wait(locksem);</CODE></P>
     <P><CODE>13 }</CODE></P>
     <BR>
     <P><CODE>14 void</CODE></P>
     <P><CODE>15 my_unlock(int fd)</CODE></P>
     <P><CODE>16 {</CODE></P>
     <P><CODE>17  Sem_post(locksem);</CODE></P>
     <P><CODE>18 }</CODE></P>
     <P>Один из семафоров используется для рекомендательной блокировки доступа к файлу и инициализируется единицей при первом вызове функции. Для получения блокировки мы вызываем sem_wait, а для ее снятия — sem_post.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label423 style="border:none;"></a>10.8. Функции sem_init и sem_destroy</P>
     </H1>
     <DIV class=section>
      <P>До сих пор мы имели дело только с именованными семафорами Posix. Как мы уже говорили, они идентифицируются аргументом <EM>пате,</EM> обычно представляющим собой имя файла в файловой системе. Стандарт Posix описывает также семафоры, размещаемые в памяти, память под которые выделяет приложение (тип sem_t), а инициализируются они системой:</P>
      <P><CODE>#include &lt;semaphore.h&gt;</CODE></P>
      <P><CODE>int sem_init(sem_t <EM>*sem,</EM> int <EM>shared,</EM> unsigned int <EM>value</EM>);</CODE></P>
      <P><CODE>/* Возвращает –1 в случае ошибки */</CODE></P>
      <P><CODE>int sem_destroy(sem_t <EM>*sem</EM>);</CODE></P>
      <P><CODE>/* Возвращает 0 в случае успешного завершения, –1 – в случае ошибки */</CODE></P>
      <P>Размещаемый в памяти семафор инициализируется вызовом sem_init. Аргумент <EM>sem</EM> указывает на переменную типа sem_t, место под которую должно быть выделено приложением. Если аргумент shared равен 0, семафор используется потоками одного процесса, в противном случае доступ к нему могут иметь несколько процессов. Если аргумент shared ненулевой, семафор должен быть размещен в одном из видов разделяемой памяти и должен быть доступен всем процессам, использующим его. Как и в вызове sem_open, аргумент <EM>value</EM> задает начальное значение семафора.</P>
      <P>После завершения работы с размещаемым в памяти семафором его можно уничтожить, вызвав sem_destroy.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ 1</STRONG></P>
       <P>Функции sem_open не требуется параметр, аналогичный <EM>shared;</EM> не требуется ей и атрибут, аналогичный PTHREAD_PROCESS_SHARED (упоминавшийся в связи с взаимными исключениями и условными переменными в главе 7), поскольку именованный семафор <EM>всегда</EM> используется совместно несколькими процессами.</P>
      </DIV>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ 2</STRONG></P>
       <P>Обратите внимание, что для размещаемого в памяти семафора нет ничего аналогичного флагу O_CREAT: функция sem_init всегда инициализирует значение семафора. Следовательно, нужно быть внимательным, чтобы вызывать sem_init только один раз для каждого семафора. (Упражнение 10.2 иллюстрирует разницу в этом смысле между именованным и размещаемым в памяти семафорами.) При вызове sem_init для уже инициализированного семафора результат непредсказуем.</P>
      </DIV>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ 3</STRONG></P>
       <P>Удостоверьтесь, что вы понимаете фундаментальную разницу между sem_open и sem_init. Первая возвращает указатель на переменную типа sem_t, причем выделение места под переменную и ее инициализация выполняются этой же функцией. Напротив, первый аргумент sem_init представляет собой указатель на переменную типа sem_t, место под которую должен был заранее выделить вызывающий. Функция sem_init только инициализирует эту переменную.</P>
      </DIV>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ 4</STRONG></P>
       <P>Стандарт Posix.1 предупреждает, что для обращения к размещаемым в памяти семафорам можно использовать только указатель, являющийся аргументом при вызове sem_init. Использование копий этого указателя может привести к неопределенным результатам.</P>
       <P>Функция sem_init возвращает –1 в случае ошибки, но она не возвращает 0 в случае успешного завершения. Это действительно странно, и примечание в Обосновании Posix. 1 говорит, что в будущих версиях функция, возможно, начнет возвращать 0 в случае успешного завершения. </P>
      </DIV>
      <P>Размещаемый в памяти семафор может быть использован в тех случаях, когда нет необходимости использовать имя, связываемое с именованным семафором. Именованные семафоры обычно используются для синхронизации работы неродственных процессов. Имя в этом случае используется для идентификации семафора.</P>
      <P>В связи с табл. 1.1 мы говорили о том, что семафоры, размещаемые в памяти, обладают живучестью процесса, но на самом деле их живучесть зависит от типа используемой разделяемой памяти. Размещаемый в памяти семафор не утрачивает функциональности до тех пор, пока память, в которой он размещен, еще доступна какому-либо процессу.</P>
      <P>■ Если размещаемый в памяти семафор совместно используется потоками одного процесса (аргумент <EM>shared</EM> при вызове sem_init равен 0), семафор обладает живучестью процесса и удаляется при завершении последнего.</P>
      <P>■ Если размещаемый в памяти семафор совместно используется несколькими процессами (аргумент <EM>shared</EM> при вызове seminit равен 1), он должен располагаться в разделяемой памяти, и в этом случае семафор существует столько, сколько существует эта область памяти. Вспомните, что и разделяемая память Posix, и разделяемая память System V обладают живучестью ядра (табл. 1.1). Это значит, что сервер может создать область разделяемой памяти, инициализировать в ней размещаемый в памяти семафор Posix, а затем завершить работу. Некоторое время спустя один или несколько клиентов могут присоединить эту область к своему адресному пространству и получить доступ к хранящемуся в ней семафору.</P>
      <P>Предупреждаем, что нижеследующий код не работает так, как ожидается:</P>
      <P><CODE>sem_t mysem;</CODE></P>
      <P><CODE>Sem_init(&amp;mysem, 1.0); /* 2-й аргумент 1 –&gt; используется процессами */</CODE></P>
      <P><CODE>if (Fork() == 0) { /* дочерний процесс */</CODE></P>
      <P><CODE> …</CODE></P>
      <P><CODE> Sem_post(&amp;mysem);</CODE></P>
      <P><CODE>}</CODE></P>
      <P><CODE>Sem_wait(&amp;mysem); /* родительский процесс: ожидание дочернего */</CODE></P>
      <P>Проблема тут в том, что семафор не располагается в разделяемой памяти (см. раздел 10.12). Память, как правило, не делится между дочерним и родительским процессами при вызове fork. Дочерний процесс запускается с копией памяти родителя, но это не то же самое, что разделяемая память.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label424 style="border:none;"></a>Пример</P>
      </H1>
      <P>В качестве иллюстрации перепишем наш пример решения задачи производителей и потребителей из листингов 10.8 и 10.9 для использования размещаемых в памяти семафоров Posix. В листинге 10.11 приведен текст новой программы.</P>
      <H2><a name=label425 style="border:none;"></a>Листинг 10.11. Задача производителей и потребителей с использованием размещаемых в памяти семафоров</H2>
      <P><CODE>//pxsem/prodcons2.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #define NBUFF 10</CODE></P>
      <BR>
      <P><CODE>3  int nitems; /* только для чтения производителем и потребителем */</CODE></P>
      <P><CODE>4  struct { /* общие данные производителя и потребителя */</CODE></P>
      <P><CODE>5   int buff[NBUFF];</CODE></P>
      <P><CODE>6   sem_t mutex, nempty, nstored; /* семафоры, а не указатели */</CODE></P>
      <P><CODE>7  } shared;</CODE></P>
      <P><CODE>8  void *produce(void *), *consume(void *);</CODE></P>
      <BR>
      <P><CODE>9  int</CODE></P>
      <P><CODE>10 main(int argc, char **argv)</CODE></P>
      <P><CODE>11 {</CODE></P>
      <P><CODE>12  pthread_t tid_produce, tid_consume;</CODE></P>
      <P><CODE>13  if (argc != 2)</CODE></P>
      <P><CODE>14   err_quit("usage: prodcons2 &lt;#items&gt;");</CODE></P>
      <P><CODE>15  nitems = atoi(argv[1]);</CODE></P>
      <P><CODE>16  /* инициализация трех семафоров */</CODE></P>
      <P><CODE>17  Sem_init(&amp;shared.mutex, 0, 1);</CODE></P>
      <P><CODE>18  Sem_init(&amp;shared.nempty, 0, NBUFF);</CODE></P>
      <P><CODE>19  Sem_init(&amp;shared.nstored, 0, 0);</CODE></P>
      <P><CODE>20  Set_concurrency(2);</CODE></P>
      <P><CODE>21  Pthread_create(&amp;tid_produce, NULL, produce, NULL);</CODE></P>
      <P><CODE>22  Pthread_create(&amp;tid_consume, NULL, consume, NULL);</CODE></P>
      <P><CODE>23  Pthread_join(tid_produce, NULL);</CODE></P>
      <P><CODE>24  Pthread_join(tid_consume, NULL):</CODE></P>
      <P><CODE>25  Sem_destroy(&amp;shared.mutex);</CODE></P>
      <P><CODE>26  Sem_destroy(&amp;shared.nempty):</CODE></P>
      <P><CODE>27  Sem_destroy(&amp;shared.nstored);</CODE></P>
      <P><CODE>28  exit(0);</CODE></P>
      <P><CODE>29 }</CODE></P>
      <BR>
      <P><CODE>30 void *</CODE></P>
      <P><CODE>31 produce(void *arg)</CODE></P>
      <P><CODE>32 {</CODE></P>
      <P><CODE>33  int i;</CODE></P>
      <P><CODE>34  for (i = 0; i &lt; nitems; i++) {</CODE></P>
      <P><CODE>35   Sem_wait(&amp;shared.nempty); /* ожидание одного свободного поля */</CODE></P>
      <P><CODE>36   Sem_wait(&amp;shared.mutex);</CODE></P>
      <P><CODE>37   shared.buff[i % NBUFF] = i; /* помещение i в циклический буфер */</CODE></P>
      <P><CODE>38   Sem_post(&amp;shared.mutex);</CODE></P>
      <P><CODE>39   Sem_post(&amp;shared.nstored); /* поместили еще один элемент */</CODE></P>
      <P><CODE>40  }</CODE></P>
      <P><CODE>41  return(NULL);</CODE></P>
      <P><CODE>42 }</CODE></P>
      <BR>
      <P><CODE>43 void *</CODE></P>
      <P><CODE>44 consume(void *arg)</CODE></P>
      <P><CODE>45 {</CODE></P>
      <P><CODE>46  int i;</CODE></P>
      <P><CODE>47  for (i = 0; i &lt; nitems; i++) {</CODE></P>
      <P><CODE>48   Sem_wait(&amp;shared.nstored); /* ожидаем появления хотя бы одного готового для обработки элемента */</CODE></P>
      <P><CODE>49   Sem_wait(&amp;shared.mutex);</CODE></P>
      <P><CODE>50   if (shared.buff[i % NBUFF] != i)</CODE></P>
      <P><CODE>51    printf("buff[*d] = *d\n", i, shared.buff[i % NBUFF]);</CODE></P>
      <P><CODE>52   Sem_post(&amp;shared.mutex);</CODE></P>
      <P><CODE>53   Sem_post(&amp;shared.nempty); /* еще одно пустое поле */</CODE></P>
      <P><CODE>54  }</CODE></P>
      <P><CODE>55  return(NULL);</CODE></P>
      <P><CODE>56 }</CODE></P>
      <H2><a name=label426 style="border:none;"></a>Выделение семафоров</H2>
      <P>6 Мы объявляем три семафора типа sem_t, и теперь это сами семафоры, а не указатели на них.</P>
      <H2><a name=label427 style="border:none;"></a>Вызов sem_init</H2>
      <P>16-27 Мы вызываем sem_init вместо sem_open* а затем sem_destroy вместо sem_unlink. Вызывать sem_destroy на самом деле не требуется, поскольку программа все равно завершается.</P>
      <P>Остальные изменения обеспечивают передачу указателей на три семафора при вызовах sem_wait и sem_post.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label428 style="border:none;"></a>10.9. Несколько производителей, один потребитель</P>
     </H1>
     <P>Решение в разделе 10.6 относится к классической задаче с одним производителем и одним потребителем. Новая, интересная модификация программы позволит нескольким производителям работать с одним потребителем. Начнем с решения из листинга 10.11, в котором использовались размещаемые в памяти семафоры. В листинге 10.12 приведены объявления глобальных переменных и функция main.</P>
     <H2><a name=label429 style="border:none;"></a>Листинг 10.12. Функция main задачи с несколькими производителями</H2>
     <P><CODE>//pxsem/prodcons3.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #define NBUFF 10</CODE></P>
     <P><CODE>3  #define MAXNTHREADS 100</CODE></P>
     <BR>
     <P><CODE>4  int nitems, nproducers; /* только для чтения производителем и потребителем */</CODE></P>
     <P><CODE>5  struct { /* общие данные */</CODE></P>
     <P><CODE>6   int buff[NBUFF];</CODE></P>
     <P><CODE>7   int nput;</CODE></P>
     <P><CODE>8   int nputval;</CODE></P>
     <P><CODE>9   sem_t mutex, nempty, nstored; /* семафоры, а не указатели */</CODE></P>
     <P><CODE>10 } shared;</CODE></P>
     <BR>
     <P><CODE>11 void *produce(void *), *consume(void *);</CODE></P>
     <BR>
     <P><CODE>12 int</CODE></P>
     <P><CODE>13 main(int argc, char **argv)</CODE></P>
     <P><CODE>14 {</CODE></P>
     <P><CODE>15  int i, count[MAXNTHREADS];</CODE></P>
     <P><CODE>16  pthread_t tid_produce[MAXNTHREADS], tid_consume;</CODE></P>
     <P><CODE>17  if (argc != 3)</CODE></P>
     <P><CODE>18   err_quit("usage: prodcons3 &lt;#items&gt; &lt;#producers&gt;");</CODE></P>
     <P><CODE>19  nitems = atoi(argv[1]);</CODE></P>
     <P><CODE>20  nproducers = min(atoi(argv[2]), MAXNTHREADS);</CODE></P>
     <P><CODE>21  /* инициализация трех семафоров */</CODE></P>
     <P><CODE>22  Sem_init(&amp;shared.mutex, 0, 1);</CODE></P>
     <P><CODE>23  Sem_init(&amp;shared.nempty, 0, NBUFF);</CODE></P>
     <P><CODE>24  Sem_init(&amp;shared.nstored, 0, 0);</CODE></P>
     <P><CODE>25  /* создание всех производителей и одного потребителя */</CODE></P>
     <P><CODE>26  Set_concurrency(nproducers + 1);</CODE></P>
     <P><CODE>27  for (i = 0; i &lt; nproducers; i++) {</CODE></P>
     <P><CODE>28   count[i] = 0;</CODE></P>
     <P><CODE>29   Pthread_create(&amp;tid_produce[i], NULL, produce, &amp;count[i]);</CODE></P>
     <P><CODE>30  }</CODE></P>
     <P><CODE>31  Pthread_create(&amp;tid_consume, NULL, consume, NULL);</CODE></P>
     <P><CODE>32  /* ожидание завершения всех производителей и потребителя */</CODE></P>
     <P><CODE>33  for (i = 0; i &lt; nproducers; i++) {</CODE></P>
     <P><CODE>34   Pthread_join(tid_produce[i], NULL);</CODE></P>
     <P><CODE>35   printf("count[%d] = %d\n", i, count[i]);</CODE></P>
     <P><CODE>36  }</CODE></P>
     <P><CODE>37  Pthread_join(tid_consume, NULL);</CODE></P>
     <P><CODE>38  Sem_destroy(&amp;shared.mutex);</CODE></P>
     <P><CODE>39  Sem_destroy(&amp;shared.nempty);</CODE></P>
     <P><CODE>40  Sem_destroy(&amp;shared.nstored);</CODE></P>
     <P><CODE>41  exit(0);</CODE></P>
     <P><CODE>42 }</CODE></P>
     <H2><a name=label430 style="border:none;"></a>Глобальные переменные</H2>
     <P>4 Глобальная переменная nitems хранит число элементов, которые должны быть совместно произведены. Переменная nproducers хранит число потоков-производителей. Оба эти значения устанавливаются с помощью аргументов командной строки.</P>
     <H2><a name=label431 style="border:none;"></a>Общая структура</H2>
     <P>5-10 В структуру shared добавляются два новых элемента: nput, обозначающий индекс следующего элемента, куда должен быть помещен объект (по модулю BUFF), и nputval <STRONG>—</STRONG>следующее значение, которое будет помещено в буфер. Эти две переменные взяты из нашего решения в листингах 7.1 и 7.2. Они нужны для синхронизации нескольких потоков-производителей.</P>
     <H2><a name=label432 style="border:none;"></a>Новые аргументы командной строки</H2>
     <P>17-20 Два новых аргумента командной строки указывают полное количество элементов, которые должны быть помещены в буфер, и количество потоков-производителей. </P>
     <H2><a name=label433 style="border:none;"></a>Запуск всех потоков</H2>
     <P>21-41 Инициализируем семафоры и запускаем потоки-производители и поток-потребитель. Затем ожидается завершение работы потоков. Эта часть кода практически идентична листингу 7.1.</P>
     <P>В листинге 10.13 приведен текст функции produce, которая выполняется каждым потоком-производителем.</P>
     <H2><a name=label434 style="border:none;"></a>Листинг 10.13. Функция, выполняемая всеми потоками-производителями</H2>
     <P><CODE>//pxsem/prodcons3.c</CODE></P>
     <P><CODE>43 void *</CODE></P>
     <P><CODE>44 produce(void *arg)</CODE></P>
     <P><CODE>45 {</CODE></P>
     <P><CODE>46  for (;;) {</CODE></P>
     <P><CODE>47   Sem_wait(&amp;shared.nempty); /* ожидание освобождения поля */</CODE></P>
     <P><CODE>48   Sem_wait(&amp;shared.mutex);</CODE></P>
     <P><CODE>49   if (shared.nput &gt;= nitems) {</CODE></P>
     <P><CODE>50    Sem_post(&amp;shared.nempty);</CODE></P>
     <P><CODE>51    Sem_post(&amp;shared.mutex);</CODE></P>
     <P><CODE>52    return(NULL); /* готово */</CODE></P>
     <P><CODE>53   }</CODE></P>
     <P><CODE>54   shared.buff[shared.nput % NBUFF] = shared.nputval;</CODE></P>
     <P><CODE>55   shared.nput++;</CODE></P>
     <P><CODE>56   shared.nputval++;</CODE></P>
     <P><CODE>57   Sem_post(&amp;shared.mutex);</CODE></P>
     <P><CODE>58   Sem_post(&amp;shared.nstored); /* еще один элемент */</CODE></P>
     <P><CODE>59   *((int *) arg) += 1;</CODE></P>
     <P><CODE>60  }</CODE></P>
     <P><CODE>61 }</CODE></P>
     <H2><a name=label435 style="border:none;"></a>Взаимное исключение между потоками-производителями</H2>
     <P>49-53 Отличие от листинга 10.8 в том, что цикл завершается, когда nitems объектов будет помещено в буфер всеми потоками. Обратите внимание, что потоки-производители могут получить семафор nempty в любой момент, но только один производитель может иметь семафор mutex. Это защищает переменные nput и nval от одновременного изменения несколькими производителями.</P>
     <H2><a name=label436 style="border:none;"></a>Завершение производителей</H2>
     <P>50-51 Нам нужно аккуратно обработать завершение потоков-производителей. После того как последний объект помещен в буфер, каждый поток выполняет </P>
     <P><CODE>Sem_wait(&amp;shared.nempty); /* ожидание пустого поля */</CODE></P>
     <P>в начале цикла, что уменьшает значение семафора nempty. Но прежде, чем поток будет завершен, он должен увеличить значение этого семафора, потому что он не помещает объект в буфер в последнем проходе цикла. Завершающий работу поток должен также освободить семафор mutex, чтобы другие производители смогли продолжить функционирование. Если мы не увеличим семафор nempty по завершении процесса и если производителей будет больше, чем мест в буфере, лишние потоки будут заблокированы навсегда, ожидая освобождения семафора nempty, и никогда не завершат свою работу.</P>
     <P>Функция consume в листинге 10.14 проверяет правильность всех записей в буфере, выводя сообщение при обнаружении ошибки.</P>
     <H2><a name=label437 style="border:none;"></a>Листинг 10.14. Функция, выполняемая потоком-потребителем</H2>
     <P><CODE>//pxsem/prodcons3.с</CODE></P>
     <P><CODE>62 void *</CODE></P>
     <P><CODE>63 consume(void *arg)</CODE></P>
     <P><CODE>64 {</CODE></P>
     <P><CODE>65  int i;</CODE></P>
     <P><CODE>66  for (i = 0; i &lt; nitems; i++) {</CODE></P>
     <P><CODE>67   Sem_wait(&amp;shared.nstored); /* ожидание помещения по крайней мере одного элемента в буфер */</CODE></P>
     <P><CODE>68   Sem_wait(&amp;shared.mutex);</CODE></P>
     <P><CODE>69   if (shared.buff[i % NBUFF] != i)</CODE></P>
     <P><CODE>70    printf("error: buff[%d] = %d\n", i, shared.buff[i % NBUFF]);</CODE></P>
     <P><CODE>71   Sem_post(&amp;shared.mutex);</CODE></P>
     <P><CODE>72   Sem_post(&amp;shared.nempty); /* еще одно пустое поле */</CODE></P>
     <P><CODE>73  }</CODE></P>
     <P><CODE>74  return(NULL);</CODE></P>
     <P><CODE>75 }</CODE></P>
     <P>Условие завершения единственного потока-потребителя звучит просто: он считает все потребленные объекты и останавливается по достижении nitems.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label438 style="border:none;"></a>10.10. Несколько производителей, несколько потребителей</P>
     </H1>
     <P>Следующее изменение, которое мы внесем в нашу пpoгрaммy, будет заключаться в добавлении возможности одновременной работы нескольких потребителей вместе с несколькими производителями. Есть ли смысл в наличии нескольких потребителей — зависит от приложения. Автор видел два примера, в которых использовался этот метод.</P>
     <P>1. Пpoгрaммa преобразования IP-адресов в имена узлов. Каждый потребитель берет IP-адрес, вызывает gethostbyaddr (раздел 9.6 [24]), затем дописывает имя узла к файлу. Поскольку каждый вызов gethostbyaddr обрабатывается неопределенное время, порядок IP-адресов в буфере будет, скорее всего, отличаться от порядка имен узлов в файле, созданном потоками-потребителями. Преимущество этой схемы в параллельности выполнения вызовов gethostbyaddr (каждый из которых может работать несколько секунд) — по одному на каждый поток-потребитель.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Предполагается наличие версии gethostbyaddr, допускающей многократное вхождение, что не всегда верно. Если эта версия недоступна, можно хранить буфер в разделяемой памяти и использовать процессы вместо потоков. </P>
     </DIV>
     <P>2. Программа, принимающая дейтаграммы UDP, обрабатывающая их и записывающая результат в базу данных. Каждая дeйтaгрaммa обрабатывается одним потоком-потребителем, которые выполняются параллельно для ускорения процесса. Хотя дейтаграммы записываются в базу данных в порядке, вообще говоря, отличном от порядка их приема, встроенная схема упорядочения записей в базе данных справляется с этой проблемой.</P>
     <P>В листинге 10.15 приведены глобальные переменные программы.</P>
     <H2><a name=label439 style="border:none;"></a>Листинг 10.15. Глобальные переменные</H2>
     <P><CODE>//pxsem/prodcons4.с</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #define NBUFF 10</CODE></P>
     <P><CODE>3  #define MAXNTHREADS 100</CODE></P>
     <P><CODE>4  int nitems, nproducers, nconsumers; /* только для чтения */</CODE></P>
     <P><CODE>5  struct { /* общие данные производителей и потребителей */</CODE></P>
     <P><CODE>6   int buff[NBUFF];</CODE></P>
     <P><CODE>7   int nput; /* номер объекта: 0, 1. 2, … */</CODE></P>
     <P><CODE>8   int nputval; /* сохраняемое в buff[] значение */</CODE></P>
     <P><CODE>9   int nget; /* номер объекта: 0, 1, 2, … */</CODE></P>
     <P><CODE>10  int ngetval; /* получаемое из buff[] значение */</CODE></P>
     <P><CODE>11  sem_t mutex, nempty, nstored; /* семафоры, а не указатели */</CODE></P>
     <P><CODE>12 } shared;</CODE></P>
     <P><CODE>13 void *produce(void *), *consume(void *);</CODE></P>
     <H2><a name=label440 style="border:none;"></a>Глобальные переменные и общая структура</H2>
     <P>4-12 Количество потоков-потребителей является глобальной переменной, устанавливаемой из командной строки. В структуру shared добавилось два новых поля: nget — номер следующего объекта, получаемого одним из потоков-потребителей, и ngetval — соответствующее значение.</P>
     <P>Функция main, текст которой приведен в листинге 10.16, запускает несколько потоков-потребителей и потоков-производителей одновременно.</P>
     <P>19-23 Новый аргумент командной строки указывает количество потоков-потребителей. Для хранения идентификаторов потоков-потребителей выделяется место под специальный массив (tid_consume), а для подсчета обработанных каждым потоком объектов выделяется массив conscount.</P>
     <P>24-50 Создаются несколько потоков-производителей и потребителей, после чего основной поток ждет их завершения.</P>
     <H2><a name=label441 style="border:none;"></a>Листинг 10.16. Функция main для версии с несколькими производителями и потребителями</H2>
     <P><CODE>//pxsem/prodcons4.с</CODE></P>
     <P><CODE>14 int</CODE></P>
     <P><CODE>15 main(int argc, char **argv)</CODE></P>
     <P><CODE>16 {</CODE></P>
     <P><CODE>17  int i, prodcount[MAXNTHREADS], conscount[MAXNTHREADS];</CODE></P>
     <P><CODE>18  pthread_t tid_produce[MAXNTHREADS], tid_consume[MAXNTHREADS];</CODE></P>
     <P><CODE>19  if (argc != 4)</CODE></P>
     <P><CODE>20   err_quit("usage: prodcons4 &lt;#items&gt; &lt;#producers&gt; &lt;#consumers&gt;");</CODE></P>
     <P><CODE>21  nitems = atoi(argv[1]);</CODE></P>
     <P><CODE>22  nproducers = min(atoi(argv[2]), MAXNTHREADS);</CODE></P>
     <P><CODE>23  nconsumers = min(atoi(argv[3]), MAXNTHREADS);</CODE></P>
     <P><CODE>24  /* инициализация трех семафоров */</CODE></P>
     <P><CODE>25  Sem_init(&amp;shared.mutex, 0, 1);</CODE></P>
     <P><CODE>26  Sem_init(&amp;shared.nempty, 0, NBUFF);</CODE></P>
     <P><CODE>27  Sem_init(&amp;shared.nstored, 0, 0);</CODE></P>
     <P><CODE>28  /* создание производителей и потребителей */</CODE></P>
     <P><CODE>29  Set_concurrency(nproducers + nconsumers);</CODE></P>
     <P><CODE>30  for (i = 0; i &lt; nproducers; i++) {</CODE></P>
     <P><CODE>31   prodcount[i] = 0;</CODE></P>
     <P><CODE>32   Pthread_create(&amp;tid_produce[i], NULL, produce, &amp;prodcount[i]);</CODE></P>
     <P><CODE>33  }</CODE></P>
     <P><CODE>34  for (i = 0; i &lt; nconsumers; i++) {</CODE></P>
     <P><CODE>35   conscount[i] = 0;</CODE></P>
     <P><CODE>36   Pthread_create(&amp;tid_consume[i], NULL, consume, &amp;conscount[i]);</CODE></P>
     <P><CODE>37  }</CODE></P>
     <P><CODE>38  /* ожидание завершения всех производителей и потребителей */</CODE></P>
     <P><CODE>39  for (i = 0; i &lt; nproducers: i++) {</CODE></P>
     <P><CODE>40   Pthread_join(tid_produce[i], NULL);</CODE></P>
     <P><CODE>41   printf("producer count[%d] = %d\n", i, prodcount[i]);</CODE></P>
     <P><CODE>42  }</CODE></P>
     <P><CODE>43  for (i = 0; i &lt; nconsumers; i++) {</CODE></P>
     <P><CODE>44   Pthread_join(tid_consume[i], NULL);</CODE></P>
     <P><CODE>45   printf("consumer count[%d] = %d\n", i, conscount[i]);</CODE></P>
     <P><CODE>46  }</CODE></P>
     <P><CODE>47  Sem_destroy(&amp;shared.mutex);</CODE></P>
     <P><CODE>48  Sem_destroy(&amp;shared.nempty);</CODE></P>
     <P><CODE>49  Sem_destroy(&amp;shared.nstored);</CODE></P>
     <P><CODE>50  exit(0);</CODE></P>
     <P><CODE>51 }</CODE></P>
     <P>Функция produce содержит одну новую строку по сравнению с листингом 10.13. В части кода, относящейся к завершению потока-производителя, появляется строка, отмеченная знаком +:</P>
     <P><CODE> if (shared.nput &gt;= nitems) {</CODE></P>
     <P><CODE>+ Sem_post(&amp;shared.nstored); /* даем возможность потребителям завершить работу */</CODE></P>
     <P><CODE>  Sem_post(&amp;shared.nempty);</CODE></P>
     <P><CODE>  Sem_post(&amp;shared.mutex);</CODE></P>
     <P><CODE>  return(NULL); /* готово */</CODE></P>
     <P><CODE> }</CODE></P>
     <P>Снова нам нужно быть аккуратными при обработке завершения процессов-производителей и потребителей. После обработки всех объектов в буфере все потребители блокируются в вызове</P>
     <P><CODE>Sem_wait(&amp;shared.nstored); /* Ожидание помещения объекта в буфер */</CODE></P>
     <P>Производителям приходится увеличивать семафор nstored для разблокирования потрeбитeлeй, чтобы они узнали, что работа завершена. Функция consume приведена в листинге 10.17. </P>
     <H2><a name=label442 style="border:none;"></a>Листинг 10.17. Функция, выполняемая всеми потоками-потребителями</H2>
     <P><CODE>//pxsem/prodcons4.c</CODE></P>
     <P><CODE>72 void *</CODE></P>
     <P><CODE>73 consume(void *arg)</CODE></P>
     <P><CODE>74 {</CODE></P>
     <P><CODE>75  int i;</CODE></P>
     <P><CODE>76  for (;;) {</CODE></P>
     <P><CODE>77   Sem_wait(&amp;shared.nstored); /* ожидание помещения объекта в буфер */</CODE></P>
     <P><CODE>78   Sem_wait(&amp;shared.mutex);</CODE></P>
     <P><CODE>79   if (shared.nget &gt;= nitems) {</CODE></P>
     <P><CODE>80    Sem_post(&amp;shared.nstored);</CODE></P>
     <P><CODE>81    Sem_post(&amp;shared.mutex);</CODE></P>
     <P><CODE>82    return(NULL); /* готово */</CODE></P>
     <P><CODE>83   }</CODE></P>
     <P><CODE>84   i = shared.nget % NBUFF;</CODE></P>
     <P><CODE>85   if (shared.buff[i] != shared.ngetval)</CODE></P>
     <P><CODE>86    printf("error: buff[%d] = %d\n", i, shared.buff[i]);</CODE></P>
     <P><CODE>87   shared.nget++;</CODE></P>
     <P><CODE>88   shared.ngetval++;</CODE></P>
     <P><CODE>89   Sem_post(&amp;shared.mutex);</CODE></P>
     <P><CODE>90   Sem_post(&amp;shared.nempty); /* освобождается место для элемента */</CODE></P>
     <P><CODE>91   *((int *) arg) += 1;</CODE></P>
     <P><CODE>92  }</CODE></P>
     <P><CODE>93 }</CODE></P>
     <H2><a name=label443 style="border:none;"></a>Завершение потоков-потребителей</H2>
     <P>79-83 Функция consume сравнивает nget и nitems, чтобы узнать, когда следует остановиться (аналогично функции produce). Обработав последний объект в буфере, потоки-потребители блокируются, ожидая изменения семафора nstored. Когда завершается очередной поток-потребитель, он увеличивает семафор nstored, давая возможность завершить работу другому потоку-потребителю.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label444 style="border:none;"></a>10.11. Несколько буферов</P>
     </H1>
     <P>Во многих программах, обрабатывающих какие-либо данные, можно встретить цикл вида</P>
     <P><CODE>while ((n = read(fdin, buff, BUFFSIZE)) &gt; 0) {</CODE></P>
     <P><CODE> /* обработка данных */</CODE></P>
     <P><CODE> write(fdout, buff, n);</CODE></P>
     <P><CODE>}</CODE></P>
     <P>Например, программы, обрабатывающие текстовые файлы, считывают строку из входного файла, выполняют с ней некоторые действия, а затем записывают строку в выходной файл. Для текстовых файлов вызовы read и write часто заменяются на функции стандартной библиотеки ввода-вывода fgets и fputs.</P>
     <P>На рис. 10.11 изображена иллюстрация к такой схеме. Здесь функция reader считывает данные из входного файла, а функция writer записывает данные в выходной файл. Используется один буфер.</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader173" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 10.10. Процесс считывает данные в буфер, а потом записывает его содержимое в другой файл</P>
     <BR>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader174" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 10.11. Один процесс, считывающий данные в буфер и записывающий их в файл</P>
     <BR>
     <P>На рис. 10.10 приведена временная диаграмма работы такой программы. Числа слева проставлены в условных единицах времени. Предполагается, что операция чтения занимает 5 единиц, записи — 7, а обработка данных между считыванием и записью требует 2 единицы времени.</P>
     <P>Можно изменить это приложение, разделив процесс на отдельные потоки, как показано на рис. 10.12. Здесь используется два потока (а не процесса), поскольку глобальный буфер автоматически разделяется между ними. Мы могли бы разделить приложение и на два процесса, но это потребовало бы использования разделяемой памяти, с которой мы еще не знакомы.</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader177" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 10.12. Разделение копирования файла между двумя потоками</P>
     <BR>
     <P>Разделение операций между потоками (или процессами) требует использования какой-либо формы уведомления между ними. Считывающий поток должен уведомлять записывающий о готовности буфера к операции записи, а записывающий должен уведомлять считывающий о том, что буфер пуст и его можно заполнять снова. На рис. 10.13 изображена временная диаграмма для новой схемы. </P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader179" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 10.13. Копирование файла двумя потоками</P>
     <BR>
     <P>Предполагается, что для обработки данных в буфере требуется две единицы времени. Важно отметить, что разделение чтения и записи между двумя потоками ничуть не ускорило выполнение операции копирования в целом. Мы не выиграли в скорости, мы просто распределили выполнение задачи между двумя потоками (или процессами).</P>
     <P>В этих диаграммах мы игнорируем множество тонкостей. Например, большая часть ядер Unix выявляет операцию последовательного считывания файла и осуществляет асинхронное упреждающее чтение следующего блока данных еще до поступления запроса. Это может ускорить работу процесса, считывающего данные. Мы также игнорируем влияние других процессов на наши считывающий и записывающий потоки, а также влияние алгоритмов разделения времени, реализованных в ядре.</P>
     <P>Следующим шагом будет использование двух потоков (или процессов) и двух буферов. Это называется классическим решением с двойной буферизацией; схема его изображена на рис. 10.14.</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader180" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 10.14. Копирование файла двумя потоками с двумя буферами</P>
     <BR>
     <P>На нашем рисунке считывающий поток помещает данные в первый буфер, а записывающий берет их из второго. После этого потоки меняются местами.</P>
     <P>На рис. 10.15 изображена временная диаграмма процесса с двойной буферизацией. Считывающий поток помещает данные в буфер № 1, а затем уведомляет записывающий о том, что буфер готов к обработке. Затем считывающий процесс помещает данные в буфер № 2, а записывающий берет их из буфера № 1.</P>
     <P>В любом случае, мы ограничены скоростью выполнения самой медленной операции — операции записи. После выполнения первых двух операций считывания серверу приходится ждать две дополнительные единицы времени, составляющие разницу в скорости выполнения операций чтения и записи. Тем не менее для нашего гипотетического примера полное время работы будет сокращено почти вдвое.</P>
     <P>Обратите внимание, что операции записи выполняются так быстро, как только возможно. Они разделены промежутками времени всего лишь в 2 единицы, тогда как в предыдущих примерах между ними проходило 9 единиц времени (рис. 10.10 и 10.13). Это может оказаться выгодным при работе с некоторыми устройствами типа накопителей на магнитной ленте, которые функционируют быстрее, если данные записываются с максимально возможной скоростью (это называется потоковым режимом — streaming mode).</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader183" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 10.15. Процесс с двойной буферизацией</P>
     <BR>
     <P>Интересно, что задача с двойной буферизацией представляет собой лишь частный случай общей задачи производителей и потребителей.</P>
     <P>Изменим нашу программу так, чтобы использовать несколько буферов. Начнем с решения из листинга 10.11, в котором использовались размещаемые в памяти семафоры. Мы получим даже не двойную буферизацию, а работу с произвольным числом буферов (задается NBUFF). В листинге 10.18 даны глобальные переменные и функция main.</P>
     <H2><a name=label445 style="border:none;"></a>Листинг 10.18. Глобальные переменные и функция main</H2>
     <P><CODE>//pxsem/mycat2.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #define NBUFF 8</CODE></P>
     <BR>
     <P><CODE>3  struct { /* общие данные */</CODE></P>
     <P><CODE>4   struct {</CODE></P>
     <P><CODE>5    char data[BUFFSIZE]; /* буфер */</CODE></P>
     <P><CODE>6    ssize_t n; /* объем буфера */</CODE></P>
     <P><CODE>7   } buff[NBUFF]; /* количество буферов */</CODE></P>
     <P><CODE>8   sem_t mutex, nempty, nstored; /* семафоры, а не указатели */</CODE></P>
     <P><CODE>9  } shared;</CODE></P>
     <P><CODE>10 int fd; /* входной файл, копируемый в стандартный поток вывода */</CODE></P>
     <P><CODE>11 void *produce(void *), *consume(void *);</CODE></P>
     <BR>
     <P><CODE>12 int</CODE></P>
     <P><CODE>13 main(int argc, char **argv)</CODE></P>
     <P><CODE>14 {</CODE></P>
     <P><CODE>15  pthread_t tid_produce, tid_consume;</CODE></P>
     <P><CODE>16  if (argc != 2)</CODE></P>
     <P><CODE>17   err_quit("usage: mycat2 &lt;pathname&gt;");</CODE></P>
     <P><CODE>18  fd = Open(argv[1], O_RDONLY);</CODE></P>
     <P><CODE>19  /* инициализация трех семафоров */</CODE></P>
     <P><CODE>20  Sem_init(&amp;shared.mutex, 0, 1);</CODE></P>
     <P><CODE>21  Sem_init(&amp;shared.nempty, 0, NBUFF);</CODE></P>
     <P><CODE>22  Sem_init(&amp;shared.nstored, 0, 0);</CODE></P>
     <P><CODE>23  /* один производитель, один потребитель */</CODE></P>
     <P><CODE>24  Set_concurrency(2);</CODE></P>
     <P><CODE>25  Pthread_create(&amp;tid_produce, NULL, produce, NULL); /* reader thread */</CODE></P>
     <P><CODE>26  Pthread_create(&amp;tid_consume, NULL, consume, NULL); /* writer thread */</CODE></P>
     <P><CODE>27  Pthread_join(tid_produce, NULL);</CODE></P>
     <P><CODE>28  Pthread_join(tid_consume, NULL);</CODE></P>
     <P><CODE>29  Sem_destroy(&amp;shared.mutex);</CODE></P>
     <P><CODE>30  Sem_destroy(&amp;shared.nempty);</CODE></P>
     <P><CODE>31  Sem_destroy(&amp;shared.nstored);</CODE></P>
     <P><CODE>32  exit(0);</CODE></P>
     <P><CODE>33 }</CODE></P>
     <H2><a name=label446 style="border:none;"></a>Объявление нескольких буферов</H2>
     <P>2-9 Структура shared содержит массив структур buff, которые состоят из буфера и его счетчика. Мы создаем NBUFF таких буферов.</P>
     <H2><a name=label447 style="border:none;"></a>Открытие входного файла</H2>
     <P>18 Аргумент командной строки интерпретируется как имя файла, который копируется в стандартный поток вывода.</P>
     <P>В листинге 10.19 приведен текст функций produce и consume.</P>
     <H2><a name=label448 style="border:none;"></a>Листинг 10.19. Функции produce и consume</H2>
     <P><CODE>//pxsem/mycat2.c</CODE></P>
     <P><CODE>34 void *</CODE></P>
     <P><CODE>35 produce(void *arg)</CODE></P>
     <P><CODE>36 {</CODE></P>
     <P><CODE>37  int i;</CODE></P>
     <P><CODE>38  for (i = 0;;) {</CODE></P>
     <P><CODE>39   Sem_wait(&amp;shared.nempty); /* Ожидание освобождения места в буфере */</CODE></P>
     <P><CODE>40   Sem_wait(&amp;shared.mutex);</CODE></P>
     <P><CODE>41   /* критическая область */</CODE></P>
     <P><CODE>42   Sem_post(&amp;shared.mutex);</CODE></P>
     <P><CODE>43   shared.buff[i].n = Read(fd, shared.buff[i].data, BUFFSIZE);</CODE></P>
     <P><CODE>44   if (shared.buff[i].n == 0) {</CODE></P>
     <P><CODE>45    Sem_post(&amp;shared.nstored); /* еще один объект */</CODE></P>
     <P><CODE>46    return(NULL);</CODE></P>
     <P><CODE>47   }</CODE></P>
     <P><CODE>48   if (++i &gt;= NBUFF)</CODE></P>
     <P><CODE>49    i = 0; /* кольцевой буфер */</CODE></P>
     <P><CODE>50   Sem_post(&amp;shared.nstored); /* еще один объект */</CODE></P>
     <P><CODE>51  }</CODE></P>
     <P><CODE>52 }</CODE></P>
     <BR>
     <P><CODE>53 void *</CODE></P>
     <P><CODE>54 consume(void *arg)</CODE></P>
     <P><CODE>55 {</CODE></P>
     <P><CODE>56  int i;</CODE></P>
     <P><CODE>57  for (i = 0;;) {</CODE></P>
     <P><CODE>58   Sem_wait(&amp;shared.nstored); /* ожидание появления объекта для обработки */</CODE></P>
     <P><CODE>59   Sem_wait(&amp;shared.mutex);</CODE></P>
     <P><CODE>60   /* критическая область */</CODE></P>
     <P><CODE>61   Sem_post(&amp;shared.mutex);</CODE></P>
     <P><CODE>62   if (shared.buff[i].n == 0)</CODE></P>
     <P><CODE>63    return(NULL);</CODE></P>
     <P><CODE>64   Write(STDOUT_FILENO, shared.buff[i].data, shared.buff[i].n);</CODE></P>
     <P><CODE>65   if (++i &gt;= NBUFF)</CODE></P>
     <P><CODE>66    i=0; /* кольцевой буфер */</CODE></P>
     <P><CODE>67   Sem_post(&amp;shared.nempty); /* освободилось место для объекта */</CODE></P>
     <P><CODE>68  }</CODE></P>
     <P><CODE>69 }</CODE></P>
     <H2><a name=label449 style="border:none;"></a>Пустая критическая область</H2>
     <P>40-42 Критическая область, защищаемая семафором mutex, в данном примере пуста. Если бы буферы данных представляли собой связный список, здесь мы могли бы удалять буфер из списка, не конфликтуя при этом с производителем. Но в нашем примере, где мы просто переходим к следующему буферу с единственным потоком-производителем, защищать нам просто нечего. Тем не менее мы оставляем операции установки и снятия блокировки, подчеркивая, что они могут потребоваться в новых версиях кода.</P>
     <H2><a name=label450 style="border:none;"></a>Считывание данных и увеличение семафора nstored</H2>
     <P>43-49 Каждый раз, когда производитель получает пустой буфер, он вызывает функцию read. При возвращении из read увеличивается семафор nstored, уведомляя потребителя о том, что буфер готов. При возвращении функцией read значения 0 (конец файла) семафор увеличивается, а производитель завершает работу.</P>
     <H2><a name=label451 style="border:none;"></a>Поток-потребитель</H2>
     <P>57-68 Поток-потребитель записывает содержимое буферов в стандартный поток вывода. Буфер, содержащий нулевой объем данных, обозначает конец файла. Как и в потоке-производителе, критическая область, защищенная семафором mutex, пуста.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>В разделе 22.3 книги [24] мы разработали пример с несколькими буферами. В этом примере производителем был обработчик сигнала SIGIO, а потребитель представлял собой основной цикл обработки (функцию dg_echo). Разделяемой переменной был счетчик nqueue. Потребитель блокировал сигнал SIGIO на время проверки или изменения счетчика.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label452 style="border:none;"></a>10.12. Использование семафоров несколькими процессами</P>
     </H1>
     <P>Правила совместного использования размещаемых в памяти семафоров несколькими процессами просты: сам семафор (переменная типа semt, адрес которой является первым аргументом sem_init) должен находиться в памяти, разделяемой всеми процессами, которые хотят его использовать, а второй аргумент функции sem_init должен быть равен 1.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Эти правила аналогичны требованиям к разделению взаимного исключения, условной переменной или блокировки чтения-записи между процессами: средство синхронизации (переменная типа pthread_mutex_t, pthread_cond_t или pthread_rwlock_t) должно находиться в разделяемой памяти и инициализироваться с атрибутом PTHREAD_PROCESS SHARED.</P>
     </DIV>
     <P>Что касается именованных семафоров, процессы всегда могут обратиться к одному и тому же семафору, указав одинаковое имя при вызове sem_open. Хотя указатели, возвращаемые sem_open отдельным процессам, могут быть различны, все функции, работающие с семафорами, будут обращаться к одному и тому же именованному семафору.</P>
     <P>Что произойдет, если мы вызовем функцию sem_open, возвращающую указатель на тип sem_t, а затем вызовем fork? В описании функции fork в стандарте Posix.1 говорится, что «все открытые родительским процессом семафоры будут открыты и в дочернем процессе». Это означает, что нижеследующий код верен:</P>
     <P><CODE>sem_t *mutex; /* глобальный указатель, копируемый, при вызове fork() */</CODE></P>
     <P><CODE>…</CODE></P>
     <P><CODE>/* родительский процесс создает именованный семафор */</CODE></P>
     <P><CODE>mutex = Sem_open(Px_ipc_name(NAME), O_CREAT | O_EXCL, FILE_MODE, 0);</CODE></P>
     <P><CODE>if ((childpid = Fork()) == 0) {</CODE></P>
     <P><CODE> /* дочерний процесс */</CODE></P>
     <P><CODE> …</CODE></P>
     <P><CODE> Sem_wait(mutex);</CODE></P>
     <P><CODE> …</CODE></P>
     <P><CODE>}</CODE></P>
     <P><CODE>/* родительский процесс */</CODE></P>
     <P><CODE>…</CODE></P>
     <P><CODE>Sem_post(mutex);</CODE></P>
     <P><CODE>…</CODE></P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Причина, по которой следует аккуратно относиться к передаче семафоров при порождении процессов, заключается в том, что состояние семафора может храниться в переменной типа sem_t, но для его работы может требоваться и другая информация (например, дескрипторы файлов). В следующей главе мы увидим, что семафоры System V однозначно определяются их целочисленными идентификаторами, возвращаемыми функцией semget. Любой процесс, которому известен идентификатор, может получить доступ к семафору. Вся информация о семафоре System V хранится в ядре, а целочисленный идентификатор просто указывает номер семафора ядру.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label453 style="border:none;"></a>10.13. Ограничения на семафоры</P>
     </H1>
     <DIV class=section>
      <P>Стандартом Posix определены два ограничения на семафоры:</P>
      <P><STRONG>■</STRONG> SEM_NSEMS_MAX — максимальное количество одновременно открытых семафоров для одного процесса (Posix требует, чтобы это значение было не менее 256);</P>
      <P><STRONG>■</STRONG> SEM_VALUE_MAX — максимальное значение семафора (Posix требует, чтобы оно было не меньше 32767).</P>
      <P>Две эти константы обычно определены в заголовочном файле &lt;unistd.h&gt; и могут быть получены во время выполнения вызовом sysconf, как мы показываем ниже.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label454 style="border:none;"></a>Пример: программа semsysconf</P>
      </H1>
      <P>Программа в листинге 10.20 вызывает sysconf и выводит два ограничения на семафоры, зависящие от конкретной реализации. </P>
      <H2><a name=label455 style="border:none;"></a>Листинг 10.20. Вызов sysconf для получения ограничений на семафоры</H2>
      <P><CODE>//pxsem/semsysconf.с</CODE></P>
      <P><CODE>1 #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2 int</CODE></P>
      <P><CODE>3 main(int argc, char **argv)</CODE></P>
      <P><CODE>4 {</CODE></P>
      <P><CODE>5  printf("SEM_NSEMS_MAX = %ld, SEM_VALUE_MAX = %ld\n",</CODE></P>
      <P><CODE>6   Sysconf(_SC_SEM_NSEMS_MAX), Sysconf(_SC_SEM_VALUE_MAX));</CODE></P>
      <P><CODE>7  exit(0);</CODE></P>
      <P><CODE>8 }</CODE></P>
      <P>При запуске этой программы в наших двух тестовых системах получим следующий результат:</P>
      <P><CODE>solaris % <STRONG>semsysconf</STRONG></CODE></P>
      <P><CODE>SEMS_NSEMS_MAX = 2147483647, SEM_VALUE_MAX = 2147483647</CODE></P>
      <P><CODE>alpha % <STRONG>semsysconf</STRONG></CODE></P>
      <P><CODE>SEMS_NSEMS_MAX = 256, SEM_VALUE_MAX = 32767</CODE></P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label456 style="border:none;"></a>10.14. Реализация с использованием FIFO</P>
     </H1>
     <DIV class=section>
      <P>Займемся реализацией именованных семафоров Posix с помощью каналов FIFO. Именованный семафор реализуется как канал FIFO с конкретным именем. Неотрицательное количество байтов в канале соответствует текущему значению семафора. Функция sem_post помещает 1 байт в канал, a sem_wait считывает его оттуда (приостанавливая выполнение процесса, если канал пуст, а именно этого мы и хотим). Функция sem_open создает канал FIFO, если указан флаг O_CREAT; открывает его дважды (один раз на запись, другой — на чтение) и при создании нового канала FIFO помещает в него некоторое количество байтов, указанное в качестве начального значения.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Этот и последующие разделы данной главы содержат усложненный материал, который можно при первом чтении пропустить.</P>
      </DIV>
      <P>Приведем текст нашего заголовочного файла semaphore.h, определяющего фундаментальный тип sem_t (листинг 10.21).</P>
      <H2><a name=label457 style="border:none;"></a>Листинг 10.21. Заголовочный файл semaphore.h</H2>
      <P><CODE>//my_pxsem_fifo/semaphore.h</CODE></P>
      <P><CODE>1  /* фундаментальный тип */</CODE></P>
      <P><CODE>2  typedef struct {</CODE></P>
      <P><CODE>3   int sem_fd[2]; /* два дескриптора fd: [0] для чтения, [1] для записи */</CODE></P>
      <P><CODE>4   int sem_magic; /* магическое число */</CODE></P>
      <P><CODE>5  } mysem_t;</CODE></P>
      <BR>
      <P><CODE>6  #define SEM_MAGIC 0x89674523</CODE></P>
      <BR>
      <P><CODE>7  #ifdef SEM_FAILED</CODE></P>
      <P><CODE>8  #undef SEM_FAILED</CODE></P>
      <P><CODE>9  #define SEM_FAILED ((mysem_t *)(-1)) /* чтобы компилятор не выдавал предупреждений*/</CODE></P>
      <BR>
      <P><CODE>10 #endif</CODE></P>
      <H2><a name=label458 style="border:none;"></a>Тип данных sem_t</H2>
      <P>1-5 Новая структура данных содержит два дескриптора, один из которых предназначен для чтения из FIFO, а другой — для записи. Для единообразия мы храним оба дескриптора в массиве из двух элементов, в котором первый дескриптор всегда открыт на чтение, а второй — на запись.</P>
      <P>Поле sem_magiс содержит значение SEM_MAGIC, если структура проинициализирована. Это значение проверяется всеми функциями, которым передается указатель на тип sem_t, чтобы гарантировать, что передан был действительно указатель на заранее инициализированную структуру, а не на произвольную область памяти. При закрытии семафора этому полю присваивается значение 0. Этот метод хотя и не совершенен, но дает возможность обнаружить некоторые ошибки при написании программ.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label459 style="border:none;"></a>Функция sem_open</P>
      </H1>
      <P>В листинге 10.22 приведен текст функции sem_open, которая создает новый семафор или открывает существующий.</P>
      <H2><a name=label460 style="border:none;"></a>Листинг 10.22. Функция sem_open</H2>
      <P><CODE>//my_pxsem_fifo/sem_open.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "semaphore.h"</CODE></P>
      <P><CODE>3  #include &lt;stdarg.h&gt; /* для произвольного списка аргументов */</CODE></P>
      <BR>
      <P><CODE>4  mysem_t *</CODE></P>
      <P><CODE>5  mysem_open(const char *pathname, int oflag, …)</CODE></P>
      <P><CODE>6  {</CODE></P>
      <P><CODE>7   int i, flags, save_errno;</CODE></P>
      <P><CODE>8   char c;</CODE></P>
      <P><CODE>9   mode_t mode;</CODE></P>
      <P><CODE>10  va_list ap;</CODE></P>
      <P><CODE>11  mysem_t *sem;</CODE></P>
      <P><CODE>12  unsigned int value;</CODE></P>
      <P><CODE>13  if (oflag &amp; O_CREAT) {</CODE></P>
      <P><CODE>14   va_start(ap, oflag); /* ар инициализируется последним аргументом */</CODE></P>
      <P><CODE>15   mode = va_arg(ap, va_mode_t);</CODE></P>
      <P><CODE>16   value = va_arg(ap, unsigned int);</CODE></P>
      <P><CODE>17   va_end(ap);</CODE></P>
      <P><CODE>18   if (mkfifo(pathname, mode) &lt; 0) {</CODE></P>
      <P><CODE>19    if (errno == EEXIST &amp;&amp; (oflag &amp; O_EXCL) == 0)</CODE></P>
      <P><CODE>20     oflag &amp;= ~O_CREAT; /* уже существует, OK */</CODE></P>
      <P><CODE>21    else</CODE></P>
      <P><CODE>22     return(SEM_FAILED);</CODE></P>
      <P><CODE>23   }</CODE></P>
      <P><CODE>24  }</CODE></P>
      <P><CODE>25  if ((sem = malloc(sizeof(mysem_t))) == NULL)</CODE></P>
      <P><CODE>26   return(SEM_FAILED);</CODE></P>
      <P><CODE>27  sem-&gt;sem_fd[0] = sem-&gt;sem_fd[1] = –1;</CODE></P>
      <P><CODE>28  if ((sem-&gt;sem_fd[0] = open(pathname, O_RDONLY | O_NONBLOCK)) &lt; 0)</CODE></P>
      <P><CODE>29   goto error;</CODE></P>
      <P><CODE>30  if ((sem-&gt;sem_fd[1] = open(pathname, O_WRONLY | O_NONBLOCK)) &lt; 0)</CODE></P>
      <P><CODE>31   goto error;</CODE></P>
      <P><CODE>32  /* отключение неблокируемого режима для sem_fd[0] */</CODE></P>
      <P><CODE>33  if ((flags = fcntl(sem-&gt;sem_fd[0], F_GETFL, 0)) &lt; 0)</CODE></P>
      <P><CODE>34   goto error;</CODE></P>
      <P><CODE>35  flags &amp;= ~O_NONBLOCK;</CODE></P>
      <P><CODE>36  if (fcntl(sem-&gt;sem_fd[0], F_SETFL, flags) &lt; 0)</CODE></P>
      <P><CODE>37   goto error;</CODE></P>
      <P><CODE>38  if (oflag &amp; O_CREAT) { /* инициализация семафора */</CODE></P>
      <P><CODE>39   for (i = 0; i &lt; value; i++)</CODE></P>
      <P><CODE>40    if (write(sem-&gt;sem_fd[1], &amp;c, 1) != 1)</CODE></P>
      <P><CODE>41   goto error;</CODE></P>
      <P><CODE>42  }</CODE></P>
      <P><CODE>43  sem-&gt;sem_magic = SEM_MAGIC;</CODE></P>
      <P><CODE>44  return(sem);</CODE></P>
      <P><CODE>45 error:</CODE></P>
      <P><CODE>46  save_errno = errno;</CODE></P>
      <P><CODE>47  if (oflag &amp; O_CREAT)</CODE></P>
      <P><CODE>48   unlink(pathname); /* если мы создали FIFO */</CODE></P>
      <P><CODE>49  close(sem-&gt;sem_fd[0]); /* игнорируем ошибку */</CODE></P>
      <P><CODE>50  close(sem-&gt;sem_fd[1]); /* игнорируем ошибку */</CODE></P>
      <P><CODE>51  free(sem);</CODE></P>
      <P><CODE>52  errno = save_errno;</CODE></P>
      <P><CODE>53  return(SEM_FAILED);</CODE></P>
      <P><CODE>54 }</CODE></P>
      <H2><a name=label461 style="border:none;"></a>Создание нового sсемафора</H2>
      <P>13-17 Если при вызове указан флаг O_CREAT, должно быть указано четыре аргумента, а не два. Мы вызываем va_start, после чего переменная ар указывает на последний явно указанный аргумент (oflag). Затем мы используем ар и функцию va_arg для получения значений третьего и четвертого аргументов. Работу со списком аргументов переменной длины и использование нашего типа va_mode_t мы обсуждали в связи с листингом 5.17.</P>
      <H2><a name=label462 style="border:none;"></a>Создание нового канала FIFO</H2>
      <P>18-23 Создается новый канал FIFO, имя которого было указано при вызове функции. Как мы отмечали в разделе 4.6, эта функция возвращает ошибку EEXIST, если канал уже существует. Если при вызове sem_open флаг O_EXCL не был указан, мы пропускаем эту ошибку; но нам не нужно будет инициализировать этот канал, так что мы при этом сбрасываем флаг O_CREAT.</P>
      <H2><a name=label463 style="border:none;"></a>Выделение памяти под тип sem_t и открытие FIFO на чтение и запись</H2>
      <P>25-37 Мы выделяем место для типа sem_t, который содержит два дескриптора. Затем мы дважды открываем канал FIFO: один раз только на чтение, а другой — только на запись. При этом мы не хотим блокирования при вызове open, поэтому указываем флаги O_NONBLOCK при открытии очереди только для чтения (вспомните табл. 4.1). Мы также указываем флаг O_NONBLOCK при открытии канала на запись, но это предназначено для обнаружения переполнения (на тот случай, если мы попытаемся записать больше, чем позволяет PIPE_BUF). После открытия канала мы отключаем неблокируемый режим для дескриптора, открытого на чтение.</P>
      <H2><a name=label464 style="border:none;"></a>Инициализация значения созданного семафора</H2>
      <P>38-42 Если мы создали семафор, его нужно проинициализировать, записав в канал FIFO value байтов. Если указанное при вызове значение value превышает определенное реализацией ограничение PIPE_BUF, вызов write после переполнения FIFO вернет ошибку с кодом EAGAIN.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label465 style="border:none;"></a>Функция sem_close</P>
      </H1>
      <P>Текст функции sem_close приведен в листинге 10.23.</P>
      <P>11-15 Мы закрываем оба дескриптора и освобождаем память, выделенную под тип sem_t.</P>
      <H2><a name=label466 style="border:none;"></a>Листинг 10.23. Функция sem_close</H2>
      <P><CODE>//my_pxsem_fifo/sem_close.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "semaphore.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  mysem_close(mysem_t *sem)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   if (sem-&gt;sem_magic != SEM_MAGIC) {</CODE></P>
      <P><CODE>7    errno = EINVAL;</CODE></P>
      <P><CODE>8    return(-1);</CODE></P>
      <P><CODE>9   }</CODE></P>
      <P><CODE>10  sem-&gt;sem_magic = 0; /* чтобы семафор нельзя было больше использовать */</CODE></P>
      <P><CODE>11  if (close(sem-&gt;sem_fd[0]) == –1 || close(sem-&gt;sem_fd[1]) == –1) {</CODE></P>
      <P><CODE>12   free(sem);</CODE></P>
      <P><CODE>13   return(-1);</CODE></P>
      <P><CODE>14  }</CODE></P>
      <P><CODE>15  free(sem);</CODE></P>
      <P><CODE>16  return(0);</CODE></P>
      <P><CODE>17 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label467 style="border:none;"></a>Функция sem_unlink</P>
      </H1>
      <P>Функция sem_unlink, текст которой приведен в листинге 10.24, удаляет из файловой системы наш семафор. Она просто вызывает unlink.</P>
      <H2><a name=label468 style="border:none;"></a>Листинг 10.24. Функция sem_unlink</H2>
      <P><CODE>//my_pxsem_fifo/sem_unlink. с</CODE></P>
      <P><CODE>1 #include "unpipc.h"</CODE></P>
      <P><CODE>2 #include "semaphore.h"</CODE></P>
      <BR>
      <P><CODE>3 int</CODE></P>
      <P><CODE>4 mysem_unlink(const char *pathname)</CODE></P>
      <P><CODE>5 {</CODE></P>
      <P><CODE>6  return(unlink(pathname));</CODE></P>
      <P><CODE>7 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label469 style="border:none;"></a>Функция sem_post</P>
      </H1>
      <P>В листинге 10.25 приведен текст функции sem_post, которая увеличивает значение семафора.</P>
      <P>11-12 Мы записываем один байт в FIFO. Если канал был пуст, это приведет к возобновлению выполнения всех процессов, заблокированных в вызове read для этого канала.</P>
      <H2><a name=label470 style="border:none;"></a>Листинг 10.25. Функция sem_post</H2>
      <P><CODE>//my_pxsem_fifo/sem_post.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "semaphore.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  mysem_post(mysem_t *sem)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   char c;</CODE></P>
      <P><CODE>7   if (sem-&gt;sem_magic != SEM_MAGIC) {</CODE></P>
      <P><CODE>8    errno = EINVAL;</CODE></P>
      <P><CODE>9    return(-1);</CODE></P>
      <P><CODE>10  }</CODE></P>
      <P><CODE>11  if (write(sem-&gt;sem_fd[1], &amp;c, 1) == 1)</CODE></P>
      <P><CODE>12   return(0);</CODE></P>
      <P><CODE>13  return(-1);</CODE></P>
      <P><CODE>14 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label471 style="border:none;"></a>Функция sem_wait</P>
      </H1>
      <P>Последняя функция для работы с именованными семафорами Posix — sem_wait. Ее текст приведен в листинге 10.26.</P>
      <H2><a name=label472 style="border:none;"></a>Листинг 10.26. Функция sem_wait</H2>
      <P><CODE>//my_pxsem_fifo/sem_wait.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "semaphore.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  mysem_wait(mysem_t *sem)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   char c;</CODE></P>
      <P><CODE>7   if (sem-&gt;sem_magic != SEM_MAGIC) {</CODE></P>
      <P><CODE>8    errno = EINVAL;</CODE></P>
      <P><CODE>9    return(-1);</CODE></P>
      <P><CODE>10  }</CODE></P>
      <P><CODE>11  if (read(sem-&gt;sem_fd[0], &amp;c, 1) == 1)</CODE></P>
      <P><CODE>12   return(0);</CODE></P>
      <P><CODE>13  return(-1);</CODE></P>
      <P><CODE>14 }</CODE> </P>
      <P>11-12 Мы считываем 1 байт из канала FIFO, причем работа приостанавливается, если канал пуст.</P>
      <P>Мы еще не реализовали функцию sem_trywait, но это можно сделать, установив флаг отключения блокировки для канала и используя обычный вызов read. Мы также не реализовали функцию sem_getvalue. В некоторых реализациях при вызове функции stat или fstat возвращается количество байтов в именованном или неименованном канале, причем оно помещается в поле st_size структуры stat. Однако это не гарантируется стандартом Posix и, следовательно, не обязательно будет работать в других системах. Пример реализации этих двух функций для работы с семафорами Posix приведен в следующем разделе.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label473 style="border:none;"></a>10.15. Реализация с помощью отображения в память</P>
     </H1>
     <DIV class=section>
      <P>Теперь займемся реализацией именованных семафоров Posix с помощью отображаемых в память файлов вместе со взаимными исключениями и условными переменными Posix. Реализация, аналогичная данной, приведена в разделе В.11.3 Обоснования стандарта IEEE 1996 [8].</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Отображаемые в память файлы описаны в главах 12 и 13. Данный раздел можно отложить, с тем чтобы вернуться к нему после прочтения этих глав. </P>
      </DIV>
      <P>Прежде всего приведем текст нашего заголовочного файла semaphore.h (листинг 10.27), в котором определяется фундаментальный тип sem_t.</P>
      <H2><a name=label474 style="border:none;"></a>Тип sem_t</H2>
      <P>1-7 Структура данных семафора содержит взаимное исключение, условную переменную и беззнаковое целое, в котором хранится текущее значение семафора. Как уже говорилось в связи с листингом 10.21, поле sem_magiс получает значение SEM_MAGIC при инициализации структуры.</P>
      <H2><a name=label475 style="border:none;"></a>Листинг 10.27. Заголовочный файл semaphore.h</H2>
      <P><CODE>//my_pxsem_mmap/semaphore.h</CODE></P>
      <P><CODE>1  /* фундаментальный тип */</CODE></P>
      <P><CODE>2  typedef struct {</CODE></P>
      <P><CODE>3   pthread_mutex_t sem_mutex; /* блокируется при проверке и изменении значения семафора */</CODE></P>
      <P><CODE>4   pthread_cond_t sem_cond; /* при изменении нулевого значения */</CODE></P>
      <P><CODE>5   unsigned int sem_count; /* значение семафора */</CODE></P>
      <P><CODE>6   int sem_magic; /* магическое значение, если семафор открыт */</CODE></P>
      <P><CODE>7  } mysem_t;</CODE></P>
      <BR>
      <P><CODE>8  #define SEM_MAGIC 0x67458923</CODE></P>
      <BR>
      <P><CODE>9  #ifdef SEM_FAILED</CODE></P>
      <P><CODE>10 #undef SEM_FAILED</CODE></P>
      <P><CODE>11 #define SEM_FAILED ((mysem_t *)(-1)) /* чтобы избежать предупреждений компилятора */</CODE></P>
      <P><CODE>12 #endif</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label476 style="border:none;"></a>Функция sem_open</P>
      </H1>
      <P>В листинге 10.28 приведен текст первой части функции sem_open, которая может использоваться для создания нового семафора или открытия существующего.</P>
      <H2><a name=label477 style="border:none;"></a>Листинг 10.28. Функция sem_open: первая половина</H2>
      <P><CODE>//my_pxsem_mmap/sem_open.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "semaphore.h"</CODE></P>
      <P><CODE>3  #include &lt;stdarg.h&gt; /* для списков аргументов переменной длины */</CODE></P>
      <P><CODE>4  #define MAX_TRIES 10 /* количество попыток инициализации */</CODE></P>
      <BR>
      <P><CODE>5  mysem_t *</CODE></P>
      <P><CODE>6  mysem_open(const char *pathname, int oflag, …)</CODE></P>
      <P><CODE>7  {</CODE></P>
      <P><CODE>8   int fd, i, created, save_errno;</CODE></P>
      <P><CODE>9   mode_t mode;</CODE></P>
      <P><CODE>10  va_list ap;</CODE></P>
      <P><CODE>11  mysem_t *sem, seminit;</CODE></P>
      <P><CODE>12  struct stat statbuff;</CODE></P>
      <P><CODE>13  unsigned int value;</CODE></P>
      <P><CODE>14  pthread_mutexattr_t mattr;</CODE></P>
      <P><CODE>15  pthread_condattr_t cattr;</CODE></P>
      <P><CODE>16  created = 0;</CODE></P>
      <P><CODE>17  sem = MAP_FAILED; /* [sic] */</CODE></P>
      <P><CODE>18 again:</CODE></P>
      <P><CODE>19  if (oflag &amp; O_CREAT) {</CODE></P>
      <P><CODE>20   va_start(ap, oflag); /* ар инициализируется последним явно указанным аргументом */</CODE></P>
      <P><CODE>21   mode = va_arg(ap, va_mode_t) &amp; ~S_IXUSR;</CODE></P>
      <P><CODE>22   value = va_arg(ap, unsigned int);</CODE></P>
      <P><CODE>23   va_end(ap);</CODE></P>
      <P><CODE>24   /* открываем с указанием флага O_EXCL и установкой бита user-execute */</CODE></P>
      <P><CODE>25   fd = open(pathname, oflag | O_EXCL | O_RDWR, mode | S_IXUSR);</CODE></P>
      <P><CODE>26   if (fd &lt; 0) {</CODE></P>
      <P><CODE>27    if (errno == EEXIST &amp;&amp; (oflag &amp; O_EXCL) == 0)</CODE></P>
      <P><CODE>28     goto exists; /* уже существует. OK */</CODE></P>
      <P><CODE>29    else</CODE></P>
      <P><CODE>30     return(SEM_FAILED);</CODE></P>
      <P><CODE>31   }</CODE></P>
      <P><CODE>32   created = 1;</CODE></P>
      <P><CODE>33   /* кто создает файл, тот его и инициализирует */</CODE></P>
      <P><CODE>34   /* установка размера файла */</CODE></P>
      <P><CODE>35   bzero(&amp;seminit, sizeof(seminit));</CODE></P>
      <P><CODE>36   if (write(fd, &amp;seminit, sizeof(seminit)) != sizeof(seminit))</CODE></P>
      <P><CODE>37    goto err;</CODE></P>
      <P><CODE>38   /* отображение файла в память */</CODE></P>
      <P><CODE>39   sem = mmap(NULL, sizeof(mysem_t), PROT_READ | PROT_WRITE,</CODE></P>
      <P><CODE>40    MAP_SHARED, fd, 0);</CODE></P>
      <P><CODE>41   if (sem == MAP_FAILED)</CODE></P>
      <P><CODE>42    goto err;</CODE></P>
      <P><CODE>43   /* инициализация взаимного исключения, условной переменной, значения семафора */</CODE></P>
      <P><CODE>44   if ((i = pthread_mutexattr_init(&amp;mattr)) != 0)</CODE></P>
      <P><CODE>45    goto pthreaderr;</CODE></P>
      <P><CODE>46   pthread_mutexattr_setpshared(&amp;mattr, PTHREAD_PROCESS_SHARED);</CODE></P>
      <P><CODE>47   i = pthread_mutex_init(&amp;sem-&gt;sem_mutex, &amp;mattr);</CODE></P>
      <P><CODE>48   pthread_mutexattr_destroy(&amp;mattr); /* не забыть удалить */</CODE></P>
      <P><CODE>49   if (i != 0)</CODE></P>
      <P><CODE>50    goto pthreaderr;</CODE></P>
      <P><CODE>51   if ((i = pthread_condattr_init(&amp;cattr)) != 0)</CODE></P>
      <P><CODE>52    goto pthreaderr;</CODE></P>
      <P><CODE>53   pthread_condattr_setpshared(&amp;cattr, PTHREAD_PROCESS_SHARED);</CODE></P>
      <P><CODE>54   i = pthread_cond_init(&amp;sem-&gt;sem_cond, &amp;cattr);</CODE></P>
      <P><CODE>55   pthread_condattr_destroy(&amp;cattr); /* не забыть удалить */</CODE></P>
      <P><CODE>56   if (i != 0)</CODE></P>
      <P><CODE>57    goto pthreaderr;</CODE></P>
      <P><CODE>58   if ((sem-&gt;sem_count = value) &gt; sysconf(_SC_SEM_VALUE_MAX)) {</CODE></P>
      <P><CODE>59    errno = EINVAL;</CODE></P>
      <P><CODE>60    goto err;</CODE></P>
      <P><CODE>61   }</CODE></P>
      <P><CODE>62   /* инициализация завершена, снимаем бит user-execute */</CODE></P>
      <P><CODE>63   if (fchmod(fd, mode) == –1)</CODE></P>
      <P><CODE>64    goto err;</CODE></P>
      <P><CODE>65   close(fd);</CODE></P>
      <P><CODE>66   sem-&gt;sem_magic = SEM_MAGIC;</CODE></P>
      <P><CODE>67   return(sem);</CODE></P>
      <P><CODE>68  }</CODE></P>
      <H2><a name=label478 style="border:none;"></a>Работа со списком аргументов переменной длины</H2>
      <P>19-23 Если при вызове функции указан флаг O_CREAT, мы должны принять четыре аргумента, а не два. Работа со списком аргументов переменной длины с помощью типа va_mode_t уже обсуждалась в связи с листингом 5.17, где мы использовали метод, аналогичный примененному здесь. Мы сбрасываем бит user-execute переменной mode (S_IXUSR) по причинам, которые вскоре будут раскрыты. Создается файл с указанным именем, и для него устанавливается бит user-execute.</P>
      <H2><a name=label479 style="border:none;"></a>Создание нового семафора и обработка потенциальной ситуации гонок</H2>
      <P>24-32 Если бы при указании флага O_CREAT мы просто открывали файл, отображали в память его содержимое и инициализировали поля структуры sem_t, у нас возникла бы ситуация гонок. Эта ситуация также уже обсуждалась в связи с листингом 5.17, и там мы воспользовались тем же методом, что и сейчас. Такая же ситуация гонок встретится нам, когда мы будем разбираться с листингом 10.37.</P>
      <H2><a name=label480 style="border:none;"></a>Установка размера файла</H2>
      <P>33-37 Мы устанавливаем размер созданного файла, записывая в него заполненную нулями структуру. Поскольку мы знаем, что только что созданный файл имеет размер 0, для установки его размера мы вызываем именно write, но не ftruncate, потому что, как мы отмечаем в разделе 13.3, Posix не гарантирует, что ftruncate срабатывает при увеличении размера обычных файлов. </P>
      <H2><a name=label481 style="border:none;"></a>Отображение содержимого файла в память</H2>
      <P>38-42 Файл отображается в память вызовом mmap. Этот файл будет содержать текущее значение структуры типа sem_t, хотя, поскольку мы только что отобразили файл в память, мы обращаемся к нему через указатель, возвращаемый mmap, и никогда не вызываем read или write.</P>
      <H2><a name=label482 style="border:none;"></a>Инициализация структуры sem_t</H2>
      <P>43-57 Мы инициализируем три поля структуры sem_t: взаимное исключение, условную переменную и значение семафора. Поскольку именованный семафор Posix может совместно использоваться всеми процессами с соответствующими правами, которым известно его имя, при инициализации взаимного исключения и условной переменной необходимо указать атрибут PTHREAD_PROCESS_SHARED. Чтобы осуществить это для взаимного исключения, нужно сначала проинициализировать атрибуты, вызвав pthread_mutexattr_init, затем установить атрибут совместного использования потоками, вызвав pthread_mutexattr_setpshared, а затем проинициализировать взаимное исключение вызовом pthread_mutex_init. Аналогичные действия придется выполнить и для условной переменной. Необходимо аккуратно уничтожать переменные, в которых хранятся атрибуты, при возникновении ошибок.</P>
      <H2><a name=label483 style="border:none;"></a>Инициализация значения семафора</H2>
      <P>58-61 Наконец мы помещаем в файл начальное значение семафора. Предварительно мы сравниваем его с максимально разрешенным значением семафора, которое может быть получено вызовом sysconf (раздел 10.13).</P>
      <H2><a name=label484 style="border:none;"></a>Сброс бита user-execute</H2>
      <P>62-67 После инициализации семафора мы сбрасываем бит user-execute. Это указывает на то, что семафор был успешно проинициализирован. Затем мы закрываем файл вызовом close, поскольку он уже был отображен в память и нам не нужно держать его открытым.</P>
      <P>В листинге 10.29 приведен текст второй половины функции sem_open. Здесь возникает ситуация гонок, обрабатываемая так же, как уже обсуждавшаяся в связи с листингом 5.19.</P>
      <H2><a name=label485 style="border:none;"></a>Листинг 10.29. Функция sem_open: вторая половина</H2>
      <P><CODE>//my_pxsem_mmap/sem_open.с</CODE></P>
      <P><CODE>69  exists:</CODE></P>
      <P><CODE>70   if ((fd = open(pathname, O_RDWR)) &lt; 0) {</CODE></P>
      <P><CODE>71    if (errno == ENOENT &amp;&amp; (oflag &amp; O_CREAT))</CODE></P>
      <P><CODE>72     goto again;</CODE></P>
      <P><CODE>73    goto err;</CODE></P>
      <P><CODE>74   }</CODE></P>
      <P><CODE>75   sem = mmap(NULL, sizeof(mysem_t), PROT_READ | PROT_WRITE,</CODE></P>
      <P><CODE>76    MAP_SHARED, fd, 0);</CODE></P>
      <P><CODE>77   if (sem == MAP_FAILED)</CODE></P>
      <P><CODE>78    goto err;</CODE></P>
      <P><CODE>79   /* удостоверимся, что инициализация завершена */</CODE></P>
      <P><CODE>80   for (i = 0; i &lt; MAX TRIES; i++) {</CODE></P>
      <P><CODE>81    if (stat(pathname, &amp;statbuff) == –1) {</CODE></P>
      <P><CODE>82     if (errno == ENOENT &amp;&amp; (oflag &amp; O_CREAT)) {</CODE></P>
      <P><CODE>83      close(fd);</CODE></P>
      <P><CODE>84      goto again;</CODE></P>
      <P><CODE>85     }</CODE></P>
      <P><CODE>86     goto err;</CODE></P>
      <P><CODE>87    }</CODE></P>
      <P><CODE>88    if ((statbuff.st_mode &amp; S_IXUSR) == 0) {</CODE></P>
      <P><CODE>89     close(fd);</CODE></P>
      <P><CODE>90     sem-&gt;sem_magic = SEM_MAGIC;</CODE></P>
      <P><CODE>91     return(sem);</CODE></P>
      <P><CODE>92    }</CODE></P>
      <P><CODE>93    sleep(1);</CODE></P>
      <P><CODE>94   }</CODE></P>
      <P><CODE>95   errno = ETIMEDOUT;</CODE></P>
      <P><CODE>96   goto err;</CODE></P>
      <P><CODE>97  pthreaderr:</CODE></P>
      <P><CODE>98   errno = i;</CODE></P>
      <P><CODE>99  err:</CODE></P>
      <P><CODE>100  /* не даем вызовам unlink и munmap изменить код errno */</CODE></P>
      <P><CODE>101  save_errno = errno;</CODE></P>
      <P><CODE>102  if (created)</CODE></P>
      <P><CODE>103   unlink(pathname);</CODE></P>
      <P><CODE>104  if (sem != MAP_FAILED)</CODE></P>
      <P><CODE>105   munmap(sem, sizeof(mysem_t));</CODE></P>
      <P><CODE>106  close(fd);</CODE></P>
      <P><CODE>107  errno = save_errno;</CODE></P>
      <P><CODE>108  return(SEM_FAILED);</CODE></P>
      <P><CODE>109 }</CODE></P>
      <H2><a name=label486 style="border:none;"></a>Открытие существующего семафора</H2>
      <P>69-78 Здесь мы завершаем нашу работу, если либо не указан флаг O_CREAT, либо он указан, но семафор уже существует. В том и в другом случае мы открываем существующий семафор. Мы открываем файл вызовом open для чтения и записи, а затем отображаем его содержимое в адресное пространство процесса вызовом mmap.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Теперь легко понять, почему в Posix.1 сказано, что «обращение к копиям семафора приводит к неопределенным результатам». Если именованный семафор реализован через отображение файла в память, он отображается в адресное пространство всех процессов, в которых он открыт. Это осуществляется функцией sem_open для каждого процесса в отдельности. Изменения, сделанные одним процессом (например, изменение счетчика семафора), становятся доступны другим процессам через отображение в память. Если мы сделаем свою собственную копию структуры sem_t, она уже не будет общей для всех процессов. Хотя нам и может показаться, что вызовы срабатывают (функции для работы с семафором не будут возвращать ошибок, по крайней мере до вызова sem_close, которая не сможет отключить отображение для копии отображенного файла), с другими процессами мы при этом взаимодействовать не сможем. Однако заметьте (табл. 1.4), что области памяти с отображаемыми файлами передаются дочерним процессам при вызове fork, поэтому создание копии семафора ядром при порождении нового процесса проблем не вызовет. </P>
      </DIV>
      <H2><a name=label487 style="border:none;"></a>Удостоверимся, что семафор проинициализирован</H2>
      <P>79-96 Мы должны подождать, пока семафор не будет проинициализирован (если несколько потоков пытаются создать семафор приблизительно одновременно). Для этого мы вызываем stat и проверяем биты разрешений файла (поле st_mode структуры stat). Если бит user-execute снят, структура успешно проинициализирована.</P>
      <H2><a name=label488 style="border:none;"></a>Возврат кодов ошибок</H2>
      <P>97-108 При возникновении ошибки нужно аккуратно вернуть ее код.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label489 style="border:none;"></a>Функция sem_close</P>
      </H1>
      <P>В листинге 10.30 приведен текст нашей функции sem_close, которая просто вызывает munmap для отображенного в память файла. Если вызвавший процесс продолжит пользоваться указателем, который был ранее возвращен sem_open, он получит сигнал SIGSEGV.</P>
      <H2><a name=label490 style="border:none;"></a>Листинг 10.30. Функция sem_close</H2>
      <P><CODE>//my_pxsem_mmap/sem_close. с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "semaphore.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  mysem_close(mysem_t *sem)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   if (sem-&gt;sem_magic != SEM_MAGIC) {</CODE></P>
      <P><CODE>7    errno = EINVAL;</CODE></P>
      <P><CODE>8    return(-1);</CODE></P>
      <P><CODE>9   }</CODE></P>
      <P><CODE>10  if (munmap(sem, sizeof(mysem_t)) == –1)</CODE></P>
      <P><CODE>11  return(-1);</CODE></P>
      <P><CODE>12  return(0);</CODE></P>
      <P><CODE>13 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label491 style="border:none;"></a>Функция sem_unlink</P>
      </H1>
      <P>Текст функции sem_unlink приведен в листинге 10.31. Она просто удаляет файл, через который реализован данный семафор, вызывая функцию unlink.</P>
      <H2><a name=label492 style="border:none;"></a>Листинг 10.31. Функция sem_unlink</H2>
      <P><CODE>//my_pxsem_mmap/sem_unlink.с</CODE></P>
      <P><CODE>1 #include "unpipc.h"</CODE></P>
      <P><CODE>2 #include "semaphore.h"</CODE></P>
      <BR>
      <P><CODE>3 int</CODE></P>
      <P><CODE>4 mysem_unlink(const char *pathname)</CODE></P>
      <P><CODE>5 {</CODE></P>
      <P><CODE>6  if (unlink(pathname) == –1)</CODE></P>
      <P><CODE>7   return(-1);</CODE></P>
      <P><CODE>8  return(0);</CODE></P>
      <P><CODE>9 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label493 style="border:none;"></a>Функция sem_post</P>
      </H1>
      <P>В листинге 10.32 приведен текст функции sem_post, которая увеличивает значение семафора, возобновляя выполнение всех процессов, заблокированных в ожидании этого события.</P>
      <H2><a name=label494 style="border:none;"></a>Листинг 10.32. Функция sem_post</H2>
      <P><CODE>//my_pxsem_mmap/sem_post.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "semaphore.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  mysem_post(mysem_t *sem)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int n;</CODE></P>
      <P><CODE>7   if (sem-&gt;sem_magic != SEM_MAGIC) {</CODE></P>
      <P><CODE>8    errno = EINVAL;</CODE></P>
      <P><CODE>9    return(-1);</CODE></P>
      <P><CODE>10  }</CODE></P>
      <P><CODE>11  if ((n = pthread_mutex_lock(&amp;sem-&gt;sem_mutex)) != 0) {</CODE></P>
      <P><CODE>12   errno = n;</CODE></P>
      <P><CODE>13   return(-1);</CODE></P>
      <P><CODE>14  }</CODE></P>
      <P><CODE>15  if (sem-&gt;sem_count == 0)</CODE></P>
      <P><CODE>16   pthread_cond_signal(&amp;sem-&gt;sem_cond);</CODE></P>
      <P><CODE>17  sem-&gt;sem_count++;</CODE></P>
      <P><CODE>18  pthread_mutex_unlock(&amp;sem-&gt;sem_mutex);</CODE></P>
      <P><CODE>19  return(0);</CODE></P>
      <P><CODE>20 }</CODE></P>
      <P>11-18 Прежде чем работать со структурой, нужно заблокировать соответствующее взаимное исключение. Если значение семафора изменяется с 0 на 1, нужно вызвать pthread_cond_signal, чтобы возобновилось выполнение одного из процессов, зарегистрированных на уведомление по данной условной переменной.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label495 style="border:none;"></a>Функция sem_wait</P>
      </H1>
      <P>В листинге 10.33 приведен текст функции sem_wait, которая ожидает изменения значения семафора с 0 на положительное, после чего уменьшает его на 1.</P>
      <H2><a name=label496 style="border:none;"></a>Листинг 10.33. Функция sem_wait</H2>
      <P><CODE>//my_pxsem_mmap/sem_wait.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "semaphore.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  mysem_wait(mysem_t *sem)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int n;</CODE></P>
      <P><CODE>7   if (setn-&gt;sem_magic != SEM_MAGIC) {</CODE></P>
      <P><CODE>8    errno = EINVAL;</CODE></P>
      <P><CODE>9    return(-1);</CODE></P>
      <P><CODE>10  }</CODE></P>
      <P><CODE>11  if ((n = pthread_mutex_lock(&amp;sem-&gt;sem_mutex)) != 0) {</CODE></P>
      <P><CODE>12   errno = n;</CODE></P>
      <P><CODE>13   return(-1);</CODE></P>
      <P><CODE>14  }</CODE></P>
      <P><CODE>15  while (sem-&gt;sem_count == 0)</CODE></P>
      <P><CODE>16   pthread_cond_wait(&amp;sem-&gt;sem_cond, &amp;sem-&gt;sem_mutex);</CODE></P>
      <P><CODE>17  sem-&gt;sem_count--;</CODE></P>
      <P><CODE>18  pthread_mutex_unlock(&amp;sem-&gt;sem_mutex);</CODE></P>
      <P><CODE>19  return(0);</CODE></P>
      <P><CODE>20 }</CODE></P>
      <P>11-18 Прежде чем работать с семафором, нужно заблокировать соответствующее взаимное исключение. Если значение семафора 0, выполнение процесса приостанавливается в вызове pthread_cond_wait до тех пор, пока другой процесс не вызовет pthread_cond_signal для этого семафора, изменив его значение с 0 на 1. После того как значение становится ненулевым, мы уменьшаем его на 1 и разблокируем взаимное исключение.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label497 style="border:none;"></a>Функция sem_trywait</P>
      </H1>
      <P>В листинге 10.34 приведен текст функции sem_trywait, которая представляет собой просто неблокируемый вариант функции sem_wait.</P>
      <P>11-22 Мы блокируем взаимное исключение и проверяем значение семафора. Если оно положительно, мы вычитаем из него 1 и возвращаем вызвавшему процессу код 0. В противном случае возвращается –1, а переменной errno присваивается код ошибки EAGAIN.</P>
      <H2><a name=label498 style="border:none;"></a>Листинг 10.34. Функция sem_trywait</H2>
      <P><CODE>//my_pxsem_nmap/sem_trywait.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "semaphore.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  mysem_trywait(mysem_t *sem)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int n, rc;</CODE></P>
      <P><CODE>7   if (sem-&gt;sem_magic != SEM_MAGIC) {</CODE></P>
      <P><CODE>8    errno = EINVAL;</CODE></P>
      <P><CODE>9    return(-1);</CODE></P>
      <P><CODE>10  }</CODE></P>
      <P><CODE>11  if ((n = pthread_mutex_lock(&amp;sem-&gt;sem_mutex)) != 0) {</CODE></P>
      <P><CODE>12   errno = n;</CODE></P>
      <P><CODE>13   return(-1);</CODE></P>
      <P><CODE>14  }</CODE></P>
      <P><CODE>15  if (sem-&gt;sem_count &gt; 0) {</CODE></P>
      <P><CODE>16   sem-&gt;sem_count--;</CODE></P>
      <P><CODE>17   rc = 0;</CODE></P>
      <P><CODE>18  } else {</CODE></P>
      <P><CODE>19   rc = –1;</CODE></P>
      <P><CODE>20   errno = EAGAIN;</CODE></P>
      <P><CODE>21  }</CODE></P>
      <P><CODE>22  pthread_mutex_unlock(&amp;sem-&gt;sem_mutex);</CODE></P>
      <P><CODE>23  return(rc);</CODE></P>
      <P><CODE>24 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label499 style="border:none;"></a>Функция sem_getvalue</P>
      </H1>
      <P>В листинге 10.35 приведен текст последней функции в этой реализации — sem_getvalue. Она возвращает текущее значение семафора.</P>
      <P>11-16 Мы блокируем соответствующее взаимное исключение и считываем значение семафора.</P>
      <H2><a name=label500 style="border:none;"></a>Листинг 10.35. Функция sem_getvalue</H2>
      <P><CODE>//my_pxsem_mmap/sem_getvalue.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "semaphore.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  mysem_getvalue(mysem_t *sem, int *pvalue)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int n;</CODE></P>
      <P><CODE>7   if (sem-&gt;sem_magic != SEM_MAGIC) {</CODE></P>
      <P><CODE>8    errno = EINVAL;</CODE></P>
      <P><CODE>9    return(-1);</CODE></P>
      <P><CODE>10  }</CODE></P>
      <P><CODE>11  if ((n = pthread_mutex_lock(&amp;sem-&gt;sem_mutex)) != 0) {</CODE></P>
      <P><CODE>12   errno = n;</CODE></P>
      <P><CODE>13   return(-1);</CODE></P>
      <P><CODE>14  }</CODE></P>
      <P><CODE>15  *pvalue = sem-&gt;sem_count;</CODE></P>
      <P><CODE>16  pthread_mutex_unlock(&amp;sem-&gt;sem_mutex);</CODE></P>
      <P><CODE>17  return(0);</CODE></P>
      <P><CODE>18 }</CODE></P>
      <P>Из этой реализации видно, что семафорами пользоваться проще, чем взаимными исключениями и условными переменными.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label501 style="border:none;"></a>10.16. Реализация с использованием семафоров System V</P>
     </H1>
     <DIV class=section>
      <P>Приведем еще один пример реализации именованных семафоров Posix — на этот раз с использованием семафоров System V. Поскольку семафоры System V появились раньше, чем семафоры Posix, эта реализация позволяет использовать последние в системах, где их поддержка не предусмотрена производителем.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Семафоры System V описаны в главе 11. Этот раздел можно пропустить при первом чтении, с тем чтобы вернуться к нему по прочтении 11 главы.</P>
      </DIV>
      <P>Начнем, как обычно, с заголовочного файла semaphore.h (листинг 10.36), который определяет фундаментальный тип данных sem_t.</P>
      <H2><a name=label502 style="border:none;"></a>Листинг 10.36. Заголовочный файл semaphore.h</H2>
      <P><CODE>//my_pxsem_svsem/semaphore.h</CODE></P>
      <P><CODE>1  /* фундаментальный тип данных */</CODE></P>
      <P><CODE>2  typedef struct {</CODE></P>
      <P><CODE>3   int sem_semid; /* идентификатор семафора System V */</CODE></P>
      <P><CODE>4   int sem_magic; /* магическое значение, если семафор открыт */</CODE></P>
      <P><CODE>5  } mysem_t;</CODE></P>
      <BR>
      <P><CODE>6  #define SEM_MAGIC 0x45678923</CODE></P>
      <BR>
      <P><CODE>7  #ifdef SEM_FAILED</CODE></P>
      <P><CODE>8  #undef SEM_FAILED</CODE></P>
      <P><CODE>9  #define SEM_FAILED ((mysem_t *)(-1)) /* исключаем предупреждения компилятора */</CODE></P>
      <P><CODE>10 #endif</CODE></P>
      <BR>
      <P><CODE>11 #ifndef SEMVMX</CODE></P>
      <P><CODE>12 #define SEMVMX 32767 /* исторически сложившееся максимальное значение для семафора System V */</CODE></P>
      <P><CODE>13 #endif</CODE></P>
      <H2><a name=label503 style="border:none;"></a>Тип данных sem_t</H2>
      <P>1-5 Мы реализуем именованный семафор Posix с помощью набора семафоров System V, состоящего из одного элемента. Структура данных семафора содержит идентификатор семафора System V и магическое число (обсуждавшееся в связи с листингом 10.21).</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label504 style="border:none;"></a>Функция sem_open</P>
      </H1>
      <P>В листинге 10.37 приведен текст первой половины функции sem_open, которая создает новый семафор или открывает существующий.</P>
      <H2><a name=label505 style="border:none;"></a>Листинг 10.37. Функция sem_open: первая часть</H2>
      <P><CODE>//my_pxsem_svsem/sem_open. с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "semaphore.h"</CODE></P>
      <P><CODE>3  #include &lt;stdarg.h&gt; /* для списков аргументов переменной длины */</CODE></P>
      <P><CODE>4  #define MAX_TRIES 10 /* количество попыток инициализации */</CODE></P>
      <BR>
      <P><CODE>5  mysem_t *</CODE></P>
      <P><CODE>6  mysem_open(const char *pathname, int oflag, … )</CODE></P>
      <P><CODE>7  {</CODE></P>
      <P><CODE>8   int i, fd, semflag, semid, save_errno;</CODE></P>
      <P><CODE>9   key_t key;</CODE></P>
      <P><CODE>10  mode_t mode;</CODE></P>
      <P><CODE>11  va_list ap;</CODE></P>
      <P><CODE>12  mysem_t *sem;</CODE></P>
      <P><CODE>13  union semun arg;</CODE></P>
      <P><CODE>14  unsigned int value;</CODE></P>
      <P><CODE>15  struct semid_ds seminfo;</CODE></P>
      <P><CODE>16  struct sembuf initop;</CODE></P>
      <P><CODE>17  /* режим доступа для sem_open() без O_CREAT не указывается; угадываем */</CODE></P>
      <P><CODE>18  semflag = SVSEM_MODE;</CODE></P>
      <P><CODE>19  semid = –1;</CODE></P>
      <P><CODE>20  if (oflag &amp; O_CREAT) {</CODE></P>
      <P><CODE>21   va_start(ap, oflag); /* инициализируем ар последним явно указанным аргументом */</CODE></P>
      <P><CODE>22   mode = va_arg(ap, va_mode_t);</CODE></P>
      <P><CODE>23   value = va_arg(ap, unsigned int);</CODE></P>
      <P><CODE>24   va_end(ap);</CODE></P>
      <P><CODE>25   /* преобразуем в ключ, который будет идентифицировать семафор System V */</CODE></P>
      <P><CODE>26   if ((fd = open(pathname, oflag, mode)) == –1)</CODE></P>
      <P><CODE>27    return(SEM_FAILED);</CODE></P>
      <P><CODE>28   close(fd);</CODE></P>
      <P><CODE>29   if ((key = ftok(pathname, 0)) == (key_t) –1)</CODE></P>
      <P><CODE>30    return(SEM_FAILED);</CODE></P>
      <P><CODE>31   semflag = IPC_CREAT | (mode &amp; 0777);</CODE></P>
      <P><CODE>32   if (oflag &amp; O_EXCL)</CODE></P>
      <P><CODE>33    semflag |= IPC_EXCL;</CODE></P>
      <P><CODE>34    /* создаем семафор System V с флагом IPC_EXCL */</CODE></P>
      <P><CODE>35   if ((semid = semget(key, 1, semflag | IPC_EXCD) &gt;= 0) {</CODE></P>
      <P><CODE>36    /* OK, мы успели первыми, поэтому инициализируем нулем */</CODE></P>
      <P><CODE>37    arg.val = 0;</CODE></P>
      <P><CODE>38    if (semctl(semid, 0, SETVAL, arg) == –1)</CODE></P>
      <P><CODE>39     goto err;</CODE></P>
      <P><CODE>40    /* увеличиваем значение, чтобы sem_otime стало ненулевым */</CODE></P>
      <P><CODE>41    if (value &gt; SEMVMX) {</CODE></P>
      <P><CODE>42     errno = EINVAL;</CODE></P>
      <P><CODE>43     goto err;</CODE></P>
      <P><CODE>44    }</CODE></P>
      <P><CODE>45    initop.sem_num = 0;</CODE></P>
      <P><CODE>46    initop.sem_op = value;</CODE></P>
      <P><CODE>47    initop.sem_flg = 0;</CODE></P>
      <P><CODE>48    if (semop(semid, &amp;initop, 1) == –1)</CODE></P>
      <P><CODE>49     goto err;</CODE></P>
      <P><CODE>50    goto finish;</CODE></P>
      <P><CODE>51   } else if (errno != EEXIST || (semflag &amp; IPC_EXCL) != 0)</CODE></P>
      <P><CODE>52    goto err:</CODE></P>
      <P><CODE>53   /* иначе продолжаем выполнение */</CODE></P>
      <P><CODE>54  }</CODE></P>
      <H2><a name=label506 style="border:none;"></a>Создание нового семафора и работа со списком аргументов переменной длины</H2>
      <P>20-24 Если вызвавший процесс указывает флаг O_CREAT, мы знаем, что функции будут переданы четыре аргумента, а не два. Работа со списком аргументов переменной длины и типом данных va_mode_t обсуждалась в связи с листингом 5.17.</P>
      <H2><a name=label507 style="border:none;"></a>Создание вспомогательного файла и преобразование полного имени в ключ System V IPC</H2>
      <P>25-30 Создается обычный файл с именем, указываемым при вызове функции. Это делается для того, чтобы указать его имя при вызове функции ftok для последующей идентификации семафора. Аргумент oflag, принятый от вызвавшего процесса, передается функции open для дополнительного файла, что позволяет создать его, если он еще не существует, и вернуть ошибку EEXIST, если файл существует и указан флаг O_EXCL. Дескриптор файла затем закрывается, поскольку единственная цель создания файла была в использовании его имени при вызове ftok, преобразующей полное имя в ключ System V IPC (раздел 3.2).</P>
      <H2><a name=label508 style="border:none;"></a>Создание набора семафоров System V с одним элементом</H2>
      <P>32-33 Мы преобразуем константы O_CREAT и O_EXCL в соответствующие константы System V IРС_ххх и вызываем semget для создания набора семафоров System V, состоящего из одного элемента. Флаг IPC_EXCL указывается всегда, чтобы можно было определить, существовал ли семафор до вызова функции или был создан ею.</P>
      <H2><a name=label509 style="border:none;"></a>Инициализация семафора</H2>
      <P>34-50 В разделе 11.2 описана фундаментальная проблема, связанная с инициализацией семафоров System V, а в разделе 11.6 приведен код, позволяющий исключить потенциальную ситуацию гонок. Здесь мы пользуемся аналогичным методом. Первый поток, который создает семафор (вспомните, что мы всегда указываем флаг IPC_EXCL), инициализирует его значением 0 с помощью команды SETVAL при вызове semctl, а затем устанавливает запрошенное вызвавшим процессом начальное значение с помощью semop. Мы можем быть уверены, что значение sem_otime семафора функцией semget устанавливается в 0 и будет изменено на ненулевое вызовом semop. Следовательно, любой поток, работающий с существующим семафором, будет знать, что он уже проинициализирован, если значение sem_otime будет отлично от 0.</P>
      <H2><a name=label510 style="border:none;"></a>Проверка начального значения</H2>
      <P>40-44 Мы проверяем начальное значение, указанное вызвавшим процессом, поскольку семафоры System V обычно хранятся как беззнаковые короткие целые (unsigned short, структура sem в разделе 11.1) с максимальным значением 32767 (раздел 11.7), тогда как семафоры Posix обычно хранятся как целые с максимально возможным размером (раздел 10.13). Константа SEMVMX определяется некоторыми реализациями как максимальное значение семафора System V, а если она не определена, то мы определяем ее равной 32 767 в листинге 10.36.</P>
      <P>52-53 Если семафор уже существует и вызвавший процесс не указал флаг O_EXCL, ошибка не возвращается. В этом случае программа переходит к открытию (не созданию) существующего семафора.</P>
      <P>В листинге 10.38 приведен текст второй половины функции sem_open.</P>
      <H2><a name=label511 style="border:none;"></a>Листинг 10.38. Функция sem_open: вторая половина</H2>
      <P><CODE>//my_pxsem_svsem/sem_open.c</CODE></P>
      <P><CODE>55  /*</CODE></P>
      <P><CODE>56   * (O_CREAT не указан) или</CODE></P>
      <P><CODE>57   * (O_CREAT без O_EXCL и семафор уже существует).</CODE></P>
      <P><CODE>58   * Нужно открыть семафор и проверить, что он уже проинициализирован.</CODE></P>
      <P><CODE>59   */</CODE></P>
      <P><CODE>60  if ((key = ftok(pathname, 0)) == (key_t) –1)</CODE></P>
      <P><CODE>61   goto err;</CODE></P>
      <P><CODE>62  if ((semid = semget(key, 0, semflag)) == –1)</CODE></P>
      <P><CODE>63 goto err;</CODE></P>
      <P><CODE>64  arg.buf = &amp;seminfo;</CODE></P>
      <P><CODE>65  for (i = 0; i &lt; MAX_TRIES; i++) {</CODE></P>
      <P><CODE>66   if (semctl(semid, 0, IPC_STAT, arg) == –1)</CODE></P>
      <P><CODE>67    goto err;</CODE></P>
      <P><CODE>68   if (arg.buf-&gt;sem_otime != 0)</CODE></P>
      <P><CODE>69    goto finish;</CODE></P>
      <P><CODE>70   sleep(1);</CODE></P>
      <P><CODE>71  }</CODE></P>
      <P><CODE>72  errno = ETIMEDOUT;</CODE></P>
      <P><CODE>73 err:</CODE></P>
      <P><CODE>74  save_errno = errno; /* не даем вызову semctl() изменить значение errno */</CODE></P>
      <P><CODE>75  if (semid != –1)</CODE></P>
      <P><CODE>76   semctl(semid, 0, IPC_RMID);</CODE></P>
      <P><CODE>77  errno = save_errno;</CODE></P>
      <P><CODE>78  return(SEM_FAILED);</CODE></P>
      <P><CODE>79 finish:</CODE></P>
      <P><CODE>80  if ((sem = malloc(sizeof(mysem_t))) == NULL)</CODE></P>
      <P><CODE>81   goto err;</CODE></P>
      <P><CODE>82  sem-&gt;sem_semid = semid;</CODE></P>
      <P><CODE>83  sem-&gt;sem_magic = SEM_MAGIC;</CODE></P>
      <P><CODE>84  return(sem);</CODE></P>
      <P><CODE>85 }</CODE></P>
      <H2><a name=label512 style="border:none;"></a>Открытие существующего семафора</H2>
      <P>55-63 Если семафор уже создан (флаг O_CREAT не указан или указан, но без O_EXCL, а семафор существует), мы открываем семафор System V с помощью semget. Обратите внимание, что в вызове sem_open указывать аргумент mode не нужно, если не указан флаг O_CREAT, но вызов semget требует указания режима доступа, даже если открывается существующий семафор. Ранее в тексте функции мы присваивали значение по умолчанию (константу SVSEM_MODE из нашего заголовочного файла unpipc.h) переменной, которую теперь передаем semget, если не указан флаг O_CREAT.</P>
      <H2><a name=label513 style="border:none;"></a>Ожидание инициализации семафора</H2>
      <P>64-72 Проверяем, что семафор уже инициализирован, вызывая semctl с командой IPC_STAT и сравнивая значение поля sem_otime возвращаемой структуры с нулем.</P>
      <H2><a name=label514 style="border:none;"></a>Возврат кода ошибки</H2>
      <P>73-78 Когда возникает ошибка, мы аккуратно вызываем все последующие функции, чтобы не изменить значение errno.</P>
      <H2><a name=label515 style="border:none;"></a>Выделение памяти под sem_t</H2>
      <P>79-84 Мы выделяем память под структуру sem_t и помещаем в нее идентификатор семафора System V. Функция возвращает указатель на эту структуру.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label516 style="border:none;"></a>Функция sem_close</P>
      </H1>
      <P>В листинге 10.39 приведен текст функции sem_close, которая вызывает free для освобождения динамически выделенной под структуру sem_t памяти. </P>
      <H2><a name=label517 style="border:none;"></a>Листинг 10.39. Функция sem_close</H2>
      <P><CODE>//my_pxsem_svsem/sem_close.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "semaphore.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  mysem_close(mysem_t *sem)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   if (sem-&gt;sem_magic != SEM_MAGIC) {</CODE></P>
      <P><CODE>7    errno = EINVAL;</CODE></P>
      <P><CODE>8    return(-1);</CODE></P>
      <P><CODE>9   }</CODE></P>
      <P><CODE>10  sem-&gt;sem_magic = 0; /* на всякий случай */</CODE></P>
      <P><CODE>11  free(sem);</CODE></P>
      <P><CODE>12  return(0);</CODE></P>
      <P><CODE>13 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label518 style="border:none;"></a>Функция sem_unlink</P>
      </H1>
      <P>Функция sem_unlink, текст которой приведен в листинге 10.40, удаляет вспомогательный файл и семафор System V, связанные с указанным ей семафором Posix.</P>
      <H2><a name=label519 style="border:none;"></a>Листинг 10.40. Функция sem_unlink</H2>
      <P><CODE>//my_pxsem_svsem/sem_unlink.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "semaphore.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  mysem_unlink(const char *pathname)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int semid;</CODE></P>
      <P><CODE>7   key_t key;</CODE></P>
      <P><CODE>8   if ((key = ftok(pathname, 0)) == (key_t) –1)</CODE></P>
      <P><CODE>9    return(-1);</CODE></P>
      <P><CODE>10  if (unlink(pathname) == –1)</CODE></P>
      <P><CODE>11   return(-1);</CODE></P>
      <P><CODE>12  if ((semid = semget(key, 1, SVSEM_MODE)) == –1)</CODE></P>
      <P><CODE>13   return(-1);</CODE></P>
      <P><CODE>14  if (semctl(semid, 0, IPC_RMID) == –1)</CODE></P>
      <P><CODE>15   return(-1);</CODE></P>
      <P><CODE>16  return(0);</CODE></P>
      <P><CODE>17 }</CODE></P>
      <H2><a name=label520 style="border:none;"></a>Получение ключа System V по полному имени</H2>
      <P>8-16 Функция ftok преобразует полное имя файла в ключ System V IPC. После этого вспомогательный файл удаляется вызовом unlink (именно в этом месте кода, на тот случай, если одна из последующих функций вернет ошибку). Затем мы открываем семафор System V вызовом semget и удаляем его с помощью команды IPC_RMID для semctl.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label521 style="border:none;"></a>Функция sem_post</P>
      </H1>
      <P>В листинге 10.41 приведен текст функции sem_post, которая увеличивает значение семафора.</P>
      <P>11-16 Мы вызываем semop с операцией, увеличивающей значение семафора на 1.</P>
      <H2><a name=label522 style="border:none;"></a>Листинг 10.41. Функция sem_post</H2>
      <P><CODE>//my_pxsem_svsem/sem_post.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "semaphore.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  mysem_post(mysem_t *sem)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   struct sembuf op;</CODE></P>
      <P><CODE>7   if (sem-&gt;sem_magic != SEM_MAGIC) {</CODE></P>
      <P><CODE>8    errno * EINVAL;</CODE></P>
      <P><CODE>9    return(-1);</CODE></P>
      <P><CODE>10  }</CODE></P>
      <P><CODE>11  op.sem_num = 0;</CODE></P>
      <P><CODE>12  op.sem_op = 1;</CODE></P>
      <P><CODE>13  op.sem_flg = 0;</CODE></P>
      <P><CODE>14  if (semop(sem-&gt;sem_semid, &amp;op, 1) &lt; 0)</CODE></P>
      <P><CODE>15   return(-1);</CODE></P>
      <P><CODE>16  return(0);</CODE></P>
      <P><CODE>17 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label523 style="border:none;"></a>Функция sem_wait</P>
      </H1>
      <P>Следующая функция приведена в листинге 10.42; она называется sem_wait и ожидает изменения значения семафора с нулевого на ненулевое, после чего уменьшает значение семафора на 1.</P>
      <P>11-16 Мы вызываем semop с операцией, уменьшающей значение семафора на 1.</P>
      <H2><a name=label524 style="border:none;"></a>Листинг 10.42. Функция sem_wait</H2>
      <P><CODE>//my_pxsem_svsem/sem_wait.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "semaphore.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  mysem_wait(mysem_t *sem)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   struct sembuf op;</CODE></P>
      <P><CODE>7   if (sem-&gt;sem_magic != SEM_MAGIC) {</CODE></P>
      <P><CODE>8    errno = EINVAL;</CODE></P>
      <P><CODE>9    return(-1);</CODE></P>
      <P><CODE>10  }</CODE></P>
      <P><CODE>11  op.sem_num = 0;</CODE></P>
      <P><CODE>12  op.sem_op = –1;</CODE></P>
      <P><CODE>13  op.sem_flg = 0;</CODE></P>
      <P><CODE>14  if (semop(sem-&gt;sem_semid, &amp;op, 1) &lt; 0)</CODE></P>
      <P><CODE>15   return(-1);</CODE></P>
      <P><CODE>16  return(0);</CODE></P>
      <P><CODE>17 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label525 style="border:none;"></a>Функция sem_trywait</P>
      </H1>
      <P>В листинге 10.43 приведен текст нашей функции sem_trywait, которая представляет собой неблокируемую версию sem_wait.</P>
      <P>13 Единственное отличие от функции sem_wait из листинга 10.42 заключается в том, что флагу sem_flg присваивается значение IPC_NOWAIT. Если операция не может быть завершена без блокирования вызвавшего потока, функция semop возвращает ошибку EAGAIN, а это именно тот код, который должен быть возвращен sem_trywait, если операция не может быть завершена без блокирования потока.</P>
      <H2><a name=label526 style="border:none;"></a>Листинг 10.43. Функция sem_trywait</H2>
      <P><CODE>//my_pxsem_svsem/sem_trywait.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "semaphore.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  mysem_trywait(mysem_t *sem)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   struct sembuf op;</CODE></P>
      <P><CODE>7   if (sem-&gt;sem_magic != SEM_MAGIC) {</CODE></P>
      <P><CODE>8    errno = EINVAL;</CODE></P>
      <P><CODE>9    return(-1);</CODE></P>
      <P><CODE>10  }</CODE></P>
      <P><CODE>11  op.sem_num = 0;</CODE></P>
      <P><CODE>12  op.sem_op = –1;</CODE></P>
      <P><CODE>13  op.sem_flg = IPC_NOWAIT;</CODE></P>
      <P><CODE>14  if (semop(sem-&gt;sem_semid, &amp;op, 1) &lt; 0)</CODE></P>
      <P><CODE>15   return(-1);</CODE></P>
      <P><CODE>16  return(0);</CODE></P>
      <P><CODE>17 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label527 style="border:none;"></a>Функция sem_getvalue</P>
      </H1>
      <P>Последняя функция приведена в листинге 10.44. Это функция sem_getvalue, возвращающая текущее значение семафора.</P>
      <P>11-14 Текущее значение семафора получается отправкой команды GETVAL функции semctl.</P>
      <H2><a name=label528 style="border:none;"></a>Листинг 10.44. Функция sem_getvalue</H2>
      <P><CODE>//my_pxsem_svsem/sem_getvalue.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "semaphore.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  mysem_getvalue(mysem_t *sem, int *pvalue)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int val;</CODE></P>
      <P><CODE>7   if (sem-&gt;sem_magic != SEM_MAGIC) {</CODE></P>
      <P><CODE>8    errno = EINVAL;</CODE></P>
      <P><CODE>9    return(-1);</CODE></P>
      <P><CODE>10  }</CODE></P>
      <P><CODE>11  if ((val = semctl(sem-&gt;sem_semid, 0, GETVAL)) &lt; 0)</CODE></P>
      <P><CODE>12   return(-1);</CODE></P>
      <P><CODE>13  *pvalue = val;</CODE></P>
      <P><CODE>14  return(0);</CODE></P>
      <P><CODE>15 }</CODE></P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label529 style="border:none;"></a>10.17. Резюме</P>
     </H1>
     <P>Семафоры Posix представляют собой семафоры-счетчики, для которых определены три основные операции:</P>
     <P>1. Создание семафора.</P>
     <P>2. Ожидание изменения значения семафора на ненулевое и последующее уменьшение значения.</P>
     <P>3. Увеличение значения семафора на 1 и возобновление выполнения всех процессов, ожидающих его изменения.</P>
     <P>Семафоры Posix могут быть именованными или неименованными (размещаемыми в памяти). Именованные семафоры всегда могут использоваться отдельными процессами, тогда как размещаемые в памяти должны для этого изначально планироваться как разделяемые между процессами. Эти типы семафоров также отличаются друг от друга по живучести: именованные семафоры обладают по меньшей мере живучестью ядра, тогда как размещаемые в памяти обладают живучестью процесса.</P>
     <P>Задача производителей и потребителей является классическим примером для иллюстрации использования семафоров. В этой главе первое решение состояло из одного потока-производителя и одного потока-потребителя; второе решение имело нескольких производителей и одного потребителя, а последнее решение допускало одновременную работу и нескольких потребителей. Затем мы показали, что классическая задача двойной буферизации является частным случаем задачи производителей и потребителей с одним производителем и одним потребителем.</P>
     <P>В этой главе было приведено три примера возможной реализации семафоров Posix. Первый пример был самым простым, в нем использовались каналы FIFO, а большая часть забот по синхронизации ложилась на ядро (функции read и write). Следующая реализация использовала отображение файлов в память (аналогично реализации очередей сообщений Posix из раздела 5.8), а также взаимное исключение и условную переменную (для синхронизации). Последняя реализация была основана на семафорах System V и представляла собой, по сути, удобный интерфейс для работы с ними.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label530 style="border:none;"></a>Упражнения</P>
     </H1>
     <P>1. Измените функции produce и consume из раздела 10.6 следующим образом. Поменяйте порядок двух вызовов Sem_wait в потребителе, чтобы возникла ситуация зависания (как описано в разделе 10.6). Затем добавьте вызов printf перед каждым Sem_wait, чтобы было ясно, какой из потоков ожидает изменения семафора. Добавьте еще один вызов printf после каждого Sem_wait, чтобы можно было определить, какой поток получил управление. Уменьшите количество буферов до двух, а затем откомпилируйте и выполните эту программу, чтобы убедиться, что она зависнет.</P>
     <P>2. Предположим, что запущено четыре экземпляра программы, вызывающей функцию my_lock из листинга 10.10:</P>
     <P><CODE>% lockpxsem &amp; lockpxsem &amp; lockpxsem &amp; lockpxsem &amp;</CODE></P>
     <P>Каждый из четырех процессов запускается с значением initflag, равным 0, поэтому при вызове sem_open всегда указывается O_CREAT. Нормально ли это?</P>
     <P>3. Что произойдет в предыдущем примере, если одна из четырех программ будет завершена после вызова my_lock, но перед вызовом my_unlock?</P>
     <P>4. Что произошло бы с программой в листинге 10.22, если бы мы не инициализировали оба дескриптора значением –1?</P>
     <P>5. Почему в листинге 10.22 мы сохраняем значение errno, а затем восстанавливаем его, вместо того чтобы написать просто:</P>
     <P><CODE>if (sem-&gt;fd[0] &gt;= 0) close(sem-&gt;fd[0]);</CODE></P>
     <P><CODE>if (sem-&gt;fd[1] &gt;= 0) close(sem-&gt;fd[1]);</CODE></P>
     <P>6. Что произойдет, если два процесса вызовут нашу реализацию sem_open через FIFO (листинг 10.22) примерно одновременно, указывая флаг O_CREAT и начальное значение 5? Может ли канал быть инициализирован (неправильно) значением 10?</P>
     <P>7. В связи с листингами 10.28 и 10.29 мы описали возможную ситуацию гонок в случае, если два процесса пытаются создать семафор примерно одновременно. Однако решение предыдущей задачи в листинге 10.22 не создавало ситуации гонок. Объясните это.</P>
     <P>8. Стандарт Posix.1 указывает дополнительную возможность для функции semwait: она может прерываться перехватываемым сигналом и возвращать код EINTR. Напишите тестовую программу, которая определяла бы, есть ли такая возможность в вашей реализации.</P>
     <P>Запустите эту тестовую программу с нашими реализациями, использующими FIFO (раздел 10.14), отображение в память (раздел 10.15) и семафоры System V (раздел 10.16).</P>
     <P>9. Какая из трех реализаций sem_post этой главы является функцией типа async-signal-safe (табл. 5.1)?</P>
     <P>10. Измените решение задачи о потребителе и производителе в разделе 10.6 так, чтобы для переменной mutex использовался тип pthread_mutex_t, а не семафор. Заметна ли разница в скорости работы программы?</P>
     <P>11. Сравните быстродействие именованных семафоров (листинги 10.8 и 10.9) и размещаемых в памяти (листинг 10.11).</P>
    </DIV>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label531 style="border:none;"></a>ГЛАВА 11</P>
     <P>Семафоры System V</P>
    </H1>
    <DIV class=section>
     <H1>
      <P><a name=label532 style="border:none;"></a>11.1.Введение</P>
     </H1>
     <P>В главе 10 мы описывали различные виды семафоров, начав с:</P>
     <P>■ бинарного семафора, который может принимать только два значения: 0 и 1. По своим свойствам такой семафор аналогичен взаимному исключению (глава 7), причем значение 0 для семафора соответствует блокированию ресурса, а 1 — освобождению.</P>
     <P>Далее мы перешли к более сложному виду семафоров:</P>
     <P>■ семафор-счетчик, значение которого лежит в диапазоне от 0 до некоторого ограничения, которое, согласно Posix, не должно быть меньше 32767. Они использовался для подсчета доступных ресурсов в задаче о производителях и потребителях, причем значение семафора соответствовало количеству доступных ресурсов.</P>
     <P>Для обоих типов семафоров операция <EM>wait</EM> состояла в ожидании изменения значения семафора с нулевого на ненулевое и последующем уменьшении этого значения на 1. Операция <EM>post</EM> увеличивала значение семафора на 1, оповещая об этом все процессы, ожидавшие изменения значения семафора.</P>
     <P>Для семафоров System V определен еще один уровень сложности:</P>
     <P>■ набор семафоров-счетчиков — один или несколько семафоров, каждый из которых является счетчиком. На количество семафоров в наборе существует ограничение (обычно порядка 25 — раздел 11.7). Когда мы говорим о семафоре System V, мы подразумеваем именно набор семафоров-счетчиков, а когда говорим о семафоре Posix, подразумевается ровно один семафор-счетчик.</P>
     <P>Для каждого набора семафоров ядро поддерживает следующую информационную структуру, определенную в файле &lt;sys/sem.h&gt;:</P>
     <P><CODE>struct semid_ds {</CODE></P>
     <P><CODE> struct ipc_perm sem_perm; /* разрешения на операции */</CODE></P>
     <P><CODE> struct sem *sem_base; /*указатель на массив семафоров в наборе */</CODE></P>
     <P><CODE> ushort sem_nsems; /* количество семафоров в наборе */</CODE></P>
     <P><CODE> time_t sem_otime; /* время последнего вызова semop(); */</CODE></P>
     <P><CODE> time_t sem_ctime; /* время создания последнего IPC_SET */</CODE></P>
     <P><CODE>};</CODE></P>
     <P>Структура ipc_perm была описана в разделе 3.3. Она содержит разрешения доступа для данного семафора.</P>
     <P>Структура sem представляет собой внутреннюю структуру данных, используемую ядром для хранения набора значений семафора. Каждый элемент набора семафоров описывается так:</P>
     <P><CODE>struct sem {</CODE></P>
     <P><CODE> ushort_t semval; /* значение семафора, неотрицательно */</CODE></P>
     <P><CODE> short sempid; /* PID последнего процесса, вызвавшего semop(), SETVAL, SETALL */</CODE></P>
     <P><CODE> ushort_t semncnt; /* количество ожидающих того, что значение семафора превысит текущее */</CODE></P>
     <P><CODE> ushort_t semzcnt; /* количество ожидающих того, что значение семафора станет равным 0*/</CODE></P>
     <P><CODE>};</CODE></P>
     <P>Обратите внимание, что sem_base представляет собой указатель на массив структур типа sem — по одному элементу массива на каждый семафор в наборе.</P>
     <P>Помимо текущих значений всех семафоров набора в ядре хранятся еще три поля данных для каждого семафора: идентификатор процесса, изменившего значение семафора последним, количество процессов, ожидающих увеличения значения семафора, и количество процессов, ожидающих того, что значение семафора станет нулевым.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>В стандарте Unix 98 данная структура не имеет имени. Приведенное выше имя (sem) взято из реализации System V. </P>
     </DIV>
     <P>Любой конкретный семафор в ядре мы можем воспринимать как структуру semid_ds, указывающую на массив структур sem. Если в наборе два элемента, мы получим картину, изображенную на рис. 11.1. На этом рисунке переменная sem_nsems имеет значение 2, а каждый из элементов набора идентифицируется индексом ([0] или [1]). </P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader189" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 11.1. Структуры данных ядра для набора семафоров из двух элементов</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label533 style="border:none;"></a>11.2. Функция semget</P>
     </H1>
     <DIV class=section>
      <P>Функция semget создает набор семафоров или обеспечивает доступ к существующему.</P>
      <P><CODE>#include &lt;sys/sem.h&gt;</CODE></P>
      <P><CODE>int semget(key_t <EM>key,</EM> int <EM>nsems,</EM> int <EM>oflag</EM>);</CODE></P>
      <P><CODE>/* Возвращает неотрицательный идентификатор в случае успешного завершения, –1 – в случае ошибки */</CODE></P>
      <P>Эта функция возвращает целое значение, называемое идентификатором семафора, которое затем используется при вызове функций semop и semctl.</P>
      <P>Аргумент <EM>nsems</EM> задает количество семафоров в наборе. Если мы не создаем новый набор, а устанавливаем доступ к существующему, этот аргумент может быть нулевым. Количество семафоров в уже созданном наборе изменить нельзя.</P>
      <P>Аргумент <EM>oflag</EM> представляет собой комбинацию констант SEM_R и SEM_A из табл. 3.3. Здесь R обозначает <EM>Read</EM> (чтение), а А — <EM>Alter</EM> (изменение). К этим константам можно логически прибавить IPC_CREAT или IPC_CREAT | IPC_EXCL, о чем мы уже говорили в связи с рис. 3.2.</P>
      <P>При создании нового семафора инициализируются следующие поля структуры semid_ds:</P>
      <P>■ поля uid и cuid структуры sem_perm устанавливаются равными действующему идентификатору пользователя процесса, а поля guid и cgid устанавливаются равными действующему идентификатору группы процесса;</P>
      <P>■ биты разрешений чтения-записи аргумента <EM>oflag</EM> сохраняются в sem_perm.mode;</P>
      <P>■ поле sem_otime устанавливается в 0, а поле sem_ctime устанавливается равным текущему времени;</P>
      <P>■ значение sem_nsems устанавливается равным <EM>nsems;</EM></P>
      <P>■ структуры sem для каждого из семафоров набора не инициализируются. Это происходит лишь при вызове semctl с командами SETVAL или SETALL.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label534 style="border:none;"></a>Инициализация значения семафора</P>
      </H1>
      <P>В комментариях к исходному коду в издании этой книги 1990 года неправильно утверждалось, что значения семафоров набора инициализируются нулем при вызове semget с созданием нового семафора. Хотя в некоторых системах это действительно происходит, гарантировать подобное поведение ядра нельзя. Более старые реализации System V вообще не инициализировали значения семафоров, оставляя их содержимое таким, каким оно было до выделения памяти.</P>
      <P>В большинстве версий документации ничего не говорится о начальных значениях семафоров при создании нового набора. Руководство по написанию переносимых программ X/Open XPG3 (1989) и стандарт Unix 98 исправляют это упущение и открыто утверждают, что значения семафоров не инициализируются вызовом semget, а устанавливаются только при вызове semctl (вскоре мы опишем эту функцию) с командами SETVAL (установка значения одного из семафоров набора) и SETALL (установка значений всех семафоров набора).</P>
      <P>Необходимость вызова двух функций для создания (semget) и инициализации (semctl) набора семафоров является неисправимым недостатком семафоров System V. Эту проблему можно решить частично, указывая флаги IPC_CREAT | IPC_EXCL при вызове semget, чтобы только один процесс, вызвавший semget первым, создавал семафор, и этот же процесс должен семафор инициализировать. </P>
      <P>Другие процессы получают при вызове semget ошибку EEXIST, так что им приходится еще раз вызывать semget, уже не указывая флагов IPC_CREAT или IPC_EXCL.</P>
      <P>Однако ситуация гонок все еще не устранена. Предположим, что два процесса попытаются создать и инициализировать набор семафоров с одним элементом приблизительно в один и тот же момент времени, причем оба они будут выполнять один и тот же фрагмент кода:</P>
      <P><CODE>1 oflag = IPC_CREAT | IPC_EXCL | SVSEM_MODE;</CODE></P>
      <P><CODE>2 if ((semid = semget(key, 1, oflag)) &gt;= 0) { /* успешное завершение, этот процесс должен инициализировать семафор */</CODE></P>
      <P><CODE>3  arg.val = 1;</CODE></P>
      <P><CODE>4  Semctl(semid, 0, SETVAL, arg);</CODE></P>
      <P><CODE>5 } else if (errno == EEXIST) { /* уже существует, поэтому просто открываем семафор */</CODE></P>
      <P><CODE>6  semid = Semget(key, 1, SVSEM_MODE);</CODE></P>
      <P><CODE>7 } else</CODE></P>
      <P><CODE>8  err_sys("semget error");</CODE></P>
      <P><CODE>9 Semop(semid, …); /* уменьшаем значение семафора на 1 */</CODE></P>
      <P>При этом может произойти вот что:</P>
      <P>1. Первый процесс выполняет строки 1-3, а затем останавливается ядром.</P>
      <P>2. Ядро запускает второй процесс, который выполняет строки 1, 2, 5, 6 и 9.</P>
      <P>Хотя первый процесс, создавший семафор, и будет единственным процессом, который проинициализирует семафор, ядро может переключиться на другой процесс в промежутке между созданием и инициализацией семафора, и тогда второй процесс сможет обратиться к семафору (строка 9), который еще не был проинициализирован. Значение семафора после выполнения строки 9 для второго процесса будет не определено.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>В семафорах Posix эта проблема исключается благодаря тому, что семафоры создаются и инициализируются единственным вызовом — sem_open. Более того, даже если указан флаг O_CREAT, семафор будет проинициализирован только в том случае, если он еще не существовал на момент вызова функции.</P>
       <P>Будет ли обсуждавшаяся выше ситуация гонок создавать какие-то проблемы — зависит от приложения. В некоторых приложениях (например, задача производителей и потребителей в листинге 10.12) единственный процесс всегда создает и инициализирует семафор. В этом варианте ситуация гонок возникать не будет. В других приложениях (пример с блокировкой файлов в листинге 10.10) нет такого единственного процесса, который бы создавал и инициализировал семафор: первый процесс, открывающий семафор, должен создать его и проинициализировать, так что в этом случае ситуацию гонок следует исключать.</P>
      </DIV>
      <P>К счастью, существует способ исключить в данном случае ситуацию гонок. Стандарт гарантирует, что при создании набора семафоров поле sem_otime структуры semid_ds инициализируется нулем. (Руководства System V с давних пор говорят об этом, это утверждается и в стандартах XPG3 и Unix 98.) Это поле устанавливается равным текущему времени только при успешном вызове semop. Следовательно, второй процесс в приведенном выше примере должен просто вызвать semctl с командой IPC_STAT после второго вызова semget (строка 6). Затем этот процесс должен ожидать изменения значения sem_otime на ненулевое, после чего он может быть уверен в том, что семафор был успешно проинициализирован другим процессом. Это значит, что создавший семафор процесс должен проинициализировать его значение и успешно вызвать semop, прежде чем другие процессы смогут воспользоваться этим семафором. Мы используем этот метод в листингах 10.37 и 11.6.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label535 style="border:none;"></a>11.3. Функция semop</P>
     </H1>
     <P>После инициализации семафора вызовом semget с одним или несколькими семафорами набора можно выполнять некоторые действия с помощью функции semop:</P>
     <P><CODE>#include &lt;sys/sem.h&gt;</CODE></P>
     <P><CODE>int semop(int <EM>semid</EM>, struct sembuf *<EM>opsptr</EM>, size_t <EM>nops</EM>);</CODE></P>
     <P><CODE>/* Возвращает 0 в случае успешного завершения, –1 – в случае ошибки */</CODE></P>
     <P>Указатель opsptr указывает на массив структур вида</P>
     <P><CODE>struct sembuf {</CODE></P>
     <P><CODE> short sem_num; /* номер семафора: 0, 1,… nsems-1 */</CODE></P>
     <P><CODE> short sem_op; /* операция с семафором: &lt;0, 0, &gt;0 */</CODE></P>
     <P><CODE> short sem_flg; /* флаги операции: 0, IPC_NOWAIT, SEM_UNDO */</CODE></P>
     <P><CODE>};</CODE></P>
     <P>Количество элементов в массиве структур sembuf, на который указывает opsptr, задается аргументом nops. Каждый элемент этого массива определяет операцию с одним конкретным семафором набора. Номер семафора указывается в поле sen_num и принимает значение 0 для первого семафора, 1 для второго и т. д., до nsems-1, где nsems соответствует количеству семафоров в наборе (второй аргумент в вызове semget при создании семафора).</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>В структуре гарантированно содержатся только три указанных выше поля. Однако в ней могут быть и другие поля, причем порядок их может быть совершенно произвольным. Поэтому не следует статически инициализировать эту структуру кодом наподобие</P>
      <P><CODE>struct sembuf ops[2] = {</CODE></P>
      <P><CODE> 0, 0, 0, /* ждем, пока первый элемент не станет равен нулю */</CODE></P>
      <P><CODE> 0, 1, SEM_UNDO /* затем увеличиваем [0] на 1 */</CODE></P>
      <P><CODE>};</CODE></P>
      <P>Вместо этого следует инициализировать ее динамически, как в нижеследующем примере:</P>
      <P><CODE>struct sembuf ops[2];</CODE></P>
      <P><CODE>ops[0].sem_num = 0; /* ждем, пока первый элемент не станет равен нулю */</CODE></P>
      <P><CODE>ops[0].sem_op = 0;</CODE></P>
      <P><CODE>ops[0].sem_flg = 0;</CODE></P>
      <P><CODE>ops[1].sem_num = 0; /* затем увеличиваем [0] на 1 */</CODE></P>
      <P><CODE>ops[1].sem_op = 1;</CODE></P>
      <P><CODE>ops[1].sem_flg = SEM_UNDO;</CODE></P>
     </DIV>
     <P>Весь массив операций, передаваемый функции semop, выполняется ядром как одна операция; атомарность при этом гарантируется. Ядро выполняет все указанные операции или ни одну из них. Пример на эту тему приведен в разделе 11.5. </P>
     <P>Каждая операция задается значением sem_op, которое может быть отрицательным, нулевым или положительным. Сделаем несколько утверждений, которыми будем пользоваться при дальнейшем обсуждении:</P>
     <P>■ semval — текущее значение семафора (рис. 11.1);</P>
     <P>■ semncnt — количество потоков, ожидающих, пока значение семафора не станет больше текущего (рис. 11.1);</P>
     <P>■ semzcnt — количество потоков, ожидающих, пока значение семафора не станет нулевым (рис. 11.1);</P>
     <P>■ semadj — корректировочное значение данного семафора для вызвавшего процесса. Это значение обновляется, только если для данной операции указан флаг SEM_UNDO в поле sem_flg структуры sembuf. Эта переменная создается в ядре для каждого указавшего флаг SEM_UNDO процесса в отдельности; поле структуры с именем semadj не обязательно должно существовать;</P>
     <P>■ когда выполнение потока приостанавливается до завершения операции с семафором (мы увидим, что поток может ожидать либо обнуления семафора, либо получения семафором положительного значения), поток перехватывает сигнал и происходит возвращение из обработчика сигнала, функция semop возвращает ошибку EINTR. Используя терминологию, введенную в книге [24, с. 124], можно сказать, что функция semop представляет собой медленный системный вызов, который прерывается перехватываемыми сигналами;</P>
     <P>■ когда выполнение потока приостанавливается до завершения операции с семафором и этот семафор удаляется из системы другим потоком или процессом, функция semop возвращает ошибку EIDRM (identifier removed — идентификатор удален).</P>
     <P>Опишем теперь работу функции semop в зависимости от трех возможных значений поля sem_op: отрицательного, нулевого и положительного.</P>
     <P>1. Если значение sem_op положительно, оно добавляется к semval. Такое действие соответствует освобождению ресурсов, управляемых семафором. Если указан флаг SEM_UNDO, значение sem_op вычитается из значения semadj данного семафора.</P>
     <P>2. Если значение semop равно нулю, вызвавший поток блокируется до тех пор, пока значение семафора (semval) не станет равным нулю. Если semval уже равно 0, происходит немедленное возвращение из функции.</P>
     <P>Если semval не равно нулю, то ядро увеличивает значение поля semzcnt данного семафора и вызвавший поток блокируется до тех пор, пока значение semval не станет нулевым (после чего значение semzcnt будет уменьшено на 1). Как отмечалось ранее, поток будет приостановлен, только если не указан флаг IPC_NOWAIT. Если семафор будет удален в процессе ожидания либо будет перехвачен сигнал, произойдет преждевременный возврат из функции с возвращением кода ошибки.</P>
     <P>3. Если значение sem_op отрицательно, вызвавший поток блокируется до тех пор, пока значение семафора не станет большим либо равным модулю sem_op. Это соответствует запрашиванию ресурсов. </P>
     <P>Если значение semval больше либо равно модулю sem_op, модуль sem_op вычитается из semval. Если указан флаг SEM_UNDO, модуль sem_op добавляется к значению поля semadj данного семафора.</P>
     <P>Если значение semval меньше модуля sem_op, значение поля semncnt данного семафора увеличивается, а вызвавший поток блокируется до тех пор, пока semval не станет больше либо равно модулю semop. Когда это произойдет, поток будет разблокирован, а модуль sem_op будет отнят от semval и из значения semncnt будет вычтена единица. Если указан флаг SEM_UNDO, модуль sem_op добавляется к значению поля semadj данного семафора. Как отмечалось ранее, поток не будет приостановлен, если указан флаг IPC_NOWAIT. Ожидание завершается преждевременно, если перехватываемый сигнал вызывает прерывание либо семафор удаляется другим потоком.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Если сравнить этот набор операций с теми, которые разрешены для семафоров Posix, мы увидим, что для последних определены только команды –1 (sem_wait) и +1 (sem_post). Для семафоров System V значение семафора может изменяться с шагом, отличным от 1, и кроме того, поток может ожидать, чтобы значение семафора стало нулевым. Эти операции являются более общими, что вместе с возможностью включения нескольких семафоров в набор делает семафоры System V более сложными, чем одиночные семафоры Posix.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label536 style="border:none;"></a>11.4. Функция semctl</P>
     </H1>
     <P>Функция semctl предназначена для выполнения разного рода вспомогательных управляющих операций с семафорами.</P>
     <P><CODE>#include &lt;sys/sem.h&gt;</CODE></P>
     <P><CODE>int semctl(int <EM>semid,</EM> int <EM>semnum,</EM> int cm<EM>d,</EM> …/* union semun <EM>arg</EM> */);</CODE></P>
     <P><CODE>/* Возвращает неотрицательное значение в случае успешного завершения (см. в тексте). –1 – в случае ошибки */</CODE></P>
     <P>Первый аргумент <EM>(semid)</EM> представляет собой идентификатор семафора, a <EM>semnum</EM> указывает элемент набора семафоров (0, 1 и т. д. до <EM>nsems</EM> –1). Значение <EM>semnum</EM> используется только командами GETVAL, SETVAL, GETNCNT, GETZCNT и GETPID.</P>
     <P>Четвертый аргумент является дополнительным — он добавляется в зависимости от команды cmd (см. комментарии в описании объединения). Объявляется это объединение следующим образом:</P>
     <P><CODE>union semun {</CODE></P>
     <P><CODE> int val; /* используется только командой SETVAL */</CODE></P>
     <P><CODE> struct semid_ds *buf; /* используется командами IPC_SET и IPC_STAT */</CODE></P>
     <P><CODE> ushort *array; /* используется командами GETALL и SETALL */</CODE></P>
     <P><CODE>};</CODE></P>
     <P>Это объединение отсутствует в системных заголовочных файлах и должно декларироваться приложением (мы определяем его в заголовочном файле unpipc.h, листинг B.1). Оно передается по значению, а не по ссылке, то есть аргументом является собственно значение объединения, а не указатель на него. </P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>К сожалению, в некоторых системах (FreeBSD и Linux) это объединение определено в заголовочном файле &lt;sys/sem.h&gt;, что затрудняет написание переносимых программ. Хотя в объявлении этого объединения в системном заголовочном файле и есть некоторый смысл, стандарт Unix 98 требует, чтобы оно каждый раз явно объявлялось приложением.</P>
     </DIV>
     <P>Ниже приведен список поддерживаемых значений аргумента cmd. В случае успешного завершения функция возвращает 0, а в случае ошибки – –1, если в описании команды не сказано что-либо другое.</P>
     <P>■ GETVAL — возвращает текущее значение semval. Поскольку значение семафора отрицательным быть не может (semval объявляется как unsigned short — беззнаковое короткое целое), в случае успешного возврата значение всегда будет неотрицательным.</P>
     <P>■ SETVAL — установка значения semval равным arg.val. В случае успешного выполнения корректировочное значение этого семафора (semadj) устанавливается равным нулю для всех процессов.</P>
     <P>■ GETPID — функция возвращает текущее значение поля sempid.</P>
     <P>■ GETNCNT — функция возвращает текущее значение поля semncnt.</P>
     <P>■ GETZCNT — функция возвращает текущее значение поля semzcnt.</P>
     <P>■ GETALL — возвращаются значения semval для всех элементов набора. Значения возвращаются через указатель arg.array, а сама функция при этом возвращает 0. Обратите внимание, что вызывающий процесс должен самостоятельно выделить массив беззнаковых коротких целых достаточного объема для хранения всех значений семафоров набора, а затем сделать так, чтобы arg.array указывал на этот массив.</P>
     <P>■ SETALL — установка значений semval для всех элементов набора. Значения задаются через указатель arg.array.</P>
     <P>■ IPC_RMID — удаление набора семафоров, задаваемого через идентификатор semid.</P>
     <P>■ IPC_SET — установка трех полей структуры semid_ds равными соответствующим полям структуры arg.buf: sem_perm.uid, sem_perm.gid и sem_perm.mode. Поле sem_ctime структуры semid_ds устанавливается равным текущему времени.</P>
     <P>■ IPC_STAT — возвращение вызвавшему процессу через аргумент arg.buf текущего значения полей структуры semid_ds для данного набора семафоров. Обратите внимание, что вызывающий процесс должен сначала выделить место под структуру semid_ds и установить на нее указатель arg.buf.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label537 style="border:none;"></a>11.5. Простые программы</P>
     </H1>
     <DIV class=section>
      <P>Поскольку семафоры System V обладают живучестью ядра, мы можем продемонстрировать работу с ними, написав несколько небольших программ, которые будут выполнять с семафорами различные действия. В промежутках между выполнением отдельных программ значения семафоров будут храниться в ядре. </P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label538 style="border:none;"></a>Программа semcreate</P>
      </H1>
      <P>Первая программа, текст которой приведен в листинге 11.1,<A HREF="#n_1" onmouseover="ShowBookNote('n_1')" onmouseout="HideBookNote('n_1')"><SUP>[1]</SUP></A> просто создает набор семафоров System V. Параметр командной строки –е соответствует флагу IPC_EXCL при вызове semget, а последним аргументом командной строки является количество семафоров в создаваемом наборе.</P>
      <H2><a name=label539 style="border:none;"></a>Листинг 11.1. Программа semcreate</H2>
      <P><CODE>//svsem/semcreate.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int с, oflag, semid, nsems;</CODE></P>
      <P><CODE>6   oflag = SVSEM_MODE | IPC_CREAT;</CODE></P>
      <P><CODE>7   while ((c = Getopt(argc, argv, "e")) != –1) {</CODE></P>
      <P><CODE>8    switch (c) {</CODE></P>
      <P><CODE>9    case 'e':</CODE></P>
      <P><CODE>10    oflag |= IPC_EXCL;</CODE></P>
      <P><CODE>11    break;</CODE></P>
      <P><CODE>12   }</CODE></P>
      <P><CODE>13  }</CODE></P>
      <P><CODE>14  if (optind != argc – 2)</CODE></P>
      <P><CODE>15   err_quit("usage: semcreate [ –e ] &lt;pathname&gt; &lt;nsems&gt;");</CODE></P>
      <P><CODE>16  nsems = atoi(argv[optind + 1]);</CODE></P>
      <P><CODE>17  semid = Semget(Ftok(argv[optind], 0), nsems, oflag);</CODE></P>
      <P><CODE>18  exit(0);</CODE></P>
      <P><CODE>19 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label540 style="border:none;"></a>Программа semrmid</P>
      </H1>
      <P>Следующая программа, текст которой приведен в листинге 11.2, удаляет набор семафоров из системы. Для этого используется вызов semctl с командой (аргументом cmd) IPC_RMID.</P>
      <H2><a name=label541 style="border:none;"></a>Листинг 11.2. Программа semrmid</H2>
      <P><CODE>//svsem/semrmid.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int semid;</CODE></P>
      <P><CODE>6   if (argc != 2)</CODE></P>
      <P><CODE>7    err_quit("usage: semrmid &lt;pathname&gt;"):</CODE></P>
      <P><CODE>8   semid = Semget(Ftok(argv[1], 0), 0, 0);</CODE></P>
      <P><CODE>9   Semctl(semid, 0, IPC_RMID);</CODE></P>
      <P><CODE>10  exit(0);</CODE></P>
      <P><CODE>11 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label542 style="border:none;"></a>Программа semsetvalues</P>
      </H1>
      <P>Программа semsetvalues (листинг 11.3) устанавливает значения всех семафоров набора.</P>
      <H2><a name=label543 style="border:none;"></a>Получение количества семафоров в наборе</H2>
      <P>11-15 После получения идентификатора семафора с помощью semget мы вызываем semctl с командой IPC_STAT, чтобы получить значения полей структуры semid_ds для данного семафора. Поле sem_nsems содержит нужную нам информацию о количестве семафоров в наборе.</P>
      <H2><a name=label544 style="border:none;"></a>Установка всех значений</H2>
      <P>19-24 Мы выделяем память под массив беззнаковых коротких целых, по одному элементу на каждый семафор набора, затем копируем полученные из командной строки значения в этот массив. Вызов semctl с командой SETALL позволяет установить все значения семафоров набора одновременно.</P>
      <H2><a name=label545 style="border:none;"></a>Листинг 11.3. Программа semsetvalues</H2>
      <P><CODE>//svsem/semsetvalues.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int semid, nsems, i;</CODE></P>
      <P><CODE>6   struct semid_ds seminfo;</CODE></P>
      <P><CODE>7   unsigned short *ptr;</CODE></P>
      <P><CODE>8   union semun arg;</CODE></P>
      <P><CODE>9   if (argc &lt; 2)</CODE></P>
      <P><CODE>10   err_quit("usage: semsetvalues &lt;pathname&gt; [ values … ]");</CODE></P>
      <P><CODE>11  /* получение количества семафоров в наборе */</CODE></P>
      <P><CODE>12  semid = Semget(Ftok(argv[1], 0), 0, 0);</CODE></P>
      <P><CODE>13  arg.buf = &amp;seminfo;</CODE></P>
      <P><CODE>14  Semctl(semid, 0, IPC_STAT, arg);</CODE></P>
      <P><CODE>15  nsems = arg.buf-&gt;sem_nsems;</CODE></P>
      <P><CODE>16  /* получение значений из командной строки */</CODE></P>
      <P><CODE>17  if (argc != nsems + 2)</CODE></P>
      <P><CODE>18  err_quit("%d semaphores in set, %d values specified", nsems, argc-2);</CODE></P>
      <P><CODE>19  /* выделение памяти под значения семафоров набора, помещение этих значений в новый массив */</CODE></P>
      <P><CODE>20  ptr = Calloc(nsems, sizeof(unsigned short));</CODE></P>
      <P><CODE>21  arg.array = ptr;</CODE></P>
      <P><CODE>22  for (i = 0; i &lt; nsems; i++)</CODE></P>
      <P><CODE>23   ptr[i] = atoi(argv[i +2]);</CODE></P>
      <P><CODE>24  Semctl(semid, 0, SETALL, arg);</CODE></P>
      <P><CODE>25  exit(0);</CODE></P>
      <P><CODE>26 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label546 style="border:none;"></a>Программа semgetvalues</P>
      </H1>
      <P>В листинге 11.4 приведен текст программы semgetvalues, которая получает и выводит значения всех семафоров набора.</P>
      <H2><a name=label547 style="border:none;"></a>Получение количества семафоров в наборе</H2>
      <P>11-15 После получения идентификатора семафора с помощью semget мы вызываем semctl с командой IPC_STAT для получения значений полей структуры semi d_ds данного семафора. Поле sem_nsems содержит нужную нам информацию о количестве семафоров в наборе.</P>
      <H2><a name=label548 style="border:none;"></a>Получение всех значений</H2>
      <P>16-22 Мы выделяем память под массив беззнаковых коротких целых, по одному элементу на каждый семафор набора. Вызов semctl с командой GETALL позволяет получить все значения семафоров набора одновременно. Каждое значение выводится.</P>
      <H2><a name=label549 style="border:none;"></a>Листинг 11.4. Программа semgetvalues</H2>
      <P><CODE>//svsem/semgetvalues.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int semid, nsems, i;</CODE></P>
      <P><CODE>6   struct semid_ds seminfo;</CODE></P>
      <P><CODE>7   unsigned short *ptr;</CODE></P>
      <P><CODE>8   union semun arg;</CODE></P>
      <P><CODE>9   if (argc != 2)</CODE></P>
      <P><CODE>10   err_quit("usage: semgetvalues &lt;pathname&gt;");</CODE></P>
      <P><CODE>11  /* получаем количество семафоров в наборе */</CODE></P>
      <P><CODE>12  semid = Semget(Ftok(argv[1], 0), 0, 0);</CODE></P>
      <P><CODE>13  arg.buf = &amp;seminfo;</CODE></P>
      <P><CODE>14  Semctl(semid, 0, IPC_STAT, arg);</CODE></P>
      <P><CODE>15  nsems = arg.buf-&gt;sem_nsems;</CODE></P>
      <P><CODE>16  /* выделяем память под имеющееся количество элементов */</CODE></P>
      <P><CODE>17  ptr = Calloc(nsems, sizeof(unsigned short));</CODE></P>
      <P><CODE>18  arg.array = ptr;</CODE></P>
      <P><CODE>19  /* получаем и выводим значения семафоров */</CODE></P>
      <P><CODE>20  Semctl(semid, 0, GETALL, arg);</CODE></P>
      <P><CODE>21  for (i = 0; i &lt; nsems; i++)</CODE></P>
      <P><CODE>22   printf("semval[%d] = %d\n", i, ptr[i]);</CODE></P>
      <P><CODE>23  exit(0);</CODE></P>
      <P><CODE>24 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label550 style="border:none;"></a>Программа semops</P>
      </H1>
      <P>В листинге 11.5 приведен текст программы semops, позволяющей выполнять последовательность действий над набором семафоров.</P>
      <H2><a name=label551 style="border:none;"></a>Параметры командной строки</H2>
      <P>7-19 Параметр –n соответствует установленному флагу IPC_NOWAIT для каждой операции, а параметр –u аналогичным образом позволяет указать для каждой операции флаг SEM_UNDO. Обратите внимание, что функция semop позволяет указывать свой набор флагов для каждого элемента структуры sembuf (то есть для каждой из операций в отдельности), но для простоты мы в нашей программе задаем одинаковые флаги для всех операций.</P>
      <H2><a name=label552 style="border:none;"></a>Выделение памяти под набор операций</H2>
      <P>20-29 После открытия семафора вызовом semget мы выделяем память под массив структур sembuf, по одному элементу на каждую операцию из командной строки. В отличие от предыдущих двух программ эта позволяет пользователю задать меньше команд, чем имеется семафоров в наборе.</P>
      <H2><a name=label553 style="border:none;"></a>Выполнение операций</H2>
      <P>30 Вызов semop выполняет последовательность операций над семафорами набора.</P>
      <H2><a name=label554 style="border:none;"></a>Листинг 11.5. Программа semops</H2>
      <P><CODE>//svsem/semops.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int с, i, flag, semid, nops;</CODE></P>
      <P><CODE>6   struct sembuf *ptr;</CODE></P>
      <P><CODE>7   flag = 0;</CODE></P>
      <P><CODE>8   while ((c = Getopt(argc, argv, "nu")) != –1) {</CODE></P>
      <P><CODE>9    switch (c) {</CODE></P>
      <P><CODE>10   case 'n':</CODE></P>
      <P><CODE>11    flag |= IPC_NOWAIT; /* для всех операций */</CODE></P>
      <P><CODE>12    break;</CODE></P>
      <P><CODE>13   case 'u':</CODE></P>
      <P><CODE>14    flag |= SEM_UNDO; /* для всех операций */</CODE></P>
      <P><CODE>15    break;</CODE></P>
      <P><CODE>16   }</CODE></P>
      <P><CODE>17  }</CODE></P>
      <P><CODE>18  if (argc = optind &lt; 2) /* argc – optind = количество оставшихся аргументов */</CODE></P>
      <P><CODE>19   err_quit("usage: semops [ –n ] [ –u ] &lt;pathname&gt; operation …");</CODE></P>
      <P><CODE>20  semid = Semget(Ftok(argv[optind], 0), 0, 0);</CODE></P>
      <P><CODE>21  optind++;</CODE></P>
      <P><CODE>22  nops = argc – optind;</CODE></P>
      <P><CODE>23  /* выделение памяти под операции, сохранение их в массиве и выполнение */</CODE></P>
      <P><CODE>24  ptr = Calloc(nops, sizeof(struct sembuf));</CODE></P>
      <P><CODE>25  for (i = 0; i &lt; nops; i++) {</CODE></P>
      <P><CODE>26   ptr[i].sem_num = i;</CODE></P>
      <P><CODE>27   ptr[i].sem_op = atoi(argv[optind + i]); /* &lt;0, 0, or &gt;0 */</CODE></P>
      <P><CODE>28   ptr[i].sem_flg = flag;</CODE></P>
      <P><CODE>29  }</CODE></P>
      <P><CODE>30  Semop(semid, ptr, nops);</CODE></P>
      <P><CODE>31  exit(0);</CODE></P>
      <P><CODE>32 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label555 style="border:none;"></a>Примеры</P>
      </H1>
      <P>Теперь мы продемонстрируем работу пяти приведенных выше программ и исследуем некоторые свойства семафоров System V:</P>
      <P><CODE>solaris % <STRONG>touch /tmp/rich</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>semcreate –e /tmp/rich 3</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>semsetvalues /tmp/rich 1 2 3</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>semgetvalues /tmp/rich</STRONG></CODE></P>
      <P><CODE>semval[0] = 1</CODE></P>
      <P><CODE>semval[1] = 2</CODE></P>
      <P><CODE>semval[2] = 3</CODE></P>
      <P>Сначала мы создали файл с именем /tmp/rich, который использовался при вызове ftok для вычисления идентификатора набора семафоров. Программа semcreate создает набор с тремя элементами. Программа semsetvalues устанавливает значения этих элементов (1, 2 и 3), a semgetvalues выводит их значения.</P>
      <P>Теперь продемонстрируем атомарность выполнения последовательности операций над набором:</P>
      <P><CODE>solaris % <STRONG>semops –n /tmp/rich –1 –2 –4</STRONG></CODE></P>
      <P><CODE>semctl error: Resource temporarily unavailable</CODE></P>
      <P><CODE>solaris % <STRONG>semgetvalues /tmp/rich</STRONG></CODE></P>
      <P><CODE>semval[0] = 1</CODE></P>
      <P><CODE>semval[1] = 2</CODE></P>
      <P><CODE>semval[2] = 3</CODE></P>
      <P>В командной строке мы указываем параметр, отключающий блокировку (-n), и три операции, каждая из которых уменьшает одно из значений набора семафоров. Первая операция завершается успешно (мы можем вычесть 1 из значения первого элемента набора, потому что до вычитания оно равно 1), вторая операция также проходит (вычитаем 2 из значения второго семафора, равного 2), но третья операция выполнена быть не может (мы не можем вычесть 4 из значения третьего семафора, потому что оно равно 3). Поскольку последняя операция последовательности не может быть выполнена и поскольку мы отключили режим блокирования процесса, функция возвращает ошибку EAGAIN. Если бы мы не указали флаг отключения блокировки, выполнение процесса было бы приостановлено до тех пор, пока операция вычитания не стала бы возможной. После этого мы проверяем, чтобы ни одно из значений семафоров набора не изменилось. Хотя первые две операции и могли бы быть выполнены, ни одна из трех на самом деле произведена не была, поскольку последняя операция была некорректной. Атомарность semop и означает, что выполняются либо все операции, либо ни одна из них.</P>
      <P>Теперь продемонстрируем работу флага SEM_UNDO:</P>
      <P><CODE>solaris % <STRONG>semsetvalues /tmp/rich 1 2 3 </STRONG><EM>устанавливаем конкретные значения</EM></CODE></P>
      <P><CODE>solaris % <STRONG>semops –u /tmp/rich -1 –2 –3  </STRONG><EM>для каждой операции указывается флаг SEM_UNDO</EM></CODE></P>
      <P><CODE>solaris % <STRONG>semgetvalues /tmp/rich</STRONG></CODE></P>
      <P><CODE>semval[0] = 1                              <EM>все произведенные изменения были сброшены</EM></CODE></P>
      <P><CODE><EM>                                           после завершения работыпрограммы semops</EM></CODE></P>
      <P><CODE>semval[1] = 2</CODE></P>
      <P><CODE>semval[2] = 3</CODE></P>
      <P><CODE>solaris % <STRONG>semops /tmp/rich -1 –2 –3     </STRONG><EM>теперь мы не указываем флаг SEM_UNDO</EM></CODE></P>
      <P><CODE>solaris % <STRONG>semgetvalues /tmp/rich</STRONG></CODE></P>
      <P><CODE>semval[0] = 0</CODE></P>
      <P><CODE>semval[1] = 0</CODE></P>
      <P><CODE>semval[2] = 0</CODE></P>
      <P>Сначала мы заново устанавливаем значения семафоров в наборе равными 1, 2 и 3 с помощью программы semsetvalues, а затем запускаем программу semops с операциями –1, –2, –3. При этом все три значения семафоров становятся нулевыми, но, так как мы указали параметр –u при вызове semops, для всех трех операций устанавливается флаг SEM_UNDO. При этом значения semadj для элементов набора семафоров становятся равными 1, 2 и 3 соответственно. После завершения программы semops эти значения добавляются к значениям семафоров, в результате чего их значения становятся равными 1, 2 и 3, как будто мы и не запускали программу. В этом мы убеждаемся, запустив semgetvalues. Затем мы снова запускаем semops, но уже без параметра –u, и убеждаемся, что при этом значения семафоров становятся нулевыми и остаются таковыми даже после выхода из программы.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label556 style="border:none;"></a>11.6. Блокирование файлов</P>
     </H1>
     <P>С помощью семафоров System V можно реализовать еще одну версию функций my_lock и my_unlock из листинга 10.10. Новый вариант приведен в листинге 11.6.</P>
     <H2><a name=label557 style="border:none;"></a>Листинг 11.6. Блокировка файлов с помощью семафоров System V</H2>
     <P><CODE>//lock/locksvsem.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #define LOCK_PATH "/tmp/svsemlock"</CODE></P>
     <P><CODE>3  #define MAX_TRIES 10</CODE></P>
     <P><CODE>4  int semid, initflag;</CODE></P>
     <P><CODE>5  struct sembuf postop, waitop;</CODE></P>
     <BR>
     <P><CODE>6  void</CODE></P>
     <P><CODE>7  my_lock (int fd)</CODE></P>
     <P><CODE>8  {</CODE></P>
     <P><CODE>9   int oflag, i;</CODE></P>
     <P><CODE>10  union semun arg;</CODE></P>
     <P><CODE>11  struct semid_ds seminfo;</CODE></P>
     <P><CODE>12  if (initflag == 0) {</CODE></P>
     <P><CODE>13   oflag = IPC_CREAT | IPC_EXCL | SVSEM_MODE;</CODE></P>
     <P><CODE>14   if ((semid = semget(Ftok(LOCK_PATH, 0), 1, oflag)) &gt;= 0) {</CODE></P>
     <P><CODE>15    /* этот процесс создал семафор первым, он же его и инициализирует */</CODE></P>
     <P><CODE>16    arg.val = 1;</CODE></P>
     <P><CODE>17    Semctl(semid, 0, SETVAL, arg);</CODE></P>
     <P><CODE>18   } else if (errno == EEXIST) {</CODE></P>
     <P><CODE>19    /* семафор создан другим процессом, убедимся, что он проинициализирован */</CODE></P>
     <P><CODE>20    semid = Semget(Ftok(LOCK_PATH, 0), 1, SVSEM_MODE);</CODE></P>
     <P><CODE>21    arg.buf = &amp;seminfo;</CODE></P>
     <P><CODE>22    for (i = 0; i &lt; MAX_TRIES; i++) {</CODE></P>
     <P><CODE>23     Semctl(semid, 0, IPC_STAT, arg);</CODE></P>
     <P><CODE>24     if (arg.buf-&gt;sem_otime != 0)</CODE></P>
     <P><CODE>25      goto init;</CODE></P>
     <P><CODE>26     sleep(1);</CODE></P>
     <P><CODE>27    }</CODE></P>
     <P><CODE>28    err_quit("semget OK, but semaphore not initialized");</CODE></P>
     <P><CODE>29   } else</CODE></P>
     <P><CODE>30    err_sys("semget error");</CODE></P>
     <P><CODE>31 init:</CODE></P>
     <P><CODE>32   initflag = 1;</CODE></P>
     <P><CODE>33   postop.sem_num = 0; /* инициализируем две структуры semop()*/</CODE></P>
     <P><CODE>34   postop.sem_op = 1;</CODE></P>
     <P><CODE>35   postop.sem_flg = SEM_UNDO;</CODE></P>
     <P><CODE>36   waitop.sem_num = 0;</CODE></P>
     <P><CODE>37   waitop.sem_op = –1;</CODE></P>
     <P><CODE>38   waitop.sem_flg = SEM_UNDO;</CODE></P>
     <P><CODE>39  }</CODE></P>
     <P><CODE>40  Semop(semid, &amp;waitop, 1); /* уменьшим на 1 */</CODE></P>
     <P><CODE>41 }</CODE></P>
     <BR>
     <P><CODE>42 void</CODE></P>
     <P><CODE>43 my_unlock(int fd)</CODE></P>
     <P><CODE>44 {</CODE></P>
     <P><CODE>45  Semop(semid, &amp;postop, 1); /* увеличим на 1*/</CODE></P>
     <P><CODE>46 }</CODE></P>
     <H2><a name=label558 style="border:none;"></a>Попытка исключающего создания</H2>
     <P>13-17 Нам нужно гарантировать, что только один процесс проинициализирует семафор, поэтому при вызове semget мы указываем флаги IPC_CREAT | IPC_EXCL. Если этот вызов оказывается успешным, процесс вызывает semctl для инициализации семафора значением 1. Если мы запустим несколько процессов одновременно и все они вызовут функцию my_lock, только один из них создаст семафор (предполагается, что он еще не существует) и проинициализирует его.</P>
     <H2><a name=label559 style="border:none;"></a>Семафор уже существует, мы его открываем</H2>
     <P>18-20 Если первый вызов semget возвращает ошибку EEXIST, процесс вызывает semget еще раз, но уже без флагов IPC_CREAT и IPC_EXCL.</P>
     <H2><a name=label560 style="border:none;"></a>Ожидание инициализации семафора</H2>
     <P>21-28 В этой программе возникает такая же ситуация гонок, как и обсуждавшаяся в разделе 11.2, когда мы говорили об инициализации семафоров System V вообще. Для исключения такой ситуации все процессы, которые обнаруживают, что семафор уже создан, вызывают semctl с командой IPC_STAT, проверяя значение sem_otime данного семафора. Когда это значение становится ненулевым, мы можем быть уверены, что создавший семафор процесс проинициализировал его и вызвал semop (этот вызов находится в конце функции) успешно. Если значение этого поля оказывается нулевым (что должно происходить крайне редко), мы приостанавливаем выполнение процесса на одну секунду вызовом sleep, а затем повторяем попытку. Число попыток мы ограничиваем, чтобы процесс не «заснул» навсегда.</P>
     <H2><a name=label561 style="border:none;"></a>Инициализация структур sembuf</H2>
     <P>33-38 Как отмечалось ранее, конкретный порядок полей структуры sembuf зависит от реализации, поэтому статически инициализировать ее нельзя. Вместо этого мы выделяем место под две такие структуры и присваиваем значения их полям во время выполнения программы, когда процесс вызывает my_lock в первый раз. При этом мы указываем флаг SEM_UNDO, чтобы ядро сняло блокировку, если процесс завершит свою работу, не сняв ее самостоятельно (см. упражнение 10.3).</P>
     <P>Создание семафора при первой необходимости реализовать довольно просто (все процессы пытаются создать семафор, игнорируя ошибку, если он уже существует), но удаление семафора после завершения работы всех процессов организовать гораздо сложнее. В случае демона печати, использующего файл с последовательным номером для упорядочения заданий печати, удалять семафор нет необходимости. Но в других приложениях может возникнуть необходимость удалить семафор при удалении соответствующего файла. В этом случае лучше пользоваться блокировкой записи, чем семафором.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label562 style="border:none;"></a>11.7. Ограничения семафоров System V</P>
     </H1>
     <DIV class=section>
      <P>На семафоры System V накладываются определенные системные ограничения, так же, как и на очереди сообщений. Большинство этих ограничений были связаны с особенностями реализации System V (раздел 3.8). Они показаны в табл. 11.1. Первая колонка содержит традиционное для System V имя переменной ядра, в которой хранится соответствующее oгрaничeниe.</P>
      <BR>
      <P>Таблица 11.1. Типичные значения ограничений для семафоров System V</P>
      <TABLE>
       <TR ALIGN=left >
        <TH ALIGN=left VALIGN=top >Имя</TH>
        <TH ALIGN=left VALIGN=top >Описание</TH>
        <TH ALIGN=left VALIGN=top >DUnix 4.0B</TH>
        <TH ALIGN=left VALIGN=top >Solaris 2.6</TH>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >semmni</TD>
        <TD ALIGN=left VALIGN=top >Максимальное количество наборов семафоров в системе</TD>
        <TD ALIGN=left VALIGN=top >16</TD>
        <TD ALIGN=left VALIGN=top >10</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >semmsl</TD>
        <TD ALIGN=left VALIGN=top >Максимальное количество семафоров в наборе</TD>
        <TD ALIGN=left VALIGN=top >25</TD>
        <TD ALIGN=left VALIGN=top >25</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >semmns</TD>
        <TD ALIGN=left VALIGN=top >Максимальное количество семафоров в системе</TD>
        <TD ALIGN=left VALIGN=top >400</TD>
        <TD ALIGN=left VALIGN=top >60</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >semopm</TD>
        <TD ALIGN=left VALIGN=top >Максимальное количество операций за один вызов semop</TD>
        <TD ALIGN=left VALIGN=top >10</TD>
        <TD ALIGN=left VALIGN=top >10</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >semmnu</TD>
        <TD ALIGN=left VALIGN=top >Максимальное количество структур undo в системе</TD>
        <TD ALIGN=left VALIGN=top ></TD>
        <TD ALIGN=left VALIGN=top >30</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >semume</TD>
        <TD ALIGN=left VALIGN=top >Максимальное количество записей в структуре undo</TD>
        <TD ALIGN=left VALIGN=top >10</TD>
        <TD ALIGN=left VALIGN=top >10</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >semvmx</TD>
        <TD ALIGN=left VALIGN=top >Максимальное значение семафора</TD>
        <TD ALIGN=left VALIGN=top >32767</TD>
        <TD ALIGN=left VALIGN=top >32767</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >semaem</TD>
        <TD ALIGN=left VALIGN=top >Максимальное значение корректировки при выходе</TD>
        <TD ALIGN=left VALIGN=top >16384</TD>
        <TD ALIGN=left VALIGN=top >16384</TD>
       </TR>
      </TABLE>
      <P>В Digital Unix 4.0B никакого ограничения на semmnu не существует.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label563 style="border:none;"></a>Пример</P>
      </H1>
      <P>Программа в листинге 11.7 позволяет определить ограничения, приведенные в табл. 11.1.</P>
      <H2><a name=label564 style="border:none;"></a>Листинг 11.7. Определение системных ограничений на семафоры System V</H2>
      <P><CODE>//svsem/limits.c</CODE></P>
      <P><CODE>1   #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2   /* максимальные величины, выше которых ограничение не проверяется */</CODE></P>
      <P><CODE>3   #define MAX_NIDS 4096 /* максимальное количество идентификаторов семафоров */</CODE></P>
      <P><CODE>4   #define MAX_VALUE 1024*1024 /* максимальное значение семафора */</CODE></P>
      <P><CODE>5   #define MAX_MEMBERS 4096 /* максимальное количество семафоров в наборе */</CODE></P>
      <P><CODE>6   #define MAX_NOPS 4096 /* максимальное количество операций за вызов semop */</CODE></P>
      <P><CODE>7   #define MAX_NPROC Sysconf(_SC_CHILD_MAX)</CODE></P>
      <BR>
      <P><CODE>8   int</CODE></P>
      <P><CODE>9   main(int argc, char **argv)</CODE></P>
      <P><CODE>10  {</CODE></P>
      <P><CODE>11   int i, j, semid, sid[MAX_NIDS], pipefd[2];</CODE></P>
      <P><CODE>12   int semmni, semvmx, semmsl, semmns, semopn, semaem, semume, semmnu;</CODE></P>
      <P><CODE>13   pid_t *child;</CODE></P>
      <P><CODE>14   union semun arg;</CODE></P>
      <P><CODE>15   struct sembuf ops[MAX_NOPS];</CODE></P>
      <P><CODE>16   /* сколько наборов с одним элементом можно создать? */</CODE></P>
      <P><CODE>17   for (i = 0; i &lt;= MAX_NIDS; i++) {</CODE></P>
      <P><CODE>18    sid[i] = semget(IPC_PRIVATE, 1, SVSEM_MODE | IPC_CREAT);</CODE></P>
      <P><CODE>19    if (sid[i] == –1) {</CODE></P>
      <P><CODE>20     semmni = i;</CODE></P>
      <P><CODE>21     printf("%d identifiers open at once\n", semmni);</CODE></P>
      <P><CODE>22     break;</CODE></P>
      <P><CODE>23    }</CODE></P>
      <P><CODE>24   }</CODE></P>
      <P><CODE>25   /* перед удалением находим максимальное значение, используя sid[0] */</CODE></P>
      <P><CODE>26   for (j = 7; j &lt; MAX_VALUE; j += 8) {</CODE></P>
      <P><CODE>27    arg.val = j;</CODE></P>
      <P><CODE>28    if (semctl(sid[0], 0, SETVAL, arg) == –1) {</CODE></P>
      <P><CODE>29     semvmx = j – 8;</CODE></P>
      <P><CODE>30     printf("max semaphore value = %d\n", semvmx);</CODE></P>
      <P><CODE>31     break;</CODE></P>
      <P><CODE>32    }</CODE></P>
      <P><CODE>33   }</CODE></P>
      <P><CODE>34   for (j = 0; j &lt; i; j++)</CODE></P>
      <P><CODE>35    Semctl(sid[j], 0, IPC_RMID);</CODE></P>
      <P><CODE>36   /* определяем максимальное количество семафоров в наборе */</CODE></P>
      <P><CODE>37   for (i = 1; i &lt;= MAX_MEMBERS; i++) {</CODE></P>
      <P><CODE>38    semid = semget(IPC_PRIVATE, i, SVSEM_MODE | IPC_CREAT);</CODE></P>
      <P><CODE>39    if (semid == –1) {</CODE></P>
      <P><CODE>40     semmsl = i-1;</CODE></P>
      <P><CODE>41     printf("max of %d members per set\n", semmsl);</CODE></P>
      <P><CODE>42     break;</CODE></P>
      <P><CODE>43    }</CODE></P>
      <P><CODE>44    Semctl(semid, 0, IPC_RMID);</CODE></P>
      <P><CODE>45   }</CODE></P>
      <P><CODE>46   /* сколько всего семафоров можно создать? */</CODE></P>
      <P><CODE>47   semmns = 0;</CODE></P>
      <P><CODE>48   for (i = 0; i &lt; semmni; i++) {</CODE></P>
      <P><CODE>49    sid[i] = semget(IPC_PRIVATE, semmsl, SVSEM_MODE | IPC_CREAT);</CODE></P>
      <P><CODE>50    if (sid[i] == –1) {</CODE></P>
      <P><CODE>51     /*</CODE></P>
      <P><CODE>52      До этого в наборе было semmsl элементов,</CODE></P>
      <P><CODE>53      но теперь мы уменьшаем количество элементов на 1 и смотрим.</CODE></P>
      <P><CODE>54      не получится ли создать семафор</CODE></P>
      <P><CODE>55     */</CODE></P>
      <P><CODE>56     for (j = semmsl-1; j &gt; 0; j--) {</CODE></P>
      <P><CODE>57      sid[1] = semget(IPC_PRIVATE, j, SVSEM_MODE | IPC_CREAT);</CODE></P>
      <P><CODE>58      if (sid[i] != –1) {</CODE></P>
      <P><CODE>59       semmns += j;</CODE></P>
      <P><CODE>60       printf("max of %d semaphores\n", semmns);</CODE></P>
      <P><CODE>61       Semctl(sid[i], 0, IPC_RMID);</CODE></P>
      <P><CODE>62       goto done;</CODE></P>
      <P><CODE>63      }</CODE></P>
      <P><CODE>64     }</CODE></P>
      <P><CODE>65     err_quit("j reached 0, semmns = %d", semmns);</CODE></P>
      <P><CODE>66    }</CODE></P>
      <P><CODE>67    semmns += semmsl;</CODE></P>
      <P><CODE>68   }</CODE></P>
      <P><CODE>69   printf("max of %d semaphores\n", semns);</CODE></P>
      <P><CODE>70  done:</CODE></P>
      <P><CODE>71   for (j = 0; j &lt; i; j++)</CODE></P>
      <P><CODE>72    Semctl(sid[j], 0, IPC_RMID);</CODE></P>
      <P><CODE>73   /* определяем количество операций за вызов semop() */</CODE></P>
      <P><CODE>74   semid = Semget(IPC_PRIVATE, semmsl, SVSEM_MODE | IPC_CREAT);</CODE></P>
      <P><CODE>75   for (i = 1; i &lt;= MAX_NOPS; i++) {</CODE></P>
      <P><CODE>76    ops[i-1].sem_num = i-1;</CODE></P>
      <P><CODE>77    ops[i-1].sem_op = 1;</CODE></P>
      <P><CODE>78    ops[i-1].sem_flg = 0;</CODE></P>
      <P><CODE>79    if (semop(semid, ops, i) += –1) {</CODE></P>
      <P><CODE>80     if (errno != E2BIG)</CODE></P>
      <P><CODE>81      err_sys("expected E2BIG from semop");</CODE></P>
      <P><CODE>82     semopn = i-1;</CODE></P>
      <P><CODE>83     printf("max of %d operations per semop()\n", semopn);</CODE></P>
      <P><CODE>84     break;</CODE></P>
      <P><CODE>85    }</CODE></P>
      <P><CODE>86   }</CODE></P>
      <P><CODE>87   Semctl(semid, 0, IPC_RMID);</CODE></P>
      <P><CODE>88   /* определение максимального значения semadj */</CODE></P>
      <P><CODE>89   /* создание одного набора с одним семафором */</CODE></P>
      <P><CODE>90   semid = Semget(IPC_PRIVATE, 1, SVSEM_MODE | IPC_CREAT);</CODE></P>
      <P><CODE>91   arg.val = semvmx;</CODE></P>
      <P><CODE>92   Semctl(semid, 0, SETVAL, arg); /* устанавливаем значение на максимум */</CODE></P>
      <P><CODE>93   for (i = semvmx-1; i &gt; 0; i--) {</CODE></P>
      <P><CODE>94    ops[0].sem_num = 0;</CODE></P>
      <P><CODE>95    ops[0].sem_op = –i;</CODE></P>
      <P><CODE>96    ops[0].sem_flg = SEM_UNDO;</CODE></P>
      <P><CODE>97    if (semop(semid, ops, 1) != –1) {</CODE></P>
      <P><CODE>98     semaem = i;</CODE></P>
      <P><CODE>99     printf("max value of adjust-on-exit = %d\n", semaem);</CODE></P>
      <P><CODE>100    break;</CODE></P>
      <P><CODE>101   }</CODE></P>
      <P><CODE>102  }</CODE></P>
      <P><CODE>103  Semctl(semid, 0, IPC_RMID);</CODE></P>
      <P><CODE>104  /* определение максимального количества структур UNDO */</CODE></P>
      <P><CODE>105  /* создаем один набор с одним семафором и инициализируем нулем */</CODE></P>
      <P><CODE>106  semid = Semget(IPC_PRIVATE, 1, SVSEM_MODE | IPC_CREAT);</CODE></P>
      <P><CODE>107  arg.val = 0;</CODE></P>
      <P><CODE>108  Semctl(semid, 0, SETVAL, arg); /* установка значения семафора в 0 */</CODE></P>
      <P><CODE>109  Pipe(pipefd);</CODE></P>
      <P><CODE>110  child = Malloc(MAX_NPROC * sizeof(pid_t));</CODE></P>
      <P><CODE>111  for (i = 0; i &lt; MAX_NPROC; i++) {</CODE></P>
      <P><CODE>112   if ((child[i] = fork()) == –1) {</CODE></P>
      <P><CODE>113    semmnu = i – 1;</CODE></P>
      <P><CODE>114    printf("fork failed, semmnu at least %d\n", semmnu);</CODE></P>
      <P><CODE>115    break;</CODE></P>
      <P><CODE>116   } else if (child[i] == 0) {</CODE></P>
      <P><CODE>117    ops[0].sem_num = 0; /* дочерний процесс вызывает semop() */</CODE></P>
      <P><CODE>118    ops[0].sem_op = 1;</CODE></P>
      <P><CODE>119    ops[0].sem_flg = SEM_UNDO;</CODE></P>
      <P><CODE>120    j = semop(semid, ops, 1); /* 0 в случае успешного завершения. –1 – в случае ошибки */</CODE></P>
      <P><CODE>121    Write(pipefd[1], &amp;j, sizeof(j));</CODE></P>
      <P><CODE>122    sleep(30); /* ожидает завершения родительским процессом */</CODE></P>
      <P><CODE>123    exit(0); /* на всякий случай */</CODE></P>
      <P><CODE>124   }</CODE></P>
      <P><CODE>125   /* родительский процесс считывает результат вызова semop() */</CODE></P>
      <P><CODE>126   Read(pipefd[0], &amp;j, sizeof(j));</CODE></P>
      <P><CODE>127   if (j == –1) {</CODE></P>
      <P><CODE>128    semmnu = i;</CODE></P>
      <P><CODE>129    printf("max # undo structures = %d\n", semmnu);</CODE></P>
      <P><CODE>130    break;</CODE></P>
      <P><CODE>131   }</CODE></P>
      <P><CODE>132  }</CODE></P>
      <P><CODE>133  Semctl(semid, 0, IPC_RMID);</CODE></P>
      <P><CODE>134  for (j = 0; j &lt;= i &amp;&amp; child[j] &gt; 0; j++)</CODE></P>
      <P><CODE>135   Kill(child[j], SIGINT);</CODE></P>
      <P><CODE>136  /* определение максимального количества записей корректировки на процесс */</CODE></P>
      <P><CODE>137  /* создание одного набора с максимальным количеством семафоров */</CODE></P>
      <P><CODE>138  semid = Semget(IPC_PRIVATE, semmsl, SVSEM_MODE | IPC_CREAT);</CODE></P>
      <P><CODE>139  for (i = 0; i &lt; semmsl; i++) {</CODE></P>
      <P><CODE>140   arg.val = 0;</CODE></P>
      <P><CODE>141   Semctl(semid, i, SETVAL, arg); /* установка значения семафора в 0 */</CODE></P>
      <P><CODE>142   ops[i].sem_num = i;</CODE></P>
      <P><CODE>143   ops[i].sem_op = 1; /* добавляем 1 к значению семафора */</CODE></P>
      <P><CODE>144   ops[i].sem_flg = SEM_UNDO;</CODE></P>
      <P><CODE>145   if (semop(semid, ops, i+1) == –1) {</CODE></P>
      <P><CODE>146    semume = i;</CODE></P>
      <P><CODE>147    printf("max # undo entries per process = %d\n", semume);</CODE></P>
      <P><CODE>148    break;</CODE></P>
      <P><CODE>149   }</CODE></P>
      <P><CODE>150  }</CODE></P>
      <P><CODE>151  Semctl(semid, 0, IPC_RMID);</CODE></P>
      <P><CODE>152  exit(0);</CODE></P>
      <P><CODE>153 }</CODE></P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label565 style="border:none;"></a>11.8. Резюме</P>
     </H1>
     <P>У семафоров System V имеются следующие отличия от семафоров Posix:</P>
     <P>1. Семафоры System V представляют собой набор значений. Последовательность операций над набором семафоров либо выполняется целиком, либо не выполняется вовсе.</P>
     <P>2. К любому элементу набора семафоров могут быть применены три операции: проверка на нулевое значение, добавление некоторого значения к текущему и вычитание некоторого значения из текущего (в предположении, что значение остается неотрицательным). Для семафоров Posix определены только операции увеличения и уменьшения значения семафора на 1 (в предположении, что значение остается неотрицательным).</P>
     <P>3. Создание семафора System V имеет некоторую особенность, заключающуюся в необходимости выполнения двух вызовов для создания и инициализации семафора, что может привести к ситуации гонок.</P>
     <P>4. Семафоры System V предоставляют возможность отмены операции с ними <EM>(undo)</EM> после завершения работы процесса.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label566 style="border:none;"></a>Упражнения</P>
     </H1>
     <P>1. Листинг 6.6 представлял собой измененный вариант листинга 6.4, в котором программа принимала идентификатор очереди вместо полного имени файла. Мы продемонстрировали, что для получения доступа к очереди System V достаточно знать только ее идентификатор (предполагается наличие достаточных разрешений). Проделайте аналогичные изменения с программой в листинге 11.5 и посмотрите, верно ли вышесказанное для семафоров System V.</P>
     <P>2. Что произойдет с программой в листинге 11.6, если файл LOCK_PATH не будет существовать?</P>
    </DIV>
   </DIV>
  </DIV>
  <DIV class=section>
   <H1>
    <P><a name=label567 style="border:none;"></a>ЧАСТЬ 4</P>
    <P>РАЗДЕЛЯЕМАЯ ПАМЯТЬ</P>
   </H1>
   <DIV class=section>
    <H1>
     <P><a name=label568 style="border:none;"></a>ГЛАВА 12</P>
     <P>Введение в разделяемую память</P>
    </H1>
    <DIV class=section>
     <H1>
      <P><a name=label569 style="border:none;"></a>12.1. Введение</P>
     </H1>
     <P>Разделяемая память является наиболее быстрым средством межпроцессного взаимодействия. После отображения области памяти в адресное пространство процессов, совместно ее использующих, для передачи данных между процессами больше не требуется участие ядра. Обычно, однако, требуется некоторая форма синхронизации процессов, помещающих данные в разделяемую память и считывающих ее оттуда. В части 3 мы обсуждали различные средства синхронизации: взаимные исключения, условные переменные, блокировки чтения-записи, блокировки записей и семафоры.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Говоря «не требуется участие ядра», мы подразумеваем, что процессы не делают системных вызовов для передачи данных. Очевидно, что все равно именно ядро обеспечивает отображение памяти, позволяющее процессам совместно ею пользоваться, и затем обслуживает эту память (обрабатывает сбои страниц и т. п.).</P>
     </DIV>
     <P>Рассмотрим по шагам работу программы копирования файла типа клиент-сервер, которую мы использовали в качестве примера для иллюстрации различных способов передачи сообщений (рис. 4.1).</P>
     <P>■ Сервер считывает данные из входного файла. Данные из файла считываются ядром в свою память, а затем копируются из ядра в память процесса.</P>
     <P>■ Сервер составляет сообщение из этих данных и отправляет его, используя именованный или неименованный канал или очередь сообщений. Эти формы IPC обычно требуют копирования данных из процесса в ядро.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Мы говорим «обычно», поскольку очереди сообщений Posix могут быть реализованы через отображение файла в память (функцию mmap мы опишем в этой главе), как мы показали в разделе 5.8 и в решении упражнения 12.2. На рис. 12.1 мы предполагаем, что очереди сообщений Posix реализованы в ядре, что также возможно. Но именованные и неименованные каналы и очереди сообщений System V требуют копирования данных из процесса в ядро вызовом write или msgsnd или копирования данных из ядра процессу вызовом read или msgrcv. </P>
     </DIV>
     <P>■ Клиент считывает данные из канала IPC, что обычно требует их копирования из ядра в пространство процесса.</P>
     <P>■ Наконец, данные копируются из буфера клиента (второй аргумент вызова write) в выходной файл.</P>
     <P>Таким образом, для копирования файла обычно требуются четыре операции копирования данных. К тому же эти операции копирования осуществляются между процессами и ядром, что часто является дорогостоящей операцией (более дорогостоящей, чем копирование данных внутри ядра или внутри одного процесса). На рис. 12.1 изображено перемещение данных между клиентом и сервером через ядро. </P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader193" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 12.1. Передача содержимого файла от сервера к клиенту</P>
     <BR>
     <P>Недостатком этих форм IPC — именованных и неименованных каналов — является то, что для передачи между процессами информация должна пройти через ядро.</P>
     <P>Разделяемая память дает возможность обойти этот недостаток, поскольку ее использование позволяет двум процессам обмениваться данными через общий участок памяти. Процессы, разумеется, должны синхронизировать и координировать свои действия. Одновременное использование участка памяти во многом аналогично совместному доступу к файлу, например к файлу с последовательным номером, который фигурировал во всех примерах на блокировку доступа к файлам. Для синхронизации такого рода может применяться любой из методов, описанных в третьей части книги.</P>
     <P>Теперь информация передается между клиентом и сервером в такой последовательности:</P>
     <P>■ сервер получает доступ к объекту разделяемой памяти, используя для синхронизации семафор (например);</P>
     <P>■ сервер считывает данные из файла в разделяемую память. Второй аргумент вызова read (адрес буфера) указывает на объект разделяемой памяти;</P>
     <P>■ после завершения операции считывания клиент уведомляется сервером с помощью семафора;</P>
     <P>■ клиент записывает данные из объекта разделяемой памяти в выходной файл. </P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader194" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 12.2. Копирование файла через разделяемую память</P>
     <BR>
     <P>Этот сценарий иллюстрирует рис. 12.2.</P>
     <P>Из этого рисунка видно, что копирование данных происходит всего лишь дважды: из входного файла в разделяемую память и из разделяемой памяти в выходной файл. Мы нарисовали два прямоугольника штриховыми линиями; они подчеркивают, что разделяемая память принадлежит как адресному пространству клиента, так и адресному пространству сервера.</P>
     <P>Концепции, связанные с использованием разделяемой памяти через интерфейсы Posix и System V, похожи. Первый интерфейс описан в главе 13, а второй — в главе 14.</P>
     <P>В этой главе мы возвращаемся к примеру с увеличением последовательного номера, который впервые появился в главе 9. Теперь мы будем хранить последовательный номер в сегменте разделяемой памяти, а не в файле.</P>
     <P>Сначала мы подчеркнем, что память разделяется между родительским и дочерним процессами при вызове fork. В пpoгрaммe из листинга 12.1<A HREF="#n_1" onmouseover="ShowBookNote('n_1')" onmouseout="HideBookNote('n_1')"><SUP>[1]</SUP></A> родительский и дочерний процессы по очереди увеличивают глобальный целочисленный счетчик count.</P>
     <H2><a name=label570 style="border:none;"></a>Листинг 12.1. Увеличение глобального счетчика родительским и дочерним процессами</H2>
     <P><CODE>//shm/incr1.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #define SEM_NAME "mysem"</CODE></P>
     <P><CODE>3  int count = 0;</CODE></P>
     <BR>
     <P><CODE>4  int</CODE></P>
     <P><CODE>5  main(int argc, char **argv)</CODE></P>
     <P><CODE>6  {</CODE></P>
     <P><CODE>7   int i, nloop;</CODE></P>
     <P><CODE>8   sem_t *mutex;</CODE></P>
     <P><CODE>9   if (argc != 2)</CODE></P>
     <P><CODE>10   err_quit("usage: incr1 &lt;#loops&gt;");</CODE></P>
     <P><CODE>11  nloop = atoi(argv[1]);</CODE></P>
     <P><CODE>12  /* создание, инициализация и удаление семафора */</CODE></P>
     <P><CODE>13  mutex = Sem_open(Px_ipc_name(SEM_NAME), O_CREAT | O_EXCL, FILE_MODE, 1);</CODE></P>
     <P><CODE>14  Sem_unlink(Px_ipc_name(SEM_NAME));</CODE></P>
     <P><CODE>15  setbuf(stdout, NULL); /* stdout не буферизуется */</CODE></P>
     <P><CODE>16  if (Fork() == 0) { /* дочерний процесс */</CODE></P>
     <P><CODE>17   for (i = 0; i &lt; nloop; i++) {</CODE></P>
     <P><CODE>18    Sem_wait(mutex);</CODE></P>
     <P><CODE>19    printf("child: %d\n", count++);</CODE></P>
     <P><CODE>20    Sem_post(mutex);</CODE></P>
     <P><CODE>21   }</CODE></P>
     <P><CODE>22   exit(0);</CODE></P>
     <P><CODE>23  }</CODE></P>
     <P><CODE>24  /* родительский процесс */</CODE></P>
     <P><CODE>25  for (i = 0; i &lt; nloop; i++) {</CODE></P>
     <P><CODE>26   Sem_wait(mutex);</CODE></P>
     <P><CODE>27   printf("parent: %d\r\", count++);</CODE></P>
     <P><CODE>28   Sem_post(mutex);</CODE></P>
     <P><CODE>29  }</CODE></P>
     <P><CODE>30  exit(0);</CODE></P>
     <P><CODE>31 }</CODE></P>
     <H2><a name=label571 style="border:none;"></a>Создание и инициализация семафора</H2>
     <P>12-14 Мы создаем и инициализируем семафор, защищающий переменную, которую мы считаем глобальной (count). Поскольку предположение о ее глобальности ложно, этот семафор на самом деле не нужен. Обратите внимание, что мы удаляем семафор из системы вызовом sem_unlink, но хотя файл с соответствующим полным именем при этом и удаляется, на открытый в данный момент семафор эта команда не действует. Этот вызов мы делаем для того, чтобы файл был удален даже при досрочном завершении программы.</P>
     <H2><a name=label572 style="border:none;"></a>Отключение буферизации стандартного потока вывода и вызов fork</H2>
     <P>15 Мы отключаем буферизацию стандартного потока вывода, поскольку запись в него будет производиться и родительским, и дочерним процессами. Это предотвращает смешивание вывода из двух процессов.</P>
     <P>16-29 Родительский и дочерний процессы увеличивают глобальный счетчик в цикле заданное число раз, выполняя операции только при установленном семафоре.</P>
     <P>Если мы запустим эту программу на выполнение и посмотрим на результат, обращая внимание только на те строки, где система переключается между родительским и дочерним процессами, мы увидим вот что:</P>
     <P><CODE>child: 0     <EM>дочерний процесс запущен первым,count=О</EM></CODE></P>
     <P><CODE>child; 1</CODE></P>
     <P><CODE>…</CODE></P>
     <P><CODE>child; 678</CODE></P>
     <P><CODE>child: 679</CODE></P>
     <P><CODE>parent: 0    <EM>дочерний процесс приостановлен, запускается родительский</EM></CODE></P>
     <P><CODE><EM>             процесс и отсчет начинается с О</EM></CODE></P>
     <P><CODE>parent: 1</CODE></P>
     <P><CODE>…</CODE></P>
     <P><CODE>parent: 1220</CODE></P>
     <P><CODE>parent: 1221</CODE></P>
     <P><CODE>child: 680   <EM>родительский процесс приостанавливается, начинает</EM></CODE></P>
     <P><CODE><EM>             выполняться дочерний процесс</EM></CODE></P>
     <P><CODE>child: 681</CODE></P>
     <P><CODE>…</CODE></P>
     <P><CODE>child: 2078</CODE></P>
     <P><CODE>child: 2079</CODE></P>
     <P><CODE>parent: 1222 <EM>дочерний процесс приостанавливается, начинает выполняться</EM></CODE></P>
     <P><CODE><EM>             родительский процесс</EM></CODE></P>
     <P><CODE>parent: 1223 и т. д.</CODE></P>
     <P>Как видно, каждый из процессов использует собственную копию глобального счетчика count. Каждый начинает со значения 0 и при прохождении цикла увеличивает значение своей копии счетчика. На рис. 12.3 изображен родительский процесс перед вызовом fork.</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader195" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 12.3. Родительский процесс перед вызовом fork</P>
     <BR>
     <P>При вызове fork дочерний процесс запускается с собственной копией данных родительского процесса. На рис. 12.4 изображены оба процесса после возвращения из fork.</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader197" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 12.4. Родительский и дочерний процессы после возвращения из fork</P>
     <BR>
     <P>Мы видим, что родительский и дочерний процессы используют отдельные копии счетчика count.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label573 style="border:none;"></a>12.2. Функции mmap, munmap и msync</P>
     </H1>
     <DIV class=section>
      <P>Функция mmap отображает в адресное пространство процесса файл или объект разделяемой памяти Posix. Мы используем эту функцию в следующих ситуациях:</P>
      <P>1. С обычными файлами для обеспечения ввода-вывода через отображение в память (раздел 12.3).</P>
      <P>2. Со специальными файлами для обеспечения неименованного отображения памяти (разделы 12.4 и 12.5).</P>
      <P>3. С shm_open для создания участка разделяемой неродственными процессами памяти Posix.</P>
      <P><CODE>#include &lt;sys/mman.h&gt;</CODE></P>
      <P><CODE>void *mmap(void <EM>*addr,</EM> size_t <EM>len,</EM> int <EM>prot,</EM> int <EM>flags,</EM> int <EM>fd,</EM> off_t <EM>offset</EM>);</CODE></P>
      <P><CODE>/* Возвращает начальный адрес участка памяти в случае успешного завершения. MAP_FAILED – в случае ошибки */</CODE></P>
      <P>Аргумент <EM>addr</EM> может указывать начальный адрес участка памяти процесса, в который следует отобразить содержимое дескриптора <EM>fd</EM>. Обычно ему присваивается значение нулевого указателя, что говорит ядру о необходимости выбрать начальный адрес самостоятельно. В любом случае функция возвращает начальный адрес сегмента памяти, выделенной для отображения.</P>
      <P>Аргумент <EM>len</EM> задает длину отображаемого участка в байтах; участок может начинаться не с начала файла (или другого объекта), а с некоторого места, задаваемого аргументом <EM>offset.</EM> Обычно <EM>offset</EM> = 0. На рис. 12.5 изображена схема отображения объекта в память.</P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader200" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 12.5. Пример отображения файла в память</P>
      <BR>
      <P>Защита участка памяти с отображенным объектом обеспечивается с помощью аргумента <EM>prot</EM> и констант, приведенных в табл. 12.1. Обычное значение этого аргумента — PROT_READ | PROT_WRITE, что обеспечивает доступ на чтение и запись.</P>
      <BR>
      <P>Таблица 12.1. Аргумент prot для вызова mmap</P>
      <TABLE>
       <TR ALIGN=left >
        <TH ALIGN=left VALIGN=top >prot</TH>
        <TH ALIGN=left VALIGN=top >Описание</TH>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >PROT_READ</TD>
        <TD ALIGN=left VALIGN=top >Данные могут быть считаны</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >PROT_WRITE</TD>
        <TD ALIGN=left VALIGN=top >Данные могут быть записаны</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >PROT_EXEC</TD>
        <TD ALIGN=left VALIGN=top >Данные могут быть выполнены</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >PROT_NONE</TD>
        <TD ALIGN=left VALIGN=top >Доступ к данным закрыт</TD>
       </TR>
      </TABLE>
      <BR>
      <P>Таблица 12.2. Аргумент flag для вызова mmap</P>
      <TABLE>
       <TR ALIGN=left >
        <TH ALIGN=left VALIGN=top >flag</TH>
        <TH ALIGN=left VALIGN=top >Описание</TH>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >MAP SHARED</TD>
        <TD ALIGN=left VALIGN=top >Изменения передаются другим процессам</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >MAP_PRIVATE</TD>
        <TD ALIGN=left VALIGN=top >Изменения не передаются другим процессам и не влияют на отображенный объект</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >MAP_FIXED</TD>
        <TD ALIGN=left VALIGN=top >Аргумент <EM>addr</EM> интерпретируется как адрес памяти</TD>
       </TR>
      </TABLE>
      <P>Аргумент <EM>flags </EM>может принимать значения из табл. 12.2. Можно указать только один из флагов — MAP_SHARED или MAP_PRIVATE, прибавив к нему при необходимости MAP_FIXED. Если указан флаг MAP_PRIVATE, все изменения будут производиться только с образом объекта в адресном пространстве процесса; другим процессам они доступны не будут. Если же указан флаг MAP_SHARED, изменения отображаемых данных видны всем процессам, совместно использующим объект.</P>
      <P>Для обеспечения переносимости пpoгрaмм флаг MAP_FIXED указывать не следует. Если он не указан, но аргумент <EM>addr</EM> представляет собой ненулевой указатель, интерпретация этого аргумента зависит от реализации. Ненулевое значение <EM>addr</EM> обычно трактуется как указатель на желаемую область памяти, в которую нужно произвести отображение. В переносимой программе значение <EM>addr</EM> должно быть нулевым и флаг MAP_FIXED не должен быть указан.</P>
      <P>Одним из способов добиться совместного использования памяти родительским и дочерним процессами является вызов mmap с флагом MAP_SHARED перед вызовом fork. Стандарт Posix.1 гарантирует в этом случае, что все отображения памяти, установленные родительским процессом, будут унаследованы дочерним. Более того, изменения в содержимом объекта, вносимые родительским процессом, будут видны дочернему, и наоборот. Эту схему мы вскоре продемонстрируем в действии.</P>
      <P>Для отключения отображения объекта в адресное пространство процесса используется вызов munmap:</P>
      <P><CODE>#include &lt;sys/mman.h&gt;</CODE></P>
      <P><CODE>int munmap(void <EM>*addr,</EM> size_t <EM>len</EM>);</CODE></P>
      <P><CODE>/* Возвращает 0 в случае успешного завершения, –1 – в случае ошибки */</CODE></P>
      <P>Аргумент <EM>addr</EM> должен содержать адрес, возвращенный mmap, a <EM>len —</EM> длину области отображения. После вызова munmap любые попытки обратиться к этой области памяти приведут к отправке процессу сигнала SIGSEGV (предполагается, что эта область памяти не будет снова отображена вызовом mmap).</P>
      <P>Если область была отображена с флагом MAP_PRIVATE, все внесенные за время работы процесса изменения сбрасываются.</P>
      <P>В изображенной на рис. 12.5 схеме ядро обеспечивает синхронизацию содержимого файла, отображенного в память, с самой памятью при помощи алгоритма работы с виртуальной памятью (если сегмент был отображен с флагом MAP_SHARED). Если мы изменяем содержимое ячейки памяти, в которую отображен файл, через некоторое время содержимое файла будет соответствующим образом изменено ядром. Однако в некоторых случаях нам нужно, чтобы содержимое файла всегда было в соответствии с содержимым памяти. Тогда для осуществления моментальной синхронизации мы вызываем msync:</P>
      <P><CODE>#include &lt;sys/mman.h&gt;</CODE></P>
      <P><CODE>int msync(void <EM>*addr,</EM> size_t <EM>len</EM>, int <EM>flags</EM>);</CODE></P>
      <P><CODE>/* Возвращает 0 в случае успешного завершения, –1 – в случае ошибки */</CODE></P>
      <P>Аргумент <EM>flags</EM> представляет собой комбинацию констант из табл. 12.3.</P>
      <BR>
      <P>Таблица 12.3. Значения аргумента flags для функции msync</P>
      <TABLE>
       <TR ALIGN=left >
        <TH ALIGN=left VALIGN=top >Константа</TH>
        <TH ALIGN=left VALIGN=top >Описание</TH>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >MS_ASYNC</TD>
        <TD ALIGN=left VALIGN=top >Осуществлять асинхронную запись</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >MS_SYNC</TD>
        <TD ALIGN=left VALIGN=top >Осуществлять синхронную запись</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >MS_INVALIDATE</TD>
        <TD ALIGN=left VALIGN=top >Сбросить кэш</TD>
       </TR>
      </TABLE>
      <P>Из двух констант MS_ASYNC и MS_SYNC указать нужно одну и только одну. Отличие между ними в том, что возврат из функции при указании флага MS_ASYNC происходит сразу же, как только данные для записи будут помещены в очередь ядром, а при указании флага MS_SYNC возврат происходит только после завершения операций записи. Если указан и флаг MS_INVALIDATE, все копии файла, содержимое которых не совпадает с его текущим содержимым, считаются устаревшими. Последующие обращения к этим копиям приведут к считыванию данных из файла.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label574 style="border:none;"></a>Почему вообще используется отображение в память?</P>
      </H1>
      <P>До сих пор мы всегда говорили об отображении в память содержимого файла, который сначала открывается вызовом open, а затем отображается вызовом mmap. Удобство состоит в том, что все операции ввода-вывода осуществляются ядром и скрыты от программиста, а он просто пишет код, считывающий и записывающий данные в некоторую область памяти. Ему не приходится вызывать read, write или lseek. Часто это заметно упрощает код.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Вспомните нашу реализацию очередей сообщений Posix с использованием mmap, где значения сохранялись в структуре msg_hdr и считывались из нее же (листинги 5.26 и 5.28).</P>
      </DIV>
      <P>Следует, однако, иметь в виду, что не все файлы могут быть отображены в память. Попытка отобразить дескриптор, указывающий на терминал или сокет, приведет к возвращению ошибки при вызове mmap. К дескрипторам этих типов доступ осуществляется только с помощью read и write (и аналогичных вызовов).</P>
      <P>Другой целью использования mmap может являться разделение памяти между неродственными процессами. В этом случае содержимое файла становится начальным содержимым разделяемой памяти и любые изменения, вносимые в нее процессами, копируются обратно в файл (что дает этому виду IPC живучесть файловой системы). Предполагается, что при вызове mmap указывается флаг MAP_SHARED, необходимый для разделения памяти между процессами.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Детали реализации mmap и связь этого вызова с механизмами реализации виртуальной памяти описаны в [14] для 4.4BSD и [6] для SVR4. </P>
      </DIV>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label575 style="border:none;"></a>12.3. Увеличение счетчика в отображаемом в память файле</P>
     </H1>
     <P>Изменим программу в листинге 12.1 (которая не работала) таким образом, чтобы родительский и дочерний процессы совместно использовали область памяти, в которой хранится счетчик. Для этого используем отображение файла в память вызовами open и mmap. В листинге 12.2 приведен текст новой программы.</P>
     <H2><a name=label576 style="border:none;"></a>Листинг 12.2. Родительский и дочерний процессы увеличивают значение счетчика в разделяемой памяти</H2>
     <P><CODE>//shm/incr2.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #define SEM_NAME "mysem"</CODE></P>
     <BR>
     <P><CODE>3  int</CODE></P>
     <P><CODE>4  main(int argc, char **argv)</CODE></P>
     <P><CODE>5  {</CODE></P>
     <P><CODE>6   int fd, i, nloop, zero = 0;</CODE></P>
     <P><CODE>7   int *ptr;</CODE></P>
     <P><CODE>8   sem_t *mutex;</CODE></P>
     <P><CODE>9   if (argc != 3)</CODE></P>
     <P><CODE>10   err_quit("usage: incr2 &lt;pathname&gt; &lt;#loops&gt;");</CODE></P>
     <P><CODE>11  nloop = atoi(argv[2]);</CODE></P>
     <P><CODE>12  /* открываем файл, инициализируем нулем и отображаем в память */</CODE></P>
     <P><CODE>13  fd = Open(argv[1], O_RDWR | O_CREAT, FILE_MODE);</CODE></P>
     <P><CODE>14  Write(fd, &amp;zero, sizeof(int));</CODE></P>
     <P><CODE>15  ptr = Mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</CODE></P>
     <P><CODE>16  Close(fd);</CODE></P>
     <P><CODE>17  /* создаем, инициализируем и отключаем семафор */</CODE></P>
     <P><CODE>18  mutex = Sem_open(Px_ipc_name(SEM_NAME), O_CREAT | O_EXCL, FILE_MODE, 1);</CODE></P>
     <P><CODE>19  Sem_unlink(Px_ipc_name(SEM_NAME));</CODE></P>
     <P><CODE>20  setbuf(stdout, NULL); /* stdout не буферизуется */</CODE></P>
     <P><CODE>21  if (Fork() == 0) { /* дочерний процесс */</CODE></P>
     <P><CODE>22   for (i = 0; i &lt; nloop; i++) {</CODE></P>
     <P><CODE>23    Sem_wait(mutex);</CODE></P>
     <P><CODE>24    printf("child: %d\n", (*ptr)++);</CODE></P>
     <P><CODE>25    Sem_post(mutex);</CODE></P>
     <P><CODE>26   }</CODE></P>
     <P><CODE>27   exit(0);</CODE></P>
     <P><CODE>28  }</CODE></P>
     <P><CODE>29  /* родительский процесс */</CODE></P>
     <P><CODE>30  for (i = 0; i &lt; nloop; i++) {</CODE></P>
     <P><CODE>31   Sem_wait(mutex);</CODE></P>
     <P><CODE>32   printf("parent: %d\n", (*ptr)++);</CODE></P>
     <P><CODE>33   Sem_post(mutex);</CODE></P>
     <P><CODE>34  }</CODE></P>
     <P><CODE>35  exit(0);</CODE></P>
     <P><CODE>36 }</CODE></P>
     <H2><a name=label577 style="border:none;"></a>Новый аргумент командной строки</H2>
     <P>11-14 Из командной строки теперь считывается еще один аргумент, задающий полное имя файла, который будет отображен в память. Мы открываем файл для чтения и записи, причем если файл не существует, он будет создан, а затем инициализируем файл нулем.</P>
     <H2><a name=label578 style="border:none;"></a>Вызов mmap и закрытие дескриптора</H2>
     <P>15-16 Вызов mmap позволяет отобразить открытый файл в адресное пространство процесса. Первый аргумент является нулевым указателем, при этом система сама выбирает адрес начала отображаемого сегмента. Длина файла совпадает с размером целого числа. Устанавливается доступ на чтение и запись. Четвертый аргумент имеет значение MAP_SHARED, что позволяет процессам «видеть» изменения, вносимые друг другом. Функция возвращает адрес начала участка разделяемой памяти, мы сохраняем его в переменной ptr.</P>
     <H2><a name=label579 style="border:none;"></a>fork</H2>
     <P>20-34 Мы отключаем буферизацию стандартного потока вывода и вызываем fork. И родительский, и дочерний процессы по очереди увеличивают значение целого, на которое указывает ptr.</P>
     <P>Отображенные в память файлы обрабатываются при вызове fork специфическим образом в том смысле, что созданные родительским процессом отображения наследуются дочерним процессом. Следовательно, открыв файл и вызвав mmap с флагом MAP_SHARED, мы получили область памяти, совместно используемую родительским и дочерним процессами. Более того, поскольку эта общая область на самом деле представляет собой отображенный файл, все изменения, вносимые в нее (область памяти, на которую указывает ptr, — размером sizeof (int)), также действуют и на содержимое реального файла (имя которого было указано в командной строке).</P>
     <P>Запустив эту программу на выполнение, мы увидим, что память, на которую указывает ptr, действительно используется совместно родительским и дочерним процессами. Приведем значения счетчика перед переключением процессов:</P>
     <P><CODE>solaris % <STRONG>incr2 /tmp/temp.110000</STRONG></CODE></P>
     <P><CODE>child: 0     <EM>запускается дочерний процесс</EM></CODE></P>
     <P><CODE>child: 1</CODE></P>
     <P><CODE>…</CODE></P>
     <P><CODE>child: 128</CODE></P>
     <P><CODE>child: 129</CODE></P>
     <P><CODE>parent: 130  <EM>дочерний процесс приостанавливается, запускается родительский процесс</EM></CODE></P>
     <P><CODE>parent: 131</CODE></P>
     <P><CODE>…</CODE></P>
     <P><CODE>parent: 636</CODE></P>
     <P><CODE>parent: 637</CODE></P>
     <P><CODE>child: 638   <EM>родительский процесс приостанавливается, запускается дочерний процесс</EM></CODE></P>
     <P><CODE>child: 639</CODE></P>
     <P><CODE>…</CODE></P>
     <P><CODE>child: 1517</CODE></P>
     <P><CODE>child: 1518</CODE></P>
     <P><CODE>parent: 1519 <EM>дочерний процесс приостанавливается, запускается родительский процесс</EM></CODE></P>
     <P><CODE>parent: 1520</CODE></P>
     <P><CODE>…</CODE></P>
     <P><CODE>parent: 19999 <EM>последняя строка вывода</EM></CODE></P>
     <P><CODE>solaris % <STRONG>od –D /tmp/temp.1</STRONG></CODE></P>
     <P><CODE>0000000 0000020000</CODE></P>
     <P><CODE>0000004</CODE></P>
     <P>Поскольку использовалось отображение файла в память, мы можем взглянуть на его содержимое с помощью программы od и увидеть, что окончательное значение счетчика (20000) действительно было сохранено в файле.</P>
     <P>На рис. 12.6 изображена схема, отличающаяся от рис. 12.4. Здесь используется разделяемая память и показано, что семафор также используется совместно. Семафор мы изобразили размещенным в ядре, но для семафоров Posix это не обязательно. В зависимости от реализации семафор может обладать различной живучестью, но она должна быть по крайней мере не меньше живучести ядра. Семафор может быть реализован также через отображение файла в память, что мы продемонстрировали в разделе 10.15. </P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader202" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 12.6. Родительский и дочерний процессы используют разделяемую память и общий семафор </P>
     <BR>
     <P>Мы показали, что у родительского и дочернего процессов имеются собственные копии указателя ptr, но обе копии указывают на одну и ту же область памяти — счетчик, увеличиваемый обоими процессами.</P>
     <P>Изменим программу в листинге 12.2 так, чтобы использовались семафоры Posix, размещаемые в памяти (вместо именованных). Разместим такой семафор в разделяемой области памяти. Новая программа приведена в листинге 12.3.</P>
     <H2><a name=label580 style="border:none;"></a>Листинг 12.3. Счетчик и семафор размещены в разделяемой памяти</H2>
     <P><CODE>//shm/incr3.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <BR>
     <P><CODE>2  struct shared {</CODE></P>
     <P><CODE>3   sem_t mutex; /* взаимное исключение: семафор, размещаемый в памяти */</CODE></P>
     <P><CODE>4   int count; /* и счетчик */</CODE></P>
     <P><CODE>5  } shared;</CODE></P>
     <BR>
     <P><CODE>6  int</CODE></P>
     <P><CODE>7  main(int argc, char **argv)</CODE></P>
     <P><CODE>8  {</CODE></P>
     <P><CODE>9   int fd, i, nloop;</CODE></P>
     <P><CODE>10  struct shared *ptr;</CODE></P>
     <P><CODE>11  if (argc != 3)</CODE></P>
     <P><CODE>12   err_quit("usage: incr3 &lt;pathname&gt; &lt;#loops&gt;");</CODE></P>
     <P><CODE>13  nloop = atoi(argv[2]);</CODE></P>
     <P><CODE>14  /* открываем файл, инициализируем нулем, отображаем в память */</CODE></P>
     <P><CODE>15  fd = Open(argv[1], O_RDWR | O_CREAT, FILE_MODE);</CODE></P>
     <P><CODE>16  Write(fd, &amp;shared, sizeof(struct shared));</CODE></P>
     <P><CODE>17  ptr = Mmap(NULL, sizeof(struct shared), PROT_READ | PROT_WRITE,</CODE></P>
     <P><CODE>18   MAP_SHARED, fd, 0);</CODE></P>
     <P><CODE>19  Close(fd);</CODE></P>
     <P><CODE>20  /* инициализация семафора, совместно используемого процессами */</CODE></P>
     <P><CODE>21  Sem_init(&amp;ptr-&gt;mutex, 1, 1);</CODE></P>
     <P><CODE>22  setbuf(stdout, NULL); /* stdout не буферизуется */</CODE></P>
     <P><CODE>23  if (Fork() == 0) { /* дочерний процесс */</CODE></P>
     <P><CODE>24   for (i = 0; i &lt; nloop; i++) {</CODE></P>
     <P><CODE>25    Sem_wait(&amp;ptr-&gt;mutex);</CODE></P>
     <P><CODE>26    printf("child: %d\n", ptr-&gt;count++);</CODE></P>
     <P><CODE>27    Sem_post(&amp;ptr-&gt;mutex);</CODE></P>
     <P><CODE>28   }</CODE></P>
     <P><CODE>29   exit(0);</CODE></P>
     <P><CODE>30  }</CODE></P>
     <P><CODE>31  /* родительский процесс */</CODE></P>
     <P><CODE>32  for (i = 0; i &lt; nloop; i++) {</CODE></P>
     <P><CODE>33   Sem_wait(&amp;ptr-&gt;mutex);</CODE></P>
     <P><CODE>34   printf("parent: %d\n", ptr-&gt;count++);</CODE></P>
     <P><CODE>35   Sem_post(&amp;ptr-&gt;mutex);</CODE></P>
     <P><CODE>36  }</CODE></P>
     <P><CODE>37  exit(0);</CODE></P>
     <P><CODE>38 }</CODE> </P>
     <H2><a name=label581 style="border:none;"></a>Определение структуры, хранящейся в разделяемой памяти</H2>
     <P>2-5 Помещаем целочисленный счетчик и семафор, защищающий его, в одну структуру. Эта структура будет храниться в разделяемой памяти.</P>
     <H2><a name=label582 style="border:none;"></a>Отображаем в память</H2>
     <P>14-19 Создается файл для отображения в память, который инициализируется структурой с нулевым значением обоих полей. При этом инициализируется только счетчик, поскольку семафор будет инициализирован позднее вызовом sem_init. Тем не менее проще инициализировать всю структуру нулями, чем только одно целочисленное поле.</P>
     <H2><a name=label583 style="border:none;"></a>Инициализация семафора</H2>
     <P>20-21 Используем семафор, размещаемый в памяти, вместо именованного. Для его инициализации единицей вызываем sem_init. Второй аргумент должен быть ненулевым, чтобы семафор мог совместно использоваться несколькими процессами.</P>
     <P>На рис. 12.7 изображена модификация рис. 12.6, где семафор переместился из ядра в разделяемую память. </P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader204" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 12.7. И семафор, и счетчик теперь хранятся в разделяемой памяти</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label584 style="border:none;"></a>12.4. Неименованное отображение в память в 4.4BSD</P>
     </H1>
     <P>Наши примеры из листингов 12.2 и 12.3 работают отлично, но нам приходится создавать файл в файловой системе (аргумент командной строки), вызывать open, записывать нули в файл вызовом write (чтобы проинициализировать его). Если mmap используется для передачи области разделяемой памяти через fork, мы можем упростить эту схему, используя свойства реализации.</P>
     <P>1. В версии 4.4BSD предоставляется возможность неименованного отображения в память. При этом полностью пропадает необходимость создавать или открывать файлы. Вместо этого указываются флаги MAP_SHARED | MAP_ANON и дескриптор fd = –1. Сдвиг, задаваемый аргументом <EM>offset, </EM>игнорируется. Память автоматически инициализируется нулями. Пример использования приведен в листинге 12.4.</P>
     <P>2. В версии SVR4 имеется файл /dev/zero, который мы открываем и дескриптор которого указываем при вызове mmap. Это устройство возвращает нули при попытке считывания, а весь направляемый на него вывод сбрасывается. Пример использования приведен в листинге 12.5. (Во многих реализациях, произошедших от BSD, также поддерживается устройство /dev/zero, например в SunOS 4.1.x и BSD/OS 3.1.)</P>
     <P>В листинге 12.4 приведена часть листинга 12.2, которая изменяется при переходе к использованию неименованного отображения в память в 4.4BSD.</P>
     <H2><a name=label585 style="border:none;"></a>Листинг 12.4. Отображение в память в 4.4BSD</H2>
     <P><CODE>//shm/incr_map_anon.с</CODE></P>
     <P><CODE>3  int</CODE></P>
     <P><CODE>4  main(int argc, char **argv)</CODE></P>
     <P><CODE>5  {</CODE></P>
     <P><CODE>6   int i, nloop;</CODE></P>
     <P><CODE>7   int *ptr;</CODE></P>
     <P><CODE>8   sem_t *mutex;</CODE></P>
     <P><CODE>9   if (argc != 2)</CODE></P>
     <P><CODE>10   err_quit("usage: incr_map_anon &lt;#loops&gt;");</CODE></P>
     <P><CODE>11  nloop = atoi(argv[1]);</CODE></P>
     <P><CODE>12  /* отображение в память */</CODE></P>
     <P><CODE>13  ptr = Mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE,</CODE></P>
     <P><CODE>14   MAP_SHARED | MAP_ANON, –1, 0);</CODE></P>
     <P>6-11 Автоматические переменные fd и zero больше не используются, как и аргумент командной строки, задававший имя создаваемого файла.</P>
     <P>12-14 Файл больше не нужно открывать. Вместо этого указывается флаг MAP_ANON при вызове mmap, а пятый аргумент этой функции (дескриптор) принимает значение –1.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label586 style="border:none;"></a>12.5. Отображение в память в SVR4 с помощью /dev/zero</P>
     </H1>
     <P>В листинге 12.5 приведена часть новой версии программы, претерпевшая изменения по сравнению с листингом 12.2 при переходе к использованию отображения с помощью /dev/zero.</P>
     <H2><a name=label587 style="border:none;"></a>Листинг 12.5. Отображение памяти в SVR4 с помощью /dev/zero</H2>
     <P><CODE>//shm/incr_dev_zero.c</CODE></P>
     <P><CODE>3  int</CODE></P>
     <P><CODE>4  main(int argc char **argv)</CODE></P>
     <P><CODE>5  {</CODE></P>
     <P><CODE>6   int fd, i, nloop;</CODE></P>
     <P><CODE>7   int *ptr;</CODE></P>
     <P><CODE>8   sem_t *mutex;</CODE></P>
     <P><CODE>9   if (argc != 2)</CODE></P>
     <P><CODE>10   err_quit("usage: incr_dev_zero &lt;#loops&gt;");</CODE></P>
     <P><CODE>11  nloop = atoi(argv[1]);</CODE></P>
     <P><CODE>12  /* открываем /dev/zero и отображаем в память */</CODE></P>
     <P><CODE>13  fd = Open("/dev/zero", O_RDWR);</CODE></P>
     <P><CODE>14  ptr = Mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</CODE></P>
     <P><CODE>15  Close(fd);</CODE></P>
     <P>6-11 Автоматическая переменная zero больше не используется, как и аргумент командной строки, задававший имя создаваемого файла.</P>
     <P>12-15 Мы открываем файл /dev/zero и передаем его дескриптор функции mmap. Область памяти будет гарантированно проинициализирована нулями.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label588 style="border:none;"></a>12.6. Обращение к объектам, отображенным в память</P>
     </H1>
     <P>Когда в память отображается обычный файл, размер полученной области (второй аргумент вызова mmap), как правило, совпадает с размером файла. Например, в листинге 12.3 размер файла устанавливается равным размеру структуры shared вызовом write и это же значение размера области используется при отображении его в память. Однако эти два параметра — размер файла и размер области памяти, в которую он отображен, — могут и отличаться.</P>
     <P>Для детального изучения особенностей функции mmap воспользуемся программой в листинге 12.6.</P>
     <H2><a name=label589 style="border:none;"></a>Листинг 12.6. Отображение файла: размер файла совпадает с размером области памяти</H2>
     <P><CODE>//shra/test1.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <BR>
     <P><CODE>2  int</CODE></P>
     <P><CODE>3  main(int argc, char **argv)</CODE></P>
     <P><CODE>4  {</CODE></P>
     <P><CODE>5   int fd, i;</CODE></P>
     <P><CODE>6   char *ptr;</CODE></P>
     <P><CODE>7   size_t filesize, mmapsize, pagesize;</CODE></P>
     <P><CODE>8   if (argc != 4)</CODE></P>
     <P><CODE>9    err_quit("usage: test1 &lt;pathname&gt; &lt;filesize&gt; &lt;mmapsize&gt;");</CODE></P>
     <P><CODE>10  filesize = atoi(argv[2]);</CODE></P>
     <P><CODE>11  mmapsize = atoi(argv[3]);</CODE></P>
     <P><CODE>12  /* открытие файла, установка его размера */</CODE></P>
     <P><CODE>13  fd = Open(argv[1], O_RDWR | O_CREAT | O_TRUNC, FILE_MODE);</CODE></P>
     <P><CODE>14  Lseek(fd, filesize-1, SEEK_SET);</CODE></P>
     <P><CODE>15  Write(fd, "", 1);</CODE></P>
     <P><CODE>16  ptr = Mmap(NULL, mmapsize, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</CODE></P>
     <P><CODE>17  Close(fd);</CODE></P>
     <P><CODE>18  pagesize = Sysconf(_SC_PAGESIZE);</CODE></P>
     <P><CODE>19  printf("PAGESIZE = %ld\n", (long) pagesize);</CODE></P>
     <P><CODE>20  for (i = 0; i &lt; max(filesize, mmapsize); i += pagesize) {</CODE></P>
     <P><CODE>21   printf("ptr[*d] = %d\n", i, ptr[i]);</CODE></P>
     <P><CODE>22   ptr[i] = 1;</CODE></P>
     <P><CODE>23   printf("ptr[%d] = %d\n", i + pagesize – 1, ptr[i + pagesize – 1]);</CODE></P>
     <P><CODE>24   ptr[i + pagesize – 1] = 1;</CODE></P>
     <P><CODE>25  }</CODE></P>
     <P><CODE>26  printf("ptr[%d] = %d\n", i, ptr[i]);</CODE></P>
     <P><CODE>27  exit(0);</CODE></P>
     <P><CODE>28 }</CODE></P>
     <H2><a name=label590 style="border:none;"></a>Аргументы командной строки</H2>
     <P>8-11 Аргументы командной строки задают полное имя создаваемого и отображаемого в память файла, его размер и размер области памяти.</P>
     <H2><a name=label591 style="border:none;"></a>Создание, открытие, урезание файла; установка его размера</H2>
     <P>12-15 Если файл не существует, он будет создан. Если он существует, его длина будет установлена равной нулю. Затем размер файла устанавливается равным указанному размеру путем вызова lseek для установки текущей позиции, равной трe-буемому размеру минус 1 и записи 1 байта.</P>
     <H2><a name=label592 style="border:none;"></a>Отображение файла в память</H2>
     <P>16-17 Файл отображается в память, причем размер области задается последним аргументом командной строки. Затем дескриптор файла закрывается.</P>
     <H2><a name=label593 style="border:none;"></a>Вывод размера страницы памяти</H2>
     <P>18-19 Размер страницы памяти получается вызовом sysconf и выводится на экран.</P>
     <H2><a name=label594 style="border:none;"></a>Чтение и запись в область отображения</H2>
     <P>20-26 Считываются и выводятся данные из области памяти, в которую отображен файл. Считываются первый и последний байты каждой страницы этой области памяти. Все значения должны быть нулевыми. Затем первый и последний байты каждой страницы устанавливаются в 1. Одно из обращений к памяти может привести к отправке сигнала процессу, что приведет к его завершению. После завершения цикла for мы добавляем еще одно обращение к следующей странице памяти, что должно заведомо привести к ошибке и завершению пpoгрaммы (если ошибка не возникла раньше).</P>
     <P>Рассмотрим первую ситуацию: размер файла совпадает с размером области памяти, но эта величина не кратна размеру страницы памяти в данной реализации:</P>
     <P><CODE>solaris % <STRONG>ls –l foo</STRONG></CODE></P>
     <P><CODE>foo: No such file or directory</CODE></P>
     <P><CODE>solaris % <STRONG>test1 foo 5000 5000</STRONG></CODE></P>
     <P><CODE>PAGESIZE = 4096</CODE></P>
     <P><CODE>ptr[0] = 0</CODE></P>
     <P><CODE>ptr[4095] = 0</CODE></P>
     <P><CODE>ptr[4096] = 0</CODE></P>
     <P><CODE>ptr[8191] = 0</CODE></P>
     <P><CODE>Segmentation Fault(coredump)</CODE></P>
     <P><CODE>solaris % <STRONG>ls-l foo</STRONG></CODE></P>
     <P><CODE>-rw-r--r-- 1 rstevens other1 5000 Mar 20 17:18 foo</CODE></P>
     <P><CODE>solaris % <STRONG>od –b –A d foo</STRONG></CODE></P>
     <P><CODE>0000000 001 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000</CODE></P>
     <P><CODE>0000016 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000</CODE></P>
     <P><CODE>*</CODE></P>
     <P><CODE>0004080 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 001</CODE></P>
     <P><CODE>0004096 001 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000</CODE></P>
     <P><CODE>0004112 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000 000</CODE></P>
     <P><CODE>0005000</CODE></P>
     <P>Размер страницы памяти составляет 4096 байт, и мы смогли обратиться ко всему содержимому второй страницы (индексы 4096-8191), но обращение к третьей странице (8192) приводит к отправке сигнала SIGSEGV, о чем интерпретатор оповещает сообщением Segmentation Fault. Хотя мы и установили значение ptr[8191] = 1, оно не было записано в файл и его размер остался равным 5000 байт. Ядро позволяет считывать и записывать данные в ту часть последней страницы, которая не относится к отображенному файлу (поскольку защита памяти осуществляется ядром постранично), но изменения в этой области памяти не будут скопированы в файл. А вот относящиеся к файлу изменения (индексы 0, 4095 и 4096) были скопированы в него, в чем мы убедились, воспользовавшись программой od (параметр –b при вызове последней указывает на необходимость выводить значения байтов в восьмеричном формате, а параметр –Ad позволяет выводить адреса в десятичном формате). На рис. 12.8 изображена схема памяти для данного примера. </P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader206" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 12.8. Размер отображаемого файла совпадает с размером области памяти</P>
     <BR>
     <P>Запустив этот пример в Digital Unix 4.0B, получим тот же результат, но размер страницы памяти в этой системе равняется 8192 байт:</P>
     <P><CODE>alpha % <STRONG>ls –l foo</STRONG></CODE></P>
     <P><CODE>foo not found</CODE></P>
     <P><CODE>alpha % <STRONG>test1 foo5000 5000</STRONG></CODE></P>
     <P><CODE>PAGESIZE = 8192</CODE></P>
     <P><CODE>ptr[0] = 0</CODE></P>
     <P><CODE>ptr[8191] = 0</CODE></P>
     <P><CODE>Memory fault (coredump)</CODE></P>
     <P><CODE>alpha % <STRONG>ls -l foo</STRONG></CODE></P>
     <P><CODE>-rw-r-r– 1 rstevens operator 5000 Mar 21 08:40 foo</CODE></P>
     <P>Мы все так же можем обратиться к памяти за пределами отображенного файла, но не выходя за грaницы страницы памяти (индексы с 5000 по 8191). Обращение к ptr[8192] приводит к отправке SIGSEGV, на что мы и рассчитывали.</P>
     <P>Вторая ситуация: размер области памяти (15000 байт) превышает размер файла (5000 байт):</P>
     <P><CODE>solaris % <STRONG>rm foo</STRONG></CODE></P>
     <P><CODE>solaris % <STRONG>test1 foo 5000 15000</STRONG></CODE></P>
     <P><CODE>ptr[0] = 0</CODE></P>
     <P><CODE>ptr[4095] = 0</CODE></P>
     <P><CODE>ptr[4096] = 0</CODE></P>
     <P><CODE>ptr[8191] = 0</CODE></P>
     <P><CODE>Bus Error(coredump)</CODE></P>
     <P><CODE>solaris % <STRONG>ls –l foo</STRONG></CODE></P>
     <P><CODE>-rw-r-r– 1 rstevens other1 5000 Mar 20 17:37 foo</CODE> </P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader207" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 12.9. Размер области памяти больше размера отображаемого файла</P>
     <BR>
     <P>Полученный результат аналогичен результату предыдущего примера, в котором размер файла равнялся размеру области отображения (5000 байт). Однако в данном примере генерируется сигнал SIGBUS (о чем интерпретатор оповещает сообщением Bus Error), тогда как в предыдущем примере отправлялся сигнал SIGSEGV. Отличие в том, что SIGBUS означает выход за грaницы отображенного файла внутри области отображения, a SIGSEGV — выход за грaницы области. Этим примером мы показали, что ядро хранит информацию о размере отображенного объекта, даже несмотря на то, что его дескриптор закрыт. Ядро позволяет указать при вызове mmap размер области памяти, больший размера файла, но не позволяет обратиться к адресам в этой области (кроме остатка последней страницы, в которой еще имеется содержимое собственно файла — индексы с 5000 по 8191 в данном случае). На рис. 12.9 приведена иллюстрация к этому примеру. </P>
     <P>Следующая программа приведена в листинге 12.7. Ею мы иллюстрируем типичные методы работы с увеличивающимися в размерах файлами: при отображении в память заказывается большой размер области, текущий размер файла учитывается при всех операциях (чтобы не выйти за его пределы в памяти), а затем он просто увеличивается, по мере того как в файл записываются данные.</P>
     <H2><a name=label595 style="border:none;"></a>Листинг 12.7. Отображение увеличивающегося файла в память</H2>
     <P><CODE>//shm/test2.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #define FILE "test.data"</CODE></P>
     <P><CODE>3  #define SIZE 32768</CODE></P>
     <BR>
     <P><CODE>4  int</CODE></P>
     <P><CODE>5  main(int argc, char **argv)</CODE></P>
     <P><CODE>6  {</CODE></P>
     <P><CODE>7   int fd, i;</CODE></P>
     <P><CODE>8   char *ptr;</CODE></P>
     <P><CODE>9   /* открытие, создание, урезание и установка размера файла, вызов mmap */</CODE></P>
     <P><CODE>10  fd = Open(FILE, O_RDWR | O_CREAT | O_TRUNC, FILE_MODE);</CODE></P>
     <P><CODE>11  ptr = Mmap(NULL, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</CODE></P>
     <P><CODE>12  for (i = 4096; i &lt;= SIZE; i += 4096) {</CODE></P>
     <P><CODE>13   printf("setting file size to %d\n", i);</CODE></P>
     <P><CODE>14   Ftruncate(fd, i);</CODE></P>
     <P><CODE>15   printf("ptr[%d] = %d\n", i-1, ptr[i-1]);</CODE></P>
     <P><CODE>16  }</CODE></P>
     <P><CODE>17  exit(0);</CODE></P>
     <P><CODE>18 }</CODE></P>
     <H2><a name=label596 style="border:none;"></a>Открытие файла</H2>
     <P>9-11 Мы создаем файл, если он еще не существует, или урезаем его до нулевой длины, если он существует. Затем файл отображается в область объемом 32 768 байт, хотя его текущий размер равен нулю.</P>
     <H2><a name=label597 style="border:none;"></a>Увеличение размера файла</H2>
     <P>12-16 Мы увеличиваем размер файла на 4096 байт за один вызов ftruncate (раздел 13.3) и считываем из него последний байт в каждом проходе цикла.</P>
     <P>Запустив эту программу, мы убедимся в возможности обращаться к новым данным по мере роста файла:</P>
     <P><CODE>alpha % <STRONG>ls –l test.data</STRONG></CODE></P>
     <P><CODE>test.data: No such file or directory</CODE></P>
     <P><CODE>alpha % <STRONG>test2</STRONG></CODE></P>
     <P><CODE>setting file size to 4096</CODE></P>
     <P><CODE>ptr[4095] = 0</CODE></P>
     <P><CODE>setting file size to 8192</CODE></P>
     <P><CODE>ptr[8191] = 0</CODE></P>
     <P><CODE>setting file size to 12288</CODE></P>
     <P><CODE>ptr[12287] = 0</CODE></P>
     <P><CODE>setting file size to 16384</CODE></P>
     <P><CODE>ptr[16383] = 0</CODE></P>
     <P><CODE>setting file size to 20480</CODE></P>
     <P><CODE>ptr[20479] = 0</CODE></P>
     <P><CODE>setting file size to 24576</CODE></P>
     <P><CODE>ptr[24575] = 0</CODE></P>
     <P><CODE>setting file size to 28672</CODE></P>
     <P><CODE>ptr[28671] = 0</CODE></P>
     <P><CODE>setting file size to 32768</CODE></P>
     <P><CODE>ptr[32767] = 0</CODE></P>
     <P><CODE>alpha % <STRONG>ls-l test.data</STRONG></CODE></P>
     <P><CODE>-rw-r--r-- 1 rstevens other1 32768 Mar 20 17:53 test.data</CODE></P>
     <P>Этот пример показывает, что ядро всегда следит за размером отображаемого в память объекта (в данном примере это файл test.data), и мы всегда имеем возможность обратиться к байтам, лежащим внутри области, ограниченной размером файла и размером отображения. Те же результаты получаются при запуске этой программы в Solaris 2.6.</P>
     <P>В этом разделе мы работали с отображением файлов в память с помощью mmap. В упражнении 13.1 нам придется немного изменить две наших программы для работы с разделяемой памятью Posix, и мы получим те же результаты.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label598 style="border:none;"></a>12.7. Резюме</P>
     </H1>
     <P>Разделяемая память представляет собой самую быстродействующую форму IPC, потому что данные из разделяемой области памяти доступны всем потокам и процессам, с ней работающим. Обычно для координации совместных действий потоков и процессов, использующих разделяемую память, требуется некоторая форма синхронизации.</P>
     <P>В этой главе мы подробно рассмотрели свойства функции mmap и отображение обычных файлов в память, потому что это один из способов обеспечения взаимодействия между неродственными процессами. После отображения файла в память для обращения к нему больше не нужно использовать вызовы read, write и lseek — вместо этого можно напрямую работать с ячейками памяти, относящимися к той области, указатель на которую возвращает mmap. Замена явных операций с файлом на обращение к ячейкам памяти может упростить программу и в некоторых случаях увеличить быстродействие.</P>
     <P>Если необходимо совместное использование области памяти после вызова fork, можно упростить решение этой задачи, используя неименованное отображение в память. Для этого в ядрах Berkeley при вызове mmap указывается флаг MAP_ANON, а в ядрах SVR4 производится отображение специального файла /dev/zero.</P>
     <P>Причина, по которой мы столь детально разобрали работу mmap, заключается в том, что отображение файлов в память часто оказывается очень полезным, а также в том, что mmap используется для работы с разделяемой памятью Posix, которая является предметом изучения следующей главы.</P>
     <P>Для работы с памятью стандартом Posix определено еще четыре функции:</P>
     <P>■ mlockall делает всю память процесса резидентной; munlockall снимает эту блокировку;</P>
     <P>■ mlock делает определенный диапазон адресов процесса резидентным. Аргументами функции являются начальный адрес и длина области. Функция munlock разблокирует указываемую область памяти.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label599 style="border:none;"></a>Упражнения</P>
     </H1>
     <P>1. Что произойдет с программой в листинге 12.7, если добавить еще один повтор цикла for?</P>
     <P>2. Предположим, что имеются два процесса, один из которых отправляет сообщения другому. Для этого используются очереди сообщений System V. Нарисуйте схему передачи сообщений от отправителя к получателю. Теперь представьте, что используется реализация очередей сообщений Posix из раздела 5.8, и нарисуйте аналогичную схему.</P>
     <P>3. Мы говорили, что при вызове mmap с флагом MAP_SHARED для синхронизации содержимого файла и памяти используются алгоритмы ядра для работы с виртуальной памятью. Прочитайте страницу документации, относящуюся к /dev/zero, чтобы узнать, что происходит, когда ядро записывает изменения обратно в этот файл.</P>
     <P>4. Измените программу в листинге 12.2, указав MAP_PRIVATE вместо MAP_SHARED. Проверьте, что результаты будут такими же, как и при выполнении программы из листинга 12.1. Что будет содержаться в файле, отображенном в память?</P>
     <P>5. В разделе 6.9 мы отметили, что единственным способом использовать select с очередью сообщений System V является создание неименованной области памяти, порождение процесса и блокирование его в вызове msgrcv, причем сообщение должно считываться в разделяемую память. Родительский процесс также создает два канала, один из которых используется для уведомления его о том, что сообщение помещено в разделяемую память, а другой — для уведомления дочернего процесса о возможности помещения нового сообщения в эту память. Тогда родительский процесс может вызвать select для открытого на чтение конца канала вместе с любыми другими дескрипторами. Напишите программу, реализующую этот алгоритм. Для выделения области неименованной разделяемой памяти используйте функцию my_shm (листинг А.31). Для создания очереди сообщений и помещения в нее записей используйте программы msgcreate и msgsnd из раздела 6.6. Родительский процесс должен просто выводить размер и тип всех считываемых дочерним процессом сообщений. </P>
    </DIV>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label600 style="border:none;"></a>ГЛАВА 13</P>
     <P>Разделяемая память Posix</P>
    </H1>
    <DIV class=section>
     <H1>
      <P><a name=label601 style="border:none;"></a>13.1. Введение</P>
     </H1>
     <P>В предыдущей главе рассматривались общие вопросы, связанные с разделяемой памятью, и детально разбиралась функция mmap. Были приведены примеры, в которых вызов mmap использовался для создания области памяти, совместно используемой родительским и дочерним процессами. В этих примерах использовалось:</P>
     <P>■ отображение файлов в память (листинг 12.2);</P>
     <P>■ неименованное отображение памяти в системе 4.4BSD (листинг 12.4);</P>
     <P>■ неименованное отображение файла /dev/zero (листинг 12.5).</P>
     <P>Теперь мы можем расширить понятие разделяемой памяти, включив в него память, совместно используемую неродственными процессами. Стандарт Posix.1 предоставляет два механизма совместного использования областей памяти для неродственных процессов:</P>
     <P>1. Отображение файлов в память: файл открывается вызовом open, а его дескриптор используется при вызове mmap для отображения содержимого файла в адресное пространство процесса. Этот метод был описан в главе 12, и его использование было проиллюстрировано на примере родственных процессов. Однако он позволяет реализовать совместное использование памяти и для неродственных процессов.</P>
     <P>2. Объекты разделяемой памяти: функция shm_open открывает объект IPC с именем стандарта Posix (например, полным именем объекта файловой системы), возвращая дескриптор, который может быть использован для отображения в адресное пространство процесса вызовом mmap. Данный метод будет описан в этой главе.</P>
     <P>Оба метода требуют вызова mmap. Отличие состоит в методе получения дескриптора, являющегося аргументом mmap: в первом случае он возвращается функцией open, а во втором — shm_open. Мы показываем это на рис. 13.1. Стандарт Posix называет <EM>объектами памяти</EM> (memory objects) и отображенные в память файлы, и объекты разделяемой памяти стандарта Posix.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label602 style="border:none;"></a>13.2. Функции shm_open и shm_unlink</P>
     </H1>
     <P>Процесс получения доступа к объекту разделяемой памяти Posix выполняется в два этапа:</P>
     <P>1. Вызов shm_open с именем IPC в качестве аргумента позволяет либо создать новый объект разделяемой памяти, либо открыть существующий.</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader211" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 13.1. Объекты памяти Posix: отображаемые в память файлы и объекты разделяемой памяти</P>
     <BR>
     <P>2. Вызов mmap позволяет отобразить разделяемую память в адресное пространство вызвавшего процесса.</P>
     <P>Аргумент <EM>пате,</EM> указанный при первом вызове shm_open, должен впоследствии использоваться всеми прочими процессами, желающими получить доступ к данной области памяти.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Причина, по которой этот процесс выполняется в два этапа вместо одного, на котором в ответ на имя объекта возвращался бы адрес соответствующей области памяти, заключается в том, что функция mmap уже существовала, когда эта форма разделяемой памяти была включена в стандарт Posix. Разумеется, эти два действия могли бы выполняться и одной функцией. Функция shm_open возвращает дескриптор (вспомните, что mq_open возвращает значение типа mqd_t, a sem_open возвращает указатель на значение типа sem_t), потому что для отображения объекта в адресное пространство процесса функция mmap использует именно дескриптор этого объекта.</P>
     </DIV>
     <P><CODE>#include &lt;sys/mman.h&gt;</CODE></P>
     <P><CODE>int shm_open(const char <EM>*name,</EM> int <EM>oflag,</EM> mode_t <EM>mode</EM>);</CODE></P>
     <P><CODE>/* Возвращает неотрицательный дескриптор в случае успешного завершения, -1 – в случае ошибки */</CODE></P>
     <P><CODE>int shm_unlink(const char <EM>*name</EM>);</CODE></P>
     <P><CODE>/* Возвращает 0 в случае успешного завершения, -1 – в случае ошибки */</CODE></P>
     <P>Требования и правила, используемые при формировании аргумента name, были описаны в разделе 2.2.</P>
     <P>Аргумент <EM>oflag</EM> должен содержать флаг O_RDONLY либо O_RDWR и один из следующих: O_CREAT, O_EXCL, O_TRUNC. Флаги O_CREAT и O_EXCL были описаны в разделе 2.3. Если вместе с флагом O_RDWR указан флаг O_TRUNC, существующий объект разделяемой памяти будет укорочен до нулевой длины.</P>
     <P>Аргумент mode задает биты разрешений доступа (табл. 2.3) и используется только при указании флага O_CREAT. Обратите внимание, что в отличие от функций mq_open и sem_open для shm_open аргумент <EM>mode</EM> указывается всегда. Если флаг O_CREAT не указан, значение аргумента <EM>mode</EM> может быть нулевым.</P>
     <P>Возвращаемое значение shm_open представляет собой целочисленный дескриптор, который может использоваться при вызове mmap в качестве пятого аргумента.</P>
     <P>Функция shm_unlink удаляет имя объекта разделяемой памяти. Как и другие подобные функции (удаление файла из файловой системы, удаление очереди сообщений и именованного семафора Posix), она не выполняет никаких действий до тех пор, пока объект не будет закрыт всеми открывшими его процессами. Однако после вызова shm_unlink последующие вызовы open, mq_open и sem_open выполняться не будут.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label603 style="border:none;"></a>13.3. Функции ftruncate и fstat</P>
     </H1>
     <P>Размер файла или объекта разделяемой памяти можно изменить вызовом ftruncate:</P>
     <P><CODE>#include &lt;unistd.h&gt;</CODE></P>
     <P><CODE>int ftruncate(int <EM>fd,</EM> off_t <EM>length</EM>);</CODE></P>
     <P><CODE>/* Возвращает 0 в случае успешного завершения, –1 – в случае ошибки */</CODE></P>
     <P>Стандарт Posix делает некоторые различия в определении действия этой функции для обычных файлов и для объектов разделяемой памяти.</P>
     <P>1. Для обычного файла: если размер файла превышает значение <EM>length,</EM> избыточные данные отбрасываются. Если размер файла оказывается меньше значения <EM>length,</EM> действие функции не определено. Поэтому для переносимости следует использовать следующий способ увеличения длины обычного файла: вызов 1 seek со сдвигом <EM>length-1</EM> и запись 1 байта в файл. К счастью, почти все реализации Unix поддерживают увеличение размера файла вызовом ftruncate.</P>
     <P>2.  Для объекта разделяемой памяти: ftruncate устанавливает размер объекта равным значению аргумента <EM>length.</EM></P>
     <P>Итак, мы вызываем ftruncate для установки размера только что созданного объекта разделяемой памяти или изменения размера существующего объекта. При открытии существующего объекта разделяемой памяти следует воспользоваться fstat для получения информации о нем:</P>
     <P><CODE>#include &lt;sys/types.h&gt;</CODE></P>
     <P><CODE>#include &lt;sys/stat.h&gt;</CODE></P>
     <P><CODE>int fstat(int <EM>fd,</EM> struct stat <EM>*buf</EM>);</CODE></P>
     <P><CODE>/* Возвращает 0 в случае успешного завершения. –1 – в случае ошибки */</CODE></P>
     <P>В структуре stat содержится больше десятка полей (они подробно описаны в главе 4 [21]), но только четыре из них содержат актуальную информацию, если <EM>fd</EM> представляет собой дескриптор области разделяемой памяти:</P>
     <P><CODE>struct stat {</CODE></P>
     <P><CODE> …</CODE></P>
     <P><CODE> mode_t st_mode; /* mode: S_I{RW}{USR,GRP,OTH} */</CODE></P>
     <P><CODE> uid_t st_uid; /* UID владельца */</CODE></P>
     <P><CODE> gid_t st_gid; /* GID владельца */</CODE></P>
     <P><CODE> off_t st_size; /* размер в байтах */</CODE></P>
     <P><CODE> …</CODE></P>
     <P><CODE>};</CODE></P>
     <P>Пример использования этих двух функций будет приведен в следующем разделе. </P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>К сожалению, стандарт Posix никак не оговаривает начальное содержимое разделяемой памяти. Описание функции shm_open гласит, что «объект разделяемой памяти будет иметь нулевой размер». Описание ftruncate гласит, что для обычных файлов (не объектов разделяемой памяти) «при увеличении размера файла он будет дополнен нулями». Однако в этом описании ничего не говорится о содержимом разделяемой памяти. Обоснование Posix.1 (Rationale) говорит, что «разделяемая память при расширении дополняется нулями», но это не официальный стандарт. Когда автор попытался уточнить этот вопрос в конференции comp.std.unix, он узнал, что некоторые производители протестовали против введения требования на заполнение памяти нулями из-за возникающих накладных расходов. Если новая область памяти не инициализируется каким-то значением (то есть содержимое остается без изменения), это может угрожать безопасности системы.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label604 style="border:none;"></a>13.4. Простые программы</P>
     </H1>
     <DIV class=section>
      <P>Приведем несколько примеров программ, работающих с разделяемой памятью Posix.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label605 style="border:none;"></a>Программа shmcreate</P>
      </H1>
      <P>Программа shmcreate, текст которой приведен в листинге 13.1,<A HREF="#n_1" onmouseover="ShowBookNote('n_1')" onmouseout="HideBookNote('n_1')"><SUP>[1]</SUP></A> создает объект разделяемой памяти с указанным именем и длиной.</P>
      <H2><a name=label606 style="border:none;"></a>Листинг 13.1. Создание объекта разделяемой памяти Posix указанного размера</H2>
      <P><CODE>//pxshm/shmcreate.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int c, fd, flags;</CODE></P>
      <P><CODE>6   char *ptr;</CODE></P>
      <P><CODE>7   off_t length;</CODE></P>
      <P><CODE>8   flags = O_RDWR | O_CREAT;</CODE></P>
      <P><CODE>9   while ((c = Getopt(argc, argv, "e")) != –1) {</CODE></P>
      <P><CODE>10   switch (c) {</CODE></P>
      <P><CODE>11   case 'e':</CODE></P>
      <P><CODE>12    flags |= O_EXCL;</CODE></P>
      <P><CODE>13    break;</CODE></P>
      <P><CODE>14   }</CODE></P>
      <P><CODE>15  }</CODE></P>
      <P><CODE>16  if (optind != argc – 2)</CODE></P>
      <P><CODE>17   err_quit("usage: shmcreate [ –e ] &lt;name&gt; &lt;length&gt;");</CODE></P>
      <P><CODE>18  length = atoi(argv[optind + 1]);</CODE></P>
      <P><CODE>19  fd = Shm_open(argv[optind], flags, FILE_MODE);</CODE></P>
      <P><CODE>20  Ftruncate(fd, length);</CODE></P>
      <P><CODE>21  ptr = Mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</CODE></P>
      <P><CODE>22  exit(0);</CODE></P>
      <P><CODE>23 }</CODE></P>
      <P>19-22 Вызов shm_open создает объект разделяемой памяти. Если указан параметр –е, будет возвращена ошибка в том случае, если такой объект уже существует. Вызов ftruncate устанавливает длину (размер объекта), a mmap отображает его содержимое в адресное пространство процесса. Затем программа завершает работу. Поскольку разделяемая память Posix обладает живучестью ядра, объект разделяемой памяти при этом не исчезает.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label607 style="border:none;"></a>Программа shmunlink</P>
      </H1>
      <P>В листинге 13.2 приведен текст тривиальной программы, удаляющей имя объекта разделяемой памяти из системы.</P>
      <H2><a name=label608 style="border:none;"></a>Листинг 13.2. Удаление имени объекта разделяемой памяти Posix</H2>
      <P><CODE>//pxshm/shmunlink.c</CODE></P>
      <P><CODE>1 #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2 int</CODE></P>
      <P><CODE>3 main(int argc, char **argv)</CODE></P>
      <P><CODE>4 {</CODE></P>
      <P><CODE>5  if (argc != 2)</CODE></P>
      <P><CODE>6   err_quit("usage: shmunlink &lt;name&gt;");</CODE></P>
      <P><CODE>7  Shm_unlink(argv[1]);</CODE></P>
      <P><CODE>8  exit(0);</CODE></P>
      <P><CODE>9 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label609 style="border:none;"></a>Программа shmwrite</P>
      </H1>
      <P>В листинге 13.3 приведен текст программы shmwrite, записывающей последовательность 0, 1, 2 254, 244, 0, 1 и т. д. в объект разделяемой памяти.</P>
      <H2><a name=label610 style="border:none;"></a>Листинг 13.3. Заполнение разделяемой памяти</H2>
      <P><CODE>//pxshm/shmwrite.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int i, fd;</CODE></P>
      <P><CODE>6   struct stat stat;</CODE></P>
      <P><CODE>7   unsigned char *ptr;</CODE></P>
      <P><CODE>8   if (argc != 2)</CODE></P>
      <P><CODE>9    err_quit("usage: shmwrite &lt;name&gt;");</CODE></P>
      <P><CODE>10  /* open, определяем размер, отображаем в память */</CODE></P>
      <P><CODE>11  fd = Shm_open(argv[1], O_RDWR, FILE_MODE);</CODE></P>
      <P><CODE>12  Fstat(fd, &amp;stat);</CODE></P>
      <P><CODE>13  ptr = Mmap(NULL, stat.st_size, PROT_READ | PROT_WRITE,</CODE></P>
      <P><CODE>14   MAP_SHARED, fd, 0);</CODE></P>
      <P><CODE>15  Close(fd);</CODE></P>
      <P><CODE>16  /* присваиваем: ptr[0] = 0, ptr[1] = 1 и т. д. */</CODE></P>
      <P><CODE>17  for (i = 0; i &lt; stat.st_size; i++)</CODE></P>
      <P><CODE>18   *ptr++ = i % 256;</CODE></P>
      <P><CODE>19  exit(0);</CODE></P>
      <P><CODE>20 }</CODE></P>
      <P>10-15 Объект разделяемой памяти открывается вызовом shm_open. Его размер мы узнаем с помощью fstat. Затем файл отображается в память вызовом mmap, после чего его дескриптор может быть закрыт.</P>
      <P>16-18 Последовательность записывается в разделяемую память.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label611 style="border:none;"></a>Программа shmread</P>
      </H1>
      <P>Программа shmread (листинг 13.4) проверяет значения, помещенные в разделяемую память программой shmwrite.</P>
      <H2><a name=label612 style="border:none;"></a>Листинг 13.4. Проверка значений в разделяемой памяти</H2>
      <P><CODE>//pxshm/shmread.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int i, fd;</CODE></P>
      <P><CODE>6   struct stat stat;</CODE></P>
      <P><CODE>7   unsigned char c, *ptr;</CODE></P>
      <P><CODE>8   if (argc != 2)</CODE></P>
      <P><CODE>9    err_quit("usage: shmread &lt;name&gt;");</CODE></P>
      <P><CODE>10  /* вызываем open, узнаем размер, отображаем в память*/</CODE></P>
      <P><CODE>11  fd = Shm_open(argv[1], O_RDONLY, FILE_MODE);</CODE></P>
      <P><CODE>12  Fstat(fd, &amp;stat);</CODE></P>
      <P><CODE>13  ptr = Mmap(NULL, stat.st_size, PROT_READ,</CODE></P>
      <P><CODE>14   MAP_SHARED, fd, 0);</CODE></P>
      <P><CODE>15  Close(fd);</CODE></P>
      <P><CODE>16  /* проверяем равенства ptr[0] = 0, ptr[1] = 1 и т. д. */</CODE></P>
      <P><CODE>17  for (i = 0; i &lt; stat.st_size; i++)</CODE></P>
      <P><CODE>18   if ((c = *ptr++) != (i % 256))</CODE></P>
      <P><CODE>19    err_ret("ptr[%d] = %d", i, c);</CODE></P>
      <P><CODE>20  exit(0);</CODE></P>
      <P><CODE>21 }</CODE></P>
      <P>10-15 Объект разделяемой памяти открывается только для чтения, его размер получается вызовом fstat, после чего он отображается в память с доступом только на чтение, а дескриптор закрывается.</P>
      <P>16-19 Проверяются значения, помещенные в разделяемую память вызовом shmwrite.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label613 style="border:none;"></a>Примеры</P>
      </H1>
      <P>Создадим объект разделяемой памяти с именем /tmp/myshm объемом 123 456 байт в системе Digital Unix 4.0B:</P>
      <P><CODE>alpha % <STRONG>shmcreate /tmp/myshm 123456</STRONG></CODE></P>
      <P><CODE>alpha % <STRONG>ls –l /tmp/myshm</STRONG></CODE></P>
      <P><CODE>-rw-r--r-- 1 rstevens system 123456 Dec 10 14:33 /tmp/myshm</CODE></P>
      <P><CODE>alpha % od –c /tmp/myshm</CODE></P>
      <P><CODE>0000000 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0</CODE></P>
      <P><CODE>*</CODE></P>
      <P><CODE>0361100</CODE></P>
      <P>Мы видим, что файл с указываемым при создании объекта разделяемой памяти именем появляется в файловой системе. Используя программу od, мы можем выяснить, что после создания файл целиком заполнен нулями (восьмеричное число 0361100 — сдвиг, соответствующий байту, следующему за последним байтом файла, — эквивалентно десятичному 123 456).</P>
      <P>Запустим программу shmwrite и убедимся в правильности записываемых значений с помощью программы od:</P>
      <P><CODE>alpha % <STRONG>shmwrite /tmp/myshm</STRONG></CODE></P>
      <P><CODE>alpha * <STRONG>od –x /tmp/myshm | head-4</STRONG></CODE></P>
      <P><CODE>0000000 0100 0302 0504 0706 0908 0b0a 0d0c 0f0e</CODE></P>
      <P><CODE>0000020 1110 1312 1514 1716 1918 1b1a 1d1c 1f1e</CODE></P>
      <P><CODE>0000040 2120 2322 2524 2726 2928 2b2a 2d2c 2f2e</CODE></P>
      <P><CODE>0000060 3130 3332 3534 3736 3938 3b3a 3d3c 3f3e</CODE></P>
      <P><CODE>alpha % <STRONG>shmread /tmp/myshm</STRONG></CODE></P>
      <P><CODE>alpha % <STRONG>shmunlink /tmp/myshm</STRONG></CODE></P>
      <P>Мы проверили содержимое разделяемой памяти и с помощью shmread, а затем удалили объект, запустив программу shmunlink.</P>
      <P>Если теперь мы запустим программу shmcreate в Solaris 2.6, то увидим, что файл указанного размера создается в каталоге /tmp:</P>
      <P><CODE>solaris % <STRONG>shmcreate –e /testshm 123</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>ls-l/tmp/.*testshm*</STRONG></CODE></P>
      <P><CODE>-rw-r--r-- 1 rstevens other1 123 Dec 10 14:40 /tmp/.SHMtestshm</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label614 style="border:none;"></a>Пример</P>
      </H1>
      <P>Приведем теперь пример (листинг 13.5), иллюстрирующий тот факт, что объект разделяемой памяти может отображаться в области, начинающиеся с разных адресов в разных процессах.</P>
      <H2><a name=label615 style="border:none;"></a>Листинг 13.5. Разделяемая память может начинаться с разных адресов в разных процессах</H2>
      <P><CODE>//pxshm/test3.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int fd1, fd2, *ptr1, *ptr2;</CODE></P>
      <P><CODE>6   pid_t childpid;</CODE></P>
      <P><CODE>7   struct stat stat;</CODE></P>
      <P><CODE>8   if (argc != 2)</CODE></P>
      <P><CODE>9    err_quit("usage: test3 &lt;name&gt;");</CODE></P>
      <P><CODE>10  shm_unlink(Px_ipc_name(argv[1]));</CODE></P>
      <P><CODE>11  fd1 = Shm_open(Px_ipc_name(argv[1]), O_RDWR | O_CREAT | O_EXCL, FILE_MODE);</CODE></P>
      <P><CODE>12  Ftruncate(fd1, sizeof(int));</CODE></P>
      <P><CODE>13  fd2 = Open("/etc/motd", O_RDONLY);</CODE></P>
      <P><CODE>14  Fstat(fd2, &amp;stat);</CODE></P>
      <P><CODE>15  if ((childpid = Fork()) == 0) {</CODE></P>
      <P><CODE>16   /* дочерний процесс */</CODE></P>
      <P><CODE>17   ptr2 = Mmap(NULL, stat.st_size, PROT_READ, MAP_SHARED, fd2, 0);</CODE></P>
      <P><CODE>18   ptr1 = Mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE,</CODE></P>
      <P><CODE>19    MAP_SHARED, fd1, 0);</CODE></P>
      <P><CODE>20   printf("child: shm ptr = %p, motd ptr = %p\n", ptr1, ptr2);</CODE></P>
      <P><CODE>21   sleep(5);</CODE></P>
      <P><CODE>22   printf("shared memory integer = %d\n", *ptr1);</CODE></P>
      <P><CODE>23   exit(0);</CODE></P>
      <P><CODE>24  }</CODE></P>
      <P><CODE>25  /* родительский процесс: вызовы map следуют в обратном порядке */</CODE></P>
      <P><CODE>26  ptr1 = Mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, fd1, 0);</CODE></P>
      <P><CODE>27  ptr2 = Mmap(NULL, stat.st_size, PROT_READ, MAP_SHARED, fd2, 0);</CODE></P>
      <P><CODE>28  printf("parent: shm ptr = %p, motd ptr = %p\n", ptr1, ptr2);</CODE></P>
      <P><CODE>29  *ptr1 = 777;</CODE></P>
      <P><CODE>30  Waitpid(childpid, NULL, 0);</CODE></P>
      <P><CODE>31  exit(0);</CODE></P>
      <P><CODE>32 }</CODE></P>
      <P>10-14 Создаем сегмент разделяемой памяти с именем, принимаемым в качестве аргумента командной строки. Его размер устанавливается равным размеру целого. Затем открываем файл /etc/motd.</P>
      <P>15-30 После вызова fork и родительский, и дочерний процессы вызывают mmap дважды, но в разном порядке. Каждый процесс выводит начальный адрес каждой из областей памяти. Затем дочерний процесс ждет 5 секунд, родительский процесс помещает значение 777 в область разделяемой памяти, после чего дочерний процесс считывает и выводит это значение.</P>
      <P>Запустив эту программу, мы убедимся, что объект разделяемой памяти начинается с разных адресов в пространствах дочернего и родительского процессов:</P>
      <P><CODE>solaris % <STRONG>test3 test3.data</STRONG></CODE></P>
      <P><CODE>parent: shm ptr = eee30000, motd ptr = eee20000</CODE></P>
      <P><CODE>child: shm ptr = eee20000, motd ptr = eee30000</CODE></P>
      <P><CODE>shared memory integer = 777</CODE></P>
      <P>Несмотря на разницу в начальных адресах, родительский процесс успешно помещает значение 777 по адресу 0xeee30000, а дочерний процесс благополучно считывает его по адресу 0хеее20000. Указатели ptr1 в родительском и дочернем процессах указывают на одну и ту же область разделяемой памяти, хотя их значения в этих процессах различны.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label616 style="border:none;"></a>13.5. Увеличение общего счетчика</P>
     </H1>
     <P>Разработаем программу, аналогичную приведенной в разделе 12.3, — несколько процессов увеличивают счетчик, хранящийся в разделяемой памяти. Итак, мы помещаем счетчик в разделяемую память, а для синхронизации доступа к нему используем именованный семафор. Отличие программы из этого раздела от предыдущей состоит в том, что процессы более не являются родственными. Поскольку обращение к объектам разделяемой памяти Posix и именованным семафорам Posix осуществляется по именам, процессы, увеличивающие общий счетчик, могут не состоять в родстве. Достаточно лишь, чтобы каждый из них знал имя IPC счетчика и чтобы у каждого были соответствующие разрешения на доступ к объектам IPC (области разделяемой памяти и семафору).</P>
     <P>В листинге 13.6 приведен текст программы-сервера, которая создает объект разделяемой памяти, затем создает и инициализирует семафор, после чего завершает работу.</P>
     <H2><a name=label617 style="border:none;"></a>Листинг 13.6. Программа, создающая и инициализирующая объект разделяемой памяти и семафор</H2>
     <P><CODE>//pxshm/server1.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <BR>
     <P><CODE>2  struct shmstruct { /* структура, помещаемая в разделяемую память */</CODE></P>
     <P><CODE>3   int count;</CODE></P>
     <P><CODE>4  };</CODE></P>
     <P><CODE>5  sem_t *mutex; /* указатель на именованный семафор */</CODE></P>
     <BR>
     <P><CODE>6  int</CODE></P>
     <P><CODE>7  main(int argc, char **argv)</CODE></P>
     <P><CODE>8  {</CODE></P>
     <P><CODE>9   int fd;</CODE></P>
     <P><CODE>10  struct shmstruct *ptr;</CODE></P>
     <P><CODE>11  if (argc != 3)</CODE></P>
     <P><CODE>12   err_quit("usage: server1 &lt;shmname&gt; &lt;semname&gt;");</CODE></P>
     <P><CODE>13  shm_unlink(Px_ipc_name(argv[1])); /* ошибки игнорируются */</CODE></P>
     <P><CODE>14  /* создание shm. установка размера, отображение, закрытие дескриптора */</CODE></P>
     <P><CODE>15  fd = Shm_open(Px_ipc_name(argv[1]), O_RDWR | O_CREAT | O_EXCL, FILE_MODE);</CODE></P>
     <P><CODE>16  Ftruncate(fd, sizeof(struct shmstruct));</CODE></P>
     <P><CODE>17  ptr = Mmap(NULL, sizeof(struct shmstruct), PROT_READ | PROT_WRITE,</CODE></P>
     <P><CODE>18   MAP_SHARED, fd, 0);</CODE></P>
     <P><CODE>19  Close(fd);</CODE></P>
     <P><CODE>20  sem_unlink(Px_ipc_name(argv[2])); /* игнорируем ошибку */</CODE></P>
     <P><CODE>21  mutex = Sem_open(Px_ipc_name(argv[2]), O_CREAT | O_EXCL, FILE_MODE, 1);</CODE></P>
     <P><CODE>22  Sem_close(mutex);</CODE></P>
     <P><CODE>23  exit(0);</CODE></P>
     <P><CODE>24 }</CODE></P>
     <H2><a name=label618 style="border:none;"></a>Создание объекта разделяемой памяти</H2>
     <P>13-19 Программа начинает работу с вызова shm_unlink, на тот случай, если объект разделяемой памяти еще существует, а затем делается вызов shm_open, создающий этот объект. Его размер устанавливается равным размеру структуры sbmstruct вызовом ftruncate, а затем mmap отображает объект в наше адресное пространство. После этого дескриптор объекта закрывается.</P>
     <H2><a name=label619 style="border:none;"></a>Создание и инициализация семафора</H2>
     <P>20-22 Сначала мы вызываем sem_unlink, на тот случай, если семафор еще существует. Затем делается вызов sem_open для создания именованного семафора и инициализации его единицей. Этот семафор будет использоваться в качестве взаимного исключения всеми процессами, которые будут обращаться к объекту разделяемой памяти. После выполнения этих операций семафор закрывается.</P>
     <H2><a name=label620 style="border:none;"></a>Завершение работы процесса</H2>
     <P>23 Процесс завершает работу. Поскольку разделяемая память Posix обладает по крайней мере живучестью ядра, объект не прекращает существования до тех пор, пока он не будет закрыт всеми открывавшими его процессами и явно удален.</P>
     <P>Нам приходится использовать разные имена для семафора и объекта разделяемой памяти. Нет никаких гарантий, что в данной реализации к именам Posix IPC будут добавляться какие-либо суффиксы или префиксы, указывающие тип объекта (очередь сообщений, семафор, разделяемая память). Мы видели, что в Solaris эти типы имен имеют префиксы .MQ, .SEM и .SHM, но в Digital Unix они префиксов не имеют.</P>
     <P>В листинге 13.7 приведен текст программы-клиента, которая увеличивает счетчик, хранящийся в разделяемой памяти, определенное число раз, блокируя семафор для каждой операции увеличения.</P>
     <H2><a name=label621 style="border:none;"></a>Листинг 13.7. Программа, увеличивающая значение счетчика в разделяемой памяти</H2>
     <P><CODE>//pxshm/client1.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <BR>
     <P><CODE>2  struct shmstruct { /* структура, помещаемая в разделяемую память */</CODE></P>
     <P><CODE>3   int count;</CODE></P>
     <P><CODE>4  };</CODE></P>
     <P><CODE>5  sem_t *mutex; /* указатель на именованный семафор */</CODE></P>
     <BR>
     <P><CODE>6  int</CODE></P>
     <P><CODE>7  main(int argc, char **argv)</CODE></P>
     <P><CODE>8  {</CODE></P>
     <P><CODE>9   int fd, i, nloop;</CODE></P>
     <P><CODE>10  pid_t pid;</CODE></P>
     <P><CODE>11  struct shmstruct *ptr;</CODE></P>
     <P><CODE>12  if (argc != 4)</CODE></P>
     <P><CODE>13   err_quit("usage: client1 &lt;shmname&gt; &lt;semname&gt; &lt;#loops&gt;");</CODE></P>
     <P><CODE>14  nloop = atoi(argv[3]);</CODE></P>
     <P><CODE>15  fd = Shm_open(Px_ipc_name(argv[1]), O_RDWR, FILE_MODE);</CODE></P>
     <P><CODE>16  ptr = Mmap(NULL, sizeof(struct shmstruct), PROT_READ | PROT_WRITE,</CODE></P>
     <P><CODE>17   MAP_SHARED, fd, 0);</CODE></P>
     <P><CODE>18  Close(fd);</CODE></P>
     <P><CODE>19  mutex = Sem_open(Px_ipc_name(argv[2]), 0);</CODE></P>
     <P><CODE>20  pid = getpid();</CODE></P>
     <P><CODE>21  for (i = 0; i &lt; nloop; i++) {</CODE></P>
     <P><CODE>22   Sem_wait(mutex);</CODE></P>
     <P><CODE>23   printf("pid %ld: %d\n", (long) pid, ptr-&gt;count++);</CODE></P>
     <P><CODE>24   Sem_post(mutex);</CODE></P>
     <P><CODE>25  }</CODE></P>
     <P><CODE>26  exit(0);</CODE></P>
     <P><CODE>27 }</CODE></P>
     <H2><a name=label622 style="border:none;"></a>Открытие области разделяемойпамяти</H2>
     <P>15-18 Вызов shm_open открывает объект разделяемой памяти, который должен уже существовать (поскольку не указан флаг O_CREAT). Память отображается в адресное пространство процесса вызовом mmap, после чего дескриптор закрывается.</P>
     <H2><a name=label623 style="border:none;"></a>Открытие семафора</H2>
     <P>19 Открываем именованный семафор.</P>
     <H2><a name=label624 style="border:none;"></a>Блокирование семафора и увеличение счетчика</H2>
     <P>20-26 Параметр командной строки позволяет указать количество увеличений счетчика. Каждый раз мы выводим предыдущее значение счетчика вместе с идентификатором процесса, поскольку одновременно работают несколько экземпляров программы.</P>
     <P>Запустим сначала сервер, а затем три экземпляра программы-клиента в фоновом режиме.</P>
     <P><CODE>solaris % <STRONG>server shm1 sem1</STRONG></CODE></P>
     <P><CODE>solaris % <STRONG>client1 shm1 sem110000 &amp;client1 shm1 sem110000 &amp;client1 shm1 sem1 10000&amp;</STRONG></CODE></P>
     <P><CODE>[2] 17976        <EM>интерпретатор выводит идентификаторы процессов</EM></CODE></P>
     <P><CODE>[3] 17977</CODE></P>
     <P><CODE>[4] 17978</CODE></P>
     <P><CODE>pid 17977: 0     <EM>и этот процесс запускается первым</EM></CODE></P>
     <P><CODE>pid 17977: 1</CODE></P>
     <P><CODE>. . .            <EM>процесс 17977 продолжает работу</EM></CODE></P>
     <P><CODE>pid 17977: 32</CODE></P>
     <P><CODE>pid 17976: 33    <EM>ядро переключается междупроцессами</EM></CODE></P>
     <P><CODE>. . .            <EM>процесс 17976 продолжает работу</EM></CODE></P>
     <P><CODE>pid 17976: 707</CODE></P>
     <P><CODE>pid 17978: 708   <EM>ядро переключается между процессами</EM></CODE></P>
     <P><CODE>. . .            <EM>процесс 17978 продолжает работу</EM></CODE></P>
     <P><CODE>pid 17978: 852</CODE></P>
     <P><CODE>pid 17977: 853   <EM>ядро переключается между процессами</EM></CODE></P>
     <P><CODE>. . .            <EM>и т.д.</EM></CODE></P>
     <P><CODE>pid 17977: 29997</CODE></P>
     <P><CODE>pid 17977: 29999 <EM>последнее выводимое значение. Оно оказывается правильным.</EM></CODE></P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label625 style="border:none;"></a>13.6. Отправка сообщений на сервер</P>
     </H1>
     <P>Изменим наше решение задачи производителей и потребителей следующим образом. Сначала запускается сервер, создающий объект разделяемой памяти, в который клиенты записывают свои сообщения. Сервер просто выводит содержимое этих сообщений, хотя задачу можно и обобщить таким образом, чтобы он выполнял действия, аналогичные демону syslog, который описан в главе 13 [24]. Мы называем группу отправляющих сообщения процессов клиентами, потому что по отношению к нашему серверу они ими и являются, однако эти клиенты могут являться серверами по отношению к другим приложениям. Например, сервер Telnet является клиентом демона syslog, когда отправляет ему сообщения для занесения их в системный журнал.</P>
     <P>Вместо передачи сообщений одним из описанных ранее методов (часть 2) будем хранить сообщения в разделяемой памяти. Это, разумеется, потребует какой-либо формы синхронизации действий клиентов, помещающих сообщения, и сервера, читающего их. На рис. 13.2 приведена схема приложения в целом.</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader215" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 13.2. Несколько клиентов отправляют сообщения серверу через разделяемую память</P>
     <BR>
     <P>Перед нами взаимодействие нескольких производителей (клиентов) и одного потребителя (сервер). Разделяемая память отображается в адресное пространство сервера и каждого из клиентов.</P>
     <P>В листинге 13.8 приведен текст заголовочного файла cliserv2.h, в котором определена структура объекта, хранимого в разделяемой памяти.</P>
     <H2><a name=label626 style="border:none;"></a>Листинг 13.8. Заголовочный файл, определяющий содержимое разделяемой памяти</H2>
     <P><CODE>//pxshm/cliserv2.h</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <BR>
     <P><CODE>2  #define MESGSIZE 256 /* максимальный размер сообщения в байтах, включая завершающий ноль */</CODE></P>
     <P><CODE>3  #define NMESG 16 /* максимальное количество сообщений */</CODE></P>
     <BR>
     <P><CODE>4  struct shmstruct { /* структура, хранящаяся в разделяемой памяти */</CODE></P>
     <P><CODE>5   sem_t mutex; /* три семафора Posix, размещаемые в памяти */</CODE></P>
     <P><CODE>6   sem_t nempty;</CODE></P>
     <P><CODE>7   sem_t nstored;</CODE></P>
     <P><CODE>8   int nput; /* индекс для следующего сообщения */</CODE></P>
     <P><CODE>9   long noverflow; /* количество переполнений */</CODE></P>
     <P><CODE>10  sem_t noverflowmutex; /* взаимное исключение для счетчика переполнений */</CODE></P>
     <P><CODE>11  long msgoff[NMESG]; /* сдвиг для каждого из сообщений */</CODE></P>
     <P><CODE>12  char msgdata[NMESG * MESGSIZE]; /* сами сообщения */</CODE></P>
     <P><CODE>13 };</CODE></P>
     <H2><a name=label627 style="border:none;"></a>Основные семафоры и переменные</H2>
     <P>5-8 Три семафора Posix, размещаемых в памяти, используются для того же, для чего семафоры использовались в задаче производителей и потребителей в разделе 10.6. Их имена mutex, nempty, nstored. Переменная nput хранит индекс следующего помещаемого сообщения. Поскольку одновременно работают несколько производителей, эта переменная защищена взаимным исключением и хранится в разделяемой памяти вместе со всеми остальными.</P>
     <H2><a name=label628 style="border:none;"></a>Счетчик переполнений</H2>
     <P>9-10 Существует вероятность того, что клиент не сможет отправить сообщение из-за отсутствия свободного места для него. Если программа-клиент представляет собой сервер для других приложений (например, сервер FTP или HTTP), она не должна блокироваться в ожидании освобождения места для сообщения. Поэтому программа-клиент будет написана таким образом, чтобы она не блокировалась, но увеличивала счетчик переполнений (noverflow). Поскольку этот счетчик также является общим для всех процессов, он также должен быть защищен взаимным исключением, чтобы его значение не было повреждено.</P>
     <H2><a name=label629 style="border:none;"></a>Сдвиги сообщений и их содержимое</H2>
     <P>11-12 Массив msgoff содержит сдвиги сообщений в массиве msgdata, в котором сообщения хранятся подряд. Таким образом, сдвиг первого сообщения msgoff[0] = 0, msgoff [1] = 256 (значение MESGSIZE), msgoff [2] = 512 и т. д.</P>
     <P>Нужно понимать, что при работе с разделяемой памятью использовать сдвиг в таких случаях необходимо, поскольку объект разделяемой памяти может быть отображен в разные области адресного пространства процесса (может начинаться с разных физических адресов). Возвращаемое mmap значение для каждого процесса может быть индивидуальным. Поэтому при работе с объектами разделяемой памяти нельзя использовать указатели, содержащие реальные адреса переменных в этом объекте.</P>
     <P>В листинге 13.9 приведен текст программы-сервера, которая ожидает помещения сообщений в разделяемую память, а затем выводит их.</P>
     <H2><a name=label630 style="border:none;"></a>Листинг 13.9. Сервер, считывающий сообщения из разделяемой памяти</H2>
     <P><CODE>//pxshm/server2.c</CODE></P>
     <P><CODE>1  #include "cliserv2.h"</CODE></P>
     <BR>
     <P><CODE>2  int</CODE></P>
     <P><CODE>3  main(int argc, char **argv)</CODE></P>
     <P><CODE>4  {</CODE></P>
     <P><CODE>5   int fd, index, lastnoverflow, temp;</CODE></P>
     <P><CODE>6   long offset;</CODE></P>
     <P><CODE>7   struct shmstruct *ptr;</CODE></P>
     <P><CODE>8   if (argc != 2)</CODE></P>
     <P><CODE>9    err_quit("usage: server2 &lt;name&gt;");</CODE></P>
     <P><CODE>10  /* создание объекта разделяемой памяти, установка размера, отображение в память, закрытие дескриптора */</CODE></P>
     <P><CODE>11  shm_unlink(Px_ipc_name(argv[1])); /* ошибка игнорируется */</CODE></P>
     <P><CODE>12  fd = Shm_open(Px_ipc_name(argv[1]), O_RDWR | O_CREAT | O_EXCL, FILE_MODE);</CODE></P>
     <P><CODE>13  ptr = Mmap(NULL, sizeof(struct shmstruct), PROT_READ | PROT_WRITE,</CODE></P>
     <P><CODE>14   MAP_SHARED, fd, 0);</CODE></P>
     <P><CODE>15  Ftruncate(fd, sizeof(struct shmstruct));</CODE></P>
     <P><CODE>16  Close(fd);</CODE></P>
     <P><CODE>17  /* инициализация массива сдвигов */</CODE></P>
     <P><CODE>18  for (index = 0; index &lt; NMESG; index++)</CODE></P>
     <P><CODE>19   ptr-&gt;msgoff[index] = index * MESGSIZE;</CODE></P>
     <P><CODE>20  /* инициализация семафоров в разделяемой памяти */</CODE></P>
     <P><CODE>21  Sem_init(&amp;ptr-&gt;mutex, 1, 1);</CODE></P>
     <P><CODE>22  Sem_init(&amp;ptr-&gt;nempty, 1, NMESG);</CODE></P>
     <P><CODE>23  Sem_init(&amp;ptr-&gt;nstored, 1, 0);</CODE></P>
     <P><CODE>24  Sem_init(&amp;ptr-&gt;noverflowmutex, 1, 1);</CODE></P>
     <P><CODE>25  /* программа-потребитель */</CODE></P>
     <P><CODE>26  index = 0;</CODE></P>
     <P><CODE>27  lastnoverflow = 0;</CODE></P>
     <P><CODE>28  for (;;) {</CODE></P>
     <P><CODE>29   Sem_wait(&amp;ptr-&gt;nstored);</CODE></P>
     <P><CODE>30   Sem_wait(&amp;ptr-&gt;mutex);</CODE></P>
     <P><CODE>31   offset = ptr-&gt;msgoff[index];</CODE></P>
     <P><CODE>32   printf("index = %d: %s\n", index, &amp;ptr-&gt;msgdata[offset]);</CODE></P>
     <P><CODE>33   if (++index &gt;= NMESG)</CODE></P>
     <P><CODE>34    index =0; /* циклический буфер */</CODE></P>
     <P><CODE>35   Sem_post(&amp;ptr-&gt;mutex);</CODE></P>
     <P><CODE>36   Sem_post(&amp;ptr-&gt;nempty);</CODE></P>
     <P><CODE>37   Sem_wait(&amp;ptr-&gt;noverflowmutex);</CODE></P>
     <P><CODE>38   temp = ptr-&gt;noverflow; /* не выводим, пока не снимем блокировку */</CODE></P>
     <P><CODE>39   Sem_post(&amp;ptr-&gt;noverflowmutex);</CODE></P>
     <P><CODE>40   if (temp != lastnoverflow) {</CODE></P>
     <P><CODE>41    printf("noverflow = %d\n", temp);</CODE></P>
     <P><CODE>42    lastnoverflow = temp;</CODE></P>
     <P><CODE>43   }</CODE></P>
     <P><CODE>44  }</CODE></P>
     <P><CODE>45  exit(0);</CODE></P>
     <P><CODE>46 }</CODE></P>
     <H2><a name=label631 style="border:none;"></a>Создание объекта разделяемой памяти</H2>
     <P>10-16 Сначала делается вызов shm_unlink, чтобы удалить объект с тем же именем, который мог остаться после другого приложения. Затем объект разделяемой памяти создается вызовом shm_open и отображается в адресное пространство процесса вызовом mmap, после чего дескриптор объекта закрывается.</P>
     <H2><a name=label632 style="border:none;"></a>Инициализация массива сдвигов</H2>
     <P>17-19 Массив сдвигов инициализируется сдвигами сообщений.</P>
     <H2><a name=label633 style="border:none;"></a>Инициализация семафоров</H2>
     <P>20-24 Инициализируются четыре семафора, размещаемые в объекте разделяемой памяти. Второй аргумент sem_init всегда делается ненулевым, поскольку семафоры будут использоваться совместно несколькими процессами.</P>
     <H2><a name=label634 style="border:none;"></a>Ожидание сообщения<STRONG>, вывод его содержимого</STRONG></H2>
     <P>25-36 Первая половина цикла for написана по стандартному алгоритму потребителя: ожидание изменения семафора nstored, установка блокировки для семафора mutex, обработка данных, увеличение значения семафора nempty.</P>
     <H2><a name=label635 style="border:none;"></a>Обработка переполнений</H2>
     <P>37-43 При каждом проходе цикла мы проверяем наличие возникших переполнений. Сравнивается текущее значение noverflows с предыдущим. Если значение изменилось, оно выводится на экран и сохраняется. Обратите внимание, что значение считывается с заблокированным взаимным исключением noverflowmutex, но блокировка снимается перед сравнением и выводом значения. Идея в том, что нужно всегда следовать общему правилу минимизации количества операций, выполняемых с заблокированным взаимным исключением. В листинге 13.10 приведен текст программы-клиента.</P>
     <H2><a name=label636 style="border:none;"></a>Листинг 13.10. Клиент, помещающий сообщения в разделяемую память</H2>
     <P><CODE>//pxshm/client2.c</CODE></P>
     <P><CODE>1  #include "cliserv2.h"</CODE></P>
     <BR>
     <P><CODE>2  int</CODE></P>
     <P><CODE>3  main(int argc, char **argv)</CODE></P>
     <P><CODE>4  {</CODE></P>
     <P><CODE>5   int fd, i, nloop, nusec;</CODE></P>
     <P><CODE>6   pid_t pid;</CODE></P>
     <P><CODE>7   char mesg[MESGSIZE];</CODE></P>
     <P><CODE>8   long offset;</CODE></P>
     <P><CODE>9   struct shmstruct *ptr;</CODE></P>
     <P><CODE>10  if (argc != 4)</CODE></P>
     <P><CODE>11   err_quit("usage: client2 &lt;name&gt; &lt;#loops&gt; &lt;#usec&gt;");</CODE></P>
     <P><CODE>12  nloop = atoi(argv[2]);</CODE></P>
     <P><CODE>13  nusec = atoi(argv[3]);</CODE></P>
     <P><CODE>14  /* открытие и отображение объекта разделяемой памяти, созданного сервером заранее */</CODE></P>
     <P><CODE>15  fd = Shm_open(Px_ipc_name(argv[1]), O_RDWR, FILE_MODE);</CODE></P>
     <P><CODE>16  ptr = Mmap(NULL, sizeof(struct shmstruct), PROT_READ | PROT_WRITE,</CODE></P>
     <P><CODE>17   MAP_SHARED, fd, 0);</CODE></P>
     <P><CODE>18  Close(fd);</CODE></P>
     <P><CODE>19  pid = getpid();</CODE></P>
     <P><CODE>20  for (i = 0; i &lt; nloop; i++) {</CODE></P>
     <P><CODE>21   Sleep_us(nusec);</CODE></P>
     <P><CODE>22   snprintf(mesg, MESGSIZE, "pid %ld; message %d", (long) pid, i);</CODE></P>
     <P><CODE>23   if (sem_trywait(&amp;ptr-&gt;nempty) == –1) {</CODE></P>
     <P><CODE>24    if (errno == EAGAIN) {</CODE></P>
     <P><CODE>25     Sem_wait(&amp;ptr-&gt;noverflowmutex);</CODE></P>
     <P><CODE>26     ptr-&gt;noverflow++;</CODE></P>
     <P><CODE>27     Sem_post(&amp;ptr-&gt;noverflowmutex);</CODE></P>
     <P><CODE>28     continue;</CODE></P>
     <P><CODE>29    } else</CODE></P>
     <P><CODE>30     err_sys("sem_trywait error");</CODE></P>
     <P><CODE>31   }</CODE></P>
     <P><CODE>32   Sem_wait(&amp;ptr-&gt;mutex);</CODE></P>
     <P><CODE>33   offset = ptr-&gt;msgoff[ptr-&gt;nput];</CODE></P>
     <P><CODE>34   if (++(ptr-&gt;nput) &gt;= NMESG)</CODE></P>
     <P><CODE>35    ptr-&gt;nput = 0; /* циклический буфер */</CODE></P>
     <P><CODE>36   Sem_post(&amp;ptr-&gt;mutex);</CODE></P>
     <P><CODE>37   strcpy(&amp;ptr-&gt;msgdata[offset], mesg);</CODE></P>
     <P><CODE>38   Sem_post(&amp;ptr-&gt;nstored);</CODE></P>
     <P><CODE>39  }</CODE></P>
     <P><CODE>40  exit(0);</CODE></P>
     <P><CODE>41 }</CODE></P>
     <H2><a name=label637 style="border:none;"></a>Аргументы командной строки</H2>
     <P>10-13 Первый аргумент командной строки задает имя объекта разделяемой памяти; второй — количество сообщений, которые должны быть отправлены серверу данным клиентом. Последний аргумент задает паузу перед отправкой очередного сообщения (в микросекундах). Мы сможем получить ситуацию переполнения, запустив одновременно несколько экземпляров клиентов и указав небольшое значение для этой паузы. Таким образом мы сможем убедиться, что сервер корректно обрабатывает ситуацию переполнения.</P>
     <H2><a name=label638 style="border:none;"></a>Открытие и отображение разделяемой памяти</H2>
     <P>14-18 Мы открываем объект разделяемой памяти, предполагая, что он уже создан и проинициализирован сервером, а затем отображаем его в адресное пространство процесса. После этого дескриптор может быть закрыт.</P>
     <H2><a name=label639 style="border:none;"></a>Отправка сообщений</H2>
     <P>19-31 Клиент работает по простому алгоритму программы-производителя, но вместо вызова sem_wait(nempty), который приводил бы к блокированию клиента в случае отсутствия места в буфере для следующего сообщения, мы вызываем sem_trywait — эта функция не блокируется. Если значение семафора нулевое, возвращается ошибка EAGAIN. Мы обрабатываем эту ошибку, увеличивая значение счетчика переполнений.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>sleep_us — функция из листингов С.9 и С.10 [21]. Она приостанавливает выполнение программы на заданное количество микросекунд. Реализуется вызовом select или poll. </P>
     </DIV>
     <P>32-37 Пока заблокирован семафор mutex, мы можем получить значение сдвига (offset) и увеличить счетчик nput, но мы снимаем блокировку с этого семафора перед операцией копирования сообщения в разделяемую память. Когда семафор заблокирован, должны выполняться только самые необходимые операции.</P>
     <P>Сначала запустим сервер в фоновом режиме, а затем запустим один экземпляр программы-клиента, указав 50 сообщений и нулевую паузу между ними: </P>
     <P><CODE>solaris % server2 serv2 &amp;</CODE></P>
     <P><CODE>[2] 27223</CODE></P>
     <P><CODE>solaris % <STRONG>client2 serv250 0</STRONG></CODE></P>
     <P><CODE>index = 0: pid 27224: message 0</CODE></P>
     <P><CODE>index = 1: pid 27224: message 1</CODE></P>
     <P><CODE>index = 2: pid 27224: message 2</CODE></P>
     <P><CODE><EM>…                                продолжает в том же духе</EM></CODE></P>
     <P><CODE>index = 15: pid 27224: message 47</CODE></P>
     <P><CODE>index = 0: pid 27224: message 48</CODE></P>
     <P><CODE>index = 1: pid 27224: message 49 <EM>нет утерянных сообщений</EM></CODE></P>
     <P>Но если мы запустим программу-клиент еще раз, то мы увидим возникновение переполнений.</P>
     <P><CODE>solaris % <STRONG>client2 serv250 0</STRONG></CODE></P>
     <P><CODE>index = 2: pid 27228: message 0</CODE></P>
     <P><CODE>index = 3: pid 27228: message 1</CODE></P>
     <P><CODE><EM>…              пока все в порядке</EM></CODE></P>
     <P><CODE>index = 10: pid 27228: message 8</CODE></P>
     <P><CODE>index = 11: pid 27228: message 9</CODE></P>
     <P><CODE>noverflow = 25 <EM>утеряно 25 сообщений</EM></CODE></P>
     <P><CODE>index = 12: pid 27228: message 10</CODE></P>
     <P><CODE>index = 13: pid 27228: message 11</CODE></P>
     <P><CODE><EM>…              нормально обрабатываются сообщения 12-22</EM></CODE></P>
     <P><CODE>index = 9: pid 27228: message 23</CODE></P>
     <P><CODE>index = 10: pid 27228: message 24</CODE></P>
     <P>На этот раз клиент успешно отправил сообщения 0-9, которые были получены и выведены сервером. Затем клиент снова получил управление и поместил сообщения 10-49, но места хватило только для первых 15, а последующие 25 (с 25 по 49) не были сохранены из-за переполнения:</P>
     <P>Очевидно, что в этом примере переполнение возникло из-за того, что мы потребовали от клиента отправлять сообщения так часто, как только возможно, не делая между ними пауз. В реальном мире такое случается редко. Целью этого примера было продемонстрировать обработку ситуаций, в которых места для очередного сообщения нет, но клиент не должен блокироваться. Такая ситуация может возникнуть, разумеется, не только при использовании разделяемой памяти, но и при использовании очередей сообщений, именованных и неименованных каналов.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Переполнение приемного буфера данными встречается не только в этом примере. В разделе 8.13 [24] обсуждалась такая ситуация в связи с дейтаграммами UDP и приемным буфером сокета UDP. В разделе 18.2 [23] подробно рассказывается о том, как доменные сокеты Unix возвращают отправителю ошибку ENOBUFS при переполнении приемного буфера получателя. Это отличает доменные сокеты от протокола UDP. Программа-клиент из листинга 13.10 узнает о переполнении буфера, поэтому если этот код поместить в функцию общего назначения, которую затем будут использовать другие программы, такая функция сможет возвращать ошибку вызывающему процессу при переполнении буфера сервера.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label640 style="border:none;"></a>13.7. Резюме</P>
     </H1>
     <P>Разделяемая память Posix реализуется с помощью функции mmap, обсуждавшейся в предыдущей главе. Сначала вызывается функция shm_open с именем объекта Posix IPC в качестве одного из аргументов. Эта функция возвращает дескриптор, который затем передается функции mmap. Результат аналогичен отображению файла в память, но разделяемая память Posix не обязательно реализуется через файл.</P>
     <P>Поскольку доступ к объектам разделяемой памяти может быть получен через дескриптор, для установки размера объекта используется функция ftruncate, а информация о существующем объекте (биты разрешений, идентификаторы пользователя и группы, размер) возвращается функцией fstat.</P>
     <P>В главах, рассказывающих об очередях сообщений и семафорах Posix, мы приводили примеры их реализации через отображение в память (разделы 5.8 и 10.15). Для разделяемой памяти Posix мы этого делать не будем, поскольку реализация тривиальна. Если мы готовы использовать отображение в файл (что и сделано в Solaris и Digital Unix), shm_open реализуется через open, a shm_unlink — через unlink.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label641 style="border:none;"></a>Упражнения</P>
     </H1>
     <P>1. Измените программы из листингов 12.6 и 12.7 таким образом, чтобы они работали с разделяемой памятью Posix, а не с отображаемым в память файлом. Убедитесь, что результаты будут такими же, как и для отображаемого в память файла.</P>
     <P>2. В циклах for в листингах 13.3 и 13.4 используется команда *ptr++ для перебора элементов массива. Не лучше ли было бы использовать ptr[i]? </P>
    </DIV>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label642 style="border:none;"></a>ГЛАВА 14</P>
     <P>Разделяемая память System V</P>
    </H1>
    <DIV class=section>
     <H1>
      <P><a name=label643 style="border:none;"></a>14.1. Введение</P>
     </H1>
     <P>Основные принципы разделяемой памяти System V совпадают с концепцией разделяемой памяти Posix. Вместо вызовов shm_open и mmap в этой системе используются вызовы shmget и shmat.</P>
     <P>Для каждого сегмента разделяемой памяти ядро хранит нижеследующую структуру, определенную в заголовочном файле &lt;sys/shm.h&gt;:</P>
     <P><CODE>struct shmid_ds {</CODE></P>
     <P><CODE> struct ipc_perm shm_perm; /* структура разрешений */</CODE></P>
     <P><CODE> size_t shm_segsz; /* размер сегмента */</CODE></P>
     <P><CODE> pid_t shm_lpid; /* идентификатор процесса, выполнившего последнюю операцию */</CODE></P>
     <P><CODE> pid_t shm_cpid; /* идентификатор процесса-создателя */</CODE></P>
     <P><CODE> shmatt_t shm_nattch; /* текущее количество подключений */</CODE></P>
     <P><CODE> shmat_t shm_cnattch; /* количество подключений in-core */</CODE></P>
     <P><CODE> time_t shm_atime; /* время последнего подключения */</CODE></P>
     <P><CODE> time_t shm_dtime; /* время последнего отключения */</CODE></P>
     <P><CODE> time_t shm_ctime; /* время последнего изменения данной структуры */</CODE></P>
     <P><CODE>};</CODE></P>
     <P>Структура ipc_perm была описана в разделе 3.3; она содержит разрешения доступа к сегменту разделяемой памяти.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label644 style="border:none;"></a>14.2. Функция shmget</P>
     </H1>
     <P>С помощью функции shmget можно создать новый сегмент разделяемой памяти или подключиться к существующему:</P>
     <P><CODE>#include &lt;sys/shm.h&gt;</CODE></P>
     <P><CODE>int shmget(key_t <EM>key,</EM> size_t <EM>size,</EM> int <EM>oflag</EM>);</CODE></P>
     <P><CODE>/* Возвращает идентификатор разделяемой памяти в случае успешного завершения. –1 –в случае ошибки */</CODE></P>
     <P>Возвращаемое целочисленное значение называется идентификатором разделяемой памяти. Он используется с тремя другими функциями shmXXX.</P>
     <P>Аргумент <EM>key</EM> может содержать значение, возвращаемое функцией ftok, или константу IPC_PRIVATE, как обсуждалось в разделе 3.2.</P>
     <P>Аргумент <EM>size</EM> указывает размер сегмента в байтах. При создании нового сегмента разделяемой памяти нужно указать ненулевой размер. Если производится обращение к существующему сегменту, аргумент <EM>size</EM> должен быть нулевым.</P>
     <P>Флаг <EM>oflag </EM>представляет собой комбинацию флагов доступа на чтение и запись из табл. 3.3. К ним могут быть добавлены с помощью логического сложения флаги IPC_CREAT или IPC_CREAT | IPC_EXCL, как уже говорилось в связи с рис. 3.2.</P>
     <P>Новый сегмент инициализируется нулями.</P>
     <P>Обратите внимание, что функция shmget создает или открывает сегмент разделяемой памяти, но не дает вызвавшему процессу доступа к нему. Для подключения сегмента памяти предназначена функция shmat, описанная в следующем разделе.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label645 style="border:none;"></a>14.3. Функция shmat</P>
     </H1>
     <P>После создания или открытия сегмента разделяемой памяти вызовом shmget его нужно подключить к адресному пространству процесса вызовом shmat:</P>
     <P><CODE>#include &lt;sys/shm.h&gt;</CODE></P>
     <P><CODE>void *shmat(int <EM>shmid,</EM> const void <EM>*shmaddr,</EM> int <EM>flag</EM>);</CODE></P>
     <P><CODE>/* Возвращает начальный адрес полученной области в случае успешного завершения. –1 –в случае ошибки */</CODE></P>
     <P>Аргумент <EM>shmid —</EM> это идентификатор разделяемой памяти, возвращенный shmget. Функция shmat возвращает адрес начала области разделяемой памяти в адресном пространстве вызвавшего процесса. Правила, по которым формируется этот адрес, таковы:</P>
     <P>■ если аргумент <EM>shmaddr</EM> представляет собой нулевой указатель, система сама выбирает начальный адрес для вызвавшего процесса. Это рекомендуемый (и обеспечивающий наилучшую совместимость) метод;</P>
     <P>■ если <EM>shmaddr</EM> отличен от нуля, возвращаемый адрес зависит от того, был ли указан флаг SHM_RND (в аргументе <EM>flag</EM> ):</P>
     <P> □ если флаг SHM_RND не указан, разделяемая память подключается непосредственно с адреса, указанного аргументом <EM>shmaddr,</EM></P>
     <P> □ если флаг SHM_RND указан, сегмент разделяемой памяти подключается с адреса, указанного аргументом <EM>shmaddr,</EM> округленного вниз до кратного константе SHMLBA. Аббревиатура LBA означает lower boundary address — нижний граничный адрес.</P>
     <P>По умолчанию сегмент подключается для чтения и записи, если процесс обладает соответствующими разрешениями. В аргументе <EM>flag</EM> можно указать константу SHM_RDONLY, которая позволит установить доступ только на чтение.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label646 style="border:none;"></a>14.4. Функция shmdt</P>
     </H1>
     <P>После завершения работы с сегментом разделяемой памяти его следует отключить вызовом shmdt:</P>
     <P><CODE>#include &lt;sys/shm.h&gt;</CODE></P>
     <P><CODE>int shmdt(const void <EM>*shmaddr</EM>);</CODE></P>
     <P><CODE>/* Возвращает 0 в случае успешного завершения, –1 – в случае ошибки */</CODE></P>
     <P>При завершении работы процесса все сегменты, которые не были отключены им явно, отключаются автоматически.</P>
     <P>Обратите внимание, что эта функция не удаляет сегмент разделяемой памяти. Удаление осуществляется функцией shmctl с командой IPC_RMIO.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label647 style="border:none;"></a>14.5. Функция shmctl</P>
     </H1>
     <P>Функция shmctl позволяет выполнять различные операции с сегментом разделяемой памяти:</P>
     <P><CODE>#include &lt;sys/shm.h&gt;</CODE></P>
     <P><CODE>int shmctl(int <EM>shmid,</EM> int <EM>and,</EM> struct shmid_ds <EM>*buff</EM>);</CODE></P>
     <P><CODE>/* Возвращает 0 в случае успешного завершения, –1 в случае ошибки */</CODE></P>
     <P>Команд (значений аргумента <EM>cmd)</EM> может быть три:</P>
     <P>■ IPC_RMID — удаление сегмента разделяемой памяти с идентификатором <EM>shmid</EM> из системы;</P>
     <P>■ IPC_SET — установка значений полей структуры shmid_ds для сегмента разделяемой памяти равными значениям соответствующих полей структуры, на которую указывает аргумент <EM>buff:</EM> shm_perm.uid, shm_perm.gid, shm_perm.mode. Значение поля shm_ctime устанавливается равным текущему системному времени;</P>
     <P>■ IPC_STAT — возвращает вызывающему процессу (через аргумент <EM>buff)</EM> текущее значение структуры shmid_ds для указанного сегмента разделяемой памяти.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label648 style="border:none;"></a>14.6. Простые программы</P>
     </H1>
     <DIV class=section>
      <P>В этом разделе приведено несколько примеров простых программ, иллюстрирующих работу с разделяемой памятью System V.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label649 style="border:none;"></a>Программа shmget</P>
      </H1>
      <P>Программа shmget, текст которой приведен в листинге 14.1,<A HREF="#n_1" onmouseover="ShowBookNote('n_1')" onmouseout="HideBookNote('n_1')"><SUP>[1]</SUP></A> создает сегмент разделяемой памяти, принимая из командной строки полное имя и длину сегмента.</P>
      <H2><a name=label650 style="border:none;"></a>Листинг 14.1. Создание сегмента разделяемой памяти System V указанного размера</H2>
      <P><CODE>//svshm/shmget.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int c, id, oflag;</CODE></P>
      <P><CODE>6   char *ptr;</CODE></P>
      <P><CODE>7   size_t length;</CODE></P>
      <P><CODE>8   oflag = SVSHM_MODE | IPC_CREAT;</CODE></P>
      <P><CODE>9   while ((c = Getopt(argc, argv, "e")) != –1) {</CODE></P>
      <P><CODE>10   switch (c) {</CODE></P>
      <P><CODE>11   case 'e':</CODE></P>
      <P><CODE>12    oflag |= IPC_EXCL;</CODE></P>
      <P><CODE>13    break;</CODE></P>
      <P><CODE>14   }</CODE></P>
      <P><CODE>15  }</CODE></P>
      <P><CODE>16  if (optind != argc – 2)</CODE></P>
      <P><CODE>17   err_quit("usage: shmget [ –e ] &lt;pathname&gt; &lt;length&gt;");</CODE></P>
      <P><CODE>18  length = atoi(argv[optind + 1]);</CODE></P>
      <P><CODE>19  id = Shmget(Ftok(argv[optind], 0), length, oflag);</CODE></P>
      <P><CODE>20  ptr = Shmat(id, NULL, 0);</CODE></P>
      <P><CODE>21  exit(0);</CODE></P>
      <P><CODE>22 }</CODE></P>
      <P>19 Вызов shmget создает сегмент разделяемой памяти указанного размера. Полное имя, передаваемое в качестве аргумента командной строки, преобразуется в ключ IPC System V вызовом ftok. Если указан параметр –е, наличие существующего сегмента с тем же именем приведет к возвращению ошибки. Если мы знаем, что сегмент уже существует, в командной строке должна быть указана нулевая длина.</P>
      <P>20 Вызов shmat подключает сегмент к адресному пространству процесса. После этого программа завершает работу. Разделяемая память System V обладает поменьшей мере живучестью ядра, поэтому сегмент разделяемой памяти при этом не удаляется.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label651 style="border:none;"></a>Программа shmrmid</P>
      </H1>
      <P>В листинге 14.2 приведен текст тривиальной программы shmrmid, которая вызывает shmctl с командой IPC_RMID для удаления сегмента разделяемой памяти из системы.</P>
      <H2><a name=label652 style="border:none;"></a>Листинг 14.2. Удаление сегмента разделяемой памяти system V из системы</H2>
      <P><CODE>//svshm/shmrmid.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int id;</CODE></P>
      <P><CODE>6   if (argc != 2)</CODE></P>
      <P><CODE>7    err_quit("usage: shmrmid &lt;pathname&gt;");</CODE></P>
      <P><CODE>8   id = Shmget(Ftok(argv[1], 0), 0, SVSHM_MODE);</CODE></P>
      <P><CODE>9   Shmctl(id, IPC_RMID, NULL);</CODE></P>
      <P><CODE>10  exit(0);</CODE></P>
      <P><CODE>11 }</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label653 style="border:none;"></a>Программа shmwrite</P>
      </H1>
      <P>В листинге 14.3 приведен текст программы shmwrite, которая заполняет сегмент разделяемой памяти последовательностью значений 0, 1, 2, …, 254, 255, 0, 1 и т. д. </P>
      <H2><a name=label654 style="border:none;"></a>Листинг 14.3. Заполнение сегмента разделяемой памяти последовательностью чисел</H2>
      <P><CODE>//svshm/shmwrite.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int i, id;</CODE></P>
      <P><CODE>6   struct shmid_ds buff;</CODE></P>
      <P><CODE>7   unsigned char *ptr;</CODE></P>
      <P><CODE>8   if (argc != 2)</CODE></P>
      <P><CODE>9    err_quit("usage: shmwrite &lt;pathname&gt;");</CODE></P>
      <P><CODE>10  id = Shmget(Ftok(argv[1], 0), 0, SVSHM_MODE);</CODE></P>
      <P><CODE>11  ptr = Shmat(id, NULL, 0);</CODE></P>
      <P><CODE>12  Shmctl(id, IPC_STAT, &amp;buff);</CODE></P>
      <P><CODE>13  /* присваиваем: ptr[0] = 0, ptr[1] = 1 и т. д. */</CODE></P>
      <P><CODE>14  for (i = 0; i &lt; buff.shm_segsz; i++)</CODE></P>
      <P><CODE>15   *ptr++ = i % 256;</CODE></P>
      <P><CODE>16  exit(0);</CODE></P>
      <P><CODE>17 }</CODE></P>
      <P>10-12 Сегмент разделяемой памяти открывается вызовом shmget и подключается вызовом shmat. Его размер может быть получен вызовом shmctl с командой IPC_STAT.</P>
      <P>13-15 В разделяемую память записывается последовательность значений.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label655 style="border:none;"></a>Программа shmread</P>
      </H1>
      <P>Программа shmread, текст которой приведен в листинге 14.4, проверяет последовательность значений, записанную в разделяемую память программой shmwrite.</P>
      <H2><a name=label656 style="border:none;"></a>Листинг 14.4. Проверка значений в сегменте разделяемой памяти</H2>
      <P><CODE>//svshm/shmread.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int i, id;</CODE></P>
      <P><CODE>6   struct shmid_ds buff;</CODE></P>
      <P><CODE>7   unsigned char c, *ptr;</CODE></P>
      <P><CODE>8   if (argc != 2)</CODE></P>
      <P><CODE>9    err_quit("usage: shmread &lt;pathname&gt;");</CODE></P>
      <P><CODE>10  id = Shmget(Ftok(argv[1], 0), 0, SVSHM_MODE);</CODE></P>
      <P><CODE>11  ptr = Shmat(id, NULL, 0);</CODE></P>
      <P><CODE>12  Shmctl(id, IPC_STAT, &amp;buff);</CODE></P>
      <P><CODE>13  /* проверка значений ptr[0] = 0, ptr[1] = 1 и т. д. */</CODE></P>
      <P><CODE>14  for (i = 0; i &lt; buff.shm_segsz; i++)</CODE></P>
      <P><CODE>15   if ((c = *ptr++) != (i % 256))</CODE></P>
      <P><CODE>16    err_ret("ptr[%d] = %d", i.e);</CODE></P>
      <P><CODE>17  exit(0);</CODE></P>
      <P><CODE>18 }</CODE></P>
      <P>10-12 Открываем и подключаем сегмент разделяемой памяти. Его размер может быть получен вызовом shmctl с командой IPC_STAT. 13-16 Проверяется последовательность, записанная программой shmwrite.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label657 style="border:none;"></a>Примеры</P>
      </H1>
      <P>Создадим сегмент разделяемой памяти длиной 1234 байта в системе Solaris 2.6. Для идентификации сегмента используем полное имя нашего исполняемого файла shmget. Это имя будет передано функции ftok. Имя исполняемого файла сервера часто используется в качестве уникального идентификатора для данного приложения:</P>
      <P><CODE>solaris % <STRONG>shmget shmget 1234</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>ipcs –bmo</STRONG></CODE></P>
      <P><CODE>IPC status from &lt;running system&gt; as of Thu Jan 8 13:17:06 1998</CODE></P>
      <P><CODE>T ID KEY        MODE       OWNER    GROUP  NATTCH SEGSZ</CODE></P>
      <P><CODE>Shared Memory:</CODE></P>
      <P><CODE>m 1  0x0000f12a –rw-r--r-- rstevens other1 0      1234</CODE></P>
      <P>Программу ipcs мы запускаем для того, чтобы убедиться, что сегмент разделяемой памяти действительно был создан и не был удален по завершении программы shmcreate. Количество подключений (хранящееся в поле shm_nattch структуры shmid_ds) равно нулю, как мы и предполагали.</P>
      <P>Теперь запустим пpoгрaммy shmwrite, чтобы заполнить содержимое разделяемой памяти последовательностью значений. Затем проверим содержимое сегмента разделяемой памяти программой shmread и удалим этот сегмент:</P>
      <P><CODE>solaris % <STRONG>shmwrite shmget</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>shmread shmget</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>shmrmid shmget</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>ipes –bmo</STRONG></CODE></P>
      <P><CODE>IPC status from &lt;running system&gt; as of Thu Jan 8 13:17:06 1998</CODE></P>
      <P><CODE>T ID KEY        MODE       OWNER    GROUP  NATTCH SEGSZ</CODE></P>
      <P><CODE>Shared Memory:</CODE></P>
      <P>Мы используем программу ipcs, чтобы убедиться, что сегмент разделяемой памяти действительно был удален.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>При использовании имени исполняемого файла сервера в качестве аргумента ftok для идентификации какого-либо вида IPC System V обычно передается полное имя этого файла (например, /usr/bin/myserverd), а не часть имени, как сделано у нас (shmget). У нас не возникло проблем в этом примере, потому что все программы запускались из того же каталога, в котором был расположен исполняемый файл сервера. Вы помните, что функция ftok использует номер i-node файла для формирования ключа IPC и ей безразлично, определяется файл своим полным именем или его частью (относительным именем). </P>
      </DIV>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label658 style="border:none;"></a>14.7. Ограничения, накладываемые на разделяемую память</P>
     </H1>
     <DIV class=section>
      <P>На разделяемую память System V накладываются определенные ограничения точно так же, как и на семафоры и очереди сообщений System V (раздел 3.8). В табл. 14.1 приведены значения этих ограничений для разных реализаций. В первом столбце приведены традиционные для System V имена переменных ядра, в которых хранятся эти ограничения.</P>
      <BR>
      <P>Таблица 14.1. Типичные значения ограничений, накладываемых на разделяемую память System V</P>
      <TABLE>
       <TR ALIGN=left >
        <TH ALIGN=left VALIGN=top >Имя</TH>
        <TH ALIGN=left VALIGN=top >Описание</TH>
        <TH ALIGN=left VALIGN=top >DUnix 4.0B</TH>
        <TH ALIGN=left VALIGN=top >Solaris 2.6</TH>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >shmmax</TD>
        <TD ALIGN=left VALIGN=top >Максимальный размер сегмента в байтах</TD>
        <TD ALIGN=left VALIGN=top >4194304</TD>
        <TD ALIGN=left VALIGN=top >1048576</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >shmmnb</TD>
        <TD ALIGN=left VALIGN=top >Минимальный размер сегмента разделяемой памяти в байтах</TD>
        <TD ALIGN=left VALIGN=top >1</TD>
        <TD ALIGN=left VALIGN=top >1</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >shmmni</TD>
        <TD ALIGN=left VALIGN=top >Максимальное количество идентификаторов разделяемой памяти в системе</TD>
        <TD ALIGN=left VALIGN=top >128</TD>
        <TD ALIGN=left VALIGN=top >100</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >shmseg</TD>
        <TD ALIGN=left VALIGN=top >Максимальное количество сегментов, подключенных к процессу</TD>
        <TD ALIGN=left VALIGN=top >32</TD>
        <TD ALIGN=left VALIGN=top >6</TD>
       </TR>
      </TABLE>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label659 style="border:none;"></a>Пример</P>
      </H1>
      <P>Программа в листинге 14.5 определяет значения четырех ограничений, приведенных в табл. 14.1.</P>
      <H2><a name=label660 style="border:none;"></a>Листинг 14.5. Определение системных ограничений на разделяемую память</H2>
      <P><CODE>//svshm/limits.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #define MAX_NIDS 4096</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int i, j, shmid[MAX_NIDS];</CODE></P>
      <P><CODE>7   void *addr[MAX_NIDS];</CODE></P>
      <P><CODE>8   unsigned long size;</CODE></P>
      <P><CODE>9   /* проверка максимального количества открываемых идентификаторов */</CODE></P>
      <P><CODE>10  for (i = 0; i &lt;= MAX_NIDS; i++) {</CODE></P>
      <P><CODE>11   shmid[i] = shmget(IPC_PRIVATE, 1024, SVSHM_MODE | IPC_CREAT);</CODE></P>
      <P><CODE>12   if (shmid[i]== –1) {</CODE></P>
      <P><CODE>13    printf("%d identifiers open at once\n", i);</CODE></P>
      <P><CODE>14    break;</CODE></P>
      <P><CODE>15   }</CODE></P>
      <P><CODE>16  }</CODE></P>
      <P><CODE>17  for (j = 0; j &lt; i; j++)</CODE></P>
      <P><CODE>18   Shmctl(shmid[j], IPC_RMID, NULL);</CODE></P>
      <P><CODE>19   /* определяем максимальное количество подключаемых сегментов */</CODE></P>
      <P><CODE>20   for (i=0;i &lt;= MAX_NIDS; i++) {</CODE></P>
      <P><CODE>21    shmid[i] = Shmget(IPC_PRIVATE, 1024, SVSHM_MODE | IPC_CREAT);</CODE></P>
      <P><CODE>22    addr[i] = shmat(shmid[i], NULL, 0);</CODE></P>
      <P><CODE>23    if (addr[i] == (void *) –1) {</CODE></P>
      <P><CODE>24     printf("%d shared memory segments attached at once\n", i);</CODE></P>
      <P><CODE>25     Shmctl(shmid[i], IPC_RMID, NULL); /* удаляем неудачно подключенный сегмент */</CODE></P>
      <P><CODE>26     break;</CODE></P>
      <P><CODE>27    }</CODE></P>
      <P><CODE>28   }</CODE></P>
      <P><CODE>29   for (j = 0; j &lt; i; j++) {</CODE></P>
      <P><CODE>30    Shmdt(addr[j]);</CODE></P>
      <P><CODE>31    Shmcfl(shmid[j], IPC_RMID, NULL);</CODE></P>
      <P><CODE>32   }</CODE></P>
      <P><CODE>33   /* проверка минимального размера сегмента */</CODE></P>
      <P><CODE>34   for (size = 1; ; size++) {</CODE></P>
      <P><CODE>35   shmid[0] = shmget(IPC_PRIVATE, size, SVSHM_MODE | IPC_CREAT);</CODE></P>
      <P><CODE>36   if (shmid[0] != –1) { /* выход при успешном создании */</CODE></P>
      <P><CODE>37    printf("minimum size of shared memory segment = %lu\n", size);</CODE></P>
      <P><CODE>38    Shmctl(shmid[0], IPC_RMID, NULL);</CODE></P>
      <P><CODE>39    break;</CODE></P>
      <P><CODE>40   }</CODE></P>
      <P><CODE>41  }</CODE></P>
      <P><CODE>42  /* определение максимального размера сегмента */</CODE></P>
      <P><CODE>43  for (size = 65536; ; size += 4096) {</CODE></P>
      <P><CODE>44   shmid[0] = shmget(IPC_PRIVATE, size, SVSHM_MODE | IPC_CREAT);</CODE></P>
      <P><CODE>45   if (shmid[0] == –1) { /* выход при ошибке */</CODE></P>
      <P><CODE>46    printf("maximum size of shared memory segment = %lu\n", size-4096);</CODE></P>
      <P><CODE>47    break;</CODE></P>
      <P><CODE>48   }</CODE></P>
      <P><CODE>49   Shmctl(shmid[0], IPC_RMID, NULL);</CODE></P>
      <P><CODE>50  }</CODE></P>
      <P><CODE>51  exit(0);</CODE></P>
      <P><CODE>52 }</CODE></P>
      <P>Запустив эту программу в Digital Unix 4.0B, увидим:</P>
      <P><CODE>alpha % <STRONG>limits</STRONG></CODE></P>
      <P><CODE>127 identifiers open at once</CODE></P>
      <P><CODE>32 shared memory segments attached at once</CODE></P>
      <P><CODE>minimum size of shared memory segment = 1</CODE></P>
      <P><CODE>maximum size of shared memory segment = 4194304</CODE></P>
      <P>Причина, по которой в табл. 14.1 приведено значение 128 для числа идентификаторов, а наша программа выводит значение 127, заключается в том, что один сегмент разделяемой памяти всегда используется системным демоном.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label661 style="border:none;"></a>14.8. Резюме</P>
     </H1>
     <P>Разделяемая память System V похожа на разделяемую память Posix. Наиболее схожи функции:</P>
     <P>■ shmget для получения идентификатора; </P>
     <P>■ shmat для подключения сегмента разделяемой памяти к адресному пространству процесса;</P>
     <P>■ shmctl с командой IPC_STAT для получения размера существующего сегмента разделяемой памяти;</P>
     <P>■ shmctl с командой IPC_RMID для удаления объекта разделяемой памяти.</P>
     <P>Одно из отличий состоит в том, что размер объекта разделяемой памяти Posix может быть изменен в любой момент вызовом ftruncate (как мы продемонстрировали в упражнении 13.1), тогда как размер объекта разделяемой памяти System V устанавливается изначально вызовом shmget и не может быть изменен.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label662 style="border:none;"></a>Упражнение</P>
     </H1>
     <P>Листинг 6.6 содержал измененную версию программы из листинга 6.4. Новая программа использовала для обращения к объекту IPC System V идентификатор вместо полного имени. Таким образом мы показали, что для доступа к очереди сообщений System V достаточно знать только ее идентификатор (если у нас имеются соответствующие разрешения). Сделайте аналогичные изменения в программе из листинга 14.4, продемонстрировав, что это верно и для разделяемой памяти System V. </P>
    </DIV>
   </DIV>
  </DIV>
  <DIV class=section>
   <H1>
    <P><a name=label663 style="border:none;"></a>ЧАСТЬ 5</P>
    <P>УДАЛЕННЫЙ ВЫЗОВ ПРОЦЕДУР</P>
   </H1>
   <DIV class=section>
    <H1>
     <P><a name=label664 style="border:none;"></a>ГЛАВА 15</P>
     <P>Двери</P>
    </H1>
    <DIV class=section>
     <H1>
      <P><a name=label665 style="border:none;"></a>15.1. Введение</P>
     </H1>
     <DIV class=section>
      <P>Поговорим о схеме клиент-сервер и вызове процедур. Существуют три различных типа вызова процедур, показанные на рис. 15.1.</P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader220" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 15.1. Три типа вызова процедур</P>
      <BR>
      <P>1. Локальный вызов процедуры (local procedure call) знаком нам по обычному программированию на языке С. Вызываемая и вызывающая процедуры (функции) при этом относятся к одному и тому же процессу. При этом обычно выполняется некая команда процессора, передающая управление новой процедуре, а вызвавшая процедура сохраняет значение регистров процессора и выделяет место в стеке Под свои локальные переменные.</P>
      <P>2. Удаленный вызов процедуры (remote procedure call — RPC) происходит в ситуации, когда вызвавшая и вызываемая процедуры относятся к разным процессам. В такой ситуации мы обычно называем вызвавшую процедуру клиентом, а вызванную — сервером. Во втором сценарии на рис. 15.1 клиент и сервер выполняются на одном и том же узле. Это типичный частный случай третьего сценария, и это именно то, что осуществляется с помощью дверей (doors). Итак, двери дают возможность вызывать процедуру (функцию) другого процесса на том же узле. Один из процессов (сервер) делает процедуру, находящуюся внутри него, доступной для вызова другим процессам (клиентам), создавая для этой процедуры дверь. Мы можем считать двери специальным типом IPC, поскольку при этом между процессами (клиентом и сервером) передается информация в форме аргументов функции и возвращаемых значений.</P>
      <P>3. RPC в общем случае дает возможность клиенту на одном узле вызвать процедуру сервера на другом узле, если эти два узла связаны каким-либо образом по сети (третий сценарий на рис. 15.1). Такой вид взаимодействия будет описан в главе 16.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Впервые двери были разработаны для распределенной операционной системы Spring. Детали этого проекта доступны по адресу http://www.sun.com/tech/projects/spring. Описание механизма дверей в этой операционной системе можно найти в книге [7].</P>
       <P>Затем двери появились в версии Solaris 2.5, хотя единственная страница документации, к ним относящаяся, содержала только предупреждение о том, что двери являются экспериментальным интерфейсом, используемым отдельными приложениями Sun. В Solaris 2.6 описание этого интерфейса занимает уже 8 страниц, но в них он характеризуется как «развивающийся». В будущих версиях Solaris 2.6 описываемый в этой главе интерфейс API может быть изменен. Предварительная версия дверей для Linux уже разрабатывается, детали можно выяснить по адресу http://www.cs.brown.edu/~tor/doors.</P>
       <P>Чтобы воспользоваться интерфейсом дверей в Solaris 2.6, нужно подключить соответствующую библиотеку (-ldoor), содержащую функции door_XXX, описываемые в этой главе, и использовать файловую систему ядра (/kernel/sys/doorfs).</P>
       <P>Хотя двери поддерживаются только в системе Solaris, мы описываем их достаточно подробно, поскольку это описание позволяет подготовить читателя к удаленному вызову процедур без необходимости обсуждать какие-либо детали сетевого интерфейса. В приложении А мы увидим, что этот интерфейс достаточно быстр — едва ли не быстрее, чем все остальные средства передачи сообщений.</P>
      </DIV>
      <P>Локальные вызовы процедур являются синхронными (synchronous): вызывающий процесс не получает управление до тех пор, пока не происходит возврат из вызванной процедуры. Потоки могут восприниматься как средство асинхронного вызова процедур: функция (указанная в третьем аргументе pthread_create) выполняется одновременно с вызвавшим процессом. Вызвавший процесс может ожидать завершения вызванного процесса с помощью функции pthread_join. Удаленный вызов процедур может быть как синхронным, так и асинхронным, но мы увидим, что вызовы через двери являются синхронными.</P>
      <P>Внутри процесса двери идентифицируются дескрипторами. Извне двери могут идентифицироваться именами в файловой системе. Сервер создает дверь вызовом door_create; аргументом этой функции является указатель на процедуру, которая будет связана с данной дверью, а возвращаемое значение является дескриптором двери. Затем сервер связывает полное имя файла с дескриптором двери с помощью функции fattach. Клиент открывает дверь вызовом open, при этом аргументом функции является полное имя файла, которое сервер связал с дверью, а возвращаемым значением — дескриптор, который будет использоваться клиентом для доступа к двери. Затем клиент может вызывать процедуру с помощью door_call. Естественно, программа, являющаяся сервером для некоторой двери, может являться клиентом для другой.</P>
      <P>Мы уже сказали, что вызовы через двери являются синхронными: когда клиент вызывает door_call, возврата из этой функции не происходит до тех пор, пока процедура на сервере не завершит работу (возможно, с ошибкой). Реализация дверей в Solaris связана с потоками. Каждый раз, когда клиент вызывает процедуру сервера, для обработки этого вызова создается новый поток в процессе-сервере. Работа с потоками обычно осуществляется автоматически функциями библиотеки дверей, при этом потоки создаются по мере необходимости, но мы увидим, что сервер может и сам управлять этими потоками, если это требуется. Это также означает, что одна и та же процедура может выполняться сервером для нескольких клиентов, причем для каждого из них будет создан отдельный поток. Такой сервер является параллельным. Поскольку одновременно могут выполняться несколько экземпляров процедуры сервера (каждая из которых представляет собой отдельный поток), содержимое этих процедур должно соответствовать определенным требованиям, которые обычно предъявляются к многопоточным программам.</P>
      <P>При удаленном вызове процедуры и данные, и дескрипторы могут быть переданы от клиента к серверу. Обратно также могут быть переданы данные и дескрипторы. Передача дескрипторов вообще является неотъемлемым свойством дверей. Более того, поскольку двери идентифицируются дескрипторами, это позволяет процессу передать дверь другому процессу. Более подробно о передаче дескрипторов будет говориться в разделе 15.8.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label666 style="border:none;"></a>Пример</P>
      </H1>
      <P>Начнем описание интерфейса дверей с простого примера: клиент передает серверу длинное целое, а сервер возвращает клиенту квадрат этого значения тоже как длинное целое. В листинге 15.1<A HREF="#n_1" onmouseover="ShowBookNote('n_1')" onmouseout="HideBookNote('n_1')"><SUP>[1]</SUP></A> приведен текст программы-клиента (в этом примере мы опускаем множество деталей, большую часть которых мы обсудим далее в тексте главы).</P>
      <H2><a name=label667 style="border:none;"></a>Листинг 15.1 .Клиент передает серверу длинное целое для возведения его в квадрат</H2>
      <P><CODE>//doors/client1.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int fd;</CODE></P>
      <P><CODE>6   long ival, oval;</CODE></P>
      <P><CODE>7   door_arg_t arg;</CODE></P>
      <P><CODE>8   if (argc != 3)</CODE></P>
      <P><CODE>9    err_quit("usage: client1 &lt;server-pathname&gt; &lt;integer-value&gt;");</CODE></P>
      <P><CODE>10  fd = Open(argv[1], O_RDWR); /* открываем дверь */</CODE></P>
      <P><CODE>11  /* задаем аргументы и указатель на результат */</CODE></P>
      <P><CODE>12  ival = atol(argv[2]);</CODE></P>
      <P><CODE>13  arg.data_ptr = (char *) &amp;ival; /* аргументы */</CODE></P>
      <P><CODE>14  arg.data_size = sizeof(long); /* размер аргументов */</CODE></P>
      <P><CODE>15  arg.desc_ptr = NULL;</CODE></P>
      <P><CODE>16  arg.desc_num = 0;</CODE></P>
      <P><CODE>17  arg.rbuf = (char *) &amp;oval; /* результат */</CODE></P>
      <P><CODE>18  arg.rsize = sizeof(long); /* размер результата */</CODE></P>
      <P><CODE>19  /* вызываем процедуру на сервере и выводим результат */</CODE></P>
      <P><CODE>20  Door_call(fd, &amp;arg);</CODE></P>
      <P><CODE>21  printf("result: %ld\n", oval);</CODE></P>
      <P><CODE>22  exit(0);</CODE></P>
      <P><CODE>23 }</CODE></P>
      <H2><a name=label668 style="border:none;"></a>Открываем дверь</H2>
      <P>8-10 Дверь задается полным именем, передаваемым в качестве аргумента командной строки. Она открывается вызовом open. Возвращаемый дескриптор называется дескриптором двери, но часто его самого и называют дверью.</P>
      <H2><a name=label669 style="border:none;"></a>Подготовка аргументов и указателя на результат</H2>
      <P>11-18 Структура arg содержит указатели на аргументы и результат. Поле data_ptr указывает на первый байт аргументов, a data_size содержит количество байтов в аргументах. Два поля desc_ptr и desc_num предназначены для передачи дескрипторов, о чем мы будем подробно говорить в разделе 15.8. rbuf указывает на первый байт буфера результата, a rsize задает его размер.</P>
      <H2><a name=label670 style="border:none;"></a>Вызов процедуры на сервере и вывод результата</H2>
      <P>19-21 Мы вызываем процедуру на сервере с помощью door_call; аргументами этого вызова являются дескриптор двери и указатель на структуру аргументов. После возвращения из этого вызова программа печатает получившийся результат.</P>
      <P>Программа-сервер приведена в листинге 15.2. Она состоит из процедуры сервера с именем servproc и функции main.</P>
      <H2><a name=label671 style="border:none;"></a>Листинг 15.2. Сервер, возводящий длинное целое в квадрат</H2>
      <P><CODE>//doors/server1.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  void</CODE></P>
      <P><CODE>3  servproc(void *cookie, char *dataptr, size_t datasize,</CODE></P>
      <P><CODE>4   door_desc_t *descptr, size_t ndesc)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   long arg, result;</CODE></P>
      <P><CODE>7   arg = *((long *) dataptr);</CODE></P>
      <P><CODE>8   result = arg * arg;</CODE></P>
      <P><CODE>9   Door_return((char *) &amp;result, sizeof(result), NULL, 0);</CODE></P>
      <P><CODE>10 }</CODE></P>
      <BR>
      <P><CODE>11 int</CODE></P>
      <P><CODE>12 main(int argc, char **argv)</CODE></P>
      <P><CODE>13 {</CODE></P>
      <P><CODE>14  int fd;</CODE></P>
      <P><CODE>15  if (argc != 2)</CODE></P>
      <P><CODE>16   err_quit("usage: server1 &lt;server-pathname&gt;");</CODE></P>
      <P><CODE>17  /* создание двери и связывание ее с файлом */</CODE></P>
      <P><CODE>18  fd = Door_create(servproc, NULL, 0);</CODE></P>
      <P><CODE>19  unlink(argv[1]);</CODE></P>
      <P><CODE>20  Close(Open(argv[1], O_CREAT | O_RDWR, FILE_MODE));</CODE></P>
      <P><CODE>21  Fattach(fd, argv[1]);</CODE></P>
      <P><CODE>22  /* функция servproc() обрабатывает все запросы клиентов */</CODE></P>
      <P><CODE>23  for (;;)</CODE></P>
      <P><CODE>24   pause();</CODE></P>
      <P><CODE>25 }</CODE></P>
      <H2><a name=label672 style="border:none;"></a>Процедура сервера</H2>
      <P>2-10 Процедура сервера вызывается с пятью аргументами, но мы используем только один из них — dataptr. Он указывает на первый байт аргумента. Аргумент, представляющий собой длинное целое, передается через этот указатель и возводится в квадрат. Управление передается клиенту вместе с результатом вызовом door_return. Первый аргумент указывает на результат, второй задает его размер, а оставшиеся предназначены для возврата дескрипторов.</P>
      <H2><a name=label673 style="border:none;"></a>Создание дескриптора двери и связывание с ним файла</H2>
      <P>17-21 Дескриптор двери создается вызовом door_create. Первый аргумент является указателем на функцию, соответствующую этой двери (servproc). После получения этого дескриптора его нужно связать с некоторым именем в файловой системе, поскольку оно будет использоваться клиентом для подключения к этой двери. Делается это путем создания обычного файла в файловой системе (сначала мы вызываем unlink, на тот случай, если такой файл уже существует, причём возможная ошибка игнорируется) и вызова fattach — функции SVR4, связывающей дескриптор с полным именем файла.</P>
      <H2><a name=label674 style="border:none;"></a>Главный поток сервера ничего не делает</H2>
      <P>22-24 Главный поток сервера блокируется при вызове pause. Вся функциональность обеспечивается функцией servproc, которая будет запускаться как отдельный поток каждый раз при получении запроса клиента.</P>
      <P>Запустим сервер в отдельном окне:</P>
      <P><CODE>solaris % <STRONG>server1 /tmp/server1</STRONG></CODE></P>
      <P>После этого запустим пpoгрaммy-клиeнт в другом окне, указав в качестве аргумента то же полное имя, которое было указано при вызове сервера:</P>
      <P><CODE>solaris % <STRONG>client1 /tmp/server19</STRONG></CODE></P>
      <P><CODE>result: 81</CODE></P>
      <P><CODE>solaris % <STRONG>ls -l /tmp/server1</STRONG></CODE></P>
      <P><CODE>Drw-r-r– 1 rstevens other1 0 Apr 9 10:09 /tmp/server1</CODE></P>
      <P>Мы получили ожидаемый результат. Вызвав ls, мы видим, что эта пpoгрaммa выводит букву D в начале строки, соответствующей файлу, указывая, что этот файл является дверью.</P>
      <P>На рис. 15.2 приведена диaгрaммa работы данного примера. Функция door_call вызывает процедуру на сервере, которая затем вызывает door_return для возврата.</P>
      <P>На рис. 15.3 приведена диaгрaммa, показывающая, что в действительности происходит при вызове процедуры в другом процессе на том же узле.</P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader223" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 15.2. Внешний вид вызова процедуры в другом процессе</P>
      <BR>
      <P>На рис. 15.3 выполняются следующие действия:</P>
      <P>0. Запускается сервер, вызывает door_create, чтобы создать дескриптор для функции servproc, затем связывает этот дескриптор с именем файла в файловой системе.</P>
      <P>1. Запускается клиент и вызывает door_call. Это функция в библиотеке дверей.</P>
      <P>2. Библиотечная функция door_call делает системный вызов. При этом указывается процедура, которая должна быть выполнена, а управление передается функции из библиотеки дверей процесса-сервера.</P>
      <P>3. Вызывается процедура сервера (servproc в данном примере).</P>
      <P>4. Процедура сервера делает все необходимое для обработки запроса клиента и вызывает door_return по завершении работы.</P>
      <P>5. Библиотечная функция door_return осуществляет системный вызов, передавая управление ядру.</P>
      <P>6. В этом вызове указывается процесс-клиент, которому и передается управление.</P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader225" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 15.3. Что в действительности происходит при вызове процедуры в другом процессе</P>
      <BR>
      <P>Последующие разделы этой главы описывают интерфейс дверей (doors API) более подробно, с множеством примеров. В приложении А мы убедимся, что двери представляют собой наиболее быструю форму IPC (при измерении времени ожидания).</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label675 style="border:none;"></a>15.2. Функция door_call</P>
     </H1>
     <P>Функция door_call вызывается клиентом для обращения к процедуре сервера, выполняемой в адресном пространстве процесса-сервера:</P>
     <P><CODE>#include &lt;door.h&gt;</CODE></P>
     <P><CODE>int door_call(int <EM>fd,</EM> door_arg_t <EM>*argp</EM>);</CODE></P>
     <P><CODE>/* Возвращает 0 в случае успешного завершения. –1 – в случае ошибки */</CODE></P>
     <P>Дескриптор <EM>fd</EM> обычно возвращается функцией open (см. листинг 15.1). Полное имя файла, открываемого клиентом, однозначно идентифицирует процедуру сервера, которая вызывается door_call при передаче дескриптора.</P>
     <P>Второй аргумент — <EM>argp</EM> — указывает на структуру, описывающую аргументы и приемный буфер для возвращаемых значений:</P>
     <P><CODE>typedef struct door_arg {</CODE></P>
     <P><CODE> char *data_ptr; /* при вызове указывает на аргументы, при возврате – на результаты */</CODE></P>
     <P><CODE> size_t data_size; /* при вызове определяет общий размер аргументов в байтах, при возврате – общий размер возвращаемых данных в байтах */</CODE></P>
     <P><CODE> door_desc_t *desc_ptr; /* при вызове указывает на аргументы-дескрипторы, при возврате указывает на возвращаемые дескрипторы */</CODE></P>
     <P><CODE> size_t desc_num; /* при вызове задает количество аргументов-дескрипторов, при возврате задает количество возвращаемых дескрипторов */</CODE></P>
     <P><CODE> char *rbuf; /* указатель на буфер результатов */</CODE></P>
     <P><CODE> size_t rsize; /* размер буфера результатов */ </CODE></P>
     <P><CODE>} door_arg_t;</CODE></P>
     <P>При возврате из удаленного вызова эта структура описывает возвращаемые значения. Все поля структуры могут быть изменены при возврате, мы подробно рассмотрим это ниже.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Использование типа char* для двух указателей кажется странным и требует использования явного преобразования типов для предотвращения вывода предупреждений компилятора. Естественно было бы использовать указатели типа void*. С указателями char* мы еще столкнемся в функции door_return. Вероятно, в Solaris 2.7 тип данных desc_num изменится на unsigned int и последний аргумент door_return изменится соответствующим образом.</P>
     </DIV>
     <P>Аргументы и результаты могут быть двух типов: данные и дескрипторы.</P>
     <P>■ Аргументы-данные представляют собой последовательность данных длиной data_size байт. На эту последовательность должен указывать data_ptr. Клиент и сервер должны заранее знать формат этих данных (и аргументов, и результатов). Нет способа указать серверу тип аргументов. В пpoгрaммax листингов 15.1 и 15.2 клиент и сервер были написаны таким образом, что они оба знали, что аргумент представлял собой одно длинное целое и возвращаемый результат также был одним длинным целым. Для скрытия внутреннего устройства передаваемых данных их можно объединить в структуру, что упростит работу тому, кто будет читать код несколько лет спустя. Итак, все аргументы можно заключить в одну структуру, результаты — в другую и обе их определить в одном заголовочном файле, используемом клиентом и сервером. Пример будет приведен в листингах 15.8 и 15.9. Если аргументов-данных нет, указатель data_ptr должен быть нулевым и размер данных data_size должен иметь значение 0.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Поскольку клиент и сервер работают с аргументами и результатами, помещаемыми в соответствующие буферы, компилировать их следует одним и тем же компилятором, поскольку разные компиляторы могут по-разному упорядочивать данные в структурах даже в одной и той же системе.</P>
     </DIV>
     <P>■ Аргументы-дескрипторы хранятся в массиве структур door_desc_t, каждая из которых содержит один передаваемый от клиента серверу дескриптор. Количество структур типа door_desc_t задается аргументом desc_num. (Мы описываем эту структуру и смысл «передачи дескриптора» в разделе 15.8.) Если аргументов-дескрипторов нет, следует передать нулевой указатель desc_ptr и присвоить полю desc_num значение 0.</P>
     <P>■ При возврате из функции data_ptr указывает на результаты-данные, a data_size задает размер возвращаемых данных. Если никакие данные не возвращаются, data_size будет иметь значение 0, а значение указателя data_ptr следует игнорировать.</P>
     <P>■ Функция может возвращать и дескрипторы, при этом desc_ptr указывает на массив структур типа door_desc_t, каждая из которых содержит один передаваемый сервером клиенту дескриптор. Количество возвращаемых структур типа door_desc_t хранится в поле desc_num. Если дескрипторы не возвращаются, значение desc_num будет равно 0, а указатель desc_ptr следует игнорировать.</P>
     <P>Можно спокойно использовать один и тот же буфер для передаваемых аргументов и возвращаемых результатов. При вызове door_call и data_ptr, и desc_ptr могут указывать на буфер, указанный аргументом rbuf.</P>
     <P>Перед вызовом door_call клиент устанавливает указатель rbuf на буфер для результатов, a rsize делает равным размеру буфера. После возвращения из функции и data_ptr, и desc_ptr будут указывать на этот буфер. Если он слишком мал для хранения результатов, возвращаемых сервером, библиотека дверей автоматически выделит новый буфер в адресном пространстве клиента с помощью mmap (раздел 12.2) и обновит значения rbuf и rsize соответствующим образом. Поля data_ptr и desc_ptr будут указывать на новый буфер. Клиент отвечает за то, чтобы обнаружить изменение этих указателей и впоследствии освободить занимаемую память вызовом munmap с аргументами rbuf и rsize. Пример будет приведен в листинге 15.4.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label676 style="border:none;"></a>15.3. Функция door_create</P>
     </H1>
     <P>Процесс-сервер определяет некоторую функцию как процедуру сервера вызовом door_create:</P>
     <P><CODE>#include &lt;door.h&gt;</CODE></P>
     <P><CODE>typedef void Door_server_proc(void <EM>*cookie,</EM> char <EM>*dataptr,</EM> size_t <EM>datasize, </EM>door_desc_t <EM>*descptr,</EM> size_t <EM>ndesc</EM>);</CODE></P>
     <P><CODE>int door_create(Door_server_proc <EM>*proc,</EM> void <EM>*cookie,</EM> u_int <EM>attr</EM>);</CODE></P>
     <P><CODE>/* Возвращает неотрицательный дескриптор в случае успешного завершения, –1 –в случае ошибки */</CODE></P>
     <P>Здесь мы добавили наше собственное определение типа, что упрощает прототип функции. Это определение утверждает, что процедуры сервера (например, servproc в листинге 15.2) вызываются с пятью аргументами и ничего не возвращают.</P>
     <P>Когда сервер вызывает door_create, первый аргумент <EM>(proc)</EM> указывает адрес процедуры сервера, которая будет вызываться через дескриптор двери, возвращаемый этим вызовом. При вызове процедуры сервера ее аргумент <EM>cookie</EM> содержит значение, передаваемое в качестве второго аргумента door_create. Это дает серверу возможность передавать процедуре какой-либо указатель каждый раз, когда эта процедура вызывается клиентом. Следующих четыре аргумента процедуры сервера — <EM>dataptr, datasize, descptr</EM> и <EM>ndesc</EM> — описывают аргументы-данные и аргументы-дескрипторы клиента. Они соответствуют первым четырем полям структуры door_arg_t, описанной в предыдущем разделе.</P>
     <P>Последний аргумент door_create(attr) описывает специальные атрибуты процедуры сервера и может быть равен либо 0, либо логической сумме двух констант:</P>
     <P>■ DOOR_PRIVATE — библиотека дверей автоматически создает новые потоки в процессе-сервере при поступлении запросов от клиентов. По умолчанию эти потоки помещаются в пул потоков и могут использоваться для обслуживания запросов клиентов по всем дверям данного процесса.</P>
     <P>Указание атрибута DOOR_PRIVATE говорит библиотеке, что для данной двери следует создать собственный пул потоков, отдельный от пула потоков процесса.</P>
     <P>■ DOOR_UNREF — когда количество дескрипторов, открытых для данной двери, изменяется с двух до одного, процедура сервера вызывается со вторым аргументом, имеющим значение DOOR_UNREF_DATA. При этом аргумент descptr представляет собой нулевой указатель, а аргументы datasize и ndesc равны нулю. Мы приведем пример использования этого атрибута в листинге 15.13.</P>
     <P>Возвращаемое сервером значение имеет тип void, поскольку процедура сервера никогда не завершает работу вызовом return. Вместо этого процедура должна вызывать door_return (функция описана в следующем разделе).</P>
     <P>В листинге 15.2 мы видели, что после получения дескриптора двери вызовом door_create сервер должен вызвать fattach для связывания этого дескриптора с некоторым файлом. Клиент затем может открыть этот файл для получения дескриптора двери, который впоследствии может быть использован при вызове door_call.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Функция fattach не включена в стандарт Posix.1, но ее наличие требуется стандартом Unix 98. Кроме того, этот стандарт определяет также функцию fdetach, отключающую связь дескриптора и файла, и программу fdetach, вызывающую эту функцию.</P>
     </DIV>
     <P>Для дескрипторов дверей, создаваемых door_create, устанавливается бит FD_CLOEXEC. Это означает, что дескриптор закрывается при вызове процессом функций типа exec. Что касается вызова fork, несмотря на то что открытые родительским процессом дескрипторы используются дочерним процессом совместно с ним, только родительский процесс будет принимать вызовы от клиентов. Дочерним процессам вызовы не передаются, хотя дескриптор, возвращаемый door_create, и будет в них открыт.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Если мы учтем, что дверь идентифицируется с помощью PID и адреса процедуры сервера (что мы узнаем из структуры door_info_t в разделе 15.6), ограничения на вызовы exec и fork станут понятны. Дочерний процесс не будет принимать вызовов, поскольку его идентификатор процесса отличается от идентификатора, связанного с дверью. Дескриптор должен быть закрыт при вызове exec, потому что хотя идентификатор при этом и не меняется, адрес процедуры сервера уже не будет иметь никакого смысла в той программе, которая будет запущена после вызова exec.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label677 style="border:none;"></a>15.4. Функция door_return</P>
     </H1>
     <P>После завершения работы процедуры сервера возврат из нее осуществляется вызовом door_return. Это приводит к возврату из door_call соответствующего клиента. </P>
     <P><CODE>#include &lt;door.h&gt;</CODE></P>
     <P><CODE>int door_return(char <EM>*dataptr,</EM> size_t <EM>datasize,</EM> door_desc_t <EM>*descptr,</EM> size_t <EM>ndesc</EM>);</CODE></P>
     <P><CODE>/* Ничего не возвращает вызвавшему процессу в случае успешного завершения. –1 – в случае ошибки */</CODE></P>
     <P>Возвращаемые данные задаются аргументами <EM>dataptr</EM> и <EM>datasize,</EM> а возвращаемые дескрипторы — <EM>descptr</EM> и <EM>ndesc.</EM></P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label678 style="border:none;"></a>15.5. Функция door_cred</P>
     </H1>
     <P>Интерфейс дверей предусматривает полезную возможность получения информации о клиенте при каждом вызове. Это осуществляется функцией door_cred:</P>
     <P><CODE>#include &lt;door.h&gt;</CODE></P>
     <P><CODE>int door_cred(door_cred_t <EM>*cred</EM>);</CODE></P>
     <P><CODE>/* Возвращает 0 в случае успешного завершения, –1 – в случае ошибки */</CODE></P>
     <P>Структура, на которую указывает аргумент <EM>cred,</EM> имеет тип door_cred_t, определяемый как</P>
     <P><CODE>typedef struct door_cred {</CODE></P>
     <P><CODE> uid_t dc_euid; /* действующий идентификатор пользователя клиента */</CODE></P>
     <P><CODE> gid_t dc_egid; /* действующий идентификатор группы клиента */</CODE></P>
     <P><CODE> uid_t dc_ruid; /* реальный идентификатор пользователя клиента */</CODE></P>
     <P><CODE> gid_t dc_rgid; /* реальный идентификатор группы клиента */</CODE></P>
     <P><CODE> pid_t dc_pid; /* идентификатор процесса клиента */</CODE></P>
     <P><CODE>} door_cred_t;</CODE></P>
     <P>В эту структуру помещается информация о клиенте при возвращении из вызова door_cred. В разделе 4.4 [21] подробно рассказывается о различиях между действующими и реальными идентификаторами пользователя и группы, а пример использования этой функции приведен в листинге. 15.5.</P>
     <P>Обратите внимание, что эта функция не принимает никаких дескрипторов. Она возвращает информацию о клиенте, осуществившем конкретный вызов через дверь, и поэтому должна вызываться из процедуры сервера или другой функции, вызываемой из процедуры сервера.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label679 style="border:none;"></a>15.6. Функция door_info</P>
     </H1>
     <P>Только что описанная функция door_cred предоставляет серверу информацию о клиенте. Клиент же может получить информацию о сервере, вызвав doo_info:</P>
     <P><CODE>#include &lt;door.h&gt;</CODE></P>
     <P><CODE>int door_info(int <EM>fd,</EM> door_info_t <EM>*info</EM>);</CODE></P>
     <P><CODE>/* Возвращает 0 в случае успешного завершения, –1 – в случае ошибки */</CODE></P>
     <P>Дескриптор <EM>fd</EM> указывает на открытую дверь. Структура типа door_info_t, на которую указывает <EM>info,</EM> после возвращения из функции содержит информацию о сервере:</P>
     <P><CODE>typedef struct doo_info {</CODE></P>
     <P><CODE> pid_t di_target; /* идентификатор процесса сервера */</CODE></P>
     <P><CODE> door_ptr_t di_proc; /* процедура сервера */</CODE></P>
     <P><CODE> door_ptr_t di_data; /* принимаемые процедурой сервера данные */</CODE></P>
     <P><CODE> door_attr_t di_attributes; /* атрибуты, связанные с данной дверью */</CODE></P>
     <P><CODE> door_id_t di_uniquifier; /* уникальный номер двери */</CODE></P>
     <P><CODE>} door info t;</CODE></P>
     <P>Поле di_target содержит идентификатор процесса сервера, a di_proc — адрес процедуры сервера в процессе (от которого клиенту, вообще говоря, пользы мало). Указатель, передаваемый процедуре сервера в качестве первого аргумента <EM>(cookie),</EM> возвращается клиенту в поле di_data.</P>
     <P>Текущие атрибуты двери помещаются в поле di_attributes, и два из них уже были описаны в разделе 15.3. Это атрибуты DOOR_PRIVATE и DOOR_UNREF. Два других атрибута называются DOOR_LOCAL (процедура является локальной для данного процесса) и DOOR_REVOKE (сервер аннулировал процедуру, связанную с этой дверью, вызвав door_revoke).</P>
     <P>Каждой двери при создании сопоставляется уникальный в пределах системы номер, который возвращается в поле di_uniquifier.</P>
     <P>Эта функция обычно вызывается клиентом для получения информации о сервере. Однако она может быть вызвана и из процедуры сервера, причем первым аргументом в этом случае должна быть константа DOOR_QUERY. Тогда функция возвратит информацию о вызвавшем потоке, то есть о данном экземпляре процедуры сервера. В этом случае адреса процедуры сервера и принимаемых аргументов (di_proc и di_data) могут представлять интерес.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label680 style="border:none;"></a>15.7. Примеры</P>
     </H1>
     <DIV class=section>
      <P>В этом разделе мы приведем примеры использования пяти только что описанных функций.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label681 style="border:none;"></a>Функция door_info</P>
      </H1>
      <P>В листинге 15.3 приведен текст программы, открывающей дверь и вызывающей door_infо для получения информации об этой двери, которая затем выводится на экран.</P>
      <H2><a name=label682 style="border:none;"></a>Листинг 15.3. Вывод информации о двери</H2>
      <P><CODE>//doors/doorinfo.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int fd;</CODE></P>
      <P><CODE>6   struct stat stat;</CODE></P>
      <P><CODE>7   struct door_info info;</CODE></P>
      <P><CODE>8   if (argc != 2)</CODE></P>
      <P><CODE>9    err_quit("usage; doorinfo &lt;pathname&gt;");</CODE></P>
      <P><CODE>10  fd = Open(argv[1], O_RDONLY);</CODE></P>
      <P><CODE>11  Fstat(fd, &amp;stat);</CODE></P>
      <P><CODE>12  if (S_ISDOOR(stat.st_mode) == 0)</CODE></P>
      <P><CODE>13   err_quit("pathname is not a door");</CODE></P>
      <P><CODE>14  Door_info(fd, &amp;info);</CODE></P>
      <P><CODE>15  printf("server PID = %ld, uniquifier = %ld",</CODE></P>
      <P><CODE>16   (long)info.di_target, (long)info.di_uniquifier);</CODE></P>
      <P><CODE>17  if (info.di_attributes &amp; DOOR_LOCAL)</CODE></P>
      <P><CODE>18   printf(", DOOR_LOCAL");</CODE></P>
      <P><CODE>19  if (info.di_attributes &amp; DOOR_PRIVATE)</CODE></P>
      <P><CODE>20   printf(", DOOR_PRIVATE");</CODE></P>
      <P><CODE>21  if (info.di_attributes &amp; DOOR_REVOKED)</CODE></P>
      <P><CODE>22   printf(", DOOR_REVOKED");</CODE></P>
      <P><CODE>23  if (info.di_attributes &amp; DOOR_UNREF)</CODE></P>
      <P><CODE>24   printf(", DOOR_UNREF");</CODE></P>
      <P><CODE>25  printf("\n");</CODE></P>
      <P><CODE>26  exit(0);</CODE></P>
      <P><CODE>27 }</CODE></P>
      <P>Сначала программа открывает файл с указанным полным именем и проверяет, что это действительно дверь. Поле st_mode структуры stat в этом случае должно содержать такое значение, что макрос S_ISDOOR будет возвращать значение «истина». Затем вызывается функция door_info.</P>
      <P>Сначала мы укажем этой программе полное имя файла, не являющегося дверью, а затем попробуем получить информацию о двух встроенных дверях Solaris 2.6:</P>
      <P><CODE>solaris % <STRONG>doorinfo/etc/passwd</STRONG></CODE></P>
      <P><CODE>pathname is not a door</CODE></P>
      <P><CODE>solaris % <STRONG>doorinfo /etc/.name_service_door</STRONG></CODE></P>
      <P><CODE>server PID = 308, uniquifier = 18, DOOR_UNREF</CODE></P>
      <P><CODE>solaris % <STRONG>doorinfo /etc/.syslog_door</STRONG></CODE></P>
      <P><CODE>server PID = 282, uniquifier = 1635</CODE></P>
      <P><CODE>solaris % <STRONG>ps –f -p 308</STRONG></CODE></P>
      <P><CODE>root 308 1 0 Apr 01 ? 0:34 /usr/sbin/nscd</CODE></P>
      <P><CODE>solaris % <STRONG>ps –f -p 282</STRONG></CODE></P>
      <P><CODE>root 282 1 0 Apr 01 ? 0:10 /usr/sbin/syslogd –n –z 14</CODE></P>
      <P>Команду ps мы используем для того, чтобы узнать, какая программа выполняется с идентификатором, возвращаемым door_info.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label683 style="border:none;"></a>Буфер результатов слишком мал</P>
      </H1>
      <P>Когда мы рассказывали о функции door_call, мы отметили, что если буфер результатов оказывается слишком мал, библиотека дверей осуществляет автоматическое выделение нового буфера. Сейчас мы покажем это на примере. В листинге 15.4 приведен текст новой программы-клиента, которая представляет собой измененную версию листинга 15.2.</P>
      <H2><a name=label684 style="border:none;"></a>Листинг 15.4. Вывод адреса полученного результата</H2>
      <P><CODE>//doors/client2.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int fd;</CODE></P>
      <P><CODE>6   long ival, oval;</CODE></P>
      <P><CODE>7   door_arg_t arg;</CODE></P>
      <P><CODE>8   if (argc != 3)</CODE></P>
      <P><CODE>9    err_quit("usage: client2 &lt;server-pathname&gt; &lt;integer-value&gt;");</CODE></P>
      <P><CODE>10  fd = Open(argv[1], O_RDWR); /* открываем дверь */</CODE></P>
      <P><CODE>11  /* подготовка аргументов и указателя на результат */</CODE></P>
      <P><CODE>12  ival = atol(argv[2]);</CODE></P>
      <P><CODE>13  arg.data_ptr = (char *) &amp;ival; /* аргументы-данные */</CODE></P>
      <P><CODE>14  arg.data_size = sizeof(long); /* объем данных */</CODE></P>
      <P><CODE>15  arg.desc_ptr = NULL;</CODE></P>
      <P><CODE>16  arg.desc_num = 0;</CODE></P>
      <P><CODE>17  arg.rbuf = (char *) &amp;oval; /* возвращаемые данные */</CODE></P>
      <P><CODE>18  arg.rsize = sizeof(long); /* объем возвращаемых данных */</CODE></P>
      <P><CODE>19  /* вызов процедуры сервера и вывод результата */</CODE></P>
      <P><CODE>20  Door_call(fd, &amp;arg);</CODE></P>
      <P><CODE>21  printf("&amp;oval = %p, data_ptr = %p, rbuf = %p, rsize = %d\n",</CODE></P>
      <P><CODE>22   &amp;oval, arg.data_ptr, arg.rbuf, arg.rsize);</CODE></P>
      <P><CODE>23  printf("result: %ld\n", *((long *) arg.data_ptr));</CODE></P>
      <P><CODE>24  exit(0);</CODE></P>
      <P><CODE>25 }</CODE></P>
      <P>19-22 В этой версии программы на экран выводится адрес переменной oval, содержимое указателя data_ptr, который должен указывать на возвращаемые функцией door_call данные, и адрес и размер приемного буфера (rbuf и rsize).</P>
      <P>Запустим эту программу, не изменяя размер приемного буфера по сравнению с листингом 15.2. Мы ожидаем, что data_ptr и rbuf будут указывать на переменную oval и rsize будет иметь значение 4 (4 байта в буфере). И действительно, вот что мы видим:</P>
      <P><CODE>solaris % <STRONG>client2 /tmp/server2 22</STRONG></CODE></P>
      <P><CODE>&amp;oval = effff740, data_ptr = effff740, rbuf = effff740, rsize = 4</CODE></P>
      <P><CODE>result: 484</CODE></P>
      <P>Изменим только одну строку в листинге 15.4, уменьшив размер буфера клиента до одного байта. Новый вариант строки 18 будет иметь вид:</P>
      <P><CODE>arg.rsize = sizeof(long) – 1; /* размер буфера данных */</CODE></P>
      <P>Запустим новую программу и увидим, что библиотека автоматически выделила место под новый буфер результатов и data_ptr теперь указывает на новый буфер:</P>
      <P><CODE>solaris % <STRONG>client3 /tmp/server3 33</STRONG></CODE></P>
      <P><CODE>&amp;oval = effff740, data_ptr = ef620000, rbuf = ef620000, rsize = 4096</CODE></P>
      <P><CODE>result: 1089</CODE></P>
      <P>Размер выделенного буфера равен 4096 байт, что совпадает с размером страницы в данной системе, который мы узнали в разделе 12.6. Этот пример показывает, что следует всегда обращаться к результатам через указатель data_ptr, а не через переменные, адреса которых были переданы в rbuf. В нашем примере к результату типа «длинное целое» следует обращаться как *(long*)arg.data_ptr, а не oval (что мы делали в листинге 15.2).</P>
      <P>Новый буфер выделяется вызовом mmap и может быть возвращен системе с помощью munmap. Клиент может повторно использовать этот буфер при новых вызовах door_call.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label685 style="border:none;"></a>Функция door_cred и информация о клиенте</P>
      </H1>
      <P>На этот раз мы изменим нашу функцию servproc из листинга 15.3, добавив в нее вызов door_cred для получения информации о пользователе. В листинге 15.5 приведен текст новой процедуры сервера; функции main клиента и сервера не претерпевают изменений по сравнению с листингами 15.2 и 15.3.</P>
      <H2><a name=label686 style="border:none;"></a>Листинг 15.5. Процедура сервера, получающая информацию о клиенте</H2>
      <P><CODE>//doors/server4.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  void</CODE></P>
      <P><CODE>3  servproc(void *cookie, char *dataptr, size_t datasize,</CODE></P>
      <P><CODE>4   door_desc_t *descptr, size_t ndesc)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   long arg, result;</CODE></P>
      <P><CODE>7   door_cred_t info;</CODE></P>
      <P><CODE>8   /* получение и вывод информации о клиенте */</CODE></P>
      <P><CODE>9   Door_cred(&amp;info);</CODE></P>
      <P><CODE>10  printf("euid = %ld, ruid = %ld, pid = %ld\n",</CODE></P>
      <P><CODE>11  (long) info.dc_euid, (long) info.dc_ruid, (long) info.dc_pid);</CODE></P>
      <P><CODE>12  arg = *((long *) dataptr);</CODE></P>
      <P><CODE>13  result = arg * arg;</CODE></P>
      <P><CODE>14  Door_return((char *) &amp;result, sizeof(result), NULL, 0);</CODE></P>
      <P><CODE>15 }</CODE></P>
      <P>Сначала мы запустим программу-клиент и увидим, что действующий и реальный идентификаторы клиента совпадают, как мы и предполагали. Затем мы сменим владельца исполняемого файла на привилегированного пользователя, установим бит SUID и запустим программу снова:</P>
      <P><CODE>solaris % <STRONG>client4 /tmp/server4 77 </STRONG><EM>первый запуск клиента</EM></CODE></P>
      <P><CODE>result: 5929</CODE></P>
      <P><CODE>solaris % <STRONG>su                      </STRONG><EM>вход под именем привилегированного пользователя</EM></CODE></P>
      <P><CODE>Password:</CODE></P>
      <P><CODE>Sun Microsystems Inc. Sun OS 5.6 Generic August 1997</CODE></P>
      <P><CODE>solaris # <STRONG>cd                     </STRONG><EM>каталог, в котором находится исполняемый файл</EM></CODE></P>
      <P><CODE>solaris # <STRONG>ls –l client4</STRONG></CODE></P>
      <P><CODE>-rwxrwxr-x 1 rstevens other1 139328 Apr 13 06:02 client4</CODE></P>
      <P><CODE>solaris # <STRONG>chown root client4     </STRONG><EM>смена владельца на привилегированного пользователя</EM></CODE></P>
      <P><CODE>solaris # <STRONG>chmod u+s client4      </STRONG><EM>включение бита SUID</EM></CODE></P>
      <P><CODE>solaris # <STRONG>ls -l client4           </STRONG><EM>проверка разрешений и владельца файла</EM></CODE></P>
      <P><CODE>-rwsrwxr-x 1 root     other1 139328 Apr 13 06:02 client4</CODE></P>
      <P><CODE>solaris # <STRONG>exit</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>ls -l client4</STRONG></CODE></P>
      <P><CODE>-rwsrwxr-x 1 root     other1 139328 Apr 13 06:02 client4</CODE></P>
      <P><CODE>solaris % <STRONG>client4 /tmp/server477 </STRONG><EM>и еще раз запускаем программу-клиент</EM></CODE></P>
      <P><CODE>result: 5929</CODE></P>
      <P>Если мы посмотрим, что в это время выводил сервер, то увидим следующую картину:</P>
      <P><CODE>solaris % <STRONG>server4 /tmp/server4</STRONG></CODE></P>
      <P><CODE>euid = 224, ruid = 224, pid = 3168</CODE></P>
      <P><CODE>euid = 0, ruid = 224, pid = 3176</CODE></P>
      <P>Действующий идентификатор пользователя при втором запуске изменился. Значение 0 означает привилегированного пользователя.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label687 style="border:none;"></a>Автоматическое управление потоками сервера</P>
      </H1>
      <P>Чтобы посмотреть, как осуществляется управление потоками сервера, добавим в процедуру сервера команду выдачи ее идентификатора потока. Добавим в нее также пятисекундную паузу, чтобы имитировать длительное выполнение. За это время мы сможем запустить несколько клиентов. В листинге 15.6 приведен текст новой процедуры сервера.</P>
      <H2><a name=label688 style="border:none;"></a>Листинг 15.6. Процедура сервера, выводящая идентификатор потока</H2>
      <P><CODE>//doors/server5.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  void</CODE></P>
      <P><CODE>3  servproc(void *cookie, char *dataptr, size_t datasize,</CODE></P>
      <P><CODE>4   door_desc_t *descptr, size_t ndesc)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   long arg, result;</CODE></P>
      <P><CODE>7   arg = *((long *) dataptr);</CODE></P>
      <P><CODE>8   printf("thread id %ld, arg = %ld\n", pr_thread_id(NULL), arg);</CODE></P>
      <P><CODE>9   sleep(5);</CODE></P>
      <P><CODE>10  result = arg * arg;</CODE></P>
      <P><CODE>11  Door_return((char*)&amp;result, sizeof(result), NULL, 0);</CODE></P>
      <P><CODE>12 }</CODE></P>
      <P>Здесь используется новая функция из нашей библиотеки — pr_thread_id. Она принимает один аргумент (указатель на идентификатор потока или нулевой указатель вместо идентификатора вызвавшего потока) и возвращает идентификатор этого потока (обычно небольшое целое число, но всегда в формате длинного целого). Процессу всегда можно сопоставить целое число — его идентификатор. Хотя мы и не знаем, к какому типу принадлежит идентификатор процесса (int или long), мы просто преобразуем значение, возвращаемое getpid, к типу long и выводим значение (листинг 9.2). Однако идентификатор потока принадлежит к типу pthread_t, который не обязательно является одним из целых типов. И действительно, в Solaris 2.6 идентификаторами потоков являются короткие целые, тогда как в Digital Unix используются указатели. Однако часто возникает необходимость сопоставлять потокам небольшие целые числа для задач отладки (как в данном примере). Наша библиотечная функция, текст которой приведен в листинге 15.7, решает этот вопрос.</P>
      <H2><a name=label689 style="border:none;"></a>Листинг 15.7. Функция pr_thread_id: возвращает небольшой целочисленный идентификатор потока</H2>
      <P><CODE>//lib/wrappthread.c</CODE></P>
      <P><CODE>245 long</CODE></P>
      <P><CODE>246 pr_thread_id(pthread_t *ptr)</CODE></P>
      <P><CODE>247 {</CODE></P>
      <P><CODE>248 #if defined(sun)</CODE></P>
      <P><CODE>249  return((ptr == NULL) ? pthread_self() : *ptr); /* Solaris */</CODE></P>
      <P><CODE>250 #elif defined(__osf__) &amp;&amp; defined(__alpha)</CODE></P>
      <P><CODE>251  pthread_t tid;</CODE></P>
      <P><CODE>252  tid = (ptr == NULL) ? pthread_self() : *ptr; /* Digital Unix */</CODE></P>
      <P><CODE>253  return(pthread_getsequence_np(tid));</CODE></P>
      <P><CODE>254 #else</CODE></P>
      <P><CODE>255  /* прочие системы */</CODE></P>
      <P><CODE>256  return((ptr == NULL) ? pthread_self() : *ptr);</CODE></P>
      <P><CODE>257 #endif</CODE></P>
      <P><CODE>258 }</CODE></P>
      <P>Если в данной реализации идентификатор потока не является небольшим целым числом, функция может быть сложнее. Она может осуществлять отображение значений типа pthread_t в целые числа и сохранять эти отображения для последующих вызовов в массиве или связном списке. Эта задача решена в функции thread_name в книге [13].</P>
      <P>Вернемся к программе из листинга 15.6. Запустим ее три раза подряд. Поскольку нам приходится ждать возвращения подсказки интерпретатора, чтобы запустить клиент еще раз, мы можем быть уверены, что каждый раз выполняется пятисекундная пауза:</P>
      <P><CODE>solaris % <STRONG>client5 /tmp/server5 55</STRONG></CODE></P>
      <P><CODE>result: 3025</CODE></P>
      <P><CODE>solaris % <STRONG>client5 /tmp/server5 66</STRONG></CODE></P>
      <P><CODE>result: 4356</CODE></P>
      <P><CODE>solaris % <STRONG>client5 /tmp/server5 77</STRONG></CODE></P>
      <P><CODE>result: 5929</CODE></P>
      <P>Взглянув на текст, выводимый сервером, мы увидим, что клиенты каждый раз обслуживались одним и тем же потоком сервера:</P>
      <P><CODE>solaris % <STRONG>server5 /tmp/server5</STRONG></CODE></P>
      <P><CODE>thread id 4, arg = 55</CODE></P>
      <P><CODE>thread id 4, arg = 66</CODE></P>
      <P><CODE>thread id 4, arg = 77</CODE></P>
      <P>Теперь запустим три экземпляра программы-клиента одновременно:</P>
      <P><CODE>solaris % <STRONG>client5 /tmp/server5 11 &amp; client5 /tmp/server5 22 &amp; client5 /tmp/server5 33 &amp;</STRONG></CODE></P>
      <P><CODE>[2] 3812</CODE></P>
      <P><CODE>[3] 3813</CODE></P>
      <P><CODE>[4] 3814</CODE></P>
      <P><CODE>solaris % result: 484</CODE></P>
      <P><CODE>result: 121</CODE></P>
      <P><CODE>result: 1089</CODE></P>
      <P>Выводимый сервером текст показывает, что для обработки второго и третьего вызова процедуры сервера создаются новые потоки:</P>
      <P><CODE>thread id 4, arg = 22</CODE></P>
      <P><CODE>thread id 5, arg = 11</CODE></P>
      <P><CODE>thread id 6, arg = 33</CODE></P>
      <P>Затем мы запустим еще два клиента одновременно (первые три уже завершили работу):</P>
      <P><CODE>solaris % <STRONG>client5 /tmp/server5 11 &amp; client5 /tmp/server5 22 &amp;</STRONG></CODE></P>
      <P><CODE>[2] 3830</CODE></P>
      <P><CODE>[3] 3831</CODE></P>
      <P><CODE>solaris % result: 484</CODE></P>
      <P><CODE>result: 121</CODE></P>
      <P>При этом сервер использует созданные ранее потоки:</P>
      <P><CODE>thread id 6, arg = 22</CODE></P>
      <P><CODE>thread id 5, arg = 11</CODE></P>
      <P>Этот пример показывает, что серверный процесс (то есть библиотека дверей, подключенная к нему) автоматически создает потоки серверных процедур по мере необходимости. Если приложению требуется контроль над созданием потоков, оно может его осуществить с помощью функций, описанных в разделе 15.9.</P>
      <P>Мы также убедились, что сервер в этом случае является параллельным (concurrent): одновременно может выполняться несколько экземпляров процедуры сервера в виде отдельных потоков для обслуживания клиентов. Это следует также из того, что результат работы сервера выводится тремя экземплярами клиента одновременно пять секунд спустя после их одновременного запуска. Если бы сервер был последовательным, первый результат появился бы через 5 секунд после запуска, следующий — через 10, а последний — через 15.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label690 style="border:none;"></a>Автоматическое управление потоками сервера: несколько процедур</P>
      </H1>
      <P>В предыдущем примере процесс-сервер содержал лишь одну процедуру сервера. Вопрос, которым мы займемся теперь, звучит так: могут ли несколько процедур одного процесса использовать один и тот же пул потоков сервера? Чтобы узнать ответ, добавим к нашему серверу еще одну процедуру, а заодно перепишем наши программы заново, чтобы продемонстрировать более приличный стиль передачи аргументов и результатов между процессами.</P>
      <P>Первый файл в этом примере называется squareproc.h. В нем определен один тип данных для входных аргументов функции, возводящей в квадрат, и еще один — для возвращаемых ею результатов. В этом заголовочном файле также определяется полное имя двери для данной процедуры. Его текст его приведен в листинге 15.8.</P>
      <H2><a name=label691 style="border:none;"></a>Листинг 15.8. Заголовочный файл squareproc.h</H2>
      <P><CODE>//doors/squareproc.h</CODE></P>
      <P><CODE>1 #define PATH_SQUARE_DOOR "/tmp/squareproc_door"</CODE></P>
      <BR>
      <P><CODE>2 typedef struct { /* аргументы squareproc() */</CODE></P>
      <P><CODE>3  long arg1;</CODE></P>
      <P><CODE>4 } squareproc_in_t;</CODE></P>
      <BR>
      <P><CODE>5 typedef struct { /* возврат squareproc() */</CODE></P>
      <P><CODE>6  long res1;</CODE></P>
      <P><CODE>7 } squareproc_out_t;</CODE></P>
      <P>Наша новая процедура будет принимать длинное целое и возвращать квадратный корень из него (типа double). Мы определяем полное имя двери этой процедуры, структуры аргументов и результатов в заголовочном файле sqrtproc.h в листинге 15.9.</P>
      <H2><a name=label692 style="border:none;"></a>Листинг 15.9. Заголовочный файл sqrtproc.h</H2>
      <P><CODE>//doors/sqrtproc.h</CODE></P>
      <P><CODE>1 #define PATH_SQRT_DOOR "/tmp/sqrtproc_door"</CODE></P>
      <BR>
      <P><CODE>2 typedef struct { /* входные данные sqrtproc() */</CODE></P>
      <P><CODE>3  long arg1;</CODE></P>
      <P><CODE>4 } sqrtproc_in_t;</CODE></P>
      <BR>
      <P><CODE>5 typedef struct { /* возвращаемые sqrtproc() данные */</CODE></P>
      <P><CODE>6  double res1;</CODE></P>
      <P><CODE>7 } sqrtproc_out_t;</CODE></P>
      <P>Программа-клиент приведена в листинге 15.10. Она последовательно вызывает две процедуры сервера и выводит возвращаемые ими результаты. Эта программа устроена аналогично другим клиентским программам, приведенным в этой главе.</P>
      <H2><a name=label693 style="border:none;"></a>Листинг 15.10. Клиент, вызывающий две процедуры</H2>
      <P><CODE>//doors/client7.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "squareproc.h"</CODE></P>
      <P><CODE>3  #include "sqrtproc.h"</CODE></P>
      <BR>
      <P><CODE>4  int</CODE></P>
      <P><CODE>5  main(int argc, char **argv)</CODE></P>
      <P><CODE>6  {</CODE></P>
      <P><CODE>7   int fdsquare, fdsqrt;</CODE></P>
      <P><CODE>8   door_arg_t arg;</CODE></P>
      <P><CODE>9   squareproc_in_t square_in;</CODE></P>
      <P><CODE>10  squareproc_out_t square_out;</CODE></P>
      <P><CODE>11  sqrtproc_in_t sqrt_in;</CODE></P>
      <P><CODE>12  sqrtproc_out_t sqrt_out;</CODE></P>
      <P><CODE>13  if (argc != 2)</CODE></P>
      <P><CODE>14   err_quit("usage: client7 &lt;integer-value&gt;");</CODE></P>
      <P><CODE>15  fdsquare = Open(PATH_SQUARE_DOOR, O_ROWR);</CODE></P>
      <P><CODE>16  fdsqrt = Open(PATH_SQRT_DOOR, O_RDWR);</CODE></P>
      <P><CODE>17  /* подготовка аргументов и вызов squareproc() */</CODE></P>
      <P><CODE>18  square_in.arg1 = atol(argv[1]);</CODE></P>
      <P><CODE>19  arg.data_ptr = (char*)&amp;square_in;</CODE></P>
      <P><CODE>20  arg.data_size = sizeof(square_in);</CODE></P>
      <P><CODE>21  arg.desc_ptr = NULL;</CODE></P>
      <P><CODE>22  arg.desc_num = 0;</CODE></P>
      <P><CODE>23  arg.rbuf = (char*)&amp;square_out;</CODE></P>
      <P><CODE>24  arg.rsize = sizeof(square_out);</CODE></P>
      <P><CODE>25  Door_call(fdsquare, &amp;arg);</CODE></P>
      <P><CODE>26  /* подготовка аргументов и вызов sqrtproc() */</CODE></P>
      <P><CODE>27  sqrt_in.arg1 = atol(argv[1]);</CODE></P>
      <P><CODE>28  arg.data_ptr = (char*)&amp;sqrt_in;</CODE></P>
      <P><CODE>29  arg.data_size = sizeof(sqrt_in);</CODE></P>
      <P><CODE>30  arg.desc_ptr = NULL;</CODE></P>
      <P><CODE>31  arg.desc_num = 0;</CODE></P>
      <P><CODE>32  arg.rbuf = (char*)&amp;sqrt_out;</CODE></P>
      <P><CODE>33  arg.rsize = sizeof(sqrt_out);</CODE></P>
      <P><CODE>34  Door_call(fdsqrt, &amp;arg);</CODE></P>
      <P><CODE>35  printf("result: %ld %g\n", square_out.res1, sqrt_out.res1);</CODE></P>
      <P><CODE>36  exit(0);</CODE></P>
      <P><CODE>37 }</CODE></P>
      <P>Текст двух серверных процедур приведен в листинге 15.11. Каждая из них выводит текущий идентификатор потока и значение аргумента, делает 5-секунд-ную паузу, вычисляет результат и завершает работу.</P>
      <H2><a name=label694 style="border:none;"></a>Листинг 15.11. Две процедуры сервера</H2>
      <P><CODE>//doors/server7.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include &lt;math.h&gt;</CODE></P>
      <P><CODE>3  #include "squareproc.h"</CODE></P>
      <P><CODE>4  #include "sqrtproc.h"</CODE></P>
      <BR>
      <P><CODE>5  void</CODE></P>
      <P><CODE>6  squareproc(void *cookie, char *dataptr, size_t datasize,</CODE></P>
      <P><CODE>7   door_desc_t *descptr, size_t ndesc)</CODE></P>
      <P><CODE>8  {</CODE></P>
      <P><CODE>9   squareproc_in_t in;</CODE></P>
      <P><CODE>10  squareproc_out_t out;</CODE></P>
      <P><CODE>11  memcpy(&amp;in, dataptr, min(sizeof(in), datasize));</CODE></P>
      <P><CODE>12  printf("squareproc: thread id %ld, arg = %ld\n",</CODE></P>
      <P><CODE>13   pr_thread_id(NULL), in.arg1);</CODE></P>
      <P><CODE>14  sleep(5);</CODE></P>
      <P><CODE>15  out.res1 = in.arg1 * in.arg1;</CODE></P>
      <P><CODE>16  Door_return((char *) &amp;out, sizeof(out), NULL, 0);</CODE></P>
      <P><CODE>17 }</CODE></P>
      <BR>
      <P><CODE>18 void</CODE></P>
      <P><CODE>19 sqrtproc(void *cookie, char *dataptr, size_t datasize,</CODE></P>
      <P><CODE>20  door_desc_t *descptr, size_t ndesc)</CODE></P>
      <P><CODE>21 {</CODE></P>
      <P><CODE>22  sqrtproc_in_t in;</CODE></P>
      <P><CODE>23  sqrtproc_out_t out;</CODE></P>
      <P><CODE>24  memcpy(&amp;in, dataptr, min(sizeof(in), datasize));</CODE></P>
      <P><CODE>25  printf("sqrtproc: thread id %ld, arg = %ld\n",</CODE></P>
      <P><CODE>26   pr_thread_id(NULL), in.arg1);</CODE></P>
      <P><CODE>27  sleep(5);</CODE></P>
      <P><CODE>28  out.res1 = sqrt((double)in.arg1);</CODE></P>
      <P><CODE>29  Door_return((char *) &amp;out, sizeof(out), NULL, 0);</CODE></P>
      <P><CODE>30 }</CODE></P>
      <P>Функция main сервера, текст которой приведен в листинге 15.12, открывает дескрипторы дверей и связывает каждый из них с одной из процедур сервера.</P>
      <H2><a name=label695 style="border:none;"></a>Листинг 15.12. Функция main сервера</H2>
      <P><CODE>//doors/server7.c</CODE></P>
      <P><CODE>31 int</CODE></P>
      <P><CODE>32 main(int argc, char **argv)</CODE></P>
      <P><CODE>33 {</CODE></P>
      <P><CODE>34  int fd;</CODE></P>
      <P><CODE>35  if (argc != 1)</CODE></P>
      <P><CODE>36   err_quit("usage: server7");</CODE></P>
      <P><CODE>37  fd = Door_create(squareproc, NULL, 0);</CODE></P>
      <P><CODE>38  unlink(PATH_SQUARE_DOOR);</CODE></P>
      <P><CODE>39  Close(Open(PATH_SQUARE_DOOR, O_CREAT | O_RDWR, FILE_MODE));</CODE></P>
      <P><CODE>40  Fattach(fd, PATH_SQUARE_DOOR);</CODE></P>
      <P><CODE>41  fd = Door_create(sqrtproc, NULL, 0);</CODE></P>
      <P><CODE>42  unlink(PATH_SQRT_DOOR);</CODE></P>
      <P><CODE>43  Close(Open(PATH_SQRT_DOOR, O_CREAT | O_RDWR, FILE_MODE));</CODE></P>
      <P><CODE>44  Fattach(fd, PATH_SQRT_DOOR);</CODE></P>
      <P><CODE>45  for (;;)</CODE></P>
      <P><CODE>46   pause();</CODE></P>
      <P><CODE>47 }</CODE></P>
      <P>Запустим программу-клиент и подождем 10 секунд до вывода результатов (как мы и ожидали):</P>
      <P><CODE>solaris % <STRONG>client7 77</STRONG></CODE></P>
      <P><CODE>result: 5929 8.77496</CODE></P>
      <P>Посмотрев на выводимый сервером текст, мы увидим, что один и тот же поток этого процесса использовался для обработки обоих запросов клиента:</P>
      <P><CODE>solaris % <STRONG>server7</STRONG></CODE></P>
      <P><CODE>squareproc: thread id 4, arg = 77</CODE></P>
      <P><CODE>sqrtproc: thread id 4, arg = 77</CODE></P>
      <P>Это подтверждает наши предположения о том, что любой поток из пула сервера может использоваться при обработке запросов клиентов для любой процедуры.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label696 style="border:none;"></a>Атрибут DOOR_UNREF для серверов</P>
      </H1>
      <P>В разделе 15.3 мы отметили, что при вызове door_create для создаваемой двери можно указать атрибут DOOR_UNREF. В документации говорится, что если количество дескрипторов, относящихся к этой двери, уменьшается с двух до одного, осуществляется специальный вызов процедуры сервера. Особенность вызова заключается в том, что второй аргумент процедуры сервера (указатель на данные) при этом является константой DOOR_UNREF_DATA. Мы продемонстрируем три способа обращения к двери.</P>
      <P>1. Дескриптор, возвращаемый door_create, считается первой ссылкой на эту дверь. Вообще говоря, причина, по которой специальный вызов происходит при изменении количества дескрипторов с 2 на 1, а не с 1 на 0, заключается в том, что первый дескриптор обычно не закрывается сервером до завершения работы.</P>
      <P>2. Полное имя, связанное с дверью в файловой системе, также считается ссылкой на дверь. Ее можно удалить вызовом функции fdetach, или запустив программу fdetach, или удалив полное имя из файловой системы (функцией unlink или командой rm).</P>
      <P>3.  Дескриптор, возвращаемый клиенту функцией open, считается открытой ссылкой до тех пор, пока не будет закрыт либо явным вызовом close, либо неявно, при завершении клиента. Во всех примерах этой главы дескриптор закрывается неявно.</P>
      <P>Первый пример показывает, что если сервер закрывает свой дескриптор после вызова fattach, немедленно происходит специальный вызов процедуры сервера. В листинге 15.13 приведен текст процедуры сервера и функции main.</P>
      <H2><a name=label697 style="border:none;"></a>Листинг 15.13. Процедура сервера, обрабатывающая специальный вызов</H2>
      <P><CODE>//doors/serverunref1.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  void</CODE></P>
      <P><CODE>3  servproc(void *cookie, char *dataptr, size_t datasize,</CODE></P>
      <P><CODE>4   door_desc_t *descptr, size_t ndesc)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   long arg, result;</CODE></P>
      <P><CODE>7   if (dataptr == DOOR_UNREF_DATA) {</CODE></P>
      <P><CODE>8    printf("door unreferenced\n");</CODE></P>
      <P><CODE>9    Door_return(NULL, 0, NULL, 0);</CODE></P>
      <P><CODE>10  }</CODE></P>
      <P><CODE>11  arg = *((long*)dataptr);</CODE></P>
      <P><CODE>12  printf("thread id %ld, arg = %ld\n", pr_thread_id(NULL), arg);</CODE></P>
      <P><CODE>13  sleep(6);</CODE></P>
      <P><CODE>14  result = arg * arg;</CODE></P>
      <P><CODE>15  Door_return((char *)&amp;result, sizeof(result), NULL, 0);</CODE></P>
      <P><CODE>16 }</CODE></P>
      <BR>
      <P><CODE>17 int</CODE></P>
      <P><CODE>18 main(int argc, char **argv)</CODE></P>
      <P><CODE>19 {</CODE></P>
      <P><CODE>20  int fd;</CODE></P>
      <P><CODE>21  if (argc != 2)</CODE></P>
      <P><CODE>22   err_quit("usage: server1 &lt;server-pathname&gt;");</CODE></P>
      <P><CODE>23  /* создание дескриптора и связывание с файлом */</CODE></P>
      <P><CODE>24  fd = Door_create(servproc, NULL, DOOR_UNREF);</CODE></P>
      <P><CODE>25  unlink(argv[1]);</CODE></P>
      <P><CODE>26  Close(Open(argv[1], O_CREAT | O_RDWR, FILE_MODE));</CODE></P>
      <P><CODE>27  Fattach(fd, argv[1]);</CODE></P>
      <P><CODE>28  Close(fd);</CODE></P>
      <P><CODE>29  /* процедура servproc() обрабатывает все запросы клиентов */</CODE></P>
      <P><CODE>30  for(;;)</CODE></P>
      <P><CODE>31   pause();</CODE></P>
      <P><CODE>32 }</CODE></P>
      <P>7-10 Процедура сервера распознает специальный вызов и выводит сообщение об этом. Возврат из специального вызова происходит путем вызова door_return с двумя нулевыми указателями и нулевыми значениями размеров.</P>
      <P>28 Теперь мы закрываем дескриптор двери после выполнения fattach. Этот дескриптор может быть нужен серверу только для вызовов door_bind, doo_info и door_revoke.</P>
      <P>Запустив сервер, мы увидим, что немедленно произойдет специальный вызов:</P>
      <P><CODE>solaris % <STRONG>serverunref1 /tmp/door1</STRONG></CODE></P>
      <P><CODE>door unreferenced</CODE></P>
      <P>Если мы проследим за значением счетчика открытых дескрипторов, мы увидим, что он становится равен 1 после возврата из door_create и 2 после возврата из fattach. Вызов close уменьшает количество открытых дескрипторов с двух до одного, что приводит к специальному вызову процедуры. Единственная оставшаяся ссылка при этом представляет собой имя в файловой системе, а этого клиенту достаточно, чтобы обратиться к двери. Поэтому клиент продолжает работать правильно:</P>
      <P><CODE>solaris % <STRONG>clientunref1 /tmp/door1 11</STRONG></CODE></P>
      <P><CODE>result: 121</CODE></P>
      <P><CODE>solaris % <STRONG>clientunref1 /tmp/door1 22</STRONG></CODE></P>
      <P><CODE>result: 484</CODE></P>
      <P>Более того, дальнейших специальных вызовов серверной процедуры не происходит. Для каждой двери осуществляется только один специальный вызов.</P>
      <P>Теперь изменим нашу программу-сервер обратно, убрав вызов close для дескриптора двери. Процедура сервера и функция main приведены в листинге 15.14.</P>
      <H2><a name=label698 style="border:none;"></a>Листинг 15.14. Сервер, не закрывающий дескриптор двери</H2>
      <P><CODE>//doors/serverunref2.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  void</CODE></P>
      <P><CODE>3  servproc(void *cookie. char *dataptr, size_t datasize,</CODE></P>
      <P><CODE>4   door_desc_t *descptr, size_t ndesc)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   long arg, result;</CODE></P>
      <P><CODE>7   if (dataptr == DOOR_UNREF_DATA) {</CODE></P>
      <P><CODE>8    printf("door unreferenced\n");</CODE></P>
      <P><CODE>9    Door_return(NULL, 0, NULL, 0);</CODE></P>
      <P><CODE>10  }</CODE></P>
      <P><CODE>11  arg = *((long *)dataptr);</CODE></P>
      <P><CODE>12  printf("thread id %ld, arg = %ld\n", pr_thread_id(NULL), arg);</CODE></P>
      <P><CODE>13  sleep(6);</CODE></P>
      <P><CODE>14  result = arg * arg;</CODE></P>
      <P><CODE>15  printf("thread id %ld returning\n", pr_thread_id(NULL));</CODE></P>
      <P><CODE>16  Door_return((char *)&amp;result, sizeof(result), NULL, 0);</CODE></P>
      <P><CODE>17 }</CODE></P>
      <BR>
      <P><CODE>18 int</CODE></P>
      <P><CODE>19 main(int argc, char **argv)</CODE></P>
      <P><CODE>20 {</CODE></P>
      <P><CODE>21  int fd;</CODE></P>
      <P><CODE>23  if (argc != 2)</CODE></P>
      <P><CODE>24   err_quit("usage: server1 &lt;server-pathname&gt;");</CODE></P>
      <P><CODE>25  /* создание двери, дескриптора и подключение к файлу */</CODE></P>
      <P><CODE>26  fd = Door_create(servproc, NULL, DOOR_UNREF);</CODE></P>
      <P><CODE>27  unlink(argv[1]);</CODE></P>
      <P><CODE>28  Close(Open(argv[1], O_CREAT | O_RDWR, FILE_MODE));</CODE></P>
      <P><CODE>29  Fattach(fd, argv[1]);</CODE></P>
      <P><CODE>30  /* servproc() обрабатывает все запросы клиентов */</CODE></P>
      <P><CODE>31  for(;;)</CODE></P>
      <P><CODE>32   pause();</CODE></P>
      <P><CODE>33 }</CODE></P>
      <P>Мы оставляем 6-секундную паузу и выводим сообщение о возврате из процедуры сервера. Запустим сервер в одном окне, а из другого проверим существование имени файла двери в файловой системе и удалим его с помощью rm:</P>
      <P><CODE>solaris % <STRONG>ls –l /tmp/door2</STRONG></CODE></P>
      <P><CODE>Drw-r--r-- 1 rstevens other1 0 Apr 16 08:58 /tmp/door2</CODE></P>
      <P><CODE>solaris % <STRONG>rm /tmp/door2</STRONG></CODE></P>
      <P>После удаления имени файла происходит специальный вызов процедуры сервера:</P>
      <P><CODE>solaris % <STRONG>serverunref2 /trap/door2</STRONG></CODE></P>
      <P><CODE>door unreferenced <EM>после удаления файла из файловой системы</EM></CODE></P>
      <P>Если мы проследим за количеством ссылок на эту дверь, то увидим следующее: одна ссылка появляется после вызова door_create, вторая — после fattach. После удаления файла с помощью rm количество ссылок снова уменьшается до единицы, что приводит к специальному вызову процедуры.</P>
      <P>В последнем примере использования этого атрибута мы снова удалим имя из файловой системы. Но на этот раз мы сначала запустим три экземпляра программы-клиента. Специальный вызов процедуры произойдет только после завершения последнего клиента, потому что каждый экземпляр клиента увеличивает количество ссылок на дверь. Используем сервер из листинга 15.14 и клиент из листинга 15.2.</P>
      <P><CODE>solaris % <STRONG>clientunref2 /tmp/door2 44 &amp; clientunref2 /tmp/door2 55 &amp; clientunref2/tmp/door2 55 &amp;</STRONG></CODE></P>
      <P><CODE>[2] 13552</CODE></P>
      <P><CODE>[3] 13553</CODE></P>
      <P><CODE>[4] 13554</CODE></P>
      <P><CODE>solaris % <STRONG>rm /tmp/door2 </STRONG><EM>клиенты все еще выполняются</EM></CODE></P>
      <P><CODE>solaris % result: 1936</CODE></P>
      <P><CODE>result: 3025</CODE></P>
      <P><CODE>result: 4356</CODE></P>
      <P>Сервер при этом выведет вот что:</P>
      <P><CODE>solaris % <STRONG>serverunref2 /tmp/door2</STRONG></CODE></P>
      <P><CODE>thread id 4, arg = 44</CODE></P>
      <P><CODE>thread id 5, arg = 55</CODE></P>
      <P><CODE>thread id 6, arg = 66</CODE></P>
      <P><CODE>thread id 4 returning</CODE></P>
      <P><CODE>thread id 5 returning</CODE></P>
      <P><CODE>thread id 6 returning</CODE></P>
      <P><CODE>door unreferenced</CODE></P>
      <P>Проследим за значением счетчика открытых ссылок для этой двери. Он становится равным 1 после вызова door_create, 2 после вызова fattach. Когда три клиента вызывают open, счетчик увеличивается с 2 до 5. После удаления имени файла счетчик уменьшается до 4. После завершения работы трех клиентов счетчик уменьшается с 4 до 1 (последовательно), и последнее его изменение с 2 до 1 приводит к специальному вызову процедуры.</P>
      <P>Этими примерами мы показали, что хотя описание атрибута DOOR_UNREF выглядит просто («специальный вызов происходит при изменении счетчика ссылок с 2 до 1»), мы должны понимать принципы работы этого счетчика, чтобы им пользоваться.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label699 style="border:none;"></a>15.8. Передача дескрипторов</P>
     </H1>
     <P>Когда мы говорим о передаче открытого дескриптора от одного процесса другому, обычно подразумевается одно из двух:</P>
     <P>■ наследование всех открытых дескрипторов родительского процесса дочерним после вызова fork;</P>
     <P>■ сохранение открытых дескрипторов при вызове exec.</P>
     <P>В первом случае процесс открывает дескриптор, вызывает fork, а затем родительский процесс закрывает дескрипторы, предоставляя дочернему возможность работать с ними. При этом открытый дескриптор передается от родительского процесса дочернему.</P>
     <P>В современных версиях Unix возможности передачи дескрипторов существенно расширены, и теперь имеется возможность передавать открытый дескриптор от одного процесса другому вне зависимости от их родства. Двери являются одним из существующих интерфейсов для передачи дескрипторов от клиента серверу и от сервера клиенту.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Передача дескрипторов через доменные сокеты Unix была описана в разделе 14.7 [24]. В ядрах Berkeley и производных от них дескрипторы передаются именно через такие сокеты. Все подробности описаны в главе 18 [23]. В ядрах SVR4 используются другие методы передачи дескрипторов, а именно команды I_SENDFD и I_RECVFD функции ioctl. Они описаны в разделе 15.5.1 [21]. Но процесс в SVR4 может воспользоваться и механизмом доменных сокетов Unix.</P>
     </DIV>
     <P>Нужно правильно понимать, что именно подразумевается под передачей дескриптора. На рис. 4.7 сервер открывал файл и копировал его целиком через нижний (на рисунке) канал. Если размер файла 1 Мбайт, через канал будет передан 1 Мбайт данных. Но если сервер передает клиенту дескриптор вместо самого файла, то через канал передается только дескриптор (который содержит небольшое количество информации ядра). Клиент может использовать этот дескриптор для считывания содержимого файла. Чтение файла при этом осуществляется именно клиентом, а сервер осуществляет только открытие файла.</P>
     <P>Нужно понимать, что сервер не может просто записать в канал числовое значение дескриптора, как в следующем фрагменте кода:</P>
     <P><CODE>int fd;</CODE></P>
     <P><CODE>fd = Open(…);</CODE></P>
     <P><CODE>Write(pipefd, &amp;fd, sizeof(int));</CODE></P>
     <P>Этот подход не работает. Дескрипторы вычисляются для каждого процесса в отдельности. Предположим, что значение дескриптора файла на сервере равно 4. Даже если дескриптор с тем же значением и открыт клиентом, он почти наверняка относится к другому файлу. Единственная ситуация, в которой дескрипторы одного процесса имеют значение для другого процесса, возникает при вызове fork.</P>
     <P>Если первый свободный дескриптор сервера имеет значение 4, вызов open вернет именно это значение. Если сервер передает дескриптор 4 клиенту, а у клиента наименьшее свободное значение дескриптора равно 7, нужно, чтобы дескриптор 7 клиента был установлен в соответствие с тем же файлом, что и дескриптор 4 сервера. Рисунки 15.4 в [21] и 18.4 в [23] иллюстрируют, что должно произойти с точки зрения ядра: два дескриптора (4 у сервера и 7 у клиента) должны указывать на один и тот же файл из таблицы ядра. Интерфейсы типа дверей и доменных сокетов Unix скрывают внутренние детали реализации, предоставляя процессам возможность легко передавать дескрипторы друг другу.</P>
     <P>Дескрипторы передаются через дверь от клиента серверу путем присваивания полю desc_ptr структуры door_arg_t значения указателя на массив структур типа door_desc_t и помещения в поле desc_num количества этих структур. Дескрипторы передаются от сервера клиенту путем присваивания третьему аргументу door_return значения указателя на массив структур door_desc_t и помещения в четвертый аргумент количества передаваемых дескрипторов:</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader228" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 15.4. Сервер файлов, передающий клиенту дескриптор</P>
     <BR>
     <P><CODE>typedef struct door_desc {</CODE></P>
     <P><CODE> door_attr_t d_attributes; /* тег объединения */</CODE></P>
     <P><CODE> union {</CODE></P>
     <P><CODE>  struct { /* верна, если tag = DOOR_DESCRIPTOR */</CODE></P>
     <P><CODE>   int d_descriptor; /* номер дескриптора */</CODE></P>
     <P><CODE>   door_id_t d_id; /* уникальный идентификатор */</CODE></P>
     <P><CODE>  } d_desc;</CODE></P>
     <P><CODE> } d_data;</CODE></P>
     <P><CODE>} door_desc_t;</CODE></P>
     <P>Эта структура содержит объединение (union), и первое поле структуры является тегом, идентифицирующим содержимое этого объединения. В настоящий момент определено только одно поле объединения (структура d_desc, описывающая дескриптор), и тег (d_attributes) должен иметь значение DOOR_DESCRIPTOR.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label700 style="border:none;"></a>Пример</P>
     </H1>
     <P>Изменим наш пример с сервером файлов таким образом, чтобы сервер открывал файл, передавал дескриптор клиенту, а клиент копировал содержимое файла в стандартный поток вывода. На рис. 15.4 приведена схема приложения. В листинге 15.15 приведен текст программы клиента.</P>
     <H2><a name=label701 style="border:none;"></a>Листинг 15.15. Клиент для сервера, передающего дескриптор</H2>
     <P><CODE>//doors/clientfd1.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <BR>
     <P><CODE>2  int</CODE></P>
     <P><CODE>3  main(int argc, char **argv)</CODE></P>
     <P><CODE>4  {</CODE></P>
     <P><CODE>5   int door, fd;</CODE></P>
     <P><CODE>6   char argbuf[BUFFSIZE], resbuf[BUFFSIZE], buff[BUFFSIZE];</CODE></P>
     <P><CODE>7   size_t len, n;</CODE></P>
     <P><CODE>8   door_arg_t arg;</CODE></P>
     <P><CODE>9   if (argc != 2)</CODE></P>
     <P><CODE>10   err_quit("usage: clientfd1 &lt;server-pathname&gt;");</CODE></P>
     <P><CODE>11  door = Open(argv[1], O_RDWR); /* открываем дверь */</CODE></P>
     <P><CODE>12  Fgets(argbuf, BUFFSIZE, stdin); /* считываем полное имя открываемого файла */</CODE></P>
     <P><CODE>13  len = strlen(argbuf);</CODE></P>
     <P><CODE>14  if (argbuf[len-1] == '\n')</CODE></P>
     <P><CODE>15   len--;</CODE></P>
     <P><CODE>16  /* подготавливаем аргумент и указатель на результат */</CODE></P>
     <P><CODE>17  arg.data_ptr = argbuf; /* аргумент-данные */</CODE></P>
     <P><CODE>18  arg.data_size = len + 1; /* размер данных */</CODE></P>
     <P><CODE>19  arg.desc_ptr = NULL;</CODE></P>
     <P><CODE>20  arg.desc_num = 0;</CODE></P>
     <P><CODE>21  arg.rbuf = resbuf; /* результаты-данные */</CODE></P>
     <P><CODE>22  arg.rsize = BUFFSIZE; /* размер возвращаемых данных */</CODE></P>
     <P><CODE>23  Door_call(door, &amp;arg); /* вызов процедуры сервера */</CODE></P>
     <P><CODE>24  if (arg.data_size != 0)</CODE></P>
     <P><CODE>25   err_quit("%.*s", arg.data_size, arg.data_ptr);</CODE></P>
     <P><CODE>26  else if (arg.desc_ptr == NULL)</CODE></P>
     <P><CODE>27   err_quit("desc_ptr is NULL");</CODE></P>
     <P><CODE>28  else if (arg.desc_num != 1)</CODE></P>
     <P><CODE>29   err_quit("desc_num = %d", arg.desc_num);</CODE></P>
     <P><CODE>30  else if (arg.desc_ptr-&gt;d_attributes != DOOR_DESCRIPTOR)</CODE></P>
     <P><CODE>31   err_quit("d_attributes = %d", arg.desc_ptr-&gt;d_attributes);</CODE></P>
     <P><CODE>32  fd = arg.desc_ptr-&gt;d_data.d_desc.d_descriptor;</CODE></P>
     <P><CODE>33  while((n = Read(fd, buff, BUFFSIZE)) &gt; 0)</CODE></P>
     <P><CODE>34   Write(STDOUT_FILENO, buff, n);</CODE></P>
     <P><CODE>35  exit(0);</CODE></P>
     <P><CODE>36 }</CODE></P>
     <H2><a name=label702 style="border:none;"></a>Открываем дверь, считываем полное имя файла</H2>
     <P>9-15 Имя файла, связанного с дверью, принимается в качестве аргумента командной строки. Имя файла, который должен быть открыт и выведен, считывается из стандартного потока ввода, а завершающий символ перевода строки удаляется.</P>
     <H2><a name=label703 style="border:none;"></a>Подготовка аргументов и указателя на буфер возврата</H2>
     <P>16-22 Подготавливается структура door_arg_t. К размеру имени файла мы добавляем единицу, чтобы сервер мог дополнить его завершающим нулем.</P>
     <H2><a name=label704 style="border:none;"></a>Вызов процедуры сервера и проверка результатов</H2>
     <P>23-31 Мы вызываем процедуру сервера и проверяем результат. Должен возвращаться только один дескриптор и никаких данных. Вскоре мы увидим, что сервер возвращает данные (сообщение об ошибке) только в том случае, если он не может открыть файл. В этом случае функция err_quit выводит сообщение об ошибке.</P>
     <H2><a name=label705 style="border:none;"></a>Считывание дескриптора и копирование файла</H2>
     <P>32-34 Дескриптор извлекается из структуры door_desc_t, и файл копируется в стандартный поток вывода.</P>
     <P>В листинге 15.16 приведен текст процедуры сервера. Функция main по сравнению с листингом 15.3 не изменилась.</P>
     <H2><a name=label706 style="border:none;"></a>Листинг 15.16. Процедура сервера, открывающая файл и возвращающая клиенту дескриптор</H2>
     <P><CODE>//doors/serverfd1.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <BR>
     <P><CODE>2  void</CODE></P>
     <P><CODE>3  servproc(void *cookie, char *dataptr, size_t datasize,</CODE></P>
     <P><CODE>4   door_desc_t *descptr, size_t ndesc)</CODE></P>
     <P><CODE>5  {</CODE></P>
     <P><CODE>6   int fd;</CODE></P>
     <P><CODE>7   char resbuf[BUFFSIZE];</CODE></P>
     <P><CODE>8   door_desc_t desc;</CODE></P>
     <P><CODE>9   dataptr[datasize-1] = 0; /* завершающий О */</CODE></P>
     <P><CODE>10  if ((fd = open(dataptr, O_RDONLY)) == –1) {</CODE></P>
     <P><CODE>11   /* ошибка, нужно сообщить клиенту */</CODE></P>
     <P><CODE>12   snprintf(resbuf, BUFFSIZE, "%s: can't open, %s",</CODE></P>
     <P><CODE>13   dataptr, strerror(errno));</CODE></P>
     <P><CODE>14   Door_return(resbuf, strlen(resbuf), NULL, 0);</CODE></P>
     <P><CODE>15  } else {</CODE></P>
     <P><CODE>16   /* ОК, возвращаем дескриптор */</CODE></P>
     <P><CODE>17   desc.d_data.d_desc.d_descriptor = fd;</CODE></P>
     <P><CODE>18   desc.d_attributes = DOOR_DESCRIPTOR;</CODE></P>
     <P><CODE>19   Door_return(NULL, 0, &amp;desc, 1);</CODE></P>
     <P><CODE>20  }</CODE></P>
     <P><CODE>21 }</CODE></P>
     <H2><a name=label707 style="border:none;"></a>Открытие файла для клиента</H2>
     <P>9-14 Мы завершаем полное имя файла клиента нулем и делаем попытку открыть этот файл вызовом open. Если возникает ошибка, сообщение о ней возвращается клиенту.</P>
     <H2><a name=label708 style="border:none;"></a>Успешное открытие файла</H2>
     <P>15-20 Если файл был успешно открыт, клиенту возвращается только его дескриптор.</P>
     <P>Запустим сервер и укажем ему имя двери /tmp/fd1, а затем запустим клиент:</P>
     <P><CODE>solaris % <STRONG>clientfd1 /tmp/fd1</STRONG></CODE></P>
     <P><CODE>/etc/shadow</CODE></P>
     <P><CODE>/etc/shadow: can't open. Permission denied</CODE></P>
     <P><CODE>solaris % <STRONG>clientfd1 /tmp/fd1</STRONG></CODE></P>
     <P><CODE>/no/such/file</CODE></P>
     <P><CODE>/no/such/file: can't open. No such file or directory</CODE></P>
     <P><CODE>solaris % <STRONG>clientfd1 /tmp/fd1</STRONG></CODE></P>
     <P><CODE>/etc/ntp.conf <EM>файл из двух строк</EM></CODE></P>
     <P><CODE>multicastclient 224.0.1.1</CODE></P>
     <P><CODE>driftfile /etc/ntp.drift</CODE></P>
     <P>В первых двух случаях мы указываем имя файла, приводящее к возврату сообщения об ошибке. В третий раз сервер передает клиенту дескриптор файла из двух строк, который благополучно выводится.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Существует проблема, связанная с передачей дескриптора через дверь. Чтобы она проявилась в нашем примере, достаточно добавить вызов printf к процедуре сервера сразу после успешного вызова open. Вы увидите, что значение дескриптора каждый раз увеличивается на единицу. Проблема в том, что сервер не закрывает дескрипторы после передачи их клиенту. Сделать это, вообще говоря, нелегко. Логично было бы выполнять закрытие дескриптора после возврата из door_return, после успешной отправки дескриптора клиенту, но возврата из door_return не происходит! Если бы мы использовали sendmsg для передачи дескриптора через доменный сокет Unix или ioctl для передачи дескриптора через канал в SVR4, мы могли бы закрыть его после возврата из sendmsg или ioctl. Однако с дверьми все по-другому, поскольку возврата из функции door_return не происходит. Единственный способ обойти проблему заключается в том, что процедура сервера должна запоминать все открытые дескрипторы и закрывать их некоторое время спустя, что несколько запутывает код.</P>
      <P>Эта проблема должна быть исправлена в Solaris 2.7 добавлением атрибута DOOR RELEASE. Отправитель устанавливает поле d_attributes равным DOOR DESCRIPTOR | DOOR_RELEASE, что говорит системе о необходимости закрывать дескриптор после передачи его клиенту.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label709 style="border:none;"></a>15.9. Функция door server_create</P>
     </H1>
     <P>В листинге 15.6 мы показали, что библиотека дверей автоматически создает новые потоки для обслуживания запросов клиентов по мере их поступления. Они создаются библиотекой как неприсоединенные потоки (detached threads) с размером стека потока по умолчанию, с отключенной возможностью отмены потока (thread cancellation) и с маской сигналов и классом планирования (scheduling class), унаследованными от потока, вызвавшего door_create. Если мы хотим изменить какой-либо из этих параметров или хотим самостоятельно работать с пулом потоков сервера, можно воспользоваться функцией door_server_create и указать нашу собственную <EM>процедуру создания сервера:</EM></P>
     <P><CODE>#include &lt;door.h&gt;</CODE></P>
     <P><CODE>typedef void Door_create_proc(door_info_t *);</CODE></P>
     <P><CODE>Door_create_proc *door_server_create(Door_create_proc <EM>*proc</EM>);</CODE></P>
     <P><CODE>/* Возвращает указатель на предыдущую процедуру создания сервера */</CODE> </P>
     <P>Как и при объявлении door_create в разделе 15.3, мы используем оператор typedef для упрощения прототипа библиотечной функции. Наш новый тип данных определяет процедуру создания сервера как принимающую один аргумент (указатель на структуру типа door_info_t) и ничего не возвращающую (void). При вызове door_server_create аргументом является указатель на нашу процедуру создания сервера, а возвращается указатель на предыдущую процедуру создания сервера. </P>
     <P>Наша процедура создания сервера вызывается при возникновении необходимости создания нового потока для обслуживания запроса клиента. Информация о том, какой из процедур сервера требуется новый поток, передается в структуре door_info_t, адрес которой принимается процедурой создания сервера. Поле di_proc содержит адрес процедуры сервера, а поле di_data содержит указатель на аргументы, передаваемые процедуре сервера при вызове.</P>
     <P>Проще всего изучить происходящее на примере. Программа-клиент не претерпевает никаких изменений по сравнению с листингом 15.1. В программу-сервер добавляются две новые функции помимо процедуры сервера и функции main. На рис. 15.5 приведена схема сервера с четырьмя функциями и последовательностью их регистрации и вызова.</P>
     <BR>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader230" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 15.5. Четыре функции в процессе-сервере</P>
     <BR>
     <P>В листинге 15.17 приведен текст функции main сервера.</P>
     <H2><a name=label710 style="border:none;"></a>Листинг 15.17. Функция main для примера с управлением пулом потоков</H2>
     <P><CODE>//doors/server6.c</CODE></P>
     <P><CODE>42 int</CODE></P>
     <P><CODE>43 main(int argc, char **argv)</CODE></P>
     <P><CODE>44 {</CODE></P>
     <P><CODE>45  if (argc != 2)</CODE></P>
     <P><CODE>46  err_quit("usage: server6 &lt;server-pathname&gt;");</CODE></P>
     <P><CODE>47  Door_server_create(my_create);</CODE></P>
     <P><CODE>48  /* создание дескриптора двери и связывание его с именем */</CODE></P>
     <P><CODE>49  Pthread_mutex_lock(&amp;fdlock);</CODE></P>
     <P><CODE>50  fd = Door_create(servproc, NULL, DOOR_PRIVATE);</CODE></P>
     <P><CODE>51  Pthread_mutex_unlock(&amp;fdlock);</CODE></P>
     <P><CODE>52  unlink(argv[1]);</CODE></P>
     <P><CODE>53  Close(Open(argv[1], O_CREAT | O_RDWR, FILE_MODE));</CODE></P>
     <P><CODE>54  Fattach(fd, argv[1]);</CODE></P>
     <P><CODE>55  /* servproc() обслуживает запросы клиентов */</CODE></P>
     <P><CODE>56  for(;;)</CODE></P>
     <P><CODE>57   pause();</CODE></P>
     <P><CODE>58 }</CODE></P>
     <P>По сравнению с листингом 15.2 было внесено четыре изменения:</P>
     <P>1. Убрано объявление дескриптора двери fd (теперь это глобальная переменная, описанная в листинге 15.18).</P>
     <P>2. Вызов door_create защищен взаимным исключением (также описанным в листинге 15.18).</P>
     <P>3. Вызов door_server_create делается перед созданием двери, при этом указывается процедура создания сервера (my_thread, которая, будет показана позже).</P>
     <P>4. В вызове door_create последний аргумент (атрибуты) имеет значение DOOR_PRIVATE вместо 0. Это говорит библиотеке о том, что данная дверь будет иметь собственный пул потоков, называемый частным пулом сервера.</P>
     <P>Задание процедуры создания сервера с помощью door_server_create и выделение частного пула сервера с помощью DOOR_PRIVATE осуществляются независимо друг от друга. Возможны четыре ситуации:</P>
     <P>1. По умолчанию частный пул сервера и процедура создания сервера отсутствуют. Система создает потоки по мере необходимости и они переходят в пул потоков процесса.</P>
     <P>2. Указан флаг DOOR_PRIVATE, но процедура создания сервера отсутствует. Система создает потоки по мере необходимости и они отходят в пул потоков процесса, если относятся к тем дверям, для которых флаг DOOR_PRIVATE не был указан, либо в пул данной двери, если она была создана с флагом DOOR_PRIVATE.</P>
     <P>3. Отсутствует частный пул сервера, но указана процедура создания сервера. Процедура создания вызывается при необходимости создания нового потока, который затем переходит в пул потоков процесса.</P>
     <P>4. Указан флаг DOOR_PRIVATE и процедура создания сервера. Процедура создания сервера вызывается каждый раз при необходимости создания потока. После создания поток должен вызвать door_bind для отнесения его к нужному частному пулу сервера, иначе он будет добавлен к пулу потоков процесса.</P>
     <P>В листинге 15.18 приведен текст двух новых функций: my_create (процедура создания сервера) и my_thread (функция, выполняемая каждым потоком, который создается my_create).</P>
     <H2><a name=label711 style="border:none;"></a>Листинг 15.18. Функции управления потоками</H2>
     <P><CODE>//doors/server6.c</CODE></P>
     <P><CODE>13 pthread_mutex_t fdlock = PTHREAD_MUTEX_INITIALIZER;</CODE></P>
     <P><CODE>14 static int fd = –1; /* дескриптор двери */</CODE></P>
     <BR>
     <P><CODE>15 void *</CODE></P>
     <P><CODE>16 my_thread(void *arg)</CODE></P>
     <P><CODE>17 {</CODE></P>
     <P><CODE>18  int oldstate;</CODE></P>
     <P><CODE>19  door_info_t *iptr = arg;</CODE></P>
     <P><CODE>20  if ((Door_server_proc*)iptr-&gt;di_proc == servproc) {</CODE></P>
     <P><CODE>21   Pthread_mutex_lock(&amp;fdlock);</CODE></P>
     <P><CODE>22   Pthread_mutex_unlock(&amp;fdlock);</CODE></P>
     <P><CODE>23   Pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &amp;oldstate);</CODE></P>
     <P><CODE>24   Door_bind(fd);</CODE></P>
     <P><CODE>25   Door_return(NULL, 0, NULL, 0);</CODE></P>
     <P><CODE>26  } else</CODE></P>
     <P><CODE>27   err_quit("my_thread: unknown function: %p", arg);</CODE></P>
     <P><CODE>28  return(NULL); /* никогда не выполняется */</CODE></P>
     <P><CODE>29 }</CODE></P>
     <BR>
     <P><CODE>30 void</CODE></P>
     <P><CODE>31 my_create(door info_t *iptr)</CODE></P>
     <P><CODE>32 {</CODE></P>
     <P><CODE>33  pthread_t tid;</CODE></P>
     <P><CODE>34  pthread_attr_t attr;</CODE></P>
     <P><CODE>35  Pthread_attr_init(&amp;attr);</CODE></P>
     <P><CODE>36  Pthread_attr_setscope(&amp;attr, PTHREAD_SCOPE_SYSTEM);</CODE></P>
     <P><CODE>37  Pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</CODE></P>
     <P><CODE>38  Pthread_create(&amp;tid, &amp;attr, my_thread, (void *)iptr);</CODE></P>
     <P><CODE>39  Pthread_attr_destroy(&amp;attr);</CODE></P>
     <P><CODE>40  printf("my_thread: created server thread %ld\n", pr_thread_id(&amp;tid)):</CODE></P>
     <P><CODE>41 }</CODE></P>
     <H2><a name=label712 style="border:none;"></a>Процедура создания сервера</H2>
     <P>30-41 Каждый раз при вызове my_create создается новый поток. Перед вызовом pthread_create атрибуты потока инициализируются, область потока устанавливается равной PTHREAD_SCOPE_SYSTEM и поток определяется как неприсоединенный (detached). Созданный поток вызывает функцию my_thread. Аргументом этой функции является указатель на структуру типа door_info_t. Если у нас имеется сервер с несколькими дверьми и мы указываем процедуру создания сервера, эта процедура создания сервера будет вызываться при необходимости создания потока для любой из дверей. Единственный способ, которым эта процедура может определить тип сервера, соответствующий нужной двери, заключается в изучении указателя di_proc в структуре типа door_info_t.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Установка области выполнения PTHREAD_SCOPE_SYSTEM означает, что поток будет конкурировать в распределении ресурсов процессора с другими потоками системы. Альтернативой является указание PTHREAD_SCOPE_PROCESS; при этом поток будет конкурировать только с другими потоками данного процесса. Последнее не будет работать с дверьми, поскольку библиотека дверей требует, чтобы тот процесс ядра, который привел к вызову данного потока, выполнял и door_return. Поток с PTHREAD_SCOPE_PROCESS может сменить поток ядра во время выполнения процедуры сервера.</P>
      <P>Причина, по которой поток должен создаваться как неприсоединенный, заключается в том, что нужно предотвратить сохранение в системе информации о потоке после его завершения, потому что отсутствует поток, вызывающий pthread_join.</P>
     </DIV>
     <H2><a name=label713 style="border:none;"></a>Функция, запускающая поток</H2>
     <P>15-20 При создании потока запускается функция my_thread, указанная в вызове pthread_create. Аргументом является указатель на структуру типа door_info_t, передаваемый my_create. В данном примере есть только одна процедура сервера — servproc, и мы просто проверяем, что аргумент указывает на эту процедуру.</P>
     <H2><a name=label714 style="border:none;"></a>Ожидание присваивания дескриптору правильного значения</H2>
     <P>21-22 Процедура создания сервера вызывается в первый раз при вызове door_create для создания первого потока сервера. Этот вызов осуществляется из библиотеки дверей до завершения работы door_create. Однако переменная fd не примет значения дескриптора двери до тех пор, пока не произойдет возврата из функции door_create (проблема курицы и яйца). Поскольку мы знаем, что my_thread выполняется отдельно от основного потока, решение состоит в том, чтобы использовать взаимное исключение fdlock следующим образом: основной поток блокирует взаимное исключение перед вызовом door_create и разблокирует после возврата из door_create (когда дескриптору fd уже присвоено некоторое значение). Функция my_thread делает попытку заблокировать взаимное исключение (ее выполнение приостанавливается до тех пор, пока основной поток не разблокирует это взаимное исключение), а затем разблокирует его. Мы могли бы добавить условную переменную и передавать по ней уведомление, но здесь это не нужно, поскольку мы заранее знаем, в каком порядке будут происходить вызовы.</P>
     <H2><a name=label715 style="border:none;"></a>Отключение отмены потока</H2>
     <P>23 При создании нового потока вызовом pthread_create его отмена по умолчанию разрешена. Если отмена потока разрешена и клиент прерывает вызов door_call в процессе его выполнения (что мы продемонстрируем в листинге 15.26), вызываются обработчики отмены потока, после чего он завершается. Если отмена потока отключена (как это делаем мы) и клиент прерывает работу в вызове door_call, процедура сервера спокойно завершает работу (поток не завершается), а результаты door_return просто сбрасываются. Поскольку серверный поток завершается, если происходит отмена потока, и поскольку процедура сервера может в этот момент выполнять какие-то действия (возможно, с заблокированными семафорами или блокировками), библиотека дверей на всякий случай отключает отмену всех создаваемых ею потоков. Если нам нужно, чтобы процедура сервера отменялась при досрочном завершении работы клиента, для этого потока следует включить возможность отмены и приготовиться обработать такую ситуацию.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Обратите внимание, что область выполнения PTHREAD_SCOPE_SYSTEM и неприсоединенность потока указываются как атрибуты при создании потока. А отмена потока может быть отключена только в процессе выполнения потока. Таким образом, хотя мы и отключаем отмену потока, он сам может ее включить и выключить тогда, когда потребуется.</P>
     </DIV>
     <H2><a name=label716 style="border:none;"></a>Связывание потока с дверью</H2>
     <P>24 Вызов door_bind позволяет добавить поток к пулу, связанному с дверью, дескриптор которой передается door_bind в качестве аргумента. Поскольку для этого нам нужно знать дескриптор двери, в этой версии сервера он является глобальной переменной.</P>
     <H2><a name=label717 style="border:none;"></a>Делаем поток доступным клиенту</H2>
     <P>25 Мы делаем поток доступным клиенту вызовом door_return с двумя нулевыми указателями и нулевыми значениями длин буферов в качестве аргументов.</P>
     <P>Процедура сервера приведена в листинге 15.19. Она идентична программе из листинга 15.6.</P>
     <H2><a name=label718 style="border:none;"></a>Листинг 15.19. Процедура сервера</H2>
     <P><CODE>//doors/server6.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <BR>
     <P><CODE>2  void</CODE></P>
     <P><CODE>3  servproc(void *cookie, char *dataptr, size_t datasize,</CODE></P>
     <P><CODE>4   door_desc_t *descptr, size_t ndesc)</CODE></P>
     <P><CODE>5  {</CODE></P>
     <P><CODE>6   long arg, result;</CODE></P>
     <P><CODE>7   arg = *((long *) dataptr);</CODE></P>
     <P><CODE>8   printf("thread id %ld, arg = %ld\n", pr_thread_id(NULL), arg);</CODE></P>
     <P><CODE>9   sleep(5);</CODE></P>
     <P><CODE>10  result = arg * arg;</CODE></P>
     <P><CODE>11  Door_return((char *)&amp;result, sizeof(result), NULL, 0);</CODE></P>
     <P><CODE>12 }</CODE></P>
     <P>Чтобы продемонстрировать работу программы, запустим сервер:</P>
     <P><CODE>solaris % <STRONG>server6 /tmp/door6</STRONG></CODE></P>
     <P><CODE>my_thread: created server thread 4</CODE></P>
     <P>После запуска сервера и вызова door_create процедура создания сервера запускается в первый раз, хотя клиент мы еще не запустили. При этом создается первый поток, ожидающий запроса от первого клиента. Затем мы запускаем клиент три раза подряд:</P>
     <P><CODE>solaris % <STRONG>client6 /tmp/door6 11</STRONG></CODE></P>
     <P><CODE>result: 121</CODE></P>
     <P><CODE>solaris % <STRONG>client6 /tmp/door6 22</STRONG></CODE></P>
     <P><CODE>result: 484</CODE></P>
     <P><CODE>solaris % <STRONG>client6 /tmp/door6 33</STRONG></CODE></P>
     <P><CODE>result: 1089</CODE></P>
     <P>Посмотрим, что при этом выводит сервер. При поступлении первого запроса клиента создается новый поток (с идентификатором потока 5), а поток с номером 4 обслуживает все запросы клиентов. Библиотека дверей всегда держит один лишний поток наготове:</P>
     <P><CODE>my_thread: created server thread 5</CODE></P>
     <P><CODE>thread id 4, arg = 11</CODE></P>
     <P><CODE>thread id 4, arg = 22</CODE></P>
     <P><CODE>thread id 4, arg = 33</CODE></P>
     <P>Запустим теперь три экземпляра клиента одновременно в фоновом режиме:</P>
     <P><CODE>solaris % <STRONG>client6 /tmp/door6 44 &amp;client6 /tmp/door6 55 &amp;client6 /tmp/door6 66 &amp;</STRONG></CODE></P>
     <P><CODE>[2] 4919</CODE></P>
     <P><CODE>[3] 4920</CODE></P>
     <P><CODE>[4] 4921</CODE></P>
     <P><CODE>solaris % result: 1936</CODE></P>
     <P><CODE>result: 4356</CODE></P>
     <P><CODE>result: 3025</CODE></P>
     <P>Посмотрев на вывод сервера, мы увидим, что было создано два новых потока (с идентификаторами 6 и 7) и потоки 4, 5 и 6 обслужили три запроса от клиентов:</P>
     <P><CODE>thread id 4, arg = 44</CODE></P>
     <P><CODE>my_thread: created server thread 6</CODE></P>
     <P><CODE>thread id 5, arg = 66</CODE></P>
     <P><CODE>my_thread: created server thread 7</CODE></P>
     <P><CODE>thread id 6, arg = 55</CODE></P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label719 style="border:none;"></a>15.10. Функции door_bind, door unbind и door_revoke</P>
     </H1>
     <P>Рассмотрим еще три функции, дополняющие интерфейс дверей:</P>
     <P><CODE>#include &lt;door.h&gt;</CODE></P>
     <P><CODE>int door_bind(int <EM>fd</EM>);</CODE></P>
     <P><CODE>int door_unbind(void);</CODE></P>
     <P><CODE>int door_revoke(int <EM>fd</EM>);</CODE></P>
     <P><CODE>/* Всe три возвращают 0 в случае успешного завершения, –1 – в случае ошибки */</CODE></P>
     <P>Функция door_bind впервые появилась в листинге 15.18. Она связывает вызвавший ее поток с частным пулом сервера, относящимся к двери с дескриптором fd. Если вызвавший поток уже подключен к какой-либо другой двери, производится его неявное отключение.</P>
     <P>Функция door_unbind осуществляет явное отключение потока от текущего пула, к которому он подключен.</P>
     <P>Функция door_revoke отключает доступ к двери с дескриптором fd. Дескриптор двери может быть отменен только процессом, создавшим эту дверь. Все вызовы через эту дверь, находящиеся в процессе выполнения в момент вызова этой функции, будут благополучно завершены.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label720 style="border:none;"></a>15.11. Досрочное завершение клиента или сервера</P>
     </H1>
     <DIV class=section>
      <P>В наших примерах до настоящего момента предполагалось, что в процессе работы клиента и сервера не возникает непредусмотренных ситуаций. Посмотрим, что произойдет, если у клиента или сервера возникнут ошибки. В случае если клиент и сервер являются частями одного процесса (локальный вызов процедуры на рис. 15.1), клиенту не нужно беспокоиться о возникновении ошибок на сервере, и наоборот. Однако если клиент и сервер находятся в различных процессах, нужно учесть возможность досрочного завершения одного из них и предусмотреть способ уведомления второго об этом событии. Об этом нужно заботиться вне зависимости от того, находятся ли клиент и сервер на одном узле или нет.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label721 style="border:none;"></a>Досрочное завершение сервера</P>
      </H1>
      <P>Если клиент блокируется в вызове door_call, ожидая получения результатов, ему нужно каким-то образом получить уведомление о завершении потока сервера по какой-либо причине. Посмотрим, что происходит в этом случае, прервав работу сервера вызовом pthread_exit. Это приведет к завершению потока сервера (а не всего процесса). В листинге 15.20 приведен текст процедуры сервера.</P>
      <H2><a name=label722 style="border:none;"></a>Листинг 15.20. Процедура сервера, завершающая работу сразу после запуска</H2>
      <P><CODE>//doors/serverintr1.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  void</CODE></P>
      <P><CODE>3  servproc(void *cookie, char *dataptr, size_t datasize,</CODE></P>
      <P><CODE>4   door_desc_t *descptr, size_t ndesc)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   long arg, result;</CODE></P>
      <P><CODE>7   pthread_exit(NULL); /* посмотрим, что произойдет с клиентом */</CODE></P>
      <P><CODE>8   arg = *((long*)dataptr);</CODE></P>
      <P><CODE>9   result = arg * arg;</CODE></P>
      <P><CODE>10  Door_return((char*)&amp;result, sizeof(result), NULL, 0);</CODE></P>
      <P><CODE>11 }</CODE></P>
      <P>Оставшаяся часть сервера не претерпевает изменений по сравнению с листингом 15.2, а программу-клиент мы берем из листинга 15.1.</P>
      <P>Запустив клиент, мы увидим, что вызов door_call возвращает ошибку EINTR, если процедура сервера завершается досрочно:</P>
      <P><CODE>solaris % <STRONG>clientintr1 /tmp/door1 11</STRONG></CODE></P>
      <P><CODE>door_call error: Interrupted system call</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label723 style="border:none;"></a>Непрерываемость системного вызова door_call</P>
      </H1>
      <P>Документация на door_call предупреждает, что эта функция не предполагает возможности перезапуска (библиотечная функция door_call делает системный вызов с тем же именем). Мы можем убедиться в этом, изменив процедуру сервера таким образом, чтобы она делала паузу в 6 секунд перед возвращением, что показано в листинге 15.21.</P>
      <H2><a name=label724 style="border:none;"></a>Листинг 15.21. Процедура сервера делает паузу в 6 секунд</H2>
      <P><CODE>//doors/serverintr2.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  void</CODE></P>
      <P><CODE>3  servproc(void *cookie, char *dataptr, size_t datasize,</CODE></P>
      <P><CODE>4  door_desc_t *descptr, size_t ndesc)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   long arg, result;</CODE></P>
      <P><CODE>7   sleep(6); /* клиент получает сигнал SIGCHLD */</CODE></P>
      <P><CODE>8   arg = *((long*)dataptr);</CODE></P>
      <P><CODE>9   result = arg * arg;</CODE></P>
      <P><CODE>10  Door_return((char*)&amp;result, sizeof(result), NULL, 0);</CODE></P>
      <P><CODE>11 }</CODE></P>
      <P>Изменим теперь клиент из листинга 15.2: установим обработчик сигнала SIGCHLD, добавив порождение процесса и завершение порожденного процесса через 2 секунды. Таким образом, через 2 секунды после вызова door_call дочерний процесс завершит работу, а родительский перехватит сигнал SIGCHLD и произойдет возврат из обработчика сигнала, прерывающий системный вызов door_call. Текст программы-клиента показан в листинге 15.22.</P>
      <H2><a name=label725 style="border:none;"></a>Листинг 15.22. Клиент, перехватывающий сигнал SIGCHLD</H2>
      <P><CODE>//doors/clientintr2.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  void</CODE></P>
      <P><CODE>3  sig_chld(int signo)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   return; /* просто прерываем door_call() */</CODE></P>
      <P><CODE>6  }</CODE></P>
      <BR>
      <P><CODE>7  int</CODE></P>
      <P><CODE>8  main(int argc, char **argv)</CODE></P>
      <P><CODE>9  {</CODE></P>
      <P><CODE>10  int fd;</CODE></P>
      <P><CODE>11  long ival, oval;</CODE></P>
      <P><CODE>12  door_arg_t arg;</CODE></P>
      <P><CODE>13  if (argc != 3)</CODE></P>
      <P><CODE>14   err_quit("usage: clientintr2 &lt;server-pathname&gt; &lt;integer-value&gt;");</CODE></P>
      <P><CODE>15  fd = Open(argv[1], O_RDWR); /* открываем дверь */</CODE></P>
      <P><CODE>16  /* подготовка аргументов и указателя на результат */</CODE></P>
      <P><CODE>17  ival = atol(argv[2]);</CODE></P>
      <P><CODE>18  arg.data_ptr = (char*)&amp;ival; /* аргументы */</CODE></P>
      <P><CODE>19  arg.data_size = sizeof(long); /* размер аргументов */</CODE></P>
      <P><CODE>20  arg.desc_ptr = NULL;</CODE></P>
      <P><CODE>21  arg.desc_num = 0;</CODE></P>
      <P><CODE>22  arg.rbuf = (char*)&amp;oval; /* данные */</CODE></P>
      <P><CODE>23  arg.rsize = sizeof(long); /* размер данных */</CODE></P>
      <P><CODE>24  Signal(SIGCHLD, sig_chld);</CODE></P>
      <P><CODE>25  if (Fork() == 0) {</CODE></P>
      <P><CODE>26   sleep(2); /* дочерний процесс */</CODE></P>
      <P><CODE>27   exit(0); /* отправка SIGCHLD */</CODE></P>
      <P><CODE>28  }</CODE></P>
      <P><CODE>29  /* вызов процедуры сервера и вывод результата */</CODE></P>
      <P><CODE>30  Door_call(fd, &amp;arg);</CODE></P>
      <P><CODE>31  printf(result: %ld\n", oval);</CODE></P>
      <P><CODE>32  exit(0);</CODE></P>
      <P><CODE>33 }</CODE></P>
      <P>Клиенту будет возвращена та же ошибка, что и при досрочном завершении сервера — EINTR:</P>
      <P><CODE>solaris % <STRONG>clientintr2 /tmp/door2 22</STRONG></CODE></P>
      <P><CODE>door_call error: interrupted system call</CODE></P>
      <P>Поэтому нужно блокировать все сигналы, которые могут прервать вызов door_call.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label726 style="border:none;"></a>Идемпотентные и неидемпотентные процедуры</P>
      </H1>
      <P>А что произойдет, если мы перехватим сигнал EINTR и вызовем процедуру сервера еще раз, поскольку мы знаем, что эта ошибка возникла из-за нашего собственного прерывания системного вызова перехваченным сигналом (SIGCHLD)? Это может привести к некоторым проблемам, как мы покажем ниже.</P>
      <P>Изменим сервер так, чтобы он выводил идентификатор вызванного потока, делал паузу в 6 секунд и выводил идентификатор потока по завершении его. В листинге 15.23 приведен текст новой процедуры сервера. </P>
      <H2><a name=label727 style="border:none;"></a>Листинг 15.23. Процедура сервера, выводящая свой идентификатор потока дважды</H2>
      <P><CODE>//doors/serverintr3.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  void</CODE></P>
      <P><CODE>3  servproc(void *cookie, char *dataptr, size_t datasize,</CODE></P>
      <P><CODE>4   door_desc_t *descptr, size_t ndesc)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   long arg, result:</CODE></P>
      <P><CODE>7   printf("thread id %ld called\n", pr_thread_id(NULL));</CODE></P>
      <P><CODE>8   sleep(6); /* даем клиенту возможность перехватить SIGCHLD */</CODE></P>
      <P><CODE>9   arg = *((long*)dataptr);</CODE></P>
      <P><CODE>10  result = arg * arg;</CODE></P>
      <P><CODE>11  printf("thread id %ld returning\n", pr_thread_id(NULL));</CODE></P>
      <P><CODE>12  Door_return((char *) &amp;result, sizeof(result), NULL, 0);</CODE></P>
      <P><CODE>13 }</CODE></P>
      <P>В листинге 15.24 приведен текст программы-клиента.</P>
      <H2><a name=label728 style="border:none;"></a>Листинг 15.24. Клиент, вызывающий door_call еще раз, после перехвата EINTR</H2>
      <P><CODE>//doors/clientintr3.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  volatile sig_atomic_t caught_sigchld;</CODE></P>
      <BR>
      <P><CODE>3  void</CODE></P>
      <P><CODE>4  sig_chld(int signo)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   caught_sigchld = 1;</CODE></P>
      <P><CODE>7   return; /* прерываем вызов door_call() */</CODE></P>
      <P><CODE>8  }</CODE></P>
      <BR>
      <P><CODE>9  int</CODE></P>
      <P><CODE>10 main(int argc, char **argv)</CODE></P>
      <P><CODE>11 {</CODE></P>
      <P><CODE>12  int fd, rc;</CODE></P>
      <P><CODE>13  long ival, oval;</CODE></P>
      <P><CODE>14  door_arg_t arg;</CODE></P>
      <P><CODE>15  if (argc != 3)</CODE></P>
      <P><CODE>16   err_quit("usage: clientintr3 &lt;server-pathname&gt; &lt;integer-value&gt;");</CODE></P>
      <P><CODE>17  fd = Open(argv[1], O_RDWR); /* открытие двери */</CODE></P>
      <P><CODE>18  /* подготовка аргументов и указателя на результаты */</CODE></P>
      <P><CODE>19  ival = atol(argv[2]);</CODE></P>
      <P><CODE>20  arg.data_ptr = (char*)&amp;ival; /* аргументы */</CODE></P>
      <P><CODE>21  arg.data_size = sizeof(long); /* размер аргументов */</CODE></P>
      <P><CODE>22  arg.desc_ptr = NULL;</CODE></P>
      <P><CODE>23  arg.desc_num = 0;</CODE></P>
      <P><CODE>24  arg.rbuf = (char*)&amp;oval; /* возвращаемые данные */</CODE></P>
      <P><CODE>25  arg.rsize = sizeof(long); /* размер данных */</CODE></P>
      <P><CODE>26  Signal(SIGCHLD, sig_chld);</CODE></P>
      <P><CODE>27  if (Fork() == 0) {</CODE></P>
      <P><CODE>28   sleep(2); /* дочерний процесс */</CODE></P>
      <P><CODE>29   exit(0); /* отправка SIGCHLD */</CODE></P>
      <P><CODE>30  }</CODE></P>
      <P><CODE>31  /* родительский процесс : вызов процедуры сервера и вывод результата */</CODE></P>
      <P><CODE>32  for (;;) {</CODE></P>
      <P><CODE>33   printf("calling door_call\n");</CODE></P>
      <P><CODE>34   if ((rc = door_call(fd, &amp;arg)) == 0)</CODE></P>
      <P><CODE>35    break; /* успешное завершение */</CODE></P>
      <P><CODE>36   if (errno == EINTR &amp;&amp; caught_sigchld) {</CODE></P>
      <P><CODE>37    caught_sigchld = 0;</CODE></P>
      <P><CODE>38    continue; /* повторный вызов door_call */</CODE></P>
      <P><CODE>39   }</CODE></P>
      <P><CODE>40   err_sys("door_call error");</CODE></P>
      <P><CODE>41  }</CODE></P>
      <P><CODE>42  printf("result: %ld\n", oval);</CODE></P>
      <P><CODE>43  exit(0);</CODE></P>
      <P><CODE>44 }</CODE></P>
      <P>2-8 Объявляем глобальную переменную caught_sigchld, устанавливая ее в единицу при перехвате сигнала SIGCHLD.</P>
      <P>31-42 Вызываем door_call в цикле, пока он не завершится успешно.</P>
      <P>Глядя на выводимые клиентом результаты, мы можем подумать, что все в порядке:</P>
      <P><CODE>solaris % <STRONG>clientintr3 /tmp/door3 33</STRONG></CODE></P>
      <P><CODE>calling door_call</CODE></P>
      <P><CODE>calling door_call</CODE></P>
      <P><CODE>result: 1089</CODE></P>
      <P>Функция door_call вызывается в первый раз, обработчик сигнала срабатывает через 2 секунды после этого и переменной caught_sigchld присваивается значение 1. door_call при этом возвращает ошибку EINTR и мы вызываем door_call еще раз. Во второй раз процедура завершается успешно.</P>
      <P>Посмотрев на выводимый сервером текст, мы увидим, что процедура сервера была вызвана дважды:</P>
      <P><CODE>solaris % <STRONG>serverintr3 /tmp/door3</STRONG></CODE></P>
      <P><CODE>thread id 4 called</CODE></P>
      <P><CODE>thread id 4 returning</CODE></P>
      <P><CODE>thread id 5 called</CODE></P>
      <P><CODE>thread id 5 returning</CODE></P>
      <P>Когда клиент второй раз вызывает door_call, это приводит к запуску нового потока, вызывающего процедуру сервера еще раз. Если процедура сервера идемпотентна, проблем в такой ситуации не возникнет. Однако если она неидемпотентна, это может привести к ошибкам.</P>
      <P>Термин «идемпотентность» по отношению к процедуре подразумевает, что процедура может быть вызвана произвольное число раз без возникновения ошибок. Наша процедура сервера, вычисляющая квадрат целого числа, идемпотентна: мы получаем правильный результат вне зависимости от того, сколько раз мы ее вызовем. Другим примером является процедура, возвращающая дату и время. Хотя эта процедура и будет возвращать разную информацию при новых вызовах (поскольку дата и время меняются), это не вызовет проблем. Классическим примером неидемпотентной процедуры является процедура уменьшения банковского счета на некоторую величину. Конечный результат будет неверным, если ее вызвать дважды.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label729 style="border:none;"></a>Досрочное завершение клиента</P>
      </H1>
      <P>Посмотрим, каким образом процедура сервера получает уведомление о досрочном завершении клиента. Пpoгрaммa-клиeнт приведена в листинге 15.25.</P>
      <H2><a name=label730 style="border:none;"></a>Листинг 15.25. Клиент, досрочно завершающий работу после вызова door_call</H2>
      <P><CODE>//doors/clientintr4.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <BR>
      <P><CODE>2  int</CODE></P>
      <P><CODE>3  main(int argc, char **argv)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   int fd;</CODE></P>
      <P><CODE>6   long ival, oval;</CODE></P>
      <P><CODE>7   door_arg_t arg;</CODE></P>
      <P><CODE>8   if (argc != 3)</CODE></P>
      <P><CODE>9    err_quit("usage: clientintr4 &lt;server-pathname&gt; &lt;integer-value&gt;");</CODE></P>
      <P><CODE>10  fd = Open(argv[1], O_RDWR); /* открываем дверь */</CODE></P>
      <P><CODE>11  /* подготовка аргументов и указателя на результаты */</CODE></P>
      <P><CODE>12  ival = atol(argv[2]);</CODE></P>
      <P><CODE>13  arg.data_ptr = (char*)&amp;ival; /* аргументы */</CODE></P>
      <P><CODE>14  arg.data_size = sizeof(long); /* размер аргументов */</CODE></P>
      <P><CODE>15  arg.desc_ptr = NULL;</CODE></P>
      <P><CODE>16  arg.desc_num = 0;</CODE></P>
      <P><CODE>17  arg.rbuf = (char*)&amp;oval; /* возвращаемые данные */</CODE></P>
      <P><CODE>18  arg.rsize = sizeof(long); /* размер возвращаемых данных */</CODE></P>
      <P><CODE>19  /* вызов процедуры сервера и вывод результата */</CODE></P>
      <P><CODE>20  alarm(3);</CODE></P>
      <P><CODE>21  Door_call(fd, &amp;arg);</CODE></P>
      <P><CODE>22  printf("result: %ld\n", oval);</CODE></P>
      <P><CODE>23  exit(0);</CODE></P>
      <P><CODE>24 }</CODE></P>
      <P>20 Единственное изменение заключается в добавлении вызова alarm(3) перед door_call. Эта функция приводит к отправке сигнала SIGALRM через три секунды после вызова, но, поскольку мы его не перехватываем, это приводит к завершению процесса. Поэтому клиент завершится до возврата из door_call, потому что в процедуру сервера вставлена шестисекундная пауза.</P>
      <P>В листинге 15.26 приведен текст процедуры сервера и обработчик отмены потока.</P>
      <H2><a name=label731 style="border:none;"></a>Листинг 15.26. Процедура сервера, обрабатывающая досрочное завершение клиента</H2>
      <P><CODE>//doors/serverintr4.с </CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  void</CODE></P>
      <P><CODE>3  servproc_cleanup(void *arg)</CODE></P>
      <P><CODE>4  {</CODE></P>
      <P><CODE>5   printf("servproc cancelled, thread id %ld\n", pr_thread_id(NULL));</CODE></P>
      <P><CODE>6  }</CODE></P>
      <BR>
      <P><CODE>7  void</CODE></P>
      <P><CODE>8  servproc(void *cookie, char *dataptr, size_t datasize,</CODE></P>
      <P><CODE>9   door_desc_t *descptr, size_t ndesc)</CODE></P>
      <P><CODE>10 {</CODE></P>
      <P><CODE>11  int oldstate, junk;</CODE></P>
      <P><CODE>12  long arg, result;</CODE></P>
      <P><CODE>13  Pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &amp;oldstate);</CODE></P>
      <P><CODE>14  pthread_cleanup_push(servproc_cleanup, NULL);</CODE></P>
      <P><CODE>15  sleep(6);</CODE></P>
      <P><CODE>16  arg = *((long*)dataptr);</CODE></P>
      <P><CODE>17  result = arg * arg;</CODE></P>
      <P><CODE>18  pthread_cleanup_pop(0);</CODE></P>
      <P><CODE>19  Pthread_setcancelstate(oldstate, &amp;junk);</CODE></P>
      <P><CODE>20  Door_return((char*)&amp;result, sizeof(result), NULL, 0);</CODE></P>
      <P><CODE>21 }</CODE></P>
      <P>Вспомните, что мы говорили об отмене выполнения потока в разделе 8.5 и в связи с листингом 15.18. Когда система обнаруживает завершение клиента в процессе выполнения серверной процедуры, потоку, обрабатывающему запрос этого клиента, отправляется запрос на отмену:</P>
      <P>■ если поток отключил возможность отмены, ничего не происходит и поток выполняется до завершения (вызов door_return), а результаты сбрасываются;</P>
      <P>■ если возможность отмены включена, вызываются обработчики отмены потока, а затем он завершает работу.</P>
      <P>В тексте процедуры сервера мы сначала вызвали pthread_setcancelstate для включения возможности отмены потока, потому что по умолчанию при создании новых потоков библиотекой возможность их отмены отключается. Эта функция сохраняет текущее состояние потока в переменной oldstate, и мы восстанавливаем его в конце функции. Затем мы вызываем pthread_cleanup_push для регистрации нашего обработчика отмены servproc_cleanup. Эта функция только выводит идентификатор отмененного потока, но вообще она может выполнять все необходимое для корректного завершения процедуры сервера (разблокировать исключения и т. п.). После возвращения из обработчика поток завершается.</P>
      <P>В текст процедуры сервера мы добавляем 6-секундную паузу, чтобы клиент мог успешно завершить работу в вызове door_call.</P>
      <P>Запустив клиент дважды, мы увидим сообщение интерпретатора Alarm clock при завершении процесса сигналом SIGALRM:</P>
      <P><CODE>solaris % <STRONG>clientintr4 /tmp/door4 44</STRONG></CODE></P>
      <P><CODE>Alarm Clock</CODE></P>
      <P><CODE>solaris % <STRONG>clientintr4 /tmp/door4 44</STRONG></CODE></P>
      <P><CODE>Alarm Clock</CODE></P>
      <P>Посмотрим, что при этом выводит сервер. Каждый раз при досрочном завершении клиента поток процедуры сервера действительно отменяется и вызывается обработчик отмены потока: </P>
      <P><CODE>solaris % <STRONG>serverintr4 /tmp/door4</STRONG></CODE></P>
      <P><CODE>servproc canceled, thread id 4</CODE></P>
      <P><CODE>servproc canceled, thread id 5</CODE></P>
      <P>Цель, с которой мы вызываем программу-клиент дважды, — показать, что после завершения потока с идентификатором 4 библиотека создает новый поток (с идентификатором 5) для обработки второго запроса клиента.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label732 style="border:none;"></a>15.12. Резюме</P>
     </H1>
     <P>Интерфейс дверей позволяет вызывать процедуры в других процессах на том же узле. В следующей главе мы обсудим возможность удаленного вызова процедур в процессах на других узлах.</P>
     <P>Основные функции этого интерфейса просты в работе и использовании. Сервер вызывает door_create для создания двери и связывания ее с процедурой сервера, а затем вызывает fattach для сопоставления этой двери и имени файла в файловой системе. Клиент вызывает open для этого имени файла и затем может вызвать door_call для вызова процедуры сервера. Возврат из процедуры сервера осуществляется вызовом door_return.</P>
     <P>Обычно разрешения для двери проверяются только один раз — при ее открытии вызовом open. Проверяются идентификаторы пользователя и группы клиента (и полного имени файла). Одной из полезных функций дверей (по сравнению с другими средствами IPC) является возможность получения информации о клиенте в процессе работы (его действующего и реального идентификаторов). Это может использоваться сервером для принятия решения о предоставлении услуг данному клиенту.</P>
     <P>Двери предоставляют возможность передачи дескрипторов от клиента серверу и обратно. Это достаточно мощное средство, поскольку дескрипторы в Unix дают возможность обращаться ко множеству объектов (файлам, сокетам или XTI, дверям).</P>
     <P>При вызове процедур в другом процессе следует учесть возможность досрочного завершения клиента или сервера. Клиент получает уведомление о досрочном завершении сервера с помощью сообщения об ошибке EINTR. Сервер получает уведомление о досрочном завершении клиента в процессе обработки процедуры посредством запроса на отмену выполнения потока данной процедуры. Сервер может обработать этот запрос или проигнорировать его.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label733 style="border:none;"></a>Упражнения</P>
     </H1>
     <P>1. Сколько байтов информации передается при вызове door_call от клиента серверу?</P>
     <P>2. Есть ли необходимость вызывать fstat для проверки типа дескриптора в листинге 15.3? Уберите этот вызов и посмотрите, что произойдет.</P>
     <P>3. В документации Solaris 2.6 для вызова sleep() говорится, что «выполнение текущего процесса приостанавливается». Почему при этом библиотека дверей имеет возможность создать новые потоки в листинге 15.6?</P>
     <P>4. В разделе 15.3 мы отмечали, что для создаваемых вызовом door_create дверей автоматически устанавливается бит FD_CLOEXEC. Однако мы можем вызвать fcntl после возврата из door_create и сбросить этот бит. Что произойдет, если мы сделаем это, вызовем exec, а затем обратимся к процедуре сервера из клиента?</P>
     <P>5. В листингах 15.23 и 15.24 добавьте вывод текущего времени в вызовах printf сервера и клиента. Запустите клиент и сервер. Почему первый экземпляр процедуры сервера возвращается через две секунды после запуска?</P>
     <P>6. Удалите блокировку, защищающую дескриптор fd в листингах 15.17 и 15.18, и убедитесь, что программа больше не работает. Какая при этом возникает ошибка?</P>
     <P>7. Если мы хотим лишь испытать возможность отмены потока с процедурой сервера, нужно ли нам устанавливать процедуру создания сервера?</P>
     <P>8. Проверьте, что вызов door_revoke дает возможность завершиться работающим с данной процедурой потокам. Выясните, что происходит при вызове door_саll после аннулирования процедуры.</P>
     <P>9. В нашем решении предыдущего упражнения и в листинге 15.17 мы говорим, что дескриптор двери должен быть глобальным, если он нужен процедуре сервера или процедуре создания сервера. Это утверждение, вообще говоря, неверно. Перепишите решение предыдущего упражнения, сохранив fd в качестве автоматической переменной функции main.</P>
     <P>10. В программе листинга 15.18 мы вызывали pthread_attr_init и pthread_attr_ destroy каждый раз, когда создавался поток. Является ли такое решение оптимальным?</P>
    </DIV>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label734 style="border:none;"></a>ГЛАВА 16</P>
     <P>Пакет Sun RPC</P>
    </H1>
    <DIV class=section>
     <H1>
      <P><a name=label735 style="border:none;"></a>16.1. Введение</P>
     </H1>
     <DIV class=section>
      <P>Когда мы разрабатываем приложение, мы встаем перед выбором:</P>
      <P>1. Написать одну большую монолитную программу, которая будет делать все.</P>
      <P>2. Разделить приложение на несколько процессов, взаимодействующих друг с другом.</P>
      <P>Если мы выбираем второй вариант, перед нами опять встает вопрос:</P>
      <P>2.1. предполагать ли, что все процессы выполняются на одном узле, что допускает использование средств IPC для взаимодействия между ними, либо</P>
      <P>2.2. допускать возможность запуска части процессов на других узлах, что требует какой-либо формы взаимодействия по сети.</P>
      <P>Взгляните на рис. 15.1. Верхняя ситуация соответствует варианту 1, средняя — варианту 2.1, а нижняя — варианту 2.2. Большая часть этой книги посвящена обсуждению случая 2.1, то есть взаимодействию процессов в пределах одного узла с помощью таких средств IPC, как передача сообщений, разделяемая память и, возможно, некоторых форм синхронизации. Взаимодействие между потоками одного процесса или разных процессов является частным случаем этого сценария.</P>
      <P>Когда мы выдвигаем требование поддержки возможности сетевого взаимодействия между составляющими приложения, для разработки чаще всего используется явное сетевое программирование. При этом в программе используются вызовы интерфейсов сокетов или XTI, о чем рассказывается в [24]. При использовании интерфейса сокетов клиенты вызывают функции socket, connect, read и write, а серверы вызывают socket, bind, listen, accept, read и write. Большая часть знакомых нам приложений (браузеры, серверы Web, клиенты и серверы Telnet) написаны именно так.</P>
      <P>Альтернативным способом разработки распределенных приложений является неявное сетевое программирование. Оно осуществляется посредством удаленного вызова процедур (remote procedure call — RPC). Приложение кодируется с использованием тех же вызовов, что и обычное несетевое, но клиент и сервер могут находиться на разных узлах. Сервером называется процесс, предоставляющий другому возможность запускать одну из составляющих его процедур, а клиентом — процесс, вызывающий процедуру сервера. То, что клиент и сервер находятся на разных узлах и для связи между ними используется сетевое взаимодействие, большей частью остается скрыто от программиста. Одним из критериев оценки качества пакета RPC является именно скрытость лежащего в основе интерфейса сети.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label736 style="border:none;"></a>Пример</P>
      </H1>
      <P>В качестве примера использования RPC перепишем листинги 15.1 и 15.2 для использования Sun RPC вместо дверей. Клиент вызывает процедуру сервера с аргументом типа long, а возвращаемое значение представляет собой квадрат аргумента. В листинге 16.1<A HREF="#n_1" onmouseover="ShowBookNote('n_1')" onmouseout="HideBookNote('n_1')"><SUP>[1]</SUP></A> приведен текст первого файла, square.х.</P>
      <H2><a name=label737 style="border:none;"></a>Листинг 16.1. Файл спецификации RPC</H2>
      <P><CODE>//sunrpc/square1/square.x</CODE></P>
      <BR>
      <P><CODE>1 struct square_in { /* входные данные (аргумент) */</CODE></P>
      <P><CODE>2  long arg1;</CODE></P>
      <P><CODE>3 };</CODE></P>
      <BR>
      <P><CODE>4 struct square_out { /* возвращаемые данные (результат) */</CODE></P>
      <P><CODE>5  long res1;</CODE></P>
      <P><CODE>6 };</CODE></P>
      <BR>
      <P><CODE>7 program SQUARE_PROG {</CODE></P>
      <P><CODE>8  version SQUARE_VERS {</CODE></P>
      <P><CODE>9   square_out SQUAREPROC(square_in) = 1; /* номер процедуры = 1 */</CODE></P>
      <P><CODE>10  } = 1; /* номер версии */</CODE></P>
      <P><CODE>11 } = 0x31230000; /* номер программы */</CODE></P>
      <P>Файлы с расширением .х называются файлами спецификации RPC. Они определяют процедуры сервера, их аргументы и возвращаемые значения.</P>
      <H2><a name=label738 style="border:none;"></a>Определение аргумента и возвращаемого значения</H2>
      <P>1-6 Мы определяем две структуры — одну для аргументов (одно поле типа long) и одну для результатов (тоже одно поле типа long).</P>
      <H2><a name=label739 style="border:none;"></a>Определение программы, версии и процедуры</H2>
      <P>7-11 Мы определяем программу RPC с именем SQUARE_PROG, состоящую из одной версии (SQUARE_VERS), а эта версия представляет собой единственную процедуру сервера с именем SQUAREPROC. Аргументом этой процедуры является структура square_in, а возвращаемым значением — структура square_out. Мы также присваиваем этой процедуре номер 1, как и версии, а программе мы присваиваем 32-разрядный шестнадцатеричный номер. (О номерах программ более подробно говорится в табл. 16.1.)</P>
      <P>Компилировать спецификацию нужно программой rpcgen, входящей в пакет Sun RPC.</P>
      <P>Теперь напишем функцию main клиента, который будет осуществлять удаленный вызов процедуры. Текст программы приведен в листинге 16.2.</P>
      <H2><a name=label740 style="border:none;"></a>Листинг 16.2. Функция main клиента, делающего удаленный вызов процедуры</H2>
      <P><CODE>//sunrpc/square1/client.c</CODE></P>
      <P><CODE>1  #include "unpipc.h" /* наш заголовочный файл */</CODE></P>
      <P><CODE>2  #include "square.h" /* создается rpcgen */</CODE></P>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   CLIENT *cl;</CODE></P>
      <P><CODE>7   square_in in;</CODE></P>
      <P><CODE>8   square_out *outp;</CODE></P>
      <P><CODE>9   if (argc != 3)</CODE></P>
      <P><CODE>10   err_quit("usage: client &lt;hostname&gt; &lt;integer-value&gt;");</CODE></P>
      <P><CODE>11  cl = Clnt_create(argv[1], SQUARE_PROG, SQUARE_VERS, "tcp");</CODE></P>
      <P><CODE>12  in.arg1 = atol(argv[2]);</CODE></P>
      <P><CODE>13  if ((outp = squareproc_1(&amp;in, cl)) == NULL)</CODE></P>
      <P><CODE>14   err_quit("ls", clnt_sperror(cl, argv[1]));</CODE></P>
      <P><CODE>15  printf("result: %ld\n", outp-&gt;res1);</CODE></P>
      <P><CODE>16  exit(0);</CODE></P>
      <P><CODE>17 }</CODE></P>
      <H2><a name=label741 style="border:none;"></a>Подключение заголовочного файла, создаваемого rpcgen</H2>
      <P>2 Мы подключаем заголовочный файл square.h, создаваемый функцией rpcgen.</P>
      <H2><a name=label742 style="border:none;"></a>Объявление дескриптора клиента</H2>
      <P>6 Мы объявляем дескриптор клиента (client handle) с именем cl. Дескрипторы клиентов выглядят как обычные указатели на тип FILE (поэтому слово CLIENT пишется заглавными буквами).</P>
      <H2><a name=label743 style="border:none;"></a>Получение дескриптора клиента</H2>
      <P>11 Мы вызываем функцию clnt_create, создающую клиент RPC:</P>
      <P><CODE>#include &lt;rpc/rpc.h&gt;</CODE></P>
      <P><CODE>CLIENT *clnt_create(const char <EM>*host,</EM> unsigned long <EM>prognum,</EM> unsigned long <EM>versnum,</EM> const char <EM>*protocol</EM>);</CODE></P>
      <P><CODE>/* Возвращает ненулевой дескриптор клиента в случае успешного завершения. NULL – в случае ошибки */</CODE></P>
      <P>Как и с обычными указателями на тип FILE, нам безразлично, на что указывает дескриптор клиента. Скорее всего, это некоторая информационная структура, хранящаяся в ядре. Функция clnt_create создает такую структуру и возвращает нам указатель на нее, а мы передаем его библиотеке RPC времени выполнения каждый раз при удаленном вызове процедуры.</P>
      <P>Первым аргументом clnt_create должно быть имя или IP-адрес узла, на котором выполняется сервер. Вторым аргументом будет имя программы, третьим — номер версии. Оба эти значения берутся из спецификации (square.х, листинг 16.1). Последний аргумент позволяет указать протокол, обычно TCP или UDP.</P>
      <H2><a name=label744 style="border:none;"></a>Вызов удаленной процедуры и вывод результата</H2>
      <P>12-15 Мы вызываем процедуру, причем первый аргумент указывает на входную структуру (&amp;in), а второй содержит дескриптор клиента. В большинстве стандартных функций ввода-вывода дескриптор файла является последним аргументом. Точно так же и в вызовах RPC дескриптор клиента передается последним. Возвращаемое значение представляет собой указатель на структуру, в которой хранится результат работы сервера. Место под входную структуру выделяет программист, а под возвращаемую — пакет RPC.</P>
      <P>В файле спецификации square.x мы назвали процедуру SQUAREPROC, но из клиента мы вызываем squareproc_1. Существует соглашение о преобразовании имени из файла спецификации к нижнему регистру и добавлении номера версии через символ подчеркивания.</P>
      <P>Со стороны сервера от нас требуется только написать процедуру. Функция main автоматически создается программой rpcgen. Текст процедуры приведен в листинге 16.3.</P>
      <H2><a name=label745 style="border:none;"></a>Листинг 16.3. Процедура сервера, вызываемая с помощью Sun RPC</H2>
      <P><CODE>//sunrpc/square1/server.c</CODE></P>
      <P><CODE>1 #include "unpipc.h"</CODE></P>
      <P><CODE>2 #include "square.h"</CODE></P>
      <BR>
      <P><CODE>3 square_out *</CODE></P>
      <P><CODE>4 squareproc_l_svc(square_in *inp, struct svc_req *rqstp)</CODE></P>
      <P><CODE>5 {</CODE></P>
      <P><CODE>6  static square_out out;</CODE></P>
      <P><CODE>7  out.res1 = inp-&gt;arg1 * inp-&gt;arg1;</CODE></P>
      <P><CODE>8  return(&amp;out);</CODE></P>
      <P><CODE>9 }</CODE></P>
      <H2><a name=label746 style="border:none;"></a>Аргументы процедуры</H2>
      <P>3-4 Прежде всего мы замечаем, что к имени процедуры добавился суффикс _svc. Это дает возможность использовать два прототипа функций ANSI С в файле square.x, один из которых определяет функцию, вызываемую клиентом в листинге 16.2 (она принимает дескриптор клиента), а второй — реальную функцию сервера (которая принимает другие аргументы).</P>
      <P>При вызове процедуры сервера первый аргумент является указателем на входную структуру, а второй — на структуру, передаваемую библиотекой RPC времени выполнения, которая содержит информацию о данном вызове (в этом примере игнорируется для простоты).</P>
      <H2><a name=label747 style="border:none;"></a>Выполнение и возврат</H2>
      <P>6-8 Программа считывает входной аргумент и возводит его в квадрат. Результат сохраняется в структуре, адрес которой возвращается процедурой сервера. Поскольку мы возвращаем адрес переменной, эта переменная не может быть автоматической. Мы объявляем ее как статическую (static).</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Внимательные читатели заметят, что это лишает нашу функцию возможности использования в защищенном поточном программировании. Мы обсудим это в разделе 16.2, где приведем пример защищенной функции. </P>
      </DIV>
      <P>Откомпилируем клиент в системе Solaris, а сервер — в BSD/OS, запустим сервер, а затем клиент:</P>
      <P><CODE>solaris % <STRONG>client bsdi 11</STRONG></CODE></P>
      <P><CODE>result: 121</CODE></P>
      <P><CODE>solaris % <STRONG>client 209.75.135.35 22</STRONG></CODE></P>
      <P><CODE>result: 484</CODE></P>
      <P>В первом случае мы указываем имя узла сервера, а во втором — его IP-адрес. Этим мы демонстрируем возможность использования как имен, так и IP-адресов для задания узла в функции clnt_create.</P>
      <P>Теперь продемонстрируем некоторые ошибки, возникающие при работе clnt_create, если, например, не существует узел или на нем не запущена программа-сервер:</P>
      <P><CODE>solaris % <STRONG>client nosuchhost 11</STRONG></CODE></P>
      <P><CODE>nosuchhost: RPC: Unknown host <EM>возвращается библиотекой RPC времени выполнения</EM></CODE></P>
      <P><CODE>clnt_create error             <EM>возвращается нашей функцией-оберткой</EM></CODE></P>
      <P><CODE>solaris % <STRONG>client localhost 11</STRONG></CODE></P>
      <P><CODE>localhost: rpc: program not registered</CODE></P>
      <P><CODE>clnt_create error</CODE></P>
      <P>Мы написали клиентскую и серверную части программы и продемонстрировали их использование вообще без явного сетевого программирования. Клиент просто вызывает две функции, а сервер вообще состоит из одной функции. Все тонкости использования XTI в Solaris, сокетов в BSD/OS и сетевого ввода-вывода обрабатываются библиотекой RPC времени выполнения. В этом и состоит предназначение RPC — предоставлять возможность создания распределенных приложений без знания сетевого программирования.</P>
      <P>Другая немаловажная деталь данного примера заключается в том, что в системах Sparc под Solaris и Intel x86 под управлением BSD/OS используется разный порядок байтов. В Sparc используется порядок big endian («тупоконечный»<A HREF="#n_2" onmouseover="ShowBookNote('n_2')" onmouseout="HideBookNote('n_2')"><SUP>[2]</SUP></A>), а в Intel — little endian («остроконечный») (что мы показали в разделе 3.4 [24]). Отличия в порядке байтов также обрабатываются библиотекой RPC времени выполнения автоматически с использованием стандарта XDR (внешнее представление данных), который мы обсудим в разделе 16.8.</P>
      <P>Создание программы-клиента и программы-сервера в данном случае требует больше операций, чем для любой другой программы этой книги. Выполняемый файл клиента получается следующим образом:</P>
      <P><CODE>solaris % <STRONG>rpcgen-Сsquare.x</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>cc-сclient.с-оclient.о</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>cc-сsquare_clnt.c-оsquare_clnt.o</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>cc-сsquare_xdr.с-оsquare_xdr.o</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>cc-оclient client.оsquare_clnt.o square_xdr.o libunpipc.a –lnsl</STRONG></CODE></P>
      <P>Параметр –С говорит rpcgen о необходимости создания прототипов функций ANSI С в заголовочном файле square.h. Программа rpcgen также создает заглушку клиента (client stub) в файле с именем square_clnt.с и файл с именем square_xdr.с, который осуществляет преобразование данных в соответствии со стандартом XDR. Наша библиотека (содержащая функции, используемые в этой книге) называется libunpipc.a, а параметр –lnsl подключает системную библиотеку сетевых функций в Solaris (включая библиотеки RPC и XDR времени выполнения).</P>
      <P>Аналогичные команды используются для создания сервера, хотя rpcgen уже не нужно запускать снова. Файл square_svc.c содержит функцию main сервера, и файл square_xdr.о, обсуждавшийся выше, также требуется для работы сервера:</P>
      <P><CODE>solaris % <STRONG>cc –с server.с –о server.о</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>сc –с square_svc.c –о square_svc.o</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>cc –о server server.о square_svc.o libunpipc.a –lnsl</STRONG></CODE></P>
      <P>При этом создаются клиент и сервер, выполняемые в системе Solaris.</P>
      <P>Если клиент и сервер должны быть построены для разных систем (как в предыдущем примере, где клиент выполнялся в Solaris, а сервер — в BSD/OS), могут потребоваться дополнительные действия. Например, некоторые файлы должны быть либо общими (через NFS), либо находиться в обеих системах, а файлы, используемые клиентом и сервером (например, square_xdr.o), должны компилироваться в каждой системе в отдельности. </P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader233" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 16.1. Этапы создания приложения клиент-сервер с использованием RPC</P>
      <BR>
      <P>На рис. 16.1 приведена схема создания приложения типа клиент-сервер. Три затемненных прямоугольника соответствуют файлам, которые мы должны написать. Штриховые линии показывают файлы, подключаемые через заголовочный файл square.h.</P>
      <P>На рис. 16.2 изображена схема происходящего при удаленном вызове процедуры. Действия выполняются в следующем порядке:</P>
      <P>1. Запускается сервер, который регистрируется в программе, управляющей портами на узле-сервере. Затем запускается клиент и вызывает clnt_create. Эта функция связывается с управляющей портами программой сервера и находит нужный порт. Функция clnt_create также устанавливает соединение с сервером по протоколу TCP (поскольку мы указали TCP в качестве используемого протокола в листинге 16.2). Мы не показываем эти шаги на рисунке и откладываем детальное обсуждение до раздела 16.3.</P>
      <P>2. Клиент вызывает локальную процедуру, называемую заглушкой клиента. В листинге 16.2 эта процедура называлась squareproc_1, а файл, содержащий ее, создавался rpcgen автоматически и получал название square_clnt.c. С точки зрения клиента именно эта функция является сервером, к которому он обращается. Целью создания заглушки является упаковка аргументов для удаленного вызова процедуры, помещение их в стандартный формат и создание одного или нескольких сетевых сообщений. Упаковка аргументов клиента в сетевое сообщение называется сортировкой (marshaling). Клиент и заглушка обычно вызывают библиотеки функций RPC (clnt_create в нашем примере). При использовании редактора связей в Solaris эти функции загружаются из библиотеки –lnsl, тогда как в BSD/OS они входят в стандартную библиотеку языка С.</P>
      <P>3. Сетевые сообщения отсылаются на удаленную систему заглушкой клиента. Обычно это требует локального системного вызова (например, write или sendto).</P>
      <P>4. Сетевые сообщения передаются на удаленную систему. Для этого обычно используются сетевые протоколы TCP и UDP.</P>
      <P>5. Заглушка сервера ожидает запросов от клиента на стороне сервера. Она рассортировывает аргументы из сетевых сообщений.</P>
      <P>6. Заглушка сервера осуществляет локальный вызов процедуры для запуска настоящей функции сервера (процедуры squareproc_l_svc в листинге 16.3), передавая ей аргументы, полученные в сетевых сообщениях от клиента.</P>
      <P>7. После завершения процедуры сервера управление возвращается заглушке сервера, которой передаются все необходимые значения.</P>
      <P>8. Заглушка сервера преобразовывает возвращаемые значения к нужному формату и рассортировывает их в сетевые сообщения для отправки обратно клиенту.</P>
      <P>9. Сообщения передаются по сети обратно клиенту. </P>
      <P>10. Заглушка клиента считывает сообщения из локального ядра (вызовом read или recvfrom).</P>
      <P>11. После возможного преобразования возвращаемых значений заглушка клиента передает их функции клиента. Этот этап воспринимается клиентом как завершение работы процедуры.</P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader234" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 16.2. Действия, происходящие при удаленном вызове процедуры</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label748 style="border:none;"></a>История</P>
      </H1>
      <P>Наверное, одна из самых старых книг по RPC — это [26]. Как пишет [4], Уайт (White) затем перешел в Xerox и там создал несколько систем RPC. Одна из них была выпущена в качестве отдельного продукта в 1981 году под именем Courier. Классической книгой по RPC является [2]. В ней описаны средства RPC проекта Cedar, работавшего на однопользовательских рабочих станциях Dorado в фирме Xerox в начале 80-х. Xerox реализовал RPC на рабочих станциях еще до того, как большинство людей узнало о том, что рабочие станции существуют! Реализация Courier для Unix распространялась много лет с версиями BSD 4.x, но в настоящий момент эта система RPC представляет только исторический интерес.</P>
      <P>Sun выпустила первую версию пакета RPC в 1985. Она была разработана Бобом Лайоном (Bob Lyon), ушедшим в Sun из фирмы Xerox в 1983. Официально она называлась ONC/RPC: Open Network Computing Remote Procedure Call (удаленный вызов процедур в открытых вычислительных сетях), но обычно ее называют просто Sun RPC. Технически она аналогична Courier. Первые версии Sun RPC были написаны с использованием интерфейса сокетов и работали с протоколами TCP и UDP. Общедоступный исходный код вышел под названием RPCSRC. В начале 90-х он был переписан под интерфейс транспортного уровня TLI (предшественник XTI), который описан в четвертой части [24]. Теперь этот код работает со всеми протоколами, поддерживаемыми ядром. Общедоступный исходный код обеих версий можно найти по адресу ftp://playground.sun.com/pub/rpc, причем версия, использующая сокеты, называется rpcsrc, а версия, использующая TLI, называется tirpcsrc (название TI-RCP образовано от Transport Independent — транспортно-независимый удаленный вызов процедур).</P>
      <P>Стандарт RFC 1831 [18] содержит обзор средств Sun RPC и описывает формат сообщений RPC, передаваемых по сети. Стандарт RFC 1832 [19] содержит описание XDR — и поддерживаемых типов данных, и формата их передачи «по проводам». Стандарт RFC 1833 [20] описывает протоколы привязки: RPCBIND и его предшественника, программу отображения портов (port mapper).</P>
      <P>Одним из наиболее распространенных приложений, использующих Sun RPC, является сетевая файловая система Sun (NFS). Обычно она не создается стандартными средствами RPC, описанными в этой главе (rpcgen и библиотека времени выполнения). Вместо этого большинство подпрограмм библиотеки оптимизируются вручную и добавляются в ядро с целью ускорить их работу. Тем не менее большинство систем, поддерживающих NFS, также поддерживают и Sun RPC.</P>
      <P>В середине 80-х Apollo соперничала с Sun за рынок рабочих станций и создала свой собственный пакет RPC, призванный вытеснить Sun RPC. Этот новый пакет назывался NCA (Network Computing Architecture — архитектура сетевых вычислений). Протоколом RPC являлся протокол NCA/RPC, а аналогом XDR была схема NDR (Network Data Representation — сетевое представление данных). Интерфейсы между клиентами и серверами определялись с помощью языка NIDL (Network Interface Definition Language — язык определений сетевого интерфейса) аналогично нашему файлу .х из листинга 16.1. Библиотека времени выполнения называлась NCK (Network Computing Kernel).</P>
      <P>Фирма Apollo была куплена Hewlett-Packard в 1989, и NCA переросла в OSF's DCE (Distributed Computing Environment — среда распределенных вычислений), основной частью которой является RPC. Более подробно о DCE можно узнать по адресу http://www.camp.opengroup.org/tech/dce. Реализация пакета DCE RPC свободно доступна на ftp://gatekeeper.dec.com/pub/DEC/DCE. Этот каталог также содержит описание внутреннего устройства пакета DCE RPC на 171 странице. Существует много версий DCE для разных платформ.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Sun RPC распространен шире, чем DCE RPC, возможно, благодаря свободно доступной реализации и включению в основную поставку большинства систем Unix. DCE RPC обычно поставляется в качестве дополнения (за дополнительную сумму). Переписывание свободно доступного кода под другие платформы пока еще не пошло полным ходом, хотя уже готовится версия для Linux. В этой главе мы опишем только средства Sun RPC. Все три пакета RPC — Courier, Sun и DCE — похожи друг на друга, поскольку основные концепции RPC остались неизменны.</P>
       <P>Большинство поставщиков Unix предоставляют отдельную подробную документацию средств RPC. Например, документация Sun доступна по адресу http://docs.sun.com, и в первом томе Developer Collection можно найти 280-страничное руководство разработчика «ONC+ Developer's Guide». Документация Digital Unix по адресу http:// www.unix.digital.com/faqs/publications/pub_page/V40D_DOCS.HTM включает 116-страничный документ под заголовком «Programming with ONC RPC».</P>
       <P>Сам по себе RPC вызывает противоречивые мнения. Восемь статей на эту тему можно найти по адресу http://www.kohala.com/~rstevens/papers.others/rpc.comments.txt.</P>
      </DIV>
      <P> В этой главе мы предполагаем наличие TI-RPC (независимая от протокола версия RPC) для большинства примеров и говорим только о протоколах TCP и UDP, хотя TI-RPC поддерживает все протоколы, какие только могут быть на данном узле. </P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label749 style="border:none;"></a>16.2. Многопоточность</P>
     </H1>
     <P>Вспомните листинг 15.6, где мы продемонстрировали автоматическое управление потоками, осуществляемое библиотекой дверей. При этом сервер по умолчанию являлся параллельным. Покажем теперь, что средства Sun RPC по умолчанию делают сервер последовательным. Начнем с примера из предыдущего раздела и изменим только процедуру сервера. В листинге 16.4 приведен текст новой функции, выводящей идентификатор потока, делающей 5-секундную паузу, выводящей идентификатор еще раз и завершающей работу.</P>
     <H2><a name=label750 style="border:none;"></a>Листинг 16.4. Процедура сервера с 5-секундной паузой</H2>
     <P><CODE>//sunrpc/square2/server.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #include "square.h"</CODE></P>
     <BR>
     <P><CODE>3  square_out *</CODE></P>
     <P><CODE>4  squareproc_1_svc(square_in *inp, struct svc_req *rqstp)</CODE></P>
     <P><CODE>5  {</CODE></P>
     <P><CODE>6   static square_out out;</CODE></P>
     <P><CODE>7   printf("thread %ld started, arg = %ld\n",</CODE></P>
     <P><CODE>8   pr_thread_id(NULL), inp-&gt;arg1);</CODE></P>
     <P><CODE>9   sleep(5);</CODE></P>
     <P><CODE>10  out.res1 = inp-&gt;arg1 * inp-&gt;arg1;</CODE></P>
     <P><CODE>11  printf("thread %ld done\n", pr_thread_id(NULL));</CODE></P>
     <P><CODE>12  return(&amp;out);</CODE></P>
     <P><CODE>13 }</CODE></P>
     <P>Запустим сервер, а после этого запустим три экземпляра программы-клиента:</P>
     <P><CODE>solaris % <STRONG>client localhost 22 &amp; client localhost 33&amp; client localhost 44 &amp;</STRONG></CODE></P>
     <P><CODE>[3] 25179</CODE></P>
     <P><CODE>[4] 25180</CODE></P>
     <P><CODE>[5] 25181</CODE></P>
     <P><CODE>solaris % result: 484 <EM>примерно через 5 секунд после появления подсказки</EM></CODE></P>
     <P><CODE>result: 1936          <EM>еще через 5 секунд</EM></CODE></P>
     <P><CODE>result: 1089          <EM>еще через 5 секунд</EM></CODE></P>
     <P>Хотя этого нельзя сказать по выводимому тексту, перед появлением очередного результата проходит примерно 5 секунд. Если мы посмотрим на текст, выводимый сервером, то увидим, что клиенты обрабатываются последовательно: сначала полностью обрабатывается запрос первого клиента, затем второго и третьего:</P>
     <P><CODE>solaris % <STRONG>server</STRONG></CODE></P>
     <P><CODE>thread 1 started, arg = 22</CODE></P>
     <P><CODE>thread 1 done</CODE></P>
     <P><CODE>thread 1 started, arg = 44</CODE></P>
     <P><CODE>thread 1 done</CODE></P>
     <P><CODE>thread 1 started, arg = 33</CODE></P>
     <P><CODE>thread 1 done</CODE></P>
     <P>Один и тот же поток обслуживает все запросы клиентов. Сервер не является многопоточным по умолчанию.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Серверы дверей в главе 15 работали не в фоновом режиме, а запускались из интерпретатора. Это давало нам возможность добавлять отладочные вызовы printf в процедуры сервера. Однако серверы Sun RPC по умолчанию являются демонами и выполняют действия так, как это описано в разделе 12.4 [24]. Это требует вызова syslog из процедуры сервера для вывода диагностической информации. Однако мы указали флаг –DDEBUG при компиляции нашего сервера, что эквивалентно определению</P>
      <P><CODE>#define DEBUG</CODE></P>
      <P>в заглушке сервера (файле square_svc.c, создаваемом rpcgen). Это запрещает функции main становиться демоном и оставляет ее подключенной к терминалу, в котором она была запущена. Поэтому мы можем спокойно вызывать printf из процедуры сервера.</P>
     </DIV>
     <P>Возможность создания многопоточного сервера появилась в Solaris 2.4 и реализуется добавлением параметра –М в строку вызова rpcgen. Это делает код, создаваемый rpcgen, защищенным. Другой параметр, –А, позволяет автоматически создавать потоки по мере необходимости для обслуживания запросов клиентов. Мы включаем оба параметра при вызове rpcgen.</P>
     <P>Однако для реализации многопоточности требуется внести изменения в текст клиента и сервера, чего мы могли ожидать, поскольку использовали тип static в листинге 16.3. Единственное изменение, которое нужно внести в файл square.х, — сменить номер версии с 1 на 2. В объявлениях аргументов процедуры и результатов ничего не изменится.</P>
     <P>В листинге 16.5 приведен текст новой программы-клиента.</P>
     <H2><a name=label751 style="border:none;"></a>Листинг 16.5. Функция main клиента многопоточного сервера</H2>
     <P><CODE>//sunrpc/square3/client.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #include "square.h"</CODE></P>
     <BR>
     <P><CODE>3  int</CODE></P>
     <P><CODE>4  main(int argc, char **argv)</CODE></P>
     <P><CODE>5  {</CODE></P>
     <P><CODE>6   CLIENT *cl;</CODE></P>
     <P><CODE>7   square_in in;</CODE></P>
     <P><CODE>8   square_out out;</CODE></P>
     <P><CODE>9   if (argc != 3)</CODE></P>
     <P><CODE>10   err_quit("usage: client &lt;hostname&gt; &lt;integer-value&gt;");</CODE></P>
     <P><CODE>11  cl = Clnt_create(argv[1], SQUARE_PROG, SQUARE_VERS, "tcp");</CODE></P>
     <P><CODE>12  in.arg1 = atol(argv[2]);</CODE></P>
     <P><CODE>13  if (squareproc_2(&amp;in, &amp;out, cl) != RPC_SUCCESS)</CODE></P>
     <P><CODE>14   err_quit("%s", clnt_sperror(cl, argv[1]));</CODE></P>
     <P><CODE>15  printf("result: %ld\n", out.res1);</CODE></P>
     <P><CODE>16  exit(0);</CODE></P>
     <P><CODE>17 }</CODE></P>
     <H2><a name=label752 style="border:none;"></a>Объявление переменной для помещения результата</H2>
     <P>8 Мы объявляем переменную типа square_out, а не указатель на нее. </P>
     <H2><a name=label753 style="border:none;"></a>Новый аргумент в вызове процедуры</H2>
     <P>12-14 Вторым аргументом вызова squareproc_2 становится указатель на переменную out, а последним аргументом является дескриптор клиента. Вместо возвращения указателя на результат (как в листинге 16.2) эта функция будет возвращать либо RPC_SUCCESS, либо некоторое другое значение в случае возникновения ошибок. Перечисление enumclnt_stat в заголовочном файле &lt;rpc/clnt_stat.h&gt; содержит все возможные коды ошибок.</P>
     <P>В листинге 16.6 приведен текст новой процедуры сервера. Как и программа из листинга 16.4, эта версия выводит идентификатор потока, ждет 5 секунд, а затем завершает работу.</P>
     <H2><a name=label754 style="border:none;"></a>Листинг 16.6. Процедура многопоточного сервера</H2>
     <P><CODE>//sunrpc/square3/server.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #include "square.h"</CODE></P>
     <BR>
     <P><CODE>3  bool_t</CODE></P>
     <P><CODE>4  squareproc_2_svc(square_in *inp, square_out *outp, struct svc_req *rqstp)</CODE></P>
     <P><CODE>5  {</CODE></P>
     <P><CODE>6   printf("thread %Id started, arg = %ld\n",</CODE></P>
     <P><CODE>7   pr_thread_id(NULL), inp-&gt;arg1);</CODE></P>
     <P><CODE>8   sleep(5);</CODE></P>
     <P><CODE>9   outp-&gt;res1 = inp-&gt;arg1 * inp-&gt;arg1;</CODE></P>
     <P><CODE>10  printf("thread %ld done\n", pr_thread_id(NULL));</CODE></P>
     <P><CODE>11  return(TRUE);</CODE></P>
     <P><CODE>12 }</CODE></P>
     <BR>
     <P><CODE>13 int</CODE></P>
     <P><CODE>14 square_prog_2_freeresult(SVCXPRT *transp, xdrproc_t xdr_result,</CODE></P>
     <P><CODE>15 caddr_t result)</CODE></P>
     <P><CODE>16 {</CODE></P>
     <P><CODE>17  xdr_free(xdr_result, result);</CODE></P>
     <P><CODE>18  return(1);</CODE></P>
     <P><CODE>19 }</CODE></P>
     <H2><a name=label755 style="border:none;"></a>Новые аргументы и возвращаемое значение</H2>
     <P>3-12 Требуемые для реализации многопоточности изменения включают изменение аргументов функций и возвращаемого значения. Вместо возвращения указателя на структуру результатов (как в листинге 16.3) указатель на эту структуру принимается в качестве второго аргумента функции. Указатель на структуру svc_req смещается на третью позицию. Теперь при успешном завершении функции возвращается значение TRUE, а при возникновении ошибок — FALSE.</P>
     <H2><a name=label756 style="border:none;"></a>Новая функция, освобождающая память XDR</H2>
     <P>13-19 Еще одно изменение заключается в добавлении функции, освобождающей все автоматически выделенные переменные. Эта функция вызывается из заглушки сервера после завершения работы процедуры сервера и отправки результата клиенту. В нашем примере просто делается вызов подпрограммы xdr_free (о ней будет говориться более подробно в связи с листингом 16.19 и упражнением 16.10). </P>
     <P>Если процедура сервера выделяла память под сохраняемый результат (например, в виде связного списка), этот вызов освободит занятую память.</P>
     <P>Создадим программу-клиент и программу-сервер и запустим три экземпляра клиента одновременно:</P>
     <P><CODE>solaris % <STRONG>client localhost 55 &amp; client localhost 66 &amp; client localhost 77 &amp;</STRONG></CODE></P>
     <P><CODE>[3] 25427</CODE></P>
     <P><CODE>[4] 25428</CODE></P>
     <P><CODE>[5] 25429</CODE></P>
     <P><CODE>solaris % result: 4356</CODE></P>
     <P><CODE>result: 3025</CODE></P>
     <P><CODE>result: 5929</CODE></P>
     <P>На этот раз мы видим, что результаты выводятся одновременно, один за другим. Взглянув на выводимый сервером текст, отметим, что используются три серверных потока и все они выполняются одновременно:</P>
     <P><CODE>solaris % <STRONG>server</STRONG></CODE></P>
     <P><CODE>thread 1 started, arg = 55</CODE></P>
     <P><CODE>thread 4 started, arg = 77</CODE></P>
     <P><CODE>thread 6 started, arg = 66</CODE></P>
     <P><CODE>thread 6 done</CODE></P>
     <P><CODE>thread 1 done</CODE></P>
     <P><CODE>thread 4 done</CODE></P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Одним из печальных следствий изменений, требуемых для реализации многопоточности, является уменьшение количества систем, поддерживающих новый код. Например, в Digital Unix 4.0B и BSD/OS 3.1 используется старая система RPC, не поддерживающая многопоточность. Это означает, что если мы хотим компилировать и использовать нашу программу в системах обоих типов, нам нужно использовать условия #ifdef для обработки различий в вызовах клиента и сервера. Конечно, клиент в BSD/OS, не являющийся многопоточным, может вызвать процедуру многопоточного сервера в Solaris, но если мы хотим, чтобы клиент или сервер компилировался в обоих типах систем, исходный код нужно изменить, предусмотрев различия.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label757 style="border:none;"></a>16.3. Привязка сервера</P>
     </H1>
     <DIV class=section>
      <P>В описании листинга 16.5 мы достаточно бегло прошлись по действиям, выполняемым на нулевом этапе: регистрация сервера в локальной программе отображения портов и определение клиентом адреса порта не были разобраны детально. Отметим прежде всего, что на любом узле с сервером RPC должна выполняться программа port mapper (отображение портов). Этой программе присваивается адрес порта TCP 111 и UDP 111, и это единственные фиксированные значения портов Интернета для Sun RPC. Серверы RPC всегда связываются с временным портом, а затем регистрируют его в локальной службе отображения портов. После запуска клиент должен связаться с программой отображения портов, узнать номер временного порта сервера, а затем связаться с самим сервером через этот порт. Программа отображения портов предоставляет также службу имен, область действия которой ограничена системой.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Некоторые читатели могут возразить, что сетевая файловая система также имеет фиксированный номер порта 2049. Хотя во многих реализациях по умолчанию действительно используется именно этот порт, а в некоторых старых реализациях он вообще жестко «зашит» в клиентскую и серверную части NFS, большинство существующих реализаций позволяют использовать и другие порты. Большая часть клиентов NFS также связывается со службой отображения портов для получения номера порта.</P>
       <P>В Solaris 2.x Sun переименовала службу отображения портов в RPCBIND. Причина этого изменения заключается в том, что термин «порт» подразумевает порт Интернета, тогда как пакет TI-RPC может работать с любым сетевым протоколом, а не только с TCP и UDP. Мы будем использовать традиционное название «программа отображения портов» (port mapper). Далее в этой главе мы будем подразумевать, что на данном узле поддерживаются только протоколы TCP и UDP.</P>
      </DIV>
      <P>Сервер и клиент работают следующим образом:</P>
      <P>1. При переходе системы в многопользовательский режим запускается пpoгрaммa отображения портов. Исполняемый файл этого демона обычно называется portmap или rpcbind.</P>
      <P>2. При запуске сервера его функция main, являющаяся частью заглушки сервера, создаваемой rpcgen, вызывает библиотечную функцию svc_create. Эта функция выясняет, какие сетевые протоколы поддерживаются узлом, и создает конечную точку (например, сокет) для каждого протокола, связывая временные порты с конечными точками протоколов TCP и UDP. Затем она связывается с локальной пpoгрaммoй отображения портов для регистрации временных номеров портов TCP и UDP вместе с номером программы и номером версии.</P>
      <P>Сама программа отображения портов также представляет собой программу RPC, и сервер регистрируется с помощью вызовов RPC (обращенных к известному порту 111). Описание процедур, поддерживаемых пpoгрaммoй отображения портов, дается в стандарте RFC 1833 [20]. Существуют три версии этой программы RPC: вторая версия работает только с портами TCP и UDP, а версии <STRONG>3</STRONG>и 4 представляют собой новые версии, работающие по протоколу RPCBIND.</P>
      <P>Можно получить список всех пpoгрaмм RPC, зарегистрированных в пpoгрaм-ме отображения портов, запустив пpoгрaммy rpcinfo. Мы можем запустить эту программу, чтобы убедиться, что порт с номером 111 используется самой программой отображения портов:</P>
      <P><CODE>solaris % <STRONG>rpcinfo –p</STRONG></CODE></P>
      <P><CODE>program vers proto port service</CODE></P>
      <P><CODE>100000 4 tcp 111 rpcbind</CODE></P>
      <P><CODE>100000 3 tcp 111 rpcbind</CODE></P>
      <P><CODE>100000 2 tcp 111 rpcbind</CODE></P>
      <P><CODE>100000 4 udp 111 rpcbind</CODE></P>
      <P><CODE>100000 3 udp 111 rpcbind</CODE></P>
      <P><CODE>100000 2 udp 111 rpcbind</CODE></P>
      <P>(Мы исключили множество несущественных в данный момент строк вывода.) Мы видим, что Solaris 2.6 поддерживает все три версии протокола, все на порте 111, причем как TCP, так и UDP. Соответствие номеров пpoгрaмм RPC их именам обычно устанавливается в файле /etc/rpc. Запустив ту же программу в BSD/OS 3.1, увидим, что в этой системе поддерживается только вторая версия программы отображения портов:</P>
      <P><CODE>bsdi % <STRONG>rpcinfo –p</STRONG></CODE></P>
      <P><CODE>program vers proto port</CODE></P>
      <P><CODE>100000 2 tcp 111 portmapper</CODE></P>
      <P><CODE>100000 2 udp 111 portmapper</CODE></P>
      <P>В Digital Unix 4.0В также поддерживается только вторая версия:</P>
      <P><CODE>alpha % <STRONG>rpcinfo –p</STRONG></CODE></P>
      <P><CODE>program vers proto port</CODE></P>
      <P><CODE>100000 2 tcp 111 portmapper</CODE></P>
      <P><CODE>100000 2 udp 111 portmapper</CODE></P>
      <P>Затем процесс сервера приостанавливает работу, ожидая поступления запросов от клиентов. Это может быть новое соединение TCP или приход дей-тaгрaммы UDP в порт UDP. Если мы запустим rpcinfo после запуска сервера из листинга 16.3, мы увидим следующий результат:</P>
      <P><CODE>solaris % <STRONG>rpcinfo –p</STRONG></CODE></P>
      <P><CODE>program vers proto port service</CODE></P>
      <P><CODE>8243773444 1 udp</CODE></P>
      <P><CODE>8243773444 1 tcp</CODE></P>
      <P>где 824377344 соответствует 0x31230000 (номер пpoгрaммы, присвоенный ей в листинге 16.1). В том же листинге мы присвоили программе номер версии 1. Обратите внимание, что сервер готов принимать запросы от клиентов по протоколам TCP и UDP и клиент может выбирать, какой из этих протоколов он будет использовать при создании дескриптора клиента (последний аргумент clnt_create в листинге 16.2).</P>
      <P>3. Клиент запускается и вызывает clnt_create. Аргументами (листинг 16.2) являются имя узла или IP-адрес сервера, номер пpoгрaммы, номер версии и строка, указывающая протокол связи. Запрос RPC направляется пpoгрaммe отображения портов узла сервера (для этого сообщения обычно используется протокол UDP), причем запрашивается информация об указанной версии указанной программы с указанным протоколом. В случае успеха номер порта сохраняется в дескрипторе клиента для обработки всех последующих вызовов RPC через этот дескриптор.</P>
      <P>В листинге 16.1 мы присвоили нашей программе номер 0x31230000. 32-разрядные номера пpoгрaмм подразделяются на группы, приведенные в табл. 16.1.</P>
      <BR>
      <P>Таблица 16.1. Диапазоны номеров программ для Sun RPC </P>
      <TABLE>
       <TR ALIGN=left >
        <TH ALIGN=left VALIGN=top >Номер программы</TH>
        <TH ALIGN=left VALIGN=top >Описание</TH>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >0x00000000–0x1fffffff</TD>
        <TD ALIGN=left VALIGN=top >Определена Sun</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >0x20000000–0x3fffffff</TD>
        <TD ALIGN=left VALIGN=top >Определена пользователем</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >0x40000000–0x5fffffff</TD>
        <TD ALIGN=left VALIGN=top >Временная (для приложений, написанных заказчиком)</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >0x60000000–0xffffffff</TD>
        <TD ALIGN=left VALIGN=top >Зарезервированы</TD>
       </TR>
      </TABLE>
      <P>Пpoгрaммa rpcinfо выводит список программ, зарегистрированных в системе. Другим источником информации о пpoгрaммax RPC могут являться файлы с расширением .х в каталоге /usr/inciude/rpcsvc.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label758 style="border:none;"></a>Inetd и серверы RPC</P>
      </H1>
      <P>По умолчанию серверы, созданные с помощью rpcgen, могут вызываться сервером верхнего уровня inetd. Этот сервер описывается в разделе 12.5 [24]. Изучение содержимого заглушки сервера, создаваемой rpcgen, показывает, что при запуске функции main сервера она проверяет, является ли стандартный поток ввода конечной точкой XTI, и если так, то предполагается, что сервер был запущен демоном inetd.</P>
      <P>После создания сервера RPC, который будет вызываться inetd, следует добавить информацию об этом сервере в файл /etc/inetd.conf. Туда помещаются следующие данные: имя программы RPC, поддерживаемые номера программ, протоколы и полное имя исполняемого файла сервера. В качестве примера мы приводим строку из конфигурационного файла Solaris:</P>
      <P><CODE>rstatd/2-4 tli rpc/datagram_v wait root /usr/lib/netsvc/rstat/rpc.rstatd rpc.rstatd</CODE></P>
      <P>Первое поле содержит имя пpoгрaммы (которому будет сопоставлен номер с помощью файла /etc/rpc); поддерживаются версии 2, 3 и 4. Следующее поле задает конечную точку XTI (или сокет), третье поле говорит о том, что поддерживаются все протоколы видимых дeйтaгрaмм. Если свериться с содержимым файла /etc/netconfig, мы узнаем, что таких протоколов два: UDP и /dev/clts. Глава 29 [24] описывает этот файл и адреса XTI. Четвертое поле (wait) указывает демону inetd на необходимость ожидания завершения этого сервера перед включением режима ожидания запроса клиента для конечной точки XTI. Все серверы RPC указывают атрибут wait в конфигурационном файле /etc/inetd.conf.</P>
      <P>Следующее поле, root, указывает идентификатор пользователя, с которым будет выполняться пpoгрaммa. Последние два поля задают полное имя исполняемого файла пpoгрaммы и имя пpoгрaммы вместе с необходимыми аргументами командной строки (у данной пpoгрaммы они отсутствуют).</P>
      <P>Демон inetd создаст конечные точки XTI и зарегистрирует их в программе отображения портов для соответствующих номеров пpoгрaмм и версий. Мы можем убедиться в этом с помощью rpcinfo:</P>
      <P><CODE>solaris % <STRONG>rpcinfo | grep statd</STRONG></CODE></P>
      <P><CODE>100001 2 udp    0.0.0.0.128.11 rstatd superuser</CODE></P>
      <P><CODE><CODE>100001 3 </CODE>udp    0.0.0.0.128.11 rstatd superuser</CODE></P>
      <P><CODE><CODE>100001 4 </CODE>udp    0.0.0.0.128.11 rstatd superuser</CODE></P>
      <P><CODE><CODE>100001 2 </CODE>ticlts \000\000\020.  rstatd superuser</CODE></P>
      <P><CODE><CODE>100001 3 </CODE>ticlts \000\000\020.  rstatd superuser</CODE></P>
      <P><CODE><CODE>100001 4 </CODE>ticlts \000\000\020.  rstatd superuser</CODE></P>
      <P>Четвертое поле содержит адреса XTI, причем 128×256+11 = 32779, и данное значение является временным номером порта, присвоенным этой концевой точке UDP.</P>
      <P>Когда дейтаграмма UDP поступает в порт 32779, демон inetd обнаруживает готовность этой дейтаграммы к обработке и вызывает fork, а затем exec для запуска программы /usr/lib/netsvc/rstat/rpc.rstatd. Перед вызовами fork и exec концевая точка XTI будет скопирована в дескрипторы 0, 1 и 2, а все прочие дескрипторы inetd будут закрыты (рис. 12.7 [24]). Демон inetd также прекратит слушать эту конечную точку XTI, не реагируя на запросы пользователей до тех пор, пока сервер (дочерний процесс по отношению к inetd) не завершит работу. Это поведение определяется атрибутом wait.</P>
      <P>Предположим, что эта программа была создана с помощью rpcgen. Тогда она сможет распознать конечную точку XTI, подключенную к стандартному потоку ввода, и инициализировать ее как конечную точку сервера RPC. Это осуществляется вызовом функций RPC svc_tli_create и svc_reg, которые в данной книге не рассматриваются. Вторая функция (вопреки названию) не регистрирует сервер в программе отображения портов — это делается лишь однажды, при запуске сервера. Функция svc_run прочитает пришедшую дейтаграмму и вызовет соответствующую процедуру сервера для обработки запроса клиента.</P>
      <P>В обычной ситуации серверы, запускаемые демоном inetd, обрабатывают один запрос клиента и завершают работу, после чего inetd переходит в режим ожидания следующего запроса. Для оптимизации работы системы серверы RPC, созданные rpcgen, ждут поступления нового запроса от клиента в течение некоторого времени (по умолчанию 2 минуты). В этом случае дейтаграмма обрабатывается уже запущенным сервером. Это исключает накладные расходы на вызов fork и exec при поступлении нескольких клиентских запросов подряд. По истечении периода ожидания сервер завершает работу, а демону inetd отсылается сигнал SIGCHLD, после чего он переходит в режим ожидания дейтаграмм по XTI.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label759 style="border:none;"></a>16.4. Аутентификация</P>
     </H1>
     <P>По умолчанию в запросе RPC не содержится информации о клиенте. Сервер отвечает на запрос клиента, не беспокоясь о том, что это за клиент. Это называется нулевой аутентификацией, или AUTH_NONE.</P>
     <P>Следующий уровень проверки подлинности называется аутентификацией Unix, или AUTH_SYS. Клиент должен сообщить библиотеке RPC времени выполнения информацию о себе (имя узла, действующий идентификатор пользователя, действующий идентификатор группы, дополнительные идентификаторы группы) для включения в каждый запрос. Изменим программу из листинга 16.2 таким образом, чтобы она включала возможность осуществления аутентификации Unix. В листинге 16.7 приведен новый текст программы-клиента.</P>
     <H2><a name=label760 style="border:none;"></a>Листинг 16.7. Клиент, осуществляющий аутентификацию unix</H2>
     <P><CODE>//sunrpc/square4/client.с</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #include "square.h"</CODE></P>
     <BR>
     <P><CODE>3  int</CODE></P>
     <P><CODE>4  main(int argc, char **argv)</CODE></P>
     <P><CODE>5  {</CODE></P>
     <P><CODE>6   CLIENT *cl;</CODE></P>
     <P><CODE>7   square_in in;</CODE></P>
     <P><CODE>8   square_out out;</CODE></P>
     <P><CODE>9   if (argc != 3)</CODE></P>
     <P><CODE>10   err_quit("usage: client &lt;hostname&gt; &lt;integer-value&gt;");</CODE></P>
     <P><CODE>11  cl = Clnt_create(argv[1], SQUARE_PROG, SQUARE_VERS, "tcp");</CODE></P>
     <P><CODE>12  auth_destroy(cl-&gt;cl_auth);</CODE></P>
     <P><CODE>13  cl-&gt;cl_auth = authsys_create_default();</CODE></P>
     <P><CODE>14  in.arg1 = atol(argv[2]);</CODE></P>
     <P><CODE>15  if (squareproc_2(&amp;in, &amp;out, cl) != RPC_SUCCESS)</CODE></P>
     <P><CODE>16   err_quit("%s", clnt_sperror(cl, argv[1]));</CODE></P>
     <P><CODE>17  printf("result: %ld\n", out.resl);</CODE></P>
     <P><CODE>18  exit(0);</CODE></P>
     <P><CODE>19 }</CODE></P>
     <P>12-13 Эти строки были добавлены в данной версии программы. Сначала мы вызываем auth_destroy для удаления предыдущей аутентификационной информации, связанной с данным дескриптором клиента (то есть дескриптор нулевой аутентификации, создаваемый по умолчанию). Затем вызов authsys_create_default создает соответствующую аутентификационную структуру Unix и мы сохраняем ее в поле cl_auth структуры CLIENT. Оставшаяся часть клиента не претерпела изменений по сравнению с листингом 16.5.</P>
     <P>В листинге 16.8 приведен текст процедуры сервера, измененный по сравнению с листингом 16.6. Мы не приводим текст процедуры square_prog_2_freeresult, которая не меняется.</P>
     <H2><a name=label761 style="border:none;"></a>Листинг 16.8. Процедура сервера, запрашивающая аутентификацию Unix</H2>
     <P><CODE>//sunrpc/square4/server.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #include "square.h"</CODE></P>
     <BR>
     <P><CODE>3  bool_t</CODE></P>
     <P><CODE>4  squareproc_2_svc(square_in *inp, square_out *outp, struct svc_req *rqstp)</CODE></P>
     <P><CODE><EM>5</EM>  {</CODE></P>
     <P><CODE>6   printf("thread %Id started, arg = %ld, auth = %d\n",</CODE></P>
     <P><CODE>7   pr_thread_id(NULL), inp-&gt;arg1, rqstp-&gt;rq_cred.oa_flavor);</CODE></P>
     <P><CODE>8   if (rqstp-&gt;rq_cred.oa_flavor == AUTH_SYS) {</CODE></P>
     <P><CODE>9    struct authsys_parms *au;</CODE></P>
     <P><CODE>10   au = (struct authsys_parms *)rqstp-&gt;rq_clntcred;</CODE></P>
     <P><CODE>11   printf("AUTH_SYS: host %s, uid %ld, gid %ld\n",</CODE></P>
     <P><CODE>12    au-&gt;aup_machname, (long) au-&gt;aup_uid, (long) au-&gt;aup_gid);</CODE></P>
     <P><CODE>13  }</CODE></P>
     <P><CODE>14  sleep(5);</CODE></P>
     <P><CODE>15  outp-&gt;res1 = inp-&gt;arg1 * inp-&gt;arg1;</CODE></P>
     <P><CODE>16  printf("thread %ld done\n", pr_thread_id(NULL));</CODE></P>
     <P><CODE>17  return(TRUE);</CODE></P>
     <P><CODE>18 }</CODE></P>
     <P>6-8 Теперь мы используем указатель на структуру svc_req, которая всегда передается в качестве одного из аргументов процедуры сервера:</P>
     <P><CODE>struct svc_req {</CODE></P>
     <P><CODE> u_long rq_prog; /* номер программы */</CODE></P>
     <P><CODE> u_long rq_vers; /* номер версии */</CODE></P>
     <P><CODE> u_long rq_proc; /* номер процедуры */</CODE></P>
     <P><CODE> struct opaque_auth rq_cred:/* данные о клиенте */</CODE></P>
     <P><CODE> caddr_t rq_clntcred; /* готовые данные (только для чтения) */</CODE></P>
     <P><CODE> SVCXPRT *rq_xprt; /* транспортный дескриптор */</CODE></P>
     <P><CODE>};</CODE></P>
     <BR>
     <P><CODE>struct opaque_auth {</CODE></P>
     <P><CODE> enum_t oa_flavor; /* flavor: константа AUTH_xxx */</CODE></P>
     <P><CODE> caddr_t oa_base; /* адрес дополнительной аутентификационной информации */</CODE></P>
     <P><CODE> u_int oa_length; /* не должно превосходить MAX_AUTH_BYTES */</CODE></P>
     <P><CODE>};</CODE></P>
     <P>Поле rq_cred содержит неформатированную информацию о клиенте, а его поле oa_flavor содержит целое число, определяющее тип аутентификации. Термин «неформатированная» означает, что библиотека не обработала информацию, на которую указывает oa_base. Но если тип идентификации относится к одному из поддерживаемых библиотекой, то в готовой информации о клиенте, на которую указывает rq_clntcred, содержится некоторая структура, соответствующая данному типу аутентификации. Программа выводит тип аутентификации и прове-9_12 ряет, соответствует ли он AUTH_SYS.</P>
     <P>Для аутентификации Unix указатель на готовую информацию (rq_clntcred) указывает на структуру authsys_parms, содержащую информацию о клиенте:</P>
     <P><CODE>struct authsys_parms {</CODE></P>
     <P><CODE> u_long aup_time; /* время создания информации */</CODE></P>
     <P><CODE> char *aup_machname; /* имя узла клиента */</CODE></P>
     <P><CODE> uid_t aup_uid; /* действующий идентификатор пользователя */</CODE></P>
     <P><CODE> gid_t aup_gid; /* действующий идентификатор группы */</CODE></P>
     <P><CODE> u_int aup_len; /* количество элементов в aup_gids[] */</CODE></P>
     <P><CODE> gid_t *aup_gidsl; /* дополнительные идентификаторы группы */</CODE></P>
     <P><CODE>};</CODE></P>
     <P>Мы получаем указатель на эту структуру и выводим имя узла клиента, его EUID и EGID.</P>
     <P>Запустив сервер и один экземпляр клиента, посмотрим на выводимый сервером текст:</P>
     <P><CODE>solaris % <STRONG>server</STRONG></CODE></P>
     <P><CODE>thread 1 started, arg = 44, auth = 1</CODE></P>
     <P><CODE>AUTH_SYS: host solaris.kohala.com, uid 765, gid 870</CODE></P>
     <P><CODE>thread 1 done</CODE></P>
     <P>Аутентификация Unix используется редко, поскольку ее легко обойти. Мы можем легко построить собственные пакеты RPC, содержащие аутентификационную информацию в формате Unix, присвоив идентификатору пользователя и группы произвольные значения, и отправить их на сервер. Сервер никак не может проверить, те ли мы, кем представляемся.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Вообще-то NFS по умолчанию использует именно аутентификацию Unix, но запросы обычно отсылаются ядром клиента NFS через зарезервированный порт (раздел 2.7 [24]). Некоторые серверы NFS настроены так, чтобы отвечать только на запросы, поступающие по зарезервированному порту. Если вы доверяете узлу клиента подключение к своим файловым системам, вы доверяете и его ядру в том, что оно правильно предоставляет информацию о своих пользователях. Если сервер не требует подключения по резервному порту, хакеры могут написать свою собственную программу, которая будет посылать запросы серверу NFS с произвольным идентификатором пользователя. Даже если сервер требует подключения по зарезервированному порту, а у вас есть своя система, в которой вы обладаете правами привилегированного пользователя, и вы можете подключиться к сети, вы сможете отправлять свои собственные запросы с произвольным содержимым на сервер NFS. </P>
     </DIV>
     <P>Пакеты RPC — как запросы, так и ответы — содержат два поля, относящиеся к аутентификации: данные о пользователе и проверочную информацию (credentials, verifier). Примером такой структуры является документ с фотографией (паспорт, права и т. п.). Данные о пользователе соответствуют написанному в паспорте тексту (имя, адрес, дата рождения и т. п.), а проверочная информация — это фотография. Существуют разные формы проверочной информации: фотография в данном случае полезнее, чем, например, рост, вес и пол. Если документ не содержит проверочной информации (как, например, читательский билет в библиотеке), любой может воспользоваться им и сказать, что он его владелец.</P>
     <P>В случае нулевой аутентификации пакеты не содержат ни данных о пользователе, ни проверочной информации. В режиме аутентификации Unix данные о пользователе содержат имя узла, идентификаторы пользователя и группы, но поле проверочной информации пусто. Поддерживаются, однако, и другие формы аутентификации, для которых эти два поля содержат другую информацию.</P>
     <P>■ AUTH_SHORT — альтернативная форма аутентификации Unix, отправляемая сервером в поле verifier в ответ на запрос клиента. Она содержит меньшее количество информации, чем в режиме аутентификации Unix, и клиент может отсылать ее серверу при последующих запросах. Используется для уменьшения количества передаваемой по сети информации.</P>
     <P>■ AUTH_DES — аббревиатура DES означает Data Encryption Standard (стандарт шифрования данных). Эта форма аутентификации основана на использовании криптографии с секретным и открытым ключом. Эта схема также называется защищенным RPC (secure RPC), а если она используется в качестве основы для построения NFS, то такая NFS также называется защищенной.</P>
     <P>■ AUTH_KERB — эта схема основана на стандарте Kerberos института MIT.</P>
     <P>В главе 19 книги [5] подробно рассказывается о двух последних формах аутентификации, включая их настройку и использование.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label762 style="border:none;"></a>16.5. Тайм-аут и повторная передача</P>
     </H1>
     <DIV class=section>
      <P>Рассмотрим стратегию обработки тайм-аутов и повторной передачи, используемую в средствах Sun RPC. Существуют два значения тайм-аутов:</P>
      <P>1. Общий тайм-аут определяет время ожидания ответа сервера клиентом. Это значение используется протоколами TCP и UDP.</P>
      <P>2. Тайм-аут повтора используется только UDP и определяет время ожидания между повторами запросов клиента, если ответ от сервера не приходит.</P>
      <P>Для протокола TCP необходимость во введении тайм-аута повтора отсутствует, поскольку этот протокол является надежным. Если сервер Не получает запроса от клиента, время ожидания по протоколу TCP со стороны клиента закончится и клиент повторит передачу. Когда сервер получает запрос клиента, он уведомляет об этом последний. Если уведомление о получении будет утрачено по пути к клиенту, тот должен будет еще раз переслать запрос. Повторные запросы сбрасываются сервером, но уведомления об их получении отсылаются клиенту. В надежных протоколах правильность доставки (время ожидания, повторная передача, обработка лишних копий данных и лишних уведомлений) обеспечивается на транспортном уровне и не входит в задачи библиотеки RPC. Один запрос, отправленный клиентом на уровне RPC, будет получен сервером ровно в одном экземпляре на уровне RPC. В противном случае клиент RPC получит сообщение о невозможности связаться с сервером. При этом совершенно не важно, что происходит на сетевом и транспортном уровнях.</P>
      <P>После создания дескриптора клиента можно использовать функцию clnt_control для получения информации и изменения свойств клиента. Эта функция работает аналогично fcntl для дескрипторов файлов или getsockopt и setsockopt для сокетов:</P>
      <P><CODE>#include &lt;rpc/rpc.h&gt;</CODE></P>
      <P><CODE>bool_t clnt_control(CLIENT <EM>*cl,</EM> unsigned int <EM>request,</EM> char <EM>*ptr</EM>);</CODE></P>
      <P><CODE>/* Возвращает TRUE в случае успешного завершения, FALSE – в случае ошибки */</CODE></P>
      <P>Здесь <EM>cl</EM> представляет собой дескриптор клиента, а на что указывает <EM>ptr —</EM> зависит от значения <EM>request.</EM></P>
      <P>Изменим программу-клиент из листинга 16.2, добавив в нее вызов данной функции, и выведем значения тайм-аутов. В листинге 16.9 приведен текст новой программы-клиента.</P>
      <H2><a name=label763 style="border:none;"></a>Листинг 16.9. Клиент, получающий и печатающий значения времени ожидания RPC</H2>
      <P><CODE>//sunrpc/square5/client.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "square.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   CLIENT *cl;</CODE></P>
      <P><CODE>7   square_in in;</CODE></P>
      <P><CODE>8   square_out *outp;</CODE></P>
      <P><CODE>9   struct timeval tv;</CODE></P>
      <P><CODE>10  if (argc != 4)</CODE></P>
      <P><CODE>11   err_quit("usage: client &lt;hostname&gt; &lt;integer-value&gt; &lt;protocol&gt;");</CODE></P>
      <P><CODE>12  cl = Clnt_create(argv[1], SQUARE_PROG, SQUARE_VERS, argv[3]);</CODE></P>
      <P><CODE>13  Clnt_control(cl, CLGET_TIMEOUT, (char*)&amp;tv);</CODE></P>
      <P><CODE>14  printf("timeout = %ld sec, %ld usec\n", tv.tv_sec, tv.tv_usec);</CODE></P>
      <P><CODE>15  if (clnt_control(cl, CLGET_RETRY_TIMEOUT, (char *) &amp;tv) == TRUE)</CODE></P>
      <P><CODE>16   printf("retry timeout = %ld sec, %ld usec\n", tv.tv_sec, tv.tv_usec);</CODE></P>
      <P><CODE>17  in.arg1 = atol(argv[2]);</CODE></P>
      <P><CODE>18  if ((outp = squareproc_1(&amp;in, cl)) == NULL)</CODE></P>
      <P><CODE>19   err_quit("%s", clnt_sperror(cl, argv[1]));</CODE></P>
      <P><CODE>20  printf(result: %ld\n", outp-&gt;res1);</CODE></P>
      <P><CODE>21  exit(0);</CODE></P>
      <P><CODE>22 }</CODE></P>
      <H2><a name=label764 style="border:none;"></a>Используемый протокол является аргументом командной строки</H2>
      <P>10-12 Теперь протокол, являющийся последним аргументом clnt_create, указывается в качестве нового параметра командной строки.</P>
      <H2><a name=label765 style="border:none;"></a>Получение значения общего тайм-аута</H2>
      <P>13-14 Первым аргументом clnt_control является дескриптор клиента, вторым — тип запроса, а третьим — указатель на буфер. Наш первый запрос имеет значение CLGET_TIMEOUT; при этом возвращается значение общего тайм-аута в структуре timeval, адрес которой передается третьим аргументом. Этот запрос корректен для всех протоколов.</P>
      <H2><a name=label766 style="border:none;"></a>Попытка получения тайм-аута повтора</H2>
      <P>15-16 Следующий запрос имеет значение CLGET_RETRY_TIMEOUT. При этом должно возвращаться значение тайм-аута повтора, но этот запрос корректен только для протокола UDP. Следовательно, если функция возвращает значение FALSE, мы ничего не печатаем.</P>
      <P>Изменим также и программу-сервер, добавив в нее ожидание продолжительностью 1000 секунд вместо 5, чтобы гарантировать получение тайм-аута по запросу клиента. Запустим сервер на узле bsdi, а клиент запустим дважды, один раз указав в качестве протокола TCP, а другой — UDP. Результат будет не таким, как мы ожидали:</P>
      <P><CODE>solaris % <STRONG>date ; client bsdi 44 tcp ; date</STRONG></CODE></P>
      <P><CODE>Wed Apr 22 14:46:57 MST 1998</CODE></P>
      <P><CODE>timeout = 30 sec, 0 usec       <EM>тайм-аут 30 секунд</EM></CODE></P>
      <P><CODE>bsdi: RPC: Timed out</CODE></P>
      <P><CODE>Wed Apr 22 14:47:22 MST 1998   <EM>но прошло только 25 секунд</EM></CODE></P>
      <P><CODE>solaris % <STRONG>date ; client bsdi 55 udp ; date</STRONG></CODE></P>
      <P><CODE>Wed Apr 22 14:48:05 MST 1998</CODE></P>
      <P><CODE>timeout = –1 sec, –1 usec      <EM>ерунда какая-то</EM></CODE></P>
      <P><CODE>retry timeout = 15 sec, 0 usec <EM>это значение кажется правильным</EM></CODE></P>
      <P><CODE>bsdi: RPC: Timed out</CODE></P>
      <P><CODE>Wed Apr 22 14:48:31 MST 1998   <EM>около 25 секунд спустя</EM></CODE></P>
      <P>В случае с протоколом TCP значение тайм-аута, возвращенное clnt_control, было 30 секунд, но библиотека возвратила ошибку через 25 секунд. Для протокола UDP было получено значение общего тайм-аута –1.</P>
      <P>Чтобы понять, что тут происходит, изучим текст заглушки клиента — функции squareproc_1 в файле square_clnt.c, созданном rpcgen. Эта функция вызывает библиотечную функцию с именем clnt_call, причем последним аргументом является структура типа timeval с именем TIMEOUT, объявляемая в этом файле, и инициализируется она значением 25 секунд. Этот аргумент clnt_call отменяет значение общего тайм-аута в 30 секунд для TCP и –1 для UDP. Он используется всегда, если клиент не устанавливает общий тайм-аут явно вызовом clnt_control с запросом CLSET_TIMEOUT. Если мы хотим изменить значение общего тайм-аута, следует вызывать clnt_control, а не изменять содержимое заглушки клиента. </P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Единственный способ проверить значение тайм-аута повтора для протокола UDP заключается в просмотре пакетов с помощью tcpdump. При этом можно увидеть, что первая дейтаграмма отправляется сразу после запуска клиента, а следующая — примерно 15 секунд спустя.</P>
      </DIV>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label767 style="border:none;"></a>Управление соединением по TCP</P>
      </H1>
      <P>Если мы будем наблюдать с помощью tcpdump за работой клиента и сервера из предыдущего примера, связывающихся по протоколу TCP, мы увидим, что сначала происходит установка соединения (трехэтапное рукопожатие TCP), затем отправляется запрос клиента и сервер отсылает уведомление о приеме этого запроса. Через 25 секунд после этого клиент отсылает серверу FIN, что вызвано завершением работы клиента, после чего следуют оставшиеся три этапа завершения соединения по TCP. В разделе 2.5 [24] эти этапы описаны подробно.</P>
      <P>Мы хотим показать, что Sun RPC использует соединение по TCP следующим образом: новое соединение по TCP устанавливается при вызове clnt_create и оно используется для всех вызовов процедур, связанных с указанной программой и версией. Соединение по TCP завершается явно вызовом clnt_destroy или неявно по завершении процесса клиента:</P>
      <P><CODE>#include &lt;rpc/rpc.h&gt;</CODE></P>
      <P><CODE>void clnt_destroy(CLIENT <EM>*cl</EM>);</CODE></P>
      <P>Начнем с клиента из листинга 16.2 и изменим его, добавив второй вызов процедуры сервера, вызовы clnt_destroy и pause. В листинге 16.10 приведен текст новой программы-клиента.</P>
      <H2><a name=label768 style="border:none;"></a>Листинг 16.10. Клиент для изучения свойств соединения по TCP</H2>
      <P><CODE>//sunrpc/square9/client.c</CODE></P>
      <P><CODE>1  #include "unpipc.h" /* наш заголовочный файл*/</CODE></P>
      <P><CODE>2  #include "square.h" /* создается rpcgen */</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   CLIENT, *cl;</CODE></P>
      <P><CODE>7   square_in in;</CODE></P>
      <P><CODE>8   square_out *outp;</CODE></P>
      <P><CODE>9   if (argc != 3)</CODE></P>
      <P><CODE>10   err_quit("usage: client &lt;hostname&gt; &lt;integer-value&gt;");</CODE></P>
      <P><CODE>11  cl = Clnt_create(argv[1], SQUARE_PROG, SQUARE_VERS, "tcp");</CODE></P>
      <P><CODE>12  in.arg1 = atol(argv[2]);</CODE></P>
      <P><CODE>13  if ((outp = squareproc_1(&amp;in, cl)) == NULL)</CODE></P>
      <P><CODE>14   err_quit("%s", clnt_sperror(c1, argv[1]));</CODE></P>
      <P><CODE>15  printf("result: %ld\n", outp-&gt;res1);</CODE></P>
      <P><CODE>16  in.arg1 *= 2;</CODE></P>
      <P><CODE>17  if ((outp = squareproc_1(&amp;in, cl)) == NULL)</CODE></P>
      <P><CODE>18   err_quit("%s", clnt_sperror(cl, argv[1]));</CODE></P>
      <P><CODE>19  printf("result: %ld\n", outp-&gt;res1);</CODE></P>
      <P><CODE>20  clnt_destroy(cl);</CODE></P>
      <P><CODE>21  pause();</CODE></P>
      <P><CODE>22  exit(0);</CODE></P>
      <P><CODE>23 }</CODE></P>
      <P>После запуска получим ожидаемый результат:</P>
      <P><CODE>solaris % <STRONG>client kalae 5</STRONG></CODE></P>
      <P><CODE>result: 25</CODE></P>
      <P><CODE>result: 100</CODE></P>
      <P><CODE><EM>программа в состоянии ожидания, пока мы не завершим ее вручную</EM></CODE></P>
      <P>Однако проверить наши предыдущие утверждения можно лишь с помощью результатов работы программы tcpdump. Она показывает, что создается одно соединение по TCP (вызовом clnt_create) и оно используется для обоих запросов клиента. Соединение завершается вызовом clnt_destroy, хотя клиент при этом и не завершает свою работу.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label769 style="border:none;"></a>Идентификатор транзакций</P>
      </H1>
      <P>Другая часть стратегии тайм-аутов и повторных передач заключается в использовании идентификаторов транзакций (transaction ID или XID) для распознавания запросов клиента и ответов сервера. Когда клиент вызывает функцию RPC, библиотека присваивает этому вызову 32-разрядный целочисленный номер и это значение отсылается в запросе RPC. Сервер должен добавить к своему ответу этот номер. При повторной отсылке запроса идентификатор не меняется. Служит он двум целям:</P>
      <P>1. Клиент проверяет, что XID ответа совпадает с XID запроса. Если совпадения нет, ответ игнорируется. Если используется протокол TCP, у клиента практически нет шансов получить ответ с неправильным идентификатором, но при использовании протокола UDP поверх плохой сети вероятность получения неправильного XID достаточно высока.</P>
      <P>2. Серверу разрешается помещать отсылаемые ответы в кэш, и для проверки идентичности ответов используется, в частности, именно XID. Об этом мы вскоре расскажем.</P>
      <P>Пакет TI-RPC использует определенный алгоритм вычисления XID для нового запроса. Алгоритм этот описан ниже. Значок ^ означает побитовую операцию XOR (исключающее ИЛИ):</P>
      <P><CODE>struct timeval now;</CODE></P>
      <P><CODE>gettimeofday(&amp;now, NULL);</CODE></P>
      <P><CODE>xid = getpid() ^ now.tv_sec ^ now.tv_usec;</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label770 style="border:none;"></a>Кэш повторных ответов</P>
      </H1>
      <P>Для включения поддержки кэша повторных ответов в библиотеке RPC сервер должен вызвать функцию svc_dg_enablecache. После включения кэша выключить его нельзя, можно только запустить процесс заново: </P>
      <P><CODE>#include &lt;rpc/rpc.h&gt;</CODE></P>
      <P><CODE>int svc_dg_enablecache(SVCXPRT <EM>*xprt,</EM> unsigned long <EM>size</EM>);</CODE></P>
      <P><CODE>/* Возвращает 1 в случае успешного завершения. 0 – в случае ошибки */</CODE></P>
      <P>Здесь <EM>xprt</EM> представляет собой транспортный дескриптор, являющийся полем структуры svc_req (раздел 16.4). Адрес этой структуры является аргументом процедуры сервера. Размер определяет количество записей в выделяемом кэше.</P>
      <P>Итак, эта функция включает поддержку кэширования всех отсылаемых ответов в очереди размером <EM>size</EM> записей. Каждый ответ однозначно определяется следующими параметрами:</P>
      <P>■ номером программы;</P>
      <P>■ номером версии;</P>
      <P>■ номером процедуры;</P>
      <P>■ XID;</P>
      <P>■ адресом клиента (IP-адрес + порт UDP).</P>
      <P>При получении запроса клиента библиотека RPC ищет в кэше ответ на такой запрос. В случае его наличия ответ отсылается клиенту без повторного вызова процедуры сервера.</P>
      <P>Цель использования кэша повторных ответов состоит в том, чтобы не нужно было вызывать процедуру сервера несколько раз при получении нескольких копий запроса клиента. Это может быть нужно в случае, если процедура неидемпотентна. Повторный запрос может быть получен из-за того, что ответ был утерян или у клиента время ожидания меньше, чем время передачи ответа по сети. Обратите внимание, что этот кэш действует только для протоколов, работающих с дейтаграммами (таких, как UDP), поскольку при использовании TCP повторный запрос никогда не может быть получен приложением — он будет обработан TCP (см. упражнение 16.6).</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label771 style="border:none;"></a>16.6. Семантика вызовов</P>
     </H1>
     <P>В листинге 15.24 мы привели пример клиента интерфейса дверей, повторно отсылавшего запрос на сервер при прерывании вызова door_call перехватываемым сигналом. Затем мы показали, что при этом процедура сервера вызывается дважды, а не однократно. Потом мы разделили процедуры сервера на две группы: идемпотентные, которые могут быть вызваны произвольное количество раз без возникновения ошибок, и неидемпотентные, наподобие вычитания определенной суммы из банковского счета.</P>
     <P>Вызовы процедур могут быть разбиты на три группы:</P>
     <P>1. «Ровно один раз» означает, что процедура была выполнена только один раз. Такого трудно достичь ввиду ненулевой вероятности сбоев в работе сервера.</P>
     <P>2. «Не более одного раза» означает, что процедура вовсе не была выполнена или что она была выполнена один раз. Если вызвавшему процессу возвращается результат, мы знаем, что процедура была выполнена. Если процессу возвращается сообщение об ошибке, мы не знаем, была ли процедура выполнена хотя бы один раз или не была выполнена вовсе. </P>
     <P>3. «По крайней мере один раз» означает, что процедура была выполнена один раз, а возможно, и больше. Это не вызывает проблем для идемпотентных процедур — клиент продолжает передавать запросы до тех пор, пока не получит правильный ответ. Однако если клиент отправит несколько запросов, существует вероятность, что процедура будет выполнена больше одного раза.</P>
     <P>При возвращении из локальной процедуры мы можем быть уверены, что она была выполнена ровно один раз. Однако если процесс завершает работу после вызова процедуры, мы не знаем, успела она выполниться или нет. Для удаленных вызовов процедур возможно несколько ситуаций.</P>
     <P>■ Если используется протокол TCP и получен ответ, мы можем быть уверены, что удаленная процедура была вызвана ровно один раз. Однако если ответ не был получен (сервер вышел из строя), мы уже не можем сказать, была процедура выполнена или нет. Обеспечение семантики «ровно один раз» при учете возможности досрочного завершения работы сервера и неполадок в сети требует системы обработки транзакций, что лежит за границами возможностей RPC.</P>
     <P>■ Если используется UDP без серверного кэша и был получен ответ, мы можем быть уверены, что процедура была вызвана по крайней мере один раз, но возможно, и несколько.</P>
     <P>■ Если используется UDP с серверным кэшем и был получен ответ, мы можем быть уверены, что процедура была вызвана ровно один раз. Однако если ответ не был получен, мы оказывается в ситуации «не более одного раза» аналогично сценарию с TCP.</P>
     <P>■ Если вы стоите перед выбором:</P>
     <P> □ TCP,</P>
     <P> □ UDP с кэшем повторных ответов,</P>
     <P> □ UDP без кэша повторных ответов —</P>
     <P>мы можем порекомендовать следующее: </P>
     <P> □ всегда используйте TCP, если только для приложения не важны накладные расходы на обеспечение надежности;</P>
     <P> □ используйте систему обработки транзакций для неидемпотентных процедур, корректное выполнение которых важно (работа с банковскими счетами, бронирование авиабилетов и т. п.);</P>
     <P> □ для неидемпотентных процедур использование TCP предпочтительно по сравнению с UDP и кэшем, поскольку TCP был изначально ориентирован на надежность, а добавление кэша к приложению, использующему UDP, вряд ли даст то же самое, что и использование TCP (см., например, раздел 20.5 [24]);</P>
     <P> □ для идемпотентных процедур можно использовать UDP без кэша;</P>
     <P> □ для неидемпотентных процедур использование UDP без кэша опасно.</P>
     <P>В следующем разделе будут рассмотрены дополнительные преимущества использования TCP. </P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label772 style="border:none;"></a>16.7. Досрочное завершение сервера или клиента</P>
     </H1>
     <DIV class=section>
      <P>Рассмотрим, что произойдет в случае досрочного завершения клиента или сервера при использовании транспортного протокола TCP. Поскольку протокол UDP не подразумевает установку соединения, при завершении процесса его собеседнику не отсылается никаких сообщений. При завершении работы одного из процессов второй дождется тайм-аута, после чего, возможно, повторно отошлет запрос и наконец прекратит попытки, выдав сообщение об ошибке, как показывалось в предыдущем разделе. При завершении работы процесса, установившего соединение по TCP, это соединение завершается отправкой пакета FIN [24, с. 36-37], и мы хотим узнать, что делает библиотека RPC при получении этого пакета.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label773 style="border:none;"></a>Досрочное завершение сервера</P>
      </H1>
      <P>Завершим работу сервера досрочно, в процессе обработки запроса клиента. Единственное изменение в программе-клиенте будет заключаться в удалении аргумента tcp из вызова clnt_call в листинге 16.2 и включении протокола в набор аргументов командной строки, как в листинге 16.9. В процедуру сервера мы добавим вызов abort. Это приведет к завершению работы процесса-сервера и отправке пакета FIN клиенту, что мы можем проверить с помощью tcpdump.</P>
      <P>Запустим в системе Solaris клиент для сервера, работающего под BSD/OS:</P>
      <P><CODE>solaris %<STRONG> client bsdi 22 tcp</STRONG></CODE></P>
      <P><CODE>bsdi: RPC: Unable to receive; An event requires attention</CODE></P>
      <P>В момент получения клиентом пакета FIN библиотека RPC находилась в состоянии ожидания ответа сервера. Она получила неожиданный ответ и вернула ошибку в вызове squareproc_1. Ошибка (RPC_CANTRECV) сохраняется библиотекой в дескрипторе клиента, и вызов clnt_sperror (из функции-обертки Clnt_create) при этом печатает сообщение Unable to receive. Оставшаяся часть сообщения об ошибке (An event requires attention) соответствует ошибке XTI, сохраненной библиотекой, которая также выводится clnt_sperror. Вызов удаленной процедуры может вернуть одну из примерно 30 различных ошибок RPC_xxx. Все они перечислены в заголовочном файле &lt;rpc/clnt_stat.h&gt;.</P>
      <P>Если мы поменяем клиент и сервер местами, мы увидим то же сообщение об ошибке, возвращаемое библиотекой RPC (RPC_CANTRECV), но при этом будет выведено дополнительное сообщение:</P>
      <P><CODE>bsdi % <STRONG>client solaris 11 tcp</STRONG></CODE></P>
      <P><CODE>solaris: RPC: Unable to receive; errno = Connection reset by peer</CODE></P>
      <P>Сервер в Solaris не был скомпилирован как многопоточный, и когда мы вызвали abort, была завершена работа всего процесса. Если мы запустим многопоточный сервер и завершим работу только одного потока — того, который обслуживает данный запрос клиента, — все изменится. Чтобы продемонстрировать это, заменим вызов abort на pthread_exit, как мы сделали в пpoгрaммe из листинга 15.20. Запустим клиент в BSD/OS, а многопоточный сервер — в Solaris:</P>
      <P><CODE>bsdi % <STRONG>client solaris 33 tcp</STRONG></CODE></P>
      <P><CODE>solaris: RPC: Timed out</CODE> </P>
      <P>После завершения работы потока сервера соединение с клиентом по TCP не разрывается. Оно остается открытым, поэтому клиенту не отсылается пакет FIN. Клиент выходит по тайм-ауту. Мы увидели бы то же сообщение об ошибке, если бы узел, на котором находится сервер, прекратил работу после получения запроса от клиента и отправки уведомления.</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label774 style="border:none;"></a>Досрочное завершение клиента</P>
      </H1>
      <P>Если клиент, использующий TCP, завершает работу в процессе выполнения процедуры RPC, серверу отправляется пакет FIN. Мы хотим узнать, как библиотека сервера реагирует на этот пакет и уведомляет об этом процедуру сервера. (В разделе 15.11 мы говорили, что поток сервера дверей отменяется при досрочном завершении клиента.)</P>
      <P>Чтобы сымитировать такую ситуацию, клиент вызывает alarm(3) непосредственно перед вызовом процедуры сервера, а процедура сервера вызывает slеер (6). Так же мы поступили и в нашем примере с дверьми в листингах 15.25 и 15.26. Поскольку клиент не перехватывает сигнал SIGALRM, процесс завершается ядром примерно за 3 секунды до отправки ответа серверу. Запустим клиент в BSD/OS, а сервер в Solaris:</P>
      <P><CODE>bsdi % <STRONG>client solaris 44 tcp</STRONG></CODE></P>
      <P><CODE>Alarm call</CODE></P>
      <P>Случилось то, что мы и ожидали. А вот на сервере не происходит ничего необычного. Процедура сервера благополучно заканчивает 6-секундную паузу и возвращается. Если мы взглянем на передаваемую по сети информацию с помощью tcpdump, мы увидим следующее:</P>
      <P>■ при завершении работы клиента (через 3 секунды после запуска) серверу отправляется пакет FIN, и сервер высылает уведомление о его приеме. В TCP для этого используется термин half-close (наполовину закрытое соединение, раздел 18.5 [22]);</P>
      <P>■ через 6 секунд после запуска клиента сервер отсылает ответ, который переправляется клиенту протоколом TCP. По соединению TCP можно отправлять данные после получения FIN, поскольку соединения TCP являются двусторонними, о чем говорится в книге [24, с. 130-132]. Клиент отвечает пакетом RST, поскольку он уже завершил работу. Он будет получен сервером при следующем открытии этого соединения, но это ни к чему не приведет.</P>
      <P>Подведем итоги.</P>
      <P>■ При использовании UDP клиенты и серверы RPC не имеют возможности узнать о досрочном завершении одного из них. Они могут выходить по тайм-ауту, если ответ не приходит, но тип ошибки при этом определить не удастся: причина может быть в досрочном завершении процесса, сбое узла, недоступности сети и т. д.</P>
      <P>■ Клиент RPC, использующий TCP, может узнать о возникших на сервере проблемах, поскольку при досрочном завершении сервера его конец соединения автоматически закрывается. Это, однако, не помогает, если сервер является многопоточным, поскольку такой сервер не закрывает соединение в случае отмены потока с процедурой сервера. Мы также не получаем информации в случае сбоя узла, поскольку при этом соединение TCP не закрывается. Во всех этих случаях следует использовать выход по тайм-ауту.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label775 style="border:none;"></a>16.8. XDR: представление внешних данных</P>
     </H1>
     <DIV class=section>
      <P>В предыдущей главе мы использовали двери для вызова процедуры одного процесса из другого процесса. При этом оба процесса выполнялись на одном узле, поэтому необходимости в преобразовании данных не возникало. Однако RPC используется для вызова процедур на разных узлах, которые могут иметь различный формат хранения данных. Прежде всего могут отличаться размеры фундаментальных типов (в некоторых системах long имеет длину 32 бита, а в других — 64). Кроме того, может отличаться порядок битов (big-endian и little-endian, о чем говорится в книге [24, с. 66-69 и 137-140]. Мы уже столкнулись с этой проблемой, когда обсуждали листинг 16.3. Сервер у нас работал на компьютере с little-endian х86, а клиент — на big-endian Sparc, но мы могли без проблем обмениваться данными (в нашем примере — одно длинное целое).</P>
      <P>Sun RPC использует стандарт XDR (External Data Representation — представление внешних данных) для описания и кодирования данных (RFC 1832 [19]). XDR является одновременно языком описания данных и набором правил для их кодирования. В XDR используется скрытая типизация (implicit typing), то есть отправитель и получатель должны заранее знать тип и порядок данных. Например, два 32-разрядных целых, одно число с плавающей точкой и одинарной точностью и строка символов.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Приведем сравнение из мира OSI. Для описания данных обычно используется нотация ASN.1 (Abstract Syntax Notation one), а для кодирования — BER (Basic Encoding Rules). Эта схема также использует явную типизацию, то есть перед каждым значением указывается его тип. В нашем примере поток байтов содержал бы: спецификатор типа целого, целое, спецификатор типа целого, целое, спецификатор типа single, число с плавающей точкой и одинарной точностью, спецификатор типа строки символов, строку символов.</P>
      </DIV>
      <P>Представление всех типов согласно XDR требует количества байтов, кратного четырем. Эти байты всегда передаются в порядке big-endian. Целые числа со знаком передаются в дополнительном коде, а числа с плавающей точкой передаются в формате IEEE. Поля переменной длины могут содержать до 3 байтов дополнения в конце, так чтобы подогнать начало следующего элемента до адреса, кратного четырем. Например, 5-символьная строка АSСII будет передана как 12 байтов:</P>
      <P>■ 4-байтовое целое, содержащее значение 5;</P>
      <P>■ 5-байтовая строка;</P>
      <P>■ 3 байта со значением 0 (дополнение).</P>
      <P>При описании XDR и поддерживаемых типов данных следует уточнить три момента.</P>
      <P>1. Как объявляются переменные различных типов в файле спецификации RPC (файл с расширением .х)? В наших примерах пока что использовалось только длинное целое.</P>
      <P>2. В какой тип языка С преобразуется данный тип программой rpcgen при составлении заголовочного файла?</P>
      <P>3. Каков реальный формат передаваемых данных?</P>
      <P>Таблица 16.2 содержит ответы на первых два вопроса. Для составления этой таблицы мы создали файл спецификации RPC со всеми поддерживаемыми стандартом XDR типами. Этот файл был обработан rpcgen, после чего мы изучили получившийся заголовочный файл.</P>
      <BR>
      <P>Таблица 16.2. Типы данных, поддерживаемые xdr и rpcgen </P>
      <TABLE>
       <TR ALIGN=left >
        <TH ALIGN=left VALIGN=top >№</TH>
        <TH ALIGN=left VALIGN=top >Файл спецификации RPC (.x)</TH>
        <TH ALIGN=left VALIGN=top >Заголовочный файл языка С (.h)</TH>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >1</TD>
        <TD ALIGN=left VALIGN=top >const name = value</TD>
        <TD ALIGN=left VALIGN=top >#define name value</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >2</TD>
        <TD ALIGN=left VALIGN=top >typedef declaration;</TD>
        <TD ALIGN=left VALIGN=top >typedef declaration;</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >3</TD>
        <TD ALIGN=left VALIGN=top >char var; short var; int var; long var; hyper var;</TD>
        <TD ALIGN=left VALIGN=top >char var; short var; int var; long var; longlong_t var;</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >4</TD>
        <TD ALIGN=left VALIGN=top >unsigned char var; unsigned short var; unsigned int var; unsigned long var; unsigned hyper var;</TD>
        <TD ALIGN=left VALIGN=top >u_char var; u_short var; u_int var; u_long var; u_longlong_t var;</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >5</TD>
        <TD ALIGN=left VALIGN=top >float var; double var; quadruple var;</TD>
        <TD ALIGN=left VALIGN=top >float var; double var; quadruple var;</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >6</TD>
        <TD ALIGN=left VALIGN=top >bool var;</TD>
        <TD ALIGN=left VALIGN=top >bool_t var;</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >7</TD>
        <TD ALIGN=left VALIGN=top >enum var {name = const, …}</TD>
        <TD ALIGN=left VALIGN=top >enum var {name = const, …}; typedef enum var var;</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >8</TD>
        <TD ALIGN=left VALIGN=top >opaque var[n];</TD>
        <TD ALIGN=left VALIGN=top >char var[n];</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >9</TD>
        <TD ALIGN=left VALIGN=top >opaque var&lt;m&gt;;</TD>
        <TD ALIGN=left VALIGN=top >struct { u_int var_len; char *var_val; } val;</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >10</TD>
        <TD ALIGN=left VALIGN=top >string var&lt;m&gt;</TD>
        <TD ALIGN=left VALIGN=top >char *var;</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >11</TD>
        <TD ALIGN=left VALIGN=top >datatype var[n];</TD>
        <TD ALIGN=left VALIGN=top >datatype var[n];</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >12</TD>
        <TD ALIGN=left VALIGN=top >datatype var&lt;m&gt;</TD>
        <TD ALIGN=left VALIGN=top >struct { uint var_len; datatype *var_val; } var;</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >13</TD>
        <TD ALIGN=left VALIGN=top >struct var {members … };</TD>
        <TD ALIGN=left VALIGN=top >struct var {members … }; typedef struct var var;</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >14</TD>
        <TD ALIGN=left VALIGN=top >union var switch (int disc) { case discvalueA: armdeclA; case discvalueB: amrdeclB; … default: defaultdecl; };</TD>
        <TD ALIGN=left VALIGN=top >struct var { int disc; union { armdeclA; armdeclB; …  defaultdecl; } var_u; }; typedef struct var var;</TD>
       </TR>
       <TR ALIGN=left >
        <TD ALIGN=left VALIGN=top >15</TD>
        <TD ALIGN=left VALIGN=top >datatype *name;</TD>
        <TD ALIGN=left VALIGN=top >datatype *name;</TD>
       </TR>
      </TABLE>
      <P>Опишем содержимое таблицы более подробно.</P>
      <P>1. Декларация const преобразуется в #define.</P>
      <P>2.  Декларация typedef преобразуется в typedef.</P>
      <P>3. Пять целых типов со знаком. Передаются XDR как 32-разрядные значения (первые четыре типа), а последний — как 64-разрядное.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>64-разрядное целое поддерживается многими компиляторами С как формат long long int или просто long long. Многие, но не все компиляторы и операционные системы поддерживают такой формат. Поскольку в созданном заголовочном файле объявляются переменные типа longlong_t, в другом заголовочном файле должно содержаться следующее определение:</P>
       <P><CODE>typedef long long longlong_t;</CODE></P>
       <P>Длинное целое в XDR занимает 32 бита, но длинное целое языка С в 64-разрядных системах Unix может занимать и 64 бита (например, в модели LP64, описанной в [24, с. 27]). Имена формата XDR устарели лет на десять и не слишком соответствуют современным стандартам. Лучше, если бы они назывались как-нибудь вроде int8_t, int16_t и т. д.</P>
      </DIV>
      <P>4. Пять целых типов без знака. Первые 4 передаются как 32-разрядные значения, а последнее — как 64-разрядное.</P>
      <P>5. Три типа данных с плавающей точкой. Первый передается как 32-разрядное значение, второй — как 64-разрядное, а третий — как 128-разрядное.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Четверная точность для чисел с плавающей точкой (quadruple precision) поддерживается в С для типов long double. He все компиляторы и операционные системы его воспринимают. Ваш компилятор может пропустить long double, но работать с этой переменной как с double. Поскольку в созданном заголовочном файле объявляются переменные типа quadruple, нужно создать другой заголовочный файл с объявлением</P>
       <P><CODE>typedef long double quadruple;</CODE></P>
       <P>В Solaris 2.6, например, нам пришлось бы включить строку</P>
       <P><CODE>%#include &lt;floatingpoint.h&gt;</CODE></P>
       <P>в начало файла спецификации RPC, потому что этот заголовочный файл содержит требуемое определение. Знак процента перед #include говорит программе rpcgen о необходимости поместить остаток строки непосредственно в создаваемый заголовочный файл.</P>
      </DIV>
      <P>6. Тип boolean эквивалентен целому со знаком. Заголовки RPC также определяют константу TRUE равной 1, a FALSE равной 0.</P>
      <P>7. Перечисление (enumeration) эквивалентно целому со знаком и совпадает с типом данных enum в С. rpcgen также создает определение типа для данной переменной.</P>
      <P>8. Скрытые данные фиксированной длины передаются библиотекой как 8-разрядные значения без интерпретации.</P>
      <P>9. Скрытые данные переменной длины также представляют собой последовательность неинтерпретируемых данных, но количество реально передаваемых данных помещается в целочисленную переменную и посылается перед самими данными. При отправке данных такого типа (например, при заполнении списка аргументов перед вызовом RPC) следует указать длину, прежде чем делать вызов. При приеме данного типа данных следует выяснить значение длины, чтобы определить, сколько данных будет принято. </P>
      <P>10. Строка представляет собой последовательность ASCII-символов. В памяти строка хранится как обычная строка символов языка С, завершаемая нулем, но при передаче перед ней отправляется целое без знака, в которое помещается количество символов данной строки (без завершающего нуля). При отправке данных такого типа размер строки определяется библиотекой с помощью вызова strlen. При приеме данные такого типа помещаются в строку символов С, завершаемую нулем.</P>
      <P>11. Массив фиксированной длины любого типа передается как последовательность n элементов данного типа.</P>
      <P>12. Массив переменной длины любого типа передается как целое без знака, указывающее количество элементов, и последовательность элементов данного типа. Максимальное количество элементов в объявлении может быть опущено. Но если это количество указать при компиляции программы, библиотека будет проверять, не превосходит ли реальная длина указанного значения m.</P>
      <P>13. Структура передается как последовательность полей. rpcgen также создает определение типа для данного имени переменной (typedef).</P>
      <P>14. Размеченное объединение состоит из целочисленного дискриминанта и набора типов данных (ветвей), зависящих от значения дискриминанта. В табл. 16.2 мы показываем, что дискриминант должен быть типа int, но он может быть и unsigned int, и enum, и bool (все эти типы передаются как 32-разрядные целые). При передаче размеченного объединения передается 32-разрядное значение дискриминанта, за которым следует значение той ветви, которая ему соответствует. В ветви default часто объявляется тип void, что означает отсутствие передаваемой вслед за дискриминантом информации. Ниже мы продемонстрируем это на примере.</P>
      <P>15. Дополнительные данные представляют собой специальный тип объединения, описанный в примере из листинга 16.24. Объявление XDR выглядит как объявление указателя в языке С, и именно указатель объявляется в созданном заголовочном файле.</P>
      <P>На рис. 16.3 сведена информация о кодировании различных типов данных в XDR.</P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader239" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 16.3. Кодирование типов данных в XDR</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label776 style="border:none;"></a>Пример: использование XDR без RPC</P>
      </H1>
      <P>Приведем пример использования XDR без RPC. Мы воспользуемся стандартом XDR для кодирования структуры данных в машинно-независимое представление, в котором они могут быть обработаны другими системами. Этот метод может использоваться для написания файлов или для отправки данных по сети в машинно-независимом формате. В листинге 16.11 приведен текст файла спецификации data .х, который на самом деле является файлом спецификации XDR, поскольку мы не объявляем никаких процедур RPC.</P>
      <DIV class=cite>
       <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
       <P>Суффикс имени файла (.х) происходит от термина «файл спецификации XDR». Спецификация RPC утверждает, что язык RPC (RPCL) идентичен XDR в части, относящейся к описанию данных. В RPCL была добавлена только возможность описания процедур.</P>
      </DIV>
      <H2><a name=label777 style="border:none;"></a>Листинг 16.11. Файл спецификации XDR</H2>
      <P><CODE>//sunrpc/xdr1/data.x</CODE></P>
      <P><CODE>1  enum result_t {</CODE></P>
      <P><CODE>2   RESULT_INT = 1, RESULT_DOUBLE = 2</CODE></P>
      <P><CODE>3  };</CODE></P>
      <BR>
      <P><CODE>4  union union_arg switch (result_t result) {</CODE></P>
      <P><CODE>5  case RESULT_INT:</CODE></P>
      <P><CODE>6   int intval;</CODE></P>
      <P><CODE>7  case RESULT_DOUBLE:</CODE></P>
      <P><CODE>8   double doubleval;</CODE></P>
      <P><CODE>9  default:</CODE></P>
      <P><CODE>10  void;</CODE></P>
      <P><CODE>11 };</CODE></P>
      <BR>
      <P><CODE>12 struct data {</CODE></P>
      <P><CODE>13  short short_arg;</CODE></P>
      <P><CODE>14  long long_arg;</CODE></P>
      <P><CODE>15  string vstring_arg&lt;128&gt;; /* строка переменной длины */</CODE></P>
      <P><CODE>16  opaque fopaque_arg[3]; /* скрытые данные фиксированной длины */</CODE></P>
      <P><CODE>17  opaque vopaque_arg&lt;&gt;; /* скрытые данные переменной длины */</CODE></P>
      <P><CODE>18  short fshort_arg[4]; /* массив фиксированной длины */</CODE></P>
      <P><CODE>19  long vlong_arg&lt;&gt;; /* массив переменной длины */</CODE></P>
      <P><CODE>20  union_arg uarg;</CODE></P>
      <P><CODE>21 };</CODE></P>
      <H2><a name=label778 style="border:none;"></a>Объявление перечисления и размеченного объединения</H2>
      <P>1-11 Мы объявляем перечислимый тип с двумя значениями и размеченное объединение, использующее это перечисление в качестве дискриминанта. Если дискриминант имеет значение RESULT_INT, после значения дискриминанта передается целое число. Если дискриминант имеет значение RESULT_DOUBLE, за ним передается число с плавающей точкой двойной точности. В противном случае после дискриминанта не передается ничего. </P>
      <H2><a name=label779 style="border:none;"></a>Объявление структуры</H2>
      <P>12-21 Мы объявляем структуру, состоящую из различных типов, поддерживаемых XDR.</P>
      <P>Поскольку мы не объявляем процедур RPC, программа rpcgen не создаст заглушку клиента и заглушку сервера. Однако она создаст заголовочный файл data.h и файл data_xdr.с, содержащий функции XDR, обеспечивающие кодирование и декодирование данных, объявленных в файле data.х.</P>
      <P>В листинге 16.12 приведен получающийся в результате работы rpcgen заголовочный файл data.h. Содержимое этого файла выглядит так, как мы и предполагали (табл. 16.2).</P>
      <H2><a name=label780 style="border:none;"></a>Листинг 16.12. Заголовочный файл data.h, созданный rpcgen из файла data.x</H2>
      <P><CODE>//sunrpc/xdr1/data.h</CODE></P>
      <P><CODE>1  /*</CODE></P>
      <P><CODE>2   * Please do not edit this file. It was generated using rpcgen.</CODE></P>
      <P><CODE>3   */</CODE></P>
      <P><CODE>4  #ifndef _DATA_H_RPCGEN</CODE></P>
      <P><CODE>5  #define _DATA_H_RPCGEN</CODE></P>
      <BR>
      <P><CODE>6  #include &lt;rpc/rpc.h&gt;</CODE></P>
      <BR>
      <P><CODE>7  enum result_t {</CODE></P>
      <P><CODE>8   RESULT_INT = 1,</CODE></P>
      <P><CODE>9   RESULT_DOUBLE = 2</CODE></P>
      <P><CODE>10 };</CODE></P>
      <P><CODE>11 typedef enum result_t result_t;</CODE></P>
      <BR>
      <P><CODE>12 struct union_arg {</CODE></P>
      <P><CODE>13  result_t result;</CODE></P>
      <P><CODE>14  union {</CODE></P>
      <P><CODE>15   int intVal;</CODE></P>
      <P><CODE>16   double doubleval;</CODE></P>
      <P><CODE>17  } union_arg_u;</CODE></P>
      <P><CODE>18 };</CODE></P>
      <P><CODE>19 typedef struct union_arg union_arg;</CODE></P>
      <BR>
      <P><CODE>20 struct data {</CODE></P>
      <P><CODE>21  short short_arg;</CODE></P>
      <P><CODE>22  long long_arg;</CODE></P>
      <P><CODE>23  char *vstring_arg;</CODE></P>
      <P><CODE>24  char fopaque_arg[3];</CODE></P>
      <P><CODE>25  struct {</CODE></P>
      <P><CODE>26   u_int vopaque_arg_len;</CODE></P>
      <P><CODE>27   char *vopaque_arg_val;</CODE></P>
      <P><CODE>28  } vopaque_arg;</CODE></P>
      <P><CODE>29  short fshort_arg[4];</CODE></P>
      <P><CODE>30  struct {</CODE></P>
      <P><CODE>31   u_int vlong_arg_len;</CODE></P>
      <P><CODE>32   long *vlong_arg_val;</CODE></P>
      <P><CODE>33  } vlong_arg;</CODE></P>
      <P><CODE>34  union_arg uarg;</CODE></P>
      <P><CODE>35 };</CODE></P>
      <P><CODE>36 typedef struct data data:</CODE></P>
      <BR>
      <P><CODE>37 /* 4the xdr functions */</CODE></P>
      <P><CODE>38 extern bool_t xdr_result_t(XDR *, result_t*);</CODE></P>
      <P><CODE>39 extern bool_t xdr_union_arg(XDR *, union_arg*);</CODE></P>
      <P><CODE>40 extern bool_t xdr_data(XDR *, data*);</CODE></P>
      <BR>
      <P><CODE>41 #endif /* !_DATA_H_RPCGEN */</CODE></P>
      <P>В файле data_xdr.с объявляется функция xdr_data, вызываемая для кодирования и декодирования структуры data, которую мы определили. Суффикс имени функции _data соответствует имени нашей структуры из листинга 16.11. Первая программа, которую мы напишем, будет называться write.с. Она будет присваивать значения полям структуры data, вызывать xdr_data для кодирования всех полей в формат XDR и записывать результат в стандартный поток вывода.</P>
      <P>Эта программа приведена в листинге 16.13.</P>
      <H2><a name=label781 style="border:none;"></a>Листинг 16.13. Инициализация структуры и кодирование ее в XDR</H2>
      <P><CODE>//sunrpc/xdr1/write.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "data.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   XDR xhandle;</CODE></P>
      <P><CODE>7   data out; /* структура, с которой мы работаем */</CODE></P>
      <P><CODE>8   char *buff; /* результат кодирования в XOR */</CODE></P>
      <P><CODE>9   char vop[2];</CODE></P>
      <P><CODE>10  long vlong[3];</CODE></P>
      <P><CODE>11  u_int size;</CODE></P>
      <P><CODE>12  out.short_arg = 1;</CODE></P>
      <P><CODE>13  out.long_arg = 2;</CODE></P>
      <P><CODE>14  out.vstring_arg = "hello, world"; /* присваиваем значение указателю */</CODE></P>
      <P><CODE>15  out.fopaque_arg[0] = 99; /* скрытые данные фиксированной длины */</CODE></P>
      <P><CODE>16  out.fopaque_arg[1] = 88;</CODE></P>
      <P><CODE>17  out.fopaque_arg[2] = 77;</CODE></P>
      <P><CODE>18  vop[0] = 33; /* скрытые данные переменной длины */</CODE></P>
      <P><CODE>19  vop[1] = 44;</CODE></P>
      <P><CODE>20  out.vopaque_arg.vopaque_arg_len = 2;</CODE></P>
      <P><CODE>21  out.vopaque_arg.vopaque_arg_val = vop;</CODE></P>
      <P><CODE>22  out.fshort_arg[0] = 9999; /* массив фиксированной длины */</CODE></P>
      <P><CODE>23  out.fshort_arg[1] = 8888;</CODE></P>
      <P><CODE>24  out.fshort_arg[2] = 7777;</CODE></P>
      <P><CODE>25  out.fshort_arg[3] = 6666;</CODE></P>
      <P><CODE>26  vlong[0] = 123456; /* массив переменной длины */</CODE></P>
      <P><CODE>27  vlong[l] = 234567;</CODE></P>
      <P><CODE>28  vlong[2] = 345678;</CODE></P>
      <P><CODE>29  out.vlong_arg.vlong_arg_len = 3;</CODE></P>
      <P><CODE>30  out.vlong_arg.vlong_arg_val = vlong;</CODE></P>
      <P><CODE>31  out.uarg.result = RESULT_INT; /* размеченное объединение */</CODE></P>
      <P><CODE>32  out.uarg.union_arg_u.intval = 123;</CODE></P>
      <P><CODE>33  buff = Malloc(BUFFSIZE); /* кратен 4-м байтам */</CODE></P>
      <P><CODE>34  xdrmem_create(&amp;xhandle, buff, BUFFSIZE, XDR_ENCODE);</CODE></P>
      <P><CODE>35  if (xdr_data(&amp;xhandle, &amp;out) != TRUE)</CODE></P>
      <P><CODE>36   err_quit("xdr_data error");</CODE></P>
      <P><CODE>37  size = xdr_getpos(&amp;xhandle);</CODE></P>
      <P><CODE>38  Write(STDOUT_FILENO, buff, size);</CODE></P>
      <P><CODE>39  exit(0);</CODE></P>
      <P><CODE>40 }</CODE></P>
      <H2><a name=label782 style="border:none;"></a>Инициализация элементов структуры ненулевыми значениями</H2>
      <P>12-32 Сначала мы присваиваем полям структуры ненулевые значения. В случае полей переменной длины мы должны установить длину этих полей. Мы присваиваем дискриминанту размеченного объединения значение RESULT_INT и помещаем в его соответствующее поле значение 123.</P>
      <H2><a name=label783 style="border:none;"></a>Выделение буфера</H2>
      <P>33 Мы вызываем malloc для выделения буфера, в который подпрограммы XDR будут помещать результаты своей работы. Адрес и размер буфера должны быть кратны четырем. Выделение массива char не гарантирует этого.</P>
      <H2><a name=label784 style="border:none;"></a>Создание потока XDR в памяти</H2>
      <P>34 Функция библиотеки времени выполнения xdrmem_create инициализирует буфер, на который указывает buff, предназначенный для использования функциями XDR как поток в памяти. Мы выделяем переменную типа XDR с именем xhandle и передаем адрес этой переменной в качестве первого аргумента. Библиотека XDR времени выполнения хранит в этой переменной всю необходимую информацию (указатель на буфер, текущее положение в буфере и т. п.). Последний аргумент имеет значение XDR_ENCODE, что указывает XDR на необходимость преобразования данных из формата узла в формат XDR.</P>
      <H2><a name=label785 style="border:none;"></a>Кодирование структуры</H2>
      <P>35-36 Мы вызываем функцию xdr_data, созданную rpcgen в файле data_xdr.c, и она кодирует структуру out в формат XDR. Возвращаемое значение TRUE говорит об успешном завершении работы функции.</P>
      <H2><a name=label786 style="border:none;"></a>Получение размера кодированных данных и запись их в поток вывода</H2>
      <P>37-38 Функция xdr_getpos возвращает текущее положение библиотеки XDR в выходном буфере (то есть сдвиг байта, в который будут помещены очередные данные). Его мы трактуем как размер готовых к записи данных. </P>
      <P>В листинге 16.14 приведен текст программы read, которая считывает данные из файла, записанного предыдущей программой, и выводит значения всех полей структуры data.</P>
      <H2><a name=label787 style="border:none;"></a>Листинг 16.14. Считывание структуры data из формата XDR</H2>
      <P><CODE>//sunrpc/xdr1/read.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "data.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   XDR xhandle;</CODE></P>
      <P><CODE>7   int i;</CODE></P>
      <P><CODE>8   char *buff;</CODE></P>
      <P><CODE>9   data in;</CODE></P>
      <P><CODE>10  ssize_t n;</CODE></P>
      <P><CODE>11  buff = Malloc(BUFFSIZE); /* адрес должен быть кратен 4-м байтам */</CODE></P>
      <P><CODE>12  n = Read(STDIN_FILENO, buff, BUFFSIZE);</CODE></P>
      <P><CODE>13  printf("read %ld bytes\n", (long) n);</CODE></P>
      <P><CODE>14  xdrmem_create(&amp;xhandle, buff, n, XDR_DECODE);</CODE></P>
      <P><CODE>15  memset(&amp;in, 0, sizeof(in));</CODE></P>
      <P><CODE>16  if (xdr_data(&amp;xhandle, &amp;in) != TRUE)</CODE></P>
      <P><CODE>17   err_quit("xdr_data error");</CODE></P>
      <P><CODE>18  printf("short_arg = %d, long_arg = %ld, vstring_arg = '%s'\n",</CODE></P>
      <P><CODE>19   in.short_arg, in.long_arg, in.vstring_arg);</CODE></P>
      <P><CODE>20  printf("fopaque[] = %d, %d, %d\n",</CODE></P>
      <P><CODE>21   in.fopaque_arg[0], in.fopaque_arg[1], in.fopaque_arg[2]);</CODE></P>
      <P><CODE>22  printf("vopaque&lt;&gt; =");</CODE></P>
      <P><CODE>23  for (i = 0; i &lt; in.vopaque_arg.vopaque_arg_len; i++)</CODE></P>
      <P><CODE>24   printf(" %d", in.vopaque_arg.vopaque_arg_val[i]);</CODE></P>
      <P><CODE>25  printf("\n");</CODE></P>
      <P><CODE>26  printf("fshort_arg[] = %d, %d, %d, %d\n", in.fshort_arg[0],</CODE></P>
      <P><CODE>27   in.fshort_arg[1], in.fshort_arg[2], in.fshort_arg[3]);</CODE></P>
      <P><CODE>28  printf("vlong&lt;&gt; =");</CODE></P>
      <P><CODE>29  for (i = 0; i &lt; in.vlong_arg.vlong_arg_len; i++)</CODE></P>
      <P><CODE>30   printf(" %ld", in.vlong_arg.vlong_arg_val[i]);</CODE></P>
      <P><CODE>31  printf("\n");</CODE></P>
      <P><CODE>32  switch (in.uarg.result) {</CODE></P>
      <P><CODE>33  case RESULT_INT:</CODE></P>
      <P><CODE>34   printf("uarg (int) = %d\n", in.uarg.union_arg_u.intval);</CODE></P>
      <P><CODE>35   break;</CODE></P>
      <P><CODE>36  case RESULT_DOUBLE:</CODE></P>
      <P><CODE>37   printf("uarg (double) = %g\n", in.uarg.union_arg_u.doubleval);</CODE></P>
      <P><CODE>38   break;</CODE></P>
      <P><CODE>39  default:</CODE></P>
      <P><CODE>40   printf("uarg (void)\n");</CODE></P>
      <P><CODE>41   break;</CODE></P>
      <P><CODE>42  }</CODE></P>
      <P><CODE>43  xdr_free(xdr_data, (char*)&amp;in);</CODE></P>
      <P><CODE>44  exit(0);</CODE></P>
      <P><CODE>45 }</CODE></P>
      <H2><a name=label788 style="border:none;"></a>Выделение правильно расположенного буфера</H2>
      <P>11-13 Вызывается функция malloc для выделения буфера. В этот буфер считывается файл, созданный предыдущей программой.</P>
      <H2><a name=label789 style="border:none;"></a>Создание потока XDR, инициализация буфера, декодирование</H2>
      <P>14-17 Инициализируем поток XDR, указав флаг XDR_DECODE, означающий, что преобразование производится из формата XDR в формат узла. Мы инициализируем структуру i n нулями и вызываем xdr_data для декодирования содержимого буфера buff в эту структуру. Мы обязаны инициализировать принимающую структуру нулями, поскольку некоторые из подпрограмм XDR (например, xdr_string) требуют выполнения этого условия. xdr_data — это та же функция, которую мы вызывали в листинге 16.13. Изменился только последний аргумент xdrmem_create: в предыдущей программе мы указывали XDR_ENCODE, а в этой — XDR_DECODE. Это значение сохраняется в дескрипторе XDR (xhandle) функцией xdrmem_create и затем используется библиотекой XDR для выбора между кодированием и декодированием данных.</P>
      <H2><a name=label790 style="border:none;"></a>Вывод значений полей структуры</H2>
      <P>18-42 Мы выводим значения всех полей структуры data.</P>
      <H2><a name=label791 style="border:none;"></a>Освобождение выделенной под XDR памяти</H2>
      <P>43 Для освобождения памяти мы вызываем функцию xdr_free (см. упражнение 16.10).</P>
      <P>Запустим программу write на компьютере Sparc, перенаправив стандартный вывод в файл с именем data:</P>
      <P><CODE>solaris % <STRONG>write &gt; data</STRONG></CODE></P>
      <P><CODE>solaris % <STRONG>ls -l data</STRONG></CODE></P>
      <P><CODE>-rw-rw-r-- 1 rstevens other1 76 Apr 23 12:32 data</CODE></P>
      <P>Мы видим, что размер файла равен 72 байтам что соответствует рис. 16.4, на котором изображена схема хранения данных.</P>
      <P>Прочитав этот файл в BSD/OS или Digital Unix, мы получим те результаты, на которые и рассчитывали:</P>
      <P><CODE>bsdi % <STRONG>read &lt; data</STRONG></CODE></P>
      <P><CODE>read 76 bytes</CODE></P>
      <P><CODE>short_arg = 1, long_arg = 2, vstring_arg = 'hello, world'</CODE></P>
      <P><CODE>fopaque[] =99, 88, 77</CODE></P>
      <P><CODE>vopaque&lt;&gt; = 33 44</CODE></P>
      <P><CODE>fshort_arg[] = 9999, 8888, 7777, 6666</CODE></P>
      <P><CODE>vlong&lt;&gt; = 123456 234567 345678</CODE></P>
      <P><CODE>uarg (int) = 123</CODE></P>
      <P><CODE>alpha % read &lt; data</CODE></P>
      <P><CODE>read 76 bytes</CODE></P>
      <P><CODE>short_arg = 1, long_arg = 2, vstring_arg = 'hello, world'</CODE></P>
      <P><CODE>fopaque[] = 99, 88, 77</CODE></P>
      <P><CODE>vopaque&lt;&gt; = 33 44</CODE></P>
      <P><CODE>fshort_arg[] = 9999, 8888, 7777, 6666</CODE></P>
      <P><CODE>vlong&lt;&gt; = 123456 234567 345678</CODE></P>
      <P><CODE>uarg (int) = 123</CODE></P>
      <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader241" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

      <P>Рис. 16.4. Формат потока XDR, записанный в листинге 16.13</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label792 style="border:none;"></a>Пример: вычисление размера буфера</P>
      </H1>
      <P>В предыдущем примере мы выделяли буфер размера BUFFSIZE (определенного в файле unpiрс.h в листинге В.1), и этого было достаточно. К сожалению, не существует простого способа вычислить объем памяти, нужный XDR для кодирования конкретных данных. Вычислить размер структуры вызовом sizeof недостаточно, потому что каждое поле кодируется XDR по отдельности. Нам придется перебирать элементы структуры, прибавляя к конечному результату объем памяти, нужный XDR для кодирования очередного элемента. В листинге 16.15 приведен пример простой структуры с тремя полями.</P>
      <H2><a name=label793 style="border:none;"></a>Листинг 16.15. Спецификация XDR для простой структуры</H2>
      <P><CODE>//sunrpc/xdrl/examplе.х</CODE></P>
      <P><CODE>1 const MAXC = 4;</CODE></P>
      <P><CODE>2 struct example {</CODE></P>
      <P><CODE>3  short a;</CODE></P>
      <P><CODE>4  double b;</CODE></P>
      <P><CODE>5  short c[MAXC];</CODE></P>
      <P><CODE>6 };</CODE></P>
      <P>Программа, текст которой приведен в листинге 16.16, вычисляет размер буфера, требуемого XDR для кодирования этой структуры. Он получается равным 28 байт.</P>
      <H2><a name=label794 style="border:none;"></a>Листинг 16.16. Программа, вычисляющая размер буфера XDR</H2>
      <P><CODE>//sunrpc/xdr1/example.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "example.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int size;</CODE></P>
      <P><CODE>7   example foo;</CODE></P>
      <P><CODE>8   size = RNDUP(sizeof(foo.a)) + RNDUP(sizeof(foo.b)) +</CODE></P>
      <P><CODE>9    RNDUP(sizeof(foo.c[0])) * MAXC;</CODE></P>
      <P><CODE>10  printf("size = %d\n", size);</CODE></P>
      <P><CODE>11  exit(0);</CODE></P>
      <P><CODE>12 }</CODE></P>
      <P>8-9 Макрос RNDUP определен в файле &lt;rpc/xdr.h&gt;. Он округляет аргумент к ближайшему кратному BYTES_PER_XDR_UNIT (4). Для массива фиксированного размера вычисляется размер каждого элемента, который затем умножается на количество элементов.</P>
      <P>Проблема возникает в случае использования типов данных переменной длины. Если мы объявим stringd&lt;10&gt;, максимальный размер будет RNDUP(sizeof( int)) (для длины) плюс RNDUP(sizeof(char)*10) (для символов строки). Но мы не можем вычислить размер буфера, если максимальный размер не указан в объявлении переменной (например, float e&lt;&gt;). Лучше всего в этом случае выделять буфер с запасом, а потом проверять, не возвращают ли подпрограммы XDR ошибку (упражнение 16.5).</P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label795 style="border:none;"></a>Пример: необязательные данные</P>
      </H1>
      <P>Существуют три способа задания необязательных данных в файле XDR, примеры для всех приведены в листинге 16.17.</P>
      <H2><a name=label796 style="border:none;"></a>Листинг 16.17. Файл спецификации XDR, иллюстрирующий способы задания необязательных данных</H2>
      <P><CODE>//sunrpc/xdr1/opt1.x</CODE></P>
      <P><CODE>1  union optlong switch (bool flag) {</CODE></P>
      <P><CODE>2  case TRUE:</CODE></P>
      <P><CODE>3   long val;</CODE></P>
      <P><CODE>4  case FALSE:</CODE></P>
      <P><CODE>5   void;</CODE></P>
      <P><CODE>6  };</CODE></P>
      <BR>
      <P><CODE>7  struct args {</CODE></P>
      <P><CODE>8   optlong arg1; /* объединение с булевским дискриминантом */</CODE></P>
      <P><CODE>9   long arg2&lt;1&gt;; /* массив переменной длины с одним элементом */</CODE></P>
      <P><CODE>10  long *arg3; /* указатель */</CODE></P>
      <P><CODE>11 };</CODE></P>
      <H2><a name=label797 style="border:none;"></a>Объявление объединения с булевским дискриминантом</H2>
      <P>1-8 Мы определяем объединение с ветвями FALSE и TRUE и структуру этого типа. Если флаг дискриминанта TRUE, за ним следует значение типа long; в противном случае за ним ничего не следует. После кодирования библиотекой XDR это объединение будет закодировано как:</P>
      <P>■ 4 байта флага со значением 1 (TRUE) и 4 байта целочисленного значения либо</P>
      <P>■ 4 байта флага со значением 0 (FALSE).</P>
      <H2><a name=label798 style="border:none;"></a>Объявление массива переменной длины</H2>
      <P>9 Если мы указываем массив переменной длины с одним возможным элементом, он будет передан как:</P>
      <P>■ 4 байта со значением 1 и 4 байта значения либо</P>
      <P>■ 4 байта со значением 0.</P>
      <H2><a name=label799 style="border:none;"></a>Объявление указателя XDR</H2>
      <P>10 Новый способ определения необязательных данных заключается в объявлении указателя. Он будет закодирован как:</P>
      <P>■ 4 байта со значением 1 и 4 байта значения либо</P>
      <P>■ 4 байта со значением 0</P>
      <P>в зависимости от значения соответствующего указателя при кодировании данных. Если указатель ненулевой, используется первый вариант кодирования. Если указатель нулевой, получится второй вариант. Это удобный способ кодирования необязательных данных в случае, если в нашем коде имеется указатель на эти данные.</P>
      <P>Важная деталь реализации, благодаря которой оба варианта дают одинаковый результат при кодировании, заключается в том, что значение TRUE равно 1, что совпадает с длиной массива переменной длины, когда в нем есть один элемент.</P>
      <P>В листинге 16.18 приведен текст заголовочного файла, созданного программой rpcgen для данного файла спецификации.</P>
      <H2><a name=label800 style="border:none;"></a>Листинг 16.18. Заголовочный файл, получившийся в результате обработки листинга 16.17</H2>
      <P><CODE>//sunrpc/xdr1/opt1.h</CODE></P>
      <P><CODE>7  struct optlong {</CODE></P>
      <P><CODE>8   bool_t flag;</CODE></P>
      <P><CODE>9   union {</CODE></P>
      <P><CODE>10  long val;</CODE></P>
      <P><CODE>11  } optlong_u;</CODE></P>
      <P><CODE>12 };</CODE></P>
      <P><CODE>13 typedef struct optlong optlong;</CODE></P>
      <BR>
      <P><CODE>14 struct args {</CODE></P>
      <P><CODE>15  optlong arg1;</CODE></P>
      <P><CODE>16  struct {</CODE></P>
      <P><CODE>17   u_int arg2_len;</CODE></P>
      <P><CODE>18   long *arg2_val;</CODE></P>
      <P><CODE>19  } arg2;</CODE></P>
      <P><CODE>20  long *arg3;</CODE></P>
      <P><CODE>21 };</CODE></P>
      <P><CODE>22 typedef struct args args;</CODE></P>
      <P>14-21 Хотя все три аргумента кодируются одинаково, способы присваивания и получения их значений в языке С различны.</P>
      <P>В листинге 16.19 приведен текст простой пpoгрaммы, устанавливающей значения всех трех аргументов так, что ни одно из полей long не кодируется.</P>
      <H2><a name=label801 style="border:none;"></a>Листинг 16.19. Ни одно из значений не будет закодировано</H2>
      <P><CODE>//sunrpc/xdr1/opt1z.с</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "opt1.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int i;</CODE></P>
      <P><CODE>7   XDR xhandle;</CODE></P>
      <P><CODE>8   char *buff;</CODE></P>
      <P><CODE>9   long *lptr;</CODE></P>
      <P><CODE>10  args out;</CODE></P>
      <P><CODE>11  size_t size;</CODE></P>
      <P><CODE>12  out.arg1.flag = FALSE;</CODE></P>
      <P><CODE>13  out.arg2.arg2_len = 0;</CODE></P>
      <P><CODE>14  out.arg3 = NULL;</CODE></P>
      <P><CODE>15  buff = Malloc(BUFFSIZE); /* Адрес должен быть кратен четырем */</CODE></P>
      <P><CODE>16  xdrmem_create(&amp;xhandle, buff, BUFFSIZE, XOR_ENCODE);</CODE></P>
      <P><CODE>17  if (xdr_args(&amp;xhandle, &amp;out) != TRUE)</CODE></P>
      <P><CODE>18   err_quit("xdr_args error");</CODE></P>
      <P><CODE>19  size = xdr_getpos(&amp;xhandle);</CODE></P>
      <P><CODE>20  lptr = (long*)buff;</CODE></P>
      <P><CODE>21  for (i = 0; i &lt; size; i += 4)</CODE></P>
      <P><CODE>22   printf("%ld\n", (long) ntohl(*lptr++));</CODE></P>
      <P><CODE>23  exit(0);</CODE></P>
      <P><CODE>24 }</CODE></P>
      <H2><a name=label802 style="border:none;"></a>Присваивание значений</H2>
      <P>12-14 Дискриминанту объединения присваивается значение FALSE, длина массива переменной длины устанавливается в 0, а указатель делается нулевым (NULL).</P>
      <H2><a name=label803 style="border:none;"></a>Выделение буфера и кодирование</H2>
      <P>15-19 Мы выделяем буфер и кодируем структуру out в поток XDR. </P>
      <H2><a name=label804 style="border:none;"></a>Вывод содержимого буфера XDR</H2>
      <P>20-22 Мы выводим содержимое буфера XDR по 4 байта, используя функцию ntohl (host-to-network long integer) для преобразования из порядка XDR big-endian в байтовый порядок узла. В результате получается именно то, что должно было быть помещено в буфер библиотекой XDR времени выполнения:</P>
      <P><CODE>solaris % <STRONG>opt1z</STRONG></CODE></P>
      <P><CODE>0</CODE></P>
      <P><CODE>0</CODE></P>
      <P><CODE>0</CODE></P>
      <P>Как мы и предполагали, каждому аргументу отводится 4 байта со значением О, указывающим на то, что за ним не следует никаких данных.</P>
      <P>В листинге 16.20 приведена измененная версия программы, которая присваивает значения всем трем аргументам, кодирует их в поток XDR и выводит его содержимое.</P>
      <H2><a name=label805 style="border:none;"></a>Листинг 16.20. Присваивание значений аргументам из листинга 16.17</H2>
      <P><CODE>//sunrpc/xdr1/opt1.c</CODE></P>
      <P><CODE>1  #include "unpipc.h"</CODE></P>
      <P><CODE>2  #include "opt1.h"</CODE></P>
      <BR>
      <P><CODE>3  int</CODE></P>
      <P><CODE>4  main(int argc, char **argv)</CODE></P>
      <P><CODE>5  {</CODE></P>
      <P><CODE>6   int i;</CODE></P>
      <P><CODE>7   XOR xhandle;</CODE></P>
      <P><CODE>8   char *buff;</CODE></P>
      <P><CODE>9   long lval2, lval3, *lptr;</CODE></P>
      <P><CODE>10  args out;</CODE></P>
      <P><CODE>11  size_t size;</CODE></P>
      <P><CODE>12  out.arg1.flag = TRUE;</CODE></P>
      <P><CODE>13  out.arg1.optlong_u.val = 5;</CODE></P>
      <P><CODE>14  lval2 = 9876;</CODE></P>
      <P><CODE>15  out.arg2.arg2_len = 1;</CODE></P>
      <P><CODE>16  out.arg2.arg2_val = &amp;lval2;</CODE></P>
      <P><CODE>17  lval3 = 123;</CODE></P>
      <P><CODE>18  out.arg3 = &amp;lval3;</CODE></P>
      <P><CODE>19  buff = Malloc(BUFFSIZE); /* адрес должен быть кратен 4 */</CODE></P>
      <P><CODE>20  xdrmem_create(&amp;xhandle, buff, BUFFSIZE, XDR_ENCODE);</CODE></P>
      <P><CODE>21  if (xdr_args(&amp;xhandle, &amp;out) != TRUE)</CODE></P>
      <P><CODE>22   err_quit("xdr_args error");</CODE></P>
      <P><CODE>23  size = xdr_getpos(&amp;xhandle);</CODE></P>
      <P><CODE>24  lptr = (long *) buff;</CODE></P>
      <P><CODE>25  for (i = 0; i &lt; size; i += 4)</CODE></P>
      <P><CODE>26   printf("%ld\n", (long) ntohl(*lptr++));</CODE></P>
      <P><CODE>27  exit(0);</CODE></P>
      <P><CODE>28 }</CODE></P>
      <H2><a name=label806 style="border:none;"></a>Присваивание значений</H2>
      <P>12-18 Для присваивания значения объединению мы устанавливаем дискриминант в TRUE, а затем присваиваем значение полю long. Длину массива мы также сначала устанавливаем в 1. Указатель мы устанавливаем на соответствующее значение в памяти.</P>
      <P>При запуске этой программы мы получим ожидаемые шесть 4-байтовых значений:</P>
      <P><CODE>solaris % <STRONG>opt1</STRONG></CODE></P>
      <P><CODE>1 <EM>значение дискриминанта TRUE</EM></CODE></P>
      <P><CODE>5</CODE></P>
      <P><CODE>1 <EM>длина массива переменной длины</EM></CODE></P>
      <P><CODE>9876</CODE></P>
      <P><CODE>1 <EM>флаг для ненулевого указателя</EM></CODE></P>
      <P><CODE>123</CODE></P>
     </DIV>
     <DIV class=section>
      <H1>
       <P><a name=label807 style="border:none;"></a>Пример: обработка связного списка</P>
      </H1>
      <P>Если осуществима передача необязательных данных, мы можем расширить возможности указателей в XDR и использовать их для кодирования и декодирования связных списков, содержащих произвольное количество элементов. В нашем примере используется связный список пар имя-значение. Соответствующий файл спецификации XDR приведен в листинге 16.21.</P>
      <H2><a name=label808 style="border:none;"></a>Листинг 16.21. Спецификация XDR для связного списка пар имя-значение</H2>
      <P><CODE>//sunrpc/xdr1/opt2.x</CODE></P>
      <P><CODE>1 struct mylist {</CODE></P>
      <P><CODE>2  string name&lt;&gt;;</CODE></P>
      <P><CODE>3  long value;</CODE></P>
      <P><CODE>4  mylist *next;</CODE></P>
      <P><CODE>5 };</CODE></P>
      <BR>
      <P><CODE>6 struct args {</CODE></P>
      <P><CODE>7  mylist *list;</CODE></P>
      <P><CODE>8 };</CODE></P>
      <P>1-5 Структура mylist содержит одну пару имя-значение и указатель на следующую структуру такого типа. Указатель в последней структуре списка будет нулевым.</P>
      <P>В листинге 16.22 приведен текст заголовочного файла, созданного программой rpcgen из файла opt2.х.</P>
      <H2><a name=label809 style="border:none;"></a>Листинг 16.22. Заголовочный файл, созданный программой rpcgen</H2>
      <P><CODE>//sunrpc/xdr1/opt2.h</CODE></P>
      <P><CODE>7  struct mylist {</CODE></P>
      <P><CODE>8   char *name;</CODE></P>
      <P><CODE>9   long value;</CODE></P>
      <P><CODE>10  struct mylist *next;</CODE></P>
      <P><CODE>11 };</CODE></P>
      <P><CODE>12 typedef struct mylist mylist;</CODE></P>
      <BR>
      <P><CODE>13 struct args {</CODE></P>
      <P><CODE>14  mylist *list;</CODE></P>
      <P><CODE>15 };</CODE></P>
      <P><CODE>16 typedef struct args args;</CODE></P>
      <P>В листинге 16.23 приведен текст программы, инициализирующей связный список с тремя парами имя-значение и кодирующей его с помощью библиотеки XDR.</P>
      <H2><a name=label810 style="border:none;"></a>Листинг 16.23. Инициализация, кодирование связного списка и вывод результата</H2>
      <P><CODE>1  //sunrpc/xdr1/opt2.c</CODE></P>
      <P><CODE>2  #include "unpipc.h"</CODE></P>
      <P><CODE>3  #include "opt2.h"</CODE></P>
      <BR>
      <P><CODE>4  int</CODE></P>
      <P><CODE>5  main(int argc, char **argv)</CODE></P>
      <P><CODE>6  {</CODE></P>
      <P><CODE>7   int i;</CODE></P>
      <P><CODE>8   XDR xhandle;</CODE></P>
      <P><CODE>9   long *lptr;</CODE></P>
      <P><CODE>10  args out; /* структура, которую мы заполняем */</CODE></P>
      <P><CODE>11  char *buff; /* результат кодирования */</CODE></P>
      <P><CODE>12  mylist nameval[4]; /* до четырех элементов в списке */</CODE></P>
      <P><CODE>13  size_t size;</CODE></P>
      <P><CODE>14  out.list = &amp;nameval[2]; /* [2] –&gt; [1] –&gt; [0] */</CODE></P>
      <P><CODE>15  nameval[2].name = "name1";</CODE></P>
      <P><CODE>16  nameval[2].value = 0x1111;</CODE></P>
      <P><CODE>17  nameval[2].next = &amp;nameval[1];</CODE></P>
      <P><CODE>18  nameval[1].name = "namee2";</CODE></P>
      <P><CODE>19  nameval[1].value = 0x2222;</CODE></P>
      <P><CODE>20  nameval[1].next = &amp;nameval[0];</CODE></P>
      <P><CODE>21  nameval[0].name = "nameee3";</CODE></P>
      <P><CODE>22  nameval[0].value = 0x3333;</CODE></P>
      <P><CODE>23  nameval[0].next = NULL;</CODE></P>
      <P><CODE>24  buff = Malloc(BUFFSIZE); /* адрес должен быть кратен 4 */</CODE></P>
      <P><CODE>25  xdrmem_create(&amp;xhandle, buff, BUFFSIZE, XDR_ENCODE);</CODE></P>
      <P><CODE>26  if (xdr_args(&amp;xhandle, tout) != TRUE)</CODE></P>
      <P><CODE>27   err_quit("xdr_args error");</CODE></P>
      <P><CODE>28  size = xdr_getpos(&amp;xhandle);</CODE></P>
      <P><CODE>29  lptr = (long*)buff;</CODE></P>
      <P><CODE>30  for (i = 0; i &lt; size; i += 4)</CODE></P>
      <P><CODE>31   printf("%8lx\n", (long)ntohl(*lptr++));</CODE></P>
      <P><CODE>32  exit(0);</CODE></P>
      <P><CODE>33 }</CODE></P>
      <H2><a name=label811 style="border:none;"></a>Инициализация связного списка</H2>
      <P>11-22 Мы выделяем память под четыре элемента, но инициализируем только три из них. Первая запись nameval[2], потом nameval[1] и nameval[0]. Указатель на начало списка (out.list) устанавливается на &amp;nameval[2]. Мы инициализируем список в таком порядке, чтобы показать, что библиотека XDR обрабатывает указатели и порядок в списке оказывается именно таким, каким он был в нашей программе, и не зависит от того, какие массивы для этого используются. Мы также инициализируем значения элементов списка шестнадцатеричными величинами, поскольку будем выводить их в этом формате.</P>
      <P>Вывод программы показывает, что перед каждым элементом списка идет значение 1 в 4 байтах (что мы можем считать длиной массива переменной длины с одним элементом или булевским значением TRUE). Четвертая запись состоит из 4 байт, в которых записан 0. Она обозначает конец списка:</P>
      <P><CODE>solaris % <STRONG>opt2</STRONG></CODE></P>
      <P><CODE>1        <EM>дальше идет один элемент</EM></CODE></P>
      <P><CODE>5        <EM>длина строки</EM></CODE></P>
      <P><CODE>6e616d65 <EM>имя(name)</EM></CODE></P>
      <P><CODE>31000000 <EM>1 и три байта дополнения</EM></CODE></P>
      <P><CODE>1111     <EM>значение</EM></CODE></P>
      <P><CODE>1        <EM>один элемент</EM></CODE></P>
      <P><CODE>6        <EM>длина строки</EM></CODE></P>
      <P><CODE>6e616d65 <EM>имя</EM></CODE></P>
      <P><CODE>65320000 <EM>е 2 и 2 байта дополнения</EM></CODE></P>
      <P><CODE>2222     <EM>значение</EM></CODE></P>
      <P><CODE>1        <EM>один элемент</EM></CODE></P>
      <P><CODE>7        <EM>длина строки</EM></CODE></P>
      <P><CODE>6e616d65 <EM>имя</EM></CODE></P>
      <P><CODE>65653300 <EM>е е 3 и 1 байт дополнения</EM></CODE></P>
      <P><CODE>3333     <EM>значение</EM></CODE></P>
      <P><CODE>0        <EM>конец списка</EM></CODE></P>
      <P>При декодировании списка библиотека XDR будет динамически выделять память под его элементы и указатели и связывать все это вместе, что позволит легко переходить от одного элемента списка к другому в программе на С.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label812 style="border:none;"></a>16.9. Форматы пакетов RPC</P>
     </H1>
     <P>На рис. 16.5 приведен формат запроса RPC в пакете TCP.</P>
     <P>Поскольку TCP передает поток байтов и не предусматривает границ сообщений, приложение должно предусматривать способ разграничения сообщений. Sun RPC определяет запись как запрос или ответ, и каждая запись состоит из одного или более фрагментов. Каждый фрагмент начинается с 4-байтового значения: старший бит является флагом последнего фрагмента, а следующие 31 бит представляют собой счетчик (длина фрагмента). Если бит последнего фрагмента имеет значение 0, данный фрагмент не является последним в записи.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Это 4-байтовое значение передается в порядке big-endian, так же как и 4-байтовые целые в XDR, но оно не относится к стандарту XDR, поскольку он не предусматривает передачи битовых полей.</P>
     </DIV>
     <P>Если вместо TCP используется UDP, первое поле в заголовке UDP будет идентификатором транзакции (XID), как показано на рис. 16.7.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>При использовании TCP на размер запроса и ответа RPC ограничения не накладываются, поскольку может использоваться любое количество фрагментов, а длина каждого из них задается 31-разрядным целым. Но при использовании протокола UDP запрос (и ответ) должен помещаться в дейтаграмму целиком, а максимальное количество данных в ней — 65507 байт (для IPv4). Во многих реализациях, предшествовавших TI-RPC, размер ограничивался значением около 8192 байт, поэтому если требуется передавать более 8000 байт, следует пользоваться протоколом TCP.</P>
     </DIV>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader243" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 16.5. Запрос RPC в пакете TCP</P>
     <BR>
     <P>Приведем спецификацию XDR для запроса RPC, взятую из RFC 1831. Имена на рис. 16.5 взяты из этой спецификации:</P>
     <P><CODE>enum autn_flavor {</CODE></P>
     <P><CODE> AUTH_NONE = 0,</CODE></P>
     <P><CODE> AUTH_SYS = 1,</CODE></P>
     <P><CODE> AUTH_SHORT = 2</CODE></P>
     <P><CODE> /* and more to be defined */</CODE></P>
     <P><CODE>};</CODE></P>
     <P><CODE>struct opaque_auth {</CODE></P>
     <P><CODE> auth_flavor flavor;</CODE></P>
     <P><CODE> opaque body&lt;400&gt;;</CODE></P>
     <P><CODE>};</CODE></P>
     <P><CODE>enum msg_type {</CODE></P>
     <P><CODE> CALL = 0,</CODE></P>
     <P><CODE> REPLY = 1</CODE></P>
     <P><CODE>};</CODE></P>
     <P><CODE>struct call_body {</CODE></P>
     <P><CODE> unsigned int rpcvers; /* версия RPC: должна быть 2 */</CODE></P>
     <P><CODE> unsigned int prog; /* номер программы */</CODE></P>
     <P><CODE> unsigned int vers; /* номер версии */</CODE></P>
     <P><CODE> unsigned int proc; /* номер процедуры */</CODE></P>
     <P><CODE> opaque_auth cred; /* данные вызывающего */</CODE></P>
     <P><CODE> opaque_auth verf; /* проверочная информация вызывающего */</CODE></P>
     <P><CODE>/* параметры, относящиеся к процедуре */</CODE></P>
     <P><CODE>};</CODE></P>
     <P><CODE>struct rpc_msg {</CODE></P>
     <P><CODE> unsigned int xid;</CODE></P>
     <P><CODE> union switch (msg_type mtype) {</CODE></P>
     <P><CODE> case CALL:</CODE></P>
     <P><CODE>  call_body cbody;</CODE></P>
     <P><CODE> case REPLY:</CODE></P>
     <P><CODE>  reply_body rbody;</CODE></P>
     <P><CODE> } body;</CODE></P>
     <P><CODE>};</CODE></P>
     <P>Содержимое скрытых данных переменной длины, содержащих сведения о пользователе и проверочную информацию, зависит от типа аутентификации. Для нулевой аутентификации, используемой по умолчанию, длина этих данных должна быть установлена в 0. Для аутентификации Unix эти данные содержат следующую структуру:</P>
     <P><CODE>struct authsys_parms {</CODE></P>
     <P><CODE> unsigned int stamp;</CODE></P>
     <P><CODE> string machinename&lt;255&gt;;</CODE></P>
     <P><CODE> unsigned int uid;</CODE></P>
     <P><CODE> unsigned int gid;</CODE></P>
     <P><CODE> unsigned int gids&lt;16&gt;;</CODE></P>
     <P><CODE>};</CODE></P>
     <P>Если тип аутентификации AUTH_SYS, тип проверки должен быть AUTH_NONE. Формат ответа RPC сложнее, чем формат запроса, поскольку в нем могут передаваться сообщения об ошибках. На рис. 16.6 показаны возможные варианты. На рис. 16.7 показан формат ответа RPC в случае успешного выполнения процедуры. Ответ передается по протоколу UDP. </P>
     <P>Ниже приводится текст спецификации XDR ответа RPC, взятый из RFC 1831.</P>
     <P><CODE>enum reply_stat {</CODE></P>
     <P><CODE> MSG_ACCEPTED = 0,</CODE></P>
     <P><CODE> MSG_DENIED = 1</CODE></P>
     <P><CODE>};</CODE></P>
     <P><CODE>enum accept_stat {</CODE></P>
     <P><CODE> SUCCESS = 0, /* успешное завершение вызова RPC */</CODE></P>
     <P><CODE> PROG_UNAVAIL = 1, /* требуемый номер программы недоступен */</CODE></P>
     <P><CODE> PROG_MISMATCH = 2, /* требуемый номер версии недоступен */</CODE></P>
     <P><CODE> PROC_UNAVAIL = 3, /* номер процедуры недоступен */</CODE></P>
     <P><CODE> GARBAGE_ARGS = 4, /* не могу декодировать аргументы */</CODE></P>
     <P><CODE> SYSTEM_ERR = 5 /* ошибка выделения памяти и т. п. */</CODE></P>
     <P><CODE>};</CODE></P>
     <P><CODE>struct accepted_reply {</CODE></P>
     <P><CODE> opaque_auth verf;</CODE></P>
     <P><CODE> union switch (accept_stat stat) {</CODE></P>
     <P><CODE> case SUCCESS:</CODE></P>
     <P><CODE>  opaque results[0]; /* результаты, возвращаемые процедурой */</CODE></P>
     <P><CODE> case PROG_MISMATCH:</CODE></P>
     <P><CODE>  struct {</CODE></P>
     <P><CODE>   unsigned int low; /* наименьший поддерживаемый номер программы */</CODE></P>
     <P><CODE>   unsigned int high; /* наибольший поддерживаемый номер программы */</CODE></P>
     <P><CODE>  } mismatch_info;</CODE></P>
     <P><CODE> default: /* PROG_UNAVAIL, PROC_UNAVAIL, GARBAGE_ARGS, SYSTEM_ERR */</CODE></P>
     <P><CODE>  void;</CODE></P>
     <P><CODE> } reply_data;</CODE></P>
     <P><CODE>};</CODE></P>
     <P><CODE>union reply_body switch (reply_stat stat) {</CODE></P>
     <P><CODE>case MSG_ACCEPTED:</CODE></P>
     <P><CODE> accepted_reply areply;</CODE></P>
     <P><CODE>case MSG_DENIED:</CODE></P>
     <P><CODE> rejected_reply rreply;</CODE></P>
     <P><CODE>} reply;</CODE></P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader244" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 16.6. Возможные варианты ответов RPC</P>
     <BR>
     <P>Вызов может быть отклонен сервером, если номер версии RPC не тот или возникает ошибка аутентификации:</P>
     <P><CODE>enum reject_stat {</CODE></P>
     <P><CODE> RPC_MISMATCH = 0, /* номер версии RPC отличен от 2 */</CODE></P>
     <P><CODE> AUTH_ERROR =1 /* ошибка аутентификации */</CODE></P>
     <P><CODE>};</CODE></P>
     <P><CODE>enum auth_stat {</CODE></P>
     <P><CODE> AUTH_OK = 0, /* успешное завершение */</CODE></P>
     <P><CODE> /* ошибки на сервере */</CODE></P>
     <P><CODE> AUTH_BADCRED = 1, /* ошибка в личных данных пользователя (нарушена контрольная сумма) */</CODE></P>
     <P><CODE> AUTH_REJECTEDCRED <EM>=</EM> 2, /* клиент должен начать сеанс заново */</CODE></P>
     <P><CODE> AUTH_BADVERF = 3, /* ошибка в проверочных данных (нарушена контрольная сумма) */</CODE></P>
     <P><CODE> AUTH_REJECTEDVERF = 4, /* проверочные данные устарели или были повторы */</CODE></P>
     <P><CODE> AUTH_TOOWEAK = 5, /* запрос отклонен системой безопасности */</CODE></P>
     <P><CODE> /* ошибки клиента */</CODE></P>
     <P><CODE> AUTH_INVALIDRESP = 6, /* фальшивые проверочные данные в ответе */</CODE></P>
     <P><CODE> AUTH_FAILED = 7 /* причина неизвестна */</CODE></P>
     <P><CODE>};</CODE></P>
     <P><CODE>union rejected_reply switch (reject_stat stat) {</CODE></P>
     <P><CODE>case RPC_MISMATCH:</CODE></P>
     <P><CODE> struct {</CODE></P>
     <P><CODE>  unsigned int low; /* наименьший номер версии RPC */</CODE></P>
     <P><CODE>  unsigned int high; /* наибольший номер версии RPC */</CODE></P>
     <P><CODE> } mismatch_info;</CODE></P>
     <P><CODE>case AUTH_ERROR:</CODE></P>
     <P><CODE> auth_stat stat;</CODE></P>
     <P><CODE>};</CODE></P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader245" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. 16.7. Ответ на успешно обработанный вызов в дейтаграмме UDP</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label813 style="border:none;"></a>16.10. Резюме</P>
     </H1>
     <P>Средства Sun RPC дают возможность создавать распределенные приложения, в которых клиентская часть может выполняться на одном узле, а серверная — на другом. Сначала следует определить процедуры сервера, которые могут быть вызваны клиентом, и написать файл спецификации RPC, описывающий аргументы и возвращаемые значения этих процедур. Затем пишется функция main клиента, вызывающая процедуры сервера, а потом сами эти процедуры. Программа клиента выглядит так, как будто она просто вызывает процедуры сервера, но на самом деле их скрытое взаимодействие по сети обеспечивается библиотекой RPC.</P>
     <P>Программа rpcgen является краеугольным камнем приложения, использующего RPC. Она считывает файл спецификации и создает заглушку клиента и заглушку сервера, а также функции, вызывающие требуемые подпрограммы XDR, которые осуществляют все необходимые преобразования данных. Библиотека XDR также является важной частью процесса. XDR определяет стандарт обмена данными различного формата между разными системами, у которых может быть по-разному определен, например, размер целого, порядок байтов и т. п. Как мы показали, XDR можно использовать и отдельно от RPC для обмена данными в машинно-независимом стандартном формате. Для передачи данных можно использовать любой механизм (сокеты, XTI, дискеты, компакт-диски или что угодно).</P>
     <P>В Sun RPC используется свой стандарт именования программ. Каждой программе присваивается 32-разрядный номер программы, 32-разрядный номер версии и 32-разрядный номер процедуры. Каждый узел с сервером RPC должен выполнять программу отображения портов в фоновом режиме (RPCBIND). Серверы RPC привязывают временные порты TCP и UDP к своим процедурам, а затем регистрируют эти порты в программе отображения портов, указывая номера программ и версий. При запуске клиент RPC связывается с программой отображения портов узла, где запущен сервер RPC, и выясняет номер нужного ему порта, а затем связывается с самим сервером по протоколам TCP или UDP.</P>
     <P>По умолчанию клиенты RPC не предоставляют аутентификационной информации и серверы RPC обрабатывают все приходящие запросы. Это аналогично написанию собственного приложения клиент-сервер с использованием сокетов или XTI. В Sun RPC предоставляются три дополнительные формы аутентификации: аутентификация Unix (предоставляется имя узла клиента, идентификатор пользователя и группы), аутентификация DES (основанная на криптографии с секретным и открытым ключом) и аутентификация Kerberos.</P>
     <P>Понимание стратегии тайм-аутов и повторных передач пакета RPC важно при использовании RPC (как и любой формы сетевого программирования). При использовании надежного транспортного протокола, такого, как TCP, клиенту RPC нужно использовать только общий тайм-аут, поскольку потеря пакетов или прием лишних копий целиком обрабатываются на транспортном уровне. Когда используется ненадежный транспортный протокол, такой как UDP, пакет RPC использует тайм-аут повтора в дополнение к общему тайм-ауту. Идентификатор транзакций используется клиентом RPC для проверки ответа на соответствие отправленному запросу. </P>
     <P>Любой вызов процедуры может быть отнесен к группе «ровно один», «не более чем один» или «не менее чем один». Для локальных вызовов этот вопрос можно не принимать во внимание, но при использовании RPC эту разницу следует понимать. Следует также понимать различия между идемпотентными и неидемпотентными процедурами.</P>
     <P>Sun RPC — это большой пакет, и мы лишь вкратце обсудили особенности его использования. Тем не менее сведений, приведенных в этой главе, должно быть достаточно для написания приложений целиком. Использование rpcgen скрывает многие детали и упрощает кодирование. Документация Sun описывает различные уровни кодирования RPC — упрощенный интерфейс, верхний уровень, средний уровень, уровень экспертов и низкий уровень, но эти категории достаточно бессмысленны. Количество функций в библиотеке RPC — 164, они могут быть разделены следующим образом:</P>
     <P>■ 11 auth_ (аутентификация);</P>
     <P>■ 26 clnt_ (клиентские);</P>
     <P>■ 5 pmap_ (доступ к программе отображения портов);</P>
     <P>■ 24 rpc_ (общего назначения);</P>
     <P>■ 44 svc_ (серверные);</P>
     <P>■ 54 xdr_ (преобразования XDR).</P>
     <P>Для сравнения отметим, что интерфейсы сокетов и XTI содержат по 25 функций, а интерфейсы дверей, очередей сообщений Posix и System V, семафоров и разделяемой памяти содержат по 10 функций. 15 функций используются для работы с потоками в стандарте Posix, 10 — для работы с условными переменными. 11 функций используются для работы с блокировками чтения-записи Posix и одна при работе с блокировкой записей fcntl.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label814 style="border:none;"></a>Упражнения</P>
     </H1>
     <P>1. При запуске сервер регистрируется в программе отображения портов. Что происходит при завершении сервера, например, клавишей завершения программы с терминала? Что произойдет, если на этот сервер впоследствии придет запрос от клиента?</P>
     <P>2. Клиент взаимодействует с сервером RPC по протоколу UDP, и кэш не включен. Клиент посылает запрос на сервер, но серверу требуется 20 секунд до отправки ответа. Клиент посылает запрос повторно через 15 секунд, что приводит к повторному запуску процедуры сервера. Что произойдет со вторым ответом сервера?</P>
     <P>3. Тип XDR string всегда кодируется в значение длины и последовательность символов. Что произойдет, если мы напишем char с[10] вместо string s&lt;10&gt;?</P>
     <P>4. Измените максимальный размер string в листинге 16.11 со 128 на 10 и запустите программу write. Что произойдет? Уберите ограничение длины и сравните файл data_xdr.с с тем, который был создан, когда длина была ограничена. Что изменилось?</P>
     <P>5. Измените третий аргумент в вызове xdrmem_create (размер буфера) в листинге 16.13 на 50 и посмотрите, что произойдет.</P>
     <P>6. В разделе 16.5 мы описали включение кэша повторных ответов при использовании протокола UDP. Мы можем сказать, что протокол TCP имеет свой собственный кэш такого рода. О чем мы говорим и как велик этот кэш у протокола TCP? (Подсказка: как протокол TCP определяет, что принята копия полученных ранее данных?)</P>
     <P>7. Есть пять полей, уникально идентифицирующих каждую запись в кэше сервера. В каком порядке следует их сравнивать, чтобы минимизировать количество сравнений?</P>
     <P>8. При просмотре передаваемых пакетов с помощью tcpdump в примере из раздела 16.5, где использовался TCP, мы узнаем, что размер запроса 48 байт, а размер ответа 32 байт (без заголовков TCP и IPv4). Получите этот размер из рисунка 16.3. Каков был бы размер при использовании UDP вместо TCP?</P>
     <P>9. Может ли клиент RPC в системе, не поддерживающей потоки, вызвать процедуру сервера, скомпилированную с поддержкой потоков? Что можно сказать о различии в передаваемых аргументах, о котором говорилось в разделе 16.2? </P>
     <P>10. В программе read из листинга 16.19 мы выделяли место под буфер, в который считывался файл, и этот буфер содержал указатель vstring_arg. Но где хранится строка, на которую указывает vstring_arg? Измените программу так, чтобы проверить ваше предположение.</P>
     <P>11. Sun RPC определяет нулевую процедуру как процедуру с номером 0 (по этой причине мы всегда начинали нумерацию процедур с 1, как в листинге 16.1). Более того, любая заглушка сервера, созданная rpcgen, автоматически определяет эту процедуру (в чем вы можете легко убедиться, посмотрев текст любой заглушки, созданной для одного из наших примеров). Нулевая процедура не принимает никаких аргументов и ничего не возвращает. Часто она используется для проверки работы сервера и измерения скорости передачи пакетов на сервер и обратно. Но если мы посмотрим на заглушку клиента, мы увидим, что в ней не содержится заглушки для этой процедуры. Посмотрите в документации описание функции clnt_call и используйте ее для вызова нулевой процедуры для любого сервера этой главы.</P>
     <P>12. Почему в табл А.1 нет записи для сообщения размером 65536 для Sun RPC поверх UDP? Почему нет записей для сообщений длиной 16384 и 32768 в табл. А.2 для Sun RPC поверх UDP?</P>
     <P>13. Проверьте, что удаление вызова xdr_free из листинга 16.19 приведет к утечке памяти. Добавьте оператор</P>
     <P><CODE>for(;;) {</CODE></P>
     <P>непосредственно перед вызовом xdrmem_create и завершающую скобку непосредственно перед вызовом xdr_free. Запустите программу и следите за ее размером в памяти с помощью ps. Удалите закрывающую скобку и поставьте ее после вызова xdr_free. Запустите программу снова и последите за ее размером еще раз. </P>
    </DIV>
   </DIV>
  </DIV>
  <DIV class=section>
   <H1>
    <P><a name=label815 style="border:none;"></a>Эпилог</P>
   </H1>
   <BR>
   <P>В этой книге подробно описаны четыре средства межпроцессного взаимодействия (IPC):</P>
   <P>1. Передача сообщений (именованные и неименованные каналы, очереди сообщений Posix и System V).</P>
   <P>2. Синхронизация (взаимные исключения и условные переменные, блокировки чтения-записи, блокировки файлов и записей, семафоры Posix и System V).</P>
   <P>3. Разделяемая память (неименованная, именованная стандартов Posix и System V).</P>
   <P>4. Вызовы процедур (двери в системе Solaris, пакет Sun RPC).</P>
   <P>Передача сообщений и вызов процедур часто используются сами по себе, без дополнительных средств синхронизации. Разделяемая память, напротив, для нормального функционирования обычно требует введения дополнительной синхронизации. Средства синхронизации иногда используются сами по себе, то есть в отдельности от прочих средств IPC.</P>
   <P>После прочтения 16 глав возникает естественный вопрос: какую форму IPC следует использовать для решения какой-либо конкретной задачи? К сожалению, универсального метода не существует. Огромное количество средств IPC в Unix возникло благодаря тому, что нет какого-либо единственного средства, которым можно было бы решить все задачи (или хотя бы большинство). Все, что вам остается, — это познакомиться с особенностями всех форм IPC и учитывать их при разработке вашего приложения.</P>
   <P>Прежде всего перечислим главные по важности моменты, которые следует учесть при выборе средств организации IPC для приложения.</P>
   <P>1. Сетевое или несетевое. Мы предполагаем, что это решение уже принято и IPC используется между процессами или потоками, выполняющимися на одном узле. Если есть вероятность того, что приложение будет распределено между несколькими узлами, следует рассмотреть возможность использования сокетов вместо IPC, чтобы впоследствии легко было переделать приложение в сетевое.</P>
   <P>2. Переносимость (вспомните табл. 1.3). Практически все системы под управлением Unix поддерживают именованные и неименованные каналы и блокировку записей стандарта Posix. К 1998 году большинство систем поддерживало средства IPC System V (очереди сообщений, семафоры и разделяемую память), тогда как лишь немногие поддерживали те же средства стандарта Posix. Должны появиться новые реализации Posix IPC, но, к сожалению, эти средства не являются обязательными в стандарте Unix 98. Многие системы поддерживают потоки Posix (включая взаимные исключения и условные переменные) или станут поддерживать их в ближайшем будущем. Некоторые системы, поддерживающие потоки Posix, не воспринимают атрибут использования между процессами для взаимных исключений и условных переменных. Блокировки чтения-записи, требуемые стандартом Unix 98, должны вскоре войти в стандарт Posix, и множество систем уже поддерживают какой-либо из видов таких блокировок. Отображение в память распространено достаточно широко, и большинство Unix-систем поддерживают неименованное отображение (с использованием либо /dev/zero, либо MAP_ANON). Средства Sun RPC должны быть доступны практически на всех системах Unix, тогда как двери пока реализованы только в Solaris.</P>
   <P>3. Производительность. Если для вашего приложения критична скорость работы средств IPC, воспользуйтесь программами из приложения А. Лучше всего изменить эти программы для имитации среды, в которой будет работать ваше приложение, и таким образом измерить скорость работы средств IPC в этой среде.</P>
   <P>4. Планирование в реальном времени. Если вам нужно воспользоваться этой функцией и система ее поддерживает, рассмотрите возможность использования функций Posix для передачи сообщений и синхронизации (очереди сообщений, семафоры, взаимные исключения и условные переменные). Например, когда увеличиваются значения семафора, в вызове к которому заблокировано несколько потоков, разблокируемый поток выбирается в соответствии с политиками планирования и параметрами заблокированных потоков. Для семафоров System V это не гарантируется.</P>
   <P>Чтобы помочь вам понять некоторые особенности и ограничения средств IPC, мы вкратце перечислим основные различия между ними:</P>
   <P>■ Именованные и неименованные каналы представляют собой потоки байтов без грaниц между сообщениями. Очереди сообщений Posix и System V предусматривают наличие границ сообщений. Сравните это с протоколами Интернета: TCP — это поток байтов, a UDP — последовательность сообщений с явно определенными границами.</P>
   <P>■ Очереди сообщений Posix могут отправлять процессу сигнал или запускать новый поток в случае, если в пустую очередь помещается сообщение. Для очередей System V такая возможность не предусматривается. Ни один из типов очередей сообщений не может быть использован непосредственно с вызовами select и poll (глава 6 [24]), хотя некие решения этой проблемы были приведены при обсуждении листинга 5.12 и в разделе 6.9.</P>
   <P>■ Данные в именованных и неименованных каналах передаются в порядке очереди (FIFO). Очереди сообщений Posix и System V предусматривают возможность присваивания сообщениям различного приоритета. При чтении из очереди Posix всегда возвращается сообщение с наивысшим приоритетом. Для очередей System V можно указать любой конкретный тип сообщения.</P>
   <P>■ При помещении сообщения в очередь Posix или System V или в именованный или неименованный канал ровно один экземпляр доставляется ровно одному считывающему потоку. Возможность передачи нескольким адресатам отсутствует (в отличие от сокетов и XTI при использовании протокола UDP — главы 18 и 19 [24]).</P>
   <P>■ Взаимные исключения, условные переменные и блокировки чтения-записи имен не имеют. Они могут легко использоваться потоками одного процесса. Совместное использование их различными процессами возможно только в случае, если эти объекты располагаются в общей для этих процессов области памяти. Семафоры Posix бывают двух типов: именованные и размещаемые в памяти. Именованные семафоры могут использоваться только различными процессами (они идентифицируются именами Posix IPC), а размещаемые в памяти должны для этого находиться в разделяемой памяти. Семафоры System V также являются именованными (с помощью типа key_t), они также могут без проблем использоваться несколькими процессами совместно.</P>
   <P>■ Блокировки записей fcntl автоматически снимаются ядром при завершении процесса, если он сам об этом не позаботится. Для семафоров System V эта возможность является дополнительной. Для взаимных исключений, условных переменных, блокировок чтения-записи и семафоров Posix эта возможность не предусматривается.</P>
   <P>■ Каждая блокировка fcntl действует на некоторый диапазон байтов (называемый записью) в файле, указываемом с помощью дескриптора. Блокировки чтения-записи не связываются ни с какими записями.</P>
   <P>■ Разделяемая память Posix и System V обладает живучестью ядра. Она существует до тех пор, пока не будет удалена явно, даже если в какой-то момент не используется ни одним процессом.</P>
   <P>■ Размер объекта разделяемой памяти Posix может быть увеличен в процессе работы. Размер сегмента разделяемой памяти System V фиксируется при его создании.</P>
   <P>■ Oгрaничeния ядра на три типа System V IPC часто требуют настройки вручную, поскольку устанавливаемые для них по умолчанию значения часто не соответствуют требованиям реальных приложений (раздел 3.8). Oгрaничeния на средства Posix IPC обычно не требуют настройки.</P>
   <P>■ Информация об объектах System V IPC (текущий размер, идентификатор владельца, время последнего изменения и т. п.) возвращается вызовом одной из функций XXXctl с командой IPC_STAT и пpoгрaммoй ipcs. Для получения информации об объектах Posix стандартных способов не предусматривается. Если реализация использует файлы в качестве основы для этих объектов, можно получить эту информацию с помощью функции stat или программы ls, если нам известен способ преобразования имени Posix IPC в полное имя файла. Если же в данной реализации файлы не используются, способа получить такую информацию может и не существовать.</P>
   <P>■ Из всех средств синхронизации — взаимных исключений, условных переменных, блокировок чтения-записи, блокировок записи, семафоров — только две функции можно вызывать из обработчика сигналов (табл. 5.1): sem_post и fcntl.</P>
   <P>■ Из всех средств передачи сообщений — каналов, очередей сообщений Posix и System V — только две функции могут быть вызваны из обработчика сигналов: read и write (используются с именованными и неименованными каналами).</P>
   <P>■ Из всех средств передачи сообщений только двери предоставляют серверу точную информацию о клиенте (раздел 15.5). В разделе 5.4 мы упомянули два других способа передачи сообщений, которые также предоставляют информацию о клиенте: доменные сокеты в BSD/OS (раздел 14.8 [24]) и каналы в SVR4, если по ним передается дескриптор файла (раздел 15.3.1 [21]).</P>
  </DIV>
  <DIV class=section>
   <H1>
    <P><a name=label816 style="border:none;"></a>ПРИЛОЖЕНИЕ А</P>
    <P>Измерение производительности</P>
   </H1>
   <DIV class=section>
    <H1>
     <P><a name=label817 style="border:none;"></a>А.1. Введение</P>
    </H1>
    <P>В основной части книги мы перечислили шесть средств передачи сообщений:</P>
    <P>■ неименованные каналы (pipes);</P>
    <P>■ именованные каналы (FIFO);</P>
    <P>■ очереди сообщений Posix;</P>
    <P>■ очереди сообщений System V;</P>
    <P>■ двери;</P>
    <P>■ SunRPC.</P>
    <P>Кроме того, мы указали пять типов средств синхронизации:</P>
    <P>■ взаимные исключения и условные переменные;</P>
    <P>■ блокировки чтения-записи;</P>
    <P>■ блокировка записей fcntl;</P>
    <P>■ семафоры Posix;</P>
    <P>■ семафоры System V.</P>
    <P>В этом приложении мы разработаем набор простых программ для измерения производительности этих видов IPC, чтобы иметь возможность аргументировать свой выбор одного из этих средств для конкретной задачи.</P>
    <P>При сравнении средств передачи сообщений нас интересуют два параметра:</P>
    <P>1. Полоса пропускания (bandwidth) — скорость передачи данных по каналу IPC. Для измерения этого параметра мы передаем огромное количество данных (миллионы байтов) от одного процесса другому. Этот параметр измеряется для различных объемов данных на операцию (например, write и read для каналов), и мы ожидаем, что полоса пропускания будет увеличиваться вместе с увеличением количества передаваемых за одну операцию данных.</P>
    <P>2. Задержка (latency) определяется как время, которое требуется небольшому сообщению, чтобы проделать путь по каналу IPC от одного процесса к другому и обратно. Мы измеряем время задержки для сообщения размером 1 байт.</P>
    <P>В реальности величина полосы пропускания говорит нам о том, сколько времени будет потрачено на передачу блока данных по каналу IPC, но IPC также используется и для передачи небольших управляющих сообщений. Задержка определяет время, необходимое для передачи этих сообщений. Важными оказываются обе величины.</P>
    <P>Чтобы измерить скорость работы средств синхронизации, мы изменим программу, увеличивающую значение счетчика в разделяемой памяти. Поскольку увеличение <STRONG>— </STRONG>элементарная операция, время будет тратиться в основном на работу средств синхронизации.</P>
    <DIV class=cite>
     <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
     <P>Программы этого приложения, используемые для измерения производительности средств IPC, основаны на пакете lmbench [15]. Этот пакет содержит набор тестов, измеряющих множество параметров системы (скорость переключения контекста и т. п.), а не только производительность средств IPC. Исходный код пакета доступен по адресу http://www.bitmover.com/lmbench.</P>
     <P>Величины, приведенные в этом приложении, дают нам возможность сравнить методы, описанные в книге. Заодно мы хотели показать, как просто измерить эти величины. Прежде чем останавливать свой выбор на одном из средств IPC, нелишне было бы получить эти значения в вашей собственной системе. К сожалению, насколько легко измерить величины, настолько же трудно объяснить аномальное их поведение в отсутствие доступа к исходному коду ядра и библиотек.</P>
    </DIV>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label818 style="border:none;"></a>А.2. Результаты</P>
    </H1>
    <DIV class=section>
     <P>Сведем вместе результаты, полученные в этом приложении. Данный раздел может использоваться как справочник при чтении книги.</P>
     <P>Для проведения измерений использовались две системы: SparcStation 4/110 под управлением Solaris 2.6 и Digital Alpha (DEC 3000 model 300, Pelican) под управлением Digital Unix 4.0В. В файл /etc/system системы Solaris 2.6 были добавлены следующие строки:</P>
     <P><CODE>set msgsys:msginfo_msgmax = 16384</CODE></P>
     <P><CODE>set msgsys:msginfo_msgmnb = 32768</CODE></P>
     <P><CODE>set msgsys:msginfo_msgseg = 4096</CODE></P>
     <P>Это дает возможность отправлять сообщения размером 16384 байт в очередь сообщений System V (табл. А.2). Те же изменения осуществляются в Digital Unix 4.0B введением следующих строк с помощью программы sysconfig:</P>
     <P><CODE>ipc:</CODE></P>
     <P><CODE> msg-max = 16384</CODE></P>
     <P><CODE> msg-mnb = 32768</CODE></P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label819 style="border:none;"></a>Результаты измерения полосы пропускания сообщений</P>
     </H1>
     <P>В табл. А.2 приведены результаты измерений на компьютере Sparc под управлением Solaris 2.6, а на рис. А.1 — график этих результатов.</P>
     <P>Как мы и предполагали, полоса пропускания увеличивается с размером сообщения. Поскольку во многих реализациях очередей сообщений System V ограничение на размер сообщения, установленное в ядре, достаточно мало (раздел 3.8), максимальный размер сообщения в нашей программе имеет значение 16384 байт. </P>
     <P>Уменьшение полосы для сообщений размером около 4096 байт в Solaris 2.6, возможно, связано с настройкой внутренних ограничений ядра. Для сравнения с [24] мы приводим результаты аналогичных измерений для сокета TCP и доменного сокета Unix. Эти две величины были получены с помощью программ пакета lmbench для сообщений размером 65536 байт. При измерении быстродействия сокета TCP оба процесса выполнялись на одном узле.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label820 style="border:none;"></a>Результаты измерения задержки</P>
     </H1>
     <P>В табл. А.1 приведены значения задержки в Solaris 2.6 и Digital Unix 4.0B.</P>
     <BR>
     <P>Таблица А.1. Задержка при передаче сообщения размером 1 байт (в микросекундах) </P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top ></TH>
       <TH ALIGN=left VALIGN=top >Канал</TH>
       <TH ALIGN=left VALIGN=top >Очередь сообщений Posix</TH>
       <TH ALIGN=left VALIGN=top >Очередь сообщений System V</TH>
       <TH ALIGN=left VALIGN=top >Двери</TH>
       <TH ALIGN=left VALIGN=top >Sun RPC TCP</TH>
       <TH ALIGN=left VALIGN=top >Sun RPC UDP</TH>
       <TH ALIGN=left VALIGN=top >Сокет TCP</TH>
       <TH ALIGN=left VALIGN=top >Сокет UDP</TH>
       <TH ALIGN=left VALIGN=top >Доменный сокет</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >Solaris 2.6</TD>
       <TD ALIGN=left VALIGN=top >324</TD>
       <TD ALIGN=left VALIGN=top >584</TD>
       <TD ALIGN=left VALIGN=top >260</TD>
       <TD ALIGN=left VALIGN=top >121</TD>
       <TD ALIGN=left VALIGN=top >1891</TD>
       <TD ALIGN=left VALIGN=top >1677</TD>
       <TD ALIGN=left VALIGN=top >798</TD>
       <TD ALIGN=left VALIGN=top >755</TD>
       <TD ALIGN=left VALIGN=top >465</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >DUnix 4.0B</TD>
       <TD ALIGN=left VALIGN=top >574</TD>
       <TD ALIGN=left VALIGN=top >995</TD>
       <TD ALIGN=left VALIGN=top >625</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top >1648</TD>
       <TD ALIGN=left VALIGN=top >1373</TD>
       <TD ALIGN=left VALIGN=top >848</TD>
       <TD ALIGN=left VALIGN=top >639</TD>
       <TD ALIGN=left VALIGN=top >289 </TD>
      </TR>
     </TABLE>
     <BR>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader246" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. А.1. Полоса пропускания средств передачи сообщений в Solaris 2.6.</P>
     <BR>
     <P>В разделе A.4 мы приведем листинги программ, использованных для получения первых четырех величин, а оставшиеся три получены с помощью пакета lmbench. При измерении скорости работы TCP и UDP оба процесса находились на одном узле. </P>
     <BR>
     <P>Таблица А.2. Полоса пропускания для разных типов сообщений в Solaris 2.6 (Мбайт/с)</P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Размер сообщения</TH>
       <TH ALIGN=left VALIGN=top >Канал</TH>
       <TH ALIGN=left VALIGN=top >Очередь сообщений Posix</TH>
       <TH ALIGN=left VALIGN=top >Очередь сообщений System V</TH>
       <TH ALIGN=left VALIGN=top >Двери</TH>
       <TH ALIGN=left VALIGN=top >Sun RPC TCP</TH>
       <TH ALIGN=left VALIGN=top >Sun RPC UDP</TH>
       <TH ALIGN=left VALIGN=top >Сокет TCP</TH>
       <TH ALIGN=left VALIGN=top >Доменный сокет</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >1024</TD>
       <TD ALIGN=left VALIGN=top >6,3</TD>
       <TD ALIGN=left VALIGN=top >3,7</TD>
       <TD ALIGN=left VALIGN=top >4,9</TD>
       <TD ALIGN=left VALIGN=top >6,3</TD>
       <TD ALIGN=left VALIGN=top >0,5</TD>
       <TD ALIGN=left VALIGN=top >0,5</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >2048</TD>
       <TD ALIGN=left VALIGN=top >8,7</TD>
       <TD ALIGN=left VALIGN=top >5,3</TD>
       <TD ALIGN=left VALIGN=top >6,3</TD>
       <TD ALIGN=left VALIGN=top >10,0</TD>
       <TD ALIGN=left VALIGN=top >0,9</TD>
       <TD ALIGN=left VALIGN=top >1,0</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >4096</TD>
       <TD ALIGN=left VALIGN=top >9,8</TD>
       <TD ALIGN=left VALIGN=top >8,4</TD>
       <TD ALIGN=left VALIGN=top >6,6</TD>
       <TD ALIGN=left VALIGN=top >12,6</TD>
       <TD ALIGN=left VALIGN=top >1,6</TD>
       <TD ALIGN=left VALIGN=top >2,8</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >8192</TD>
       <TD ALIGN=left VALIGN=top >12,7</TD>
       <TD ALIGN=left VALIGN=top >10,2</TD>
       <TD ALIGN=left VALIGN=top >5,8</TD>
       <TD ALIGN=left VALIGN=top >14,4</TD>
       <TD ALIGN=left VALIGN=top >2,4</TD>
       <TD ALIGN=left VALIGN=top >2,8</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >16384</TD>
       <TD ALIGN=left VALIGN=top >13,1</TD>
       <TD ALIGN=left VALIGN=top >11,6</TD>
       <TD ALIGN=left VALIGN=top >6,1</TD>
       <TD ALIGN=left VALIGN=top >16,8</TD>
       <TD ALIGN=left VALIGN=top >3,2</TD>
       <TD ALIGN=left VALIGN=top >3,4</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >32768</TD>
       <TD ALIGN=left VALIGN=top >13,2</TD>
       <TD ALIGN=left VALIGN=top >13,4</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top >11,4</TD>
       <TD ALIGN=left VALIGN=top >3,5</TD>
       <TD ALIGN=left VALIGN=top >4,3</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >65536</TD>
       <TD ALIGN=left VALIGN=top >13,7</TD>
       <TD ALIGN=left VALIGN=top >14,4</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top >12,2</TD>
       <TD ALIGN=left VALIGN=top >3,7</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top >13,2</TD>
       <TD ALIGN=left VALIGN=top >11,3</TD>
      </TR>
     </TABLE>
     <BR>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader247" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. А.2. Полоса пропускания для различных средств передачи сообщений (Digital Unix 4.0B)</P>
     <BR>
     <P>Таблица А.З. Полоса пропускания для различных типов сообщения в Digital Unix 4.0B (Мбайт/с)</P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Размер сообщения</TH>
       <TH ALIGN=left VALIGN=top >Канал</TH>
       <TH ALIGN=left VALIGN=top >Очередь сообщений Posix</TH>
       <TH ALIGN=left VALIGN=top >Очередь сообщений System V</TH>
       <TH ALIGN=left VALIGN=top >Sun RPC TCP</TH>
       <TH ALIGN=left VALIGN=top >Sun RPC UDP</TH>
       <TH ALIGN=left VALIGN=top >Сокет TCP</TH>
       <TH ALIGN=left VALIGN=top >Доменный сокет</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >1024</TD>
       <TD ALIGN=left VALIGN=top >9,9</TD>
       <TD ALIGN=left VALIGN=top >1,8</TD>
       <TD ALIGN=left VALIGN=top >12,7</TD>
       <TD ALIGN=left VALIGN=top >0,6</TD>
       <TD ALIGN=left VALIGN=top >0,6</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >2048</TD>
       <TD ALIGN=left VALIGN=top >15,2</TD>
       <TD ALIGN=left VALIGN=top >3,5</TD>
       <TD ALIGN=left VALIGN=top >15,0</TD>
       <TD ALIGN=left VALIGN=top >0,8</TD>
       <TD ALIGN=left VALIGN=top >1,0</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >4096</TD>
       <TD ALIGN=left VALIGN=top >17,1</TD>
       <TD ALIGN=left VALIGN=top >5,9</TD>
       <TD ALIGN=left VALIGN=top >21,1</TD>
       <TD ALIGN=left VALIGN=top >1,3</TD>
       <TD ALIGN=left VALIGN=top >1,8</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >8192</TD>
       <TD ALIGN=left VALIGN=top >16,5</TD>
       <TD ALIGN=left VALIGN=top >8,6</TD>
       <TD ALIGN=left VALIGN=top >17,1</TD>
       <TD ALIGN=left VALIGN=top >1,8</TD>
       <TD ALIGN=left VALIGN=top >2,5</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >16384</TD>
       <TD ALIGN=left VALIGN=top >17,3</TD>
       <TD ALIGN=left VALIGN=top >11,7</TD>
       <TD ALIGN=left VALIGN=top >17,3</TD>
       <TD ALIGN=left VALIGN=top >2,3</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >32768</TD>
       <TD ALIGN=left VALIGN=top >15,9</TD>
       <TD ALIGN=left VALIGN=top >14,0</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top >2,6</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >65536</TD>
       <TD ALIGN=left VALIGN=top >14,2</TD>
       <TD ALIGN=left VALIGN=top >9,4</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top >2,8</TD>
       <TD ALIGN=left VALIGN=top ></TD>
       <TD ALIGN=left VALIGN=top >4,6</TD>
       <TD ALIGN=left VALIGN=top >18,0</TD>
      </TR>
     </TABLE>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label821 style="border:none;"></a>Результаты синхронизации потоков</P>
     </H1>
     <P>В табл. А.4 приведены значения времени, нужного одному или нескольким потокам для увеличения счетчика в разделяемой памяти с использованием различных средств синхронизации в Solaris 2.6, а на рис. А.3 показан график этих значений. Каждый поток увеличивает значение счетчика 1000000 раз, а количество потоков меняется от 1 до 5. В табл. А.5 приведены эти же значения для Digital Unix 4.0В, а на рис. А.4 — график этих значений. </P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader248" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. А.З. Время увеличения счетчика в разделяемой памяти (Solaris 2.6)</P>
     <BR>
     <P>Мы увеличиваем количество потоков, чтобы проверить правильность кода. Кроме того, при добавлении потоков время работы программы может начать расти нелинейно. Блокировка fcntl может использоваться только одним потоком, поскольку эта форма синхронизации предназначена только для использования между несколькими процессами, а не потоками одного процесса. </P>
     <P>В Digital Unix 4.0B значения для семафоров Posix оказываются непомерно большими, если работает более одного потока, что указывает на наличие какой-то аномалии. На графике мы эти значения не приводим.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Одна из возможных причин этой аномалии заключается в том, что в этой программе синхронизация проверяется неправильно. В данном случае потоки не делают ничего полезного, и все время уходит на синхронизацию. Поскольку потоки создаются с внутрипроцессной конкуренцией, при потере управления потоком блокировка сохраняется, поэтому поток, получающий управление, выполняться дальше не может. </P>
     </DIV>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader249" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис.А.4. Время увеличения счетчика в разделяемой памяти (Digital Unix 4.0B)</P>
     <BR>
     <P>Таблица А.4. Время увеличения счетчика в разделяемой памяти для Solaris 2.6 (в секундах)</P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Кол-во потоков</TH>
       <TH ALIGN=left VALIGN=top >Взаимное исключение Posix</TH>
       <TH ALIGN=left VALIGN=top >Блокировка чтения-записи</TH>
       <TH ALIGN=left VALIGN=top >Семафор Posix в памяти</TH>
       <TH ALIGN=left VALIGN=top >Именованный семафор Posix</TH>
       <TH ALIGN=left VALIGN=top >Семафор System V</TH>
       <TH ALIGN=left VALIGN=top >Семафор System V с UNDO</TH>
       <TH ALIGN=left VALIGN=top >Блокировка записей fcntl</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >1</TD>
       <TD ALIGN=left VALIGN=top >0,7</TD>
       <TD ALIGN=left VALIGN=top >2,0</TD>
       <TD ALIGN=left VALIGN=top >4,5</TD>
       <TD ALIGN=left VALIGN=top >15,4</TD>
       <TD ALIGN=left VALIGN=top >16,3</TD>
       <TD ALIGN=left VALIGN=top >21,1</TD>
       <TD ALIGN=left VALIGN=top >89,4</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >2</TD>
       <TD ALIGN=left VALIGN=top >1,5</TD>
       <TD ALIGN=left VALIGN=top >5,4</TD>
       <TD ALIGN=left VALIGN=top >9,0</TD>
       <TD ALIGN=left VALIGN=top >31,1</TD>
       <TD ALIGN=left VALIGN=top >31,5</TD>
       <TD ALIGN=left VALIGN=top >37,5</TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >3</TD>
       <TD ALIGN=left VALIGN=top >2,2</TD>
       <TD ALIGN=left VALIGN=top >7,5</TD>
       <TD ALIGN=left VALIGN=top >14,4</TD>
       <TD ALIGN=left VALIGN=top >46,5</TD>
       <TD ALIGN=left VALIGN=top >48,3</TD>
       <TD ALIGN=left VALIGN=top >57,7</TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >4</TD>
       <TD ALIGN=left VALIGN=top >2,9</TD>
       <TD ALIGN=left VALIGN=top >13,7</TD>
       <TD ALIGN=left VALIGN=top >18,2</TD>
       <TD ALIGN=left VALIGN=top >62,5</TD>
       <TD ALIGN=left VALIGN=top >65,8</TD>
       <TD ALIGN=left VALIGN=top >75,8</TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >5</TD>
       <TD ALIGN=left VALIGN=top >3,7</TD>
       <TD ALIGN=left VALIGN=top >19,7</TD>
       <TD ALIGN=left VALIGN=top >22,8</TD>
       <TD ALIGN=left VALIGN=top >76,8</TD>
       <TD ALIGN=left VALIGN=top >81,8</TD>
       <TD ALIGN=left VALIGN=top >90,0</TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
     </TABLE>
     <BR>
     <P>Таблица А.5. Время увеличения счетчика в разделяемой памяти в Digital Unix 4.0B (в секундах) </P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Кол-во потоков</TH>
       <TH ALIGN=left VALIGN=top >Взаимное исключение Posix</TH>
       <TH ALIGN=left VALIGN=top >Блокировка чтения-записи</TH>
       <TH ALIGN=left VALIGN=top >Семафор Posix в памяти</TH>
       <TH ALIGN=left VALIGN=top >Именованный семафор Posix</TH>
       <TH ALIGN=left VALIGN=top >Семафор System V</TH>
       <TH ALIGN=left VALIGN=top >Семафор System V с UNDO</TH>
       <TH ALIGN=left VALIGN=top >Блокировка записей fcntl</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >1</TD>
       <TD ALIGN=left VALIGN=top >2,9</TD>
       <TD ALIGN=left VALIGN=top >12,9</TD>
       <TD ALIGN=left VALIGN=top >13,2</TD>
       <TD ALIGN=left VALIGN=top >14,2</TD>
       <TD ALIGN=left VALIGN=top >26,6</TD>
       <TD ALIGN=left VALIGN=top >46,6</TD>
       <TD ALIGN=left VALIGN=top >96,4</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >2</TD>
       <TD ALIGN=left VALIGN=top >11,4</TD>
       <TD ALIGN=left VALIGN=top >40,8</TD>
       <TD ALIGN=left VALIGN=top >742,5</TD>
       <TD ALIGN=left VALIGN=top >771,6</TD>
       <TD ALIGN=left VALIGN=top >54,9</TD>
       <TD ALIGN=left VALIGN=top >93,9</TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >3</TD>
       <TD ALIGN=left VALIGN=top >28,4</TD>
       <TD ALIGN=left VALIGN=top >73,2</TD>
       <TD ALIGN=left VALIGN=top >1080,5</TD>
       <TD ALIGN=left VALIGN=top >1074,5</TD>
       <TD ALIGN=left VALIGN=top >84,5</TD>
       <TD ALIGN=left VALIGN=top >141,9</TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >4</TD>
       <TD ALIGN=left VALIGN=top >49,3</TD>
       <TD ALIGN=left VALIGN=top >95,0</TD>
       <TD ALIGN=left VALIGN=top >1534,1</TD>
       <TD ALIGN=left VALIGN=top >1502,2</TD>
       <TD ALIGN=left VALIGN=top >109,9</TD>
       <TD ALIGN=left VALIGN=top >188,4</TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >5</TD>
       <TD ALIGN=left VALIGN=top >67,3</TD>
       <TD ALIGN=left VALIGN=top >126,3</TD>
       <TD ALIGN=left VALIGN=top >1923,3</TD>
       <TD ALIGN=left VALIGN=top >1764,1</TD>
       <TD ALIGN=left VALIGN=top >137,3</TD>
       <TD ALIGN=left VALIGN=top >233,6</TD>
       <TD ALIGN=left VALIGN=top ></TD>
      </TR>
     </TABLE>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label822 style="border:none;"></a>Результаты синхронизации процессов</P>
     </H1>
     <P> В табл. А.4 и А.5 и на соответствующих рисунках были приведены результаты синхронизации потоков одного процесса. Интересно посмотреть, как взаимодействуют разные процессы. В табл. А.6 и на рис. А.5 приведены результаты измерения времени увеличения счетчика несколькими процессами в Solaris 2.6, а в табл. А.7 и на рис. А.6 — в Digital Unix 4.0B. Результаты похожи на полученные для потоков, однако в Solaris 2.6 теперь получаются одинаковые результаты для первых двух типов семафоров. Мы приводим на графике только первое значение для fcntl, поскольку последующие слишком велики. Как отмечалось в разделе 7.2, Digital Unix 4.0B не поддерживает атрибут PTHREAD_PROCESS_SHARED, поэтому мы не можем измерить скорость работы взаимных исключений в этой системе. Для семафоров Posix в Digital Unix 4.0B опять наблюдаются аномалии. </P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader250" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. А.5. Время увеличения счетчика в разделяемой памяти (Solaris 2.6)</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-_.jpg" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. А.6. Время увеличения счетчика в разделяемой памяти </P>
     <BR>
     <P>Таблица А.6. Время увеличения счетчика в разделяемой памяти для Solaris 2.6 (в секундах) </P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Кол-во процессов</TH>
       <TH ALIGN=left VALIGN=top >Взаимное исключение Posix</TH>
       <TH ALIGN=left VALIGN=top >Блокировка чтения-записи</TH>
       <TH ALIGN=left VALIGN=top >Семафор Posix в памяти</TH>
       <TH ALIGN=left VALIGN=top >Именованный семафор Posix</TH>
       <TH ALIGN=left VALIGN=top >Семафор System V</TH>
       <TH ALIGN=left VALIGN=top >Семафор System V с UNDO</TH>
       <TH ALIGN=left VALIGN=top >Блокировка записей fcntl</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >1</TD>
       <TD ALIGN=left VALIGN=top >0,8</TD>
       <TD ALIGN=left VALIGN=top >1,6</TD>
       <TD ALIGN=left VALIGN=top >13,6</TD>
       <TD ALIGN=left VALIGN=top >14,3</TD>
       <TD ALIGN=left VALIGN=top >17,3</TD>
       <TD ALIGN=left VALIGN=top >22,1</TD>
       <TD ALIGN=left VALIGN=top >90,7</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >2</TD>
       <TD ALIGN=left VALIGN=top >1,6</TD>
       <TD ALIGN=left VALIGN=top >3,9</TD>
       <TD ALIGN=left VALIGN=top >29,2</TD>
       <TD ALIGN=left VALIGN=top >29,2</TD>
       <TD ALIGN=left VALIGN=top >34,9</TD>
       <TD ALIGN=left VALIGN=top >41,6</TD>
       <TD ALIGN=left VALIGN=top >244,5</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >3</TD>
       <TD ALIGN=left VALIGN=top >2,3</TD>
       <TD ALIGN=left VALIGN=top >6,4</TD>
       <TD ALIGN=left VALIGN=top >41,6</TD>
       <TD ALIGN=left VALIGN=top >42,9</TD>
       <TD ALIGN=left VALIGN=top >54,0</TD>
       <TD ALIGN=left VALIGN=top >60,1</TD>
       <TD ALIGN=left VALIGN=top >376,4</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >4</TD>
       <TD ALIGN=left VALIGN=top >3,1</TD>
       <TD ALIGN=left VALIGN=top >12,2</TD>
       <TD ALIGN=left VALIGN=top >57,3</TD>
       <TD ALIGN=left VALIGN=top >58,8</TD>
       <TD ALIGN=left VALIGN=top >72,4</TD>
       <TD ALIGN=left VALIGN=top >81,9</TD>
       <TD ALIGN=left VALIGN=top >558,0</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >5</TD>
       <TD ALIGN=left VALIGN=top >4,0</TD>
       <TD ALIGN=left VALIGN=top >20,4</TD>
       <TD ALIGN=left VALIGN=top >70,4</TD>
       <TD ALIGN=left VALIGN=top >73,5</TD>
       <TD ALIGN=left VALIGN=top >87,8</TD>
       <TD ALIGN=left VALIGN=top >102,6</TD>
       <TD ALIGN=left VALIGN=top >764,0</TD>
      </TR>
     </TABLE>
     <BR>
     <P>Таблица А.7. Время увеличения счетчика в разделяемой памяти для Digital Unix 4.0B (в секундах)</P>
     <TABLE>
      <TR ALIGN=left >
       <TH ALIGN=left VALIGN=top >Количество процессов</TH>
       <TH ALIGN=left VALIGN=top >Семафор Posix в памяти</TH>
       <TH ALIGN=left VALIGN=top >Именованный семафор Posix</TH>
       <TH ALIGN=left VALIGN=top >Семафор System V</TH>
       <TH ALIGN=left VALIGN=top >Семафор System V с UNDO</TH>
       <TH ALIGN=left VALIGN=top >Блокировка записей fcntl</TH>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >1</TD>
       <TD ALIGN=left VALIGN=top >12,8</TD>
       <TD ALIGN=left VALIGN=top >12,5</TD>
       <TD ALIGN=left VALIGN=top >30,1</TD>
       <TD ALIGN=left VALIGN=top >49,0</TD>
       <TD ALIGN=left VALIGN=top >98,1</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >2</TD>
       <TD ALIGN=left VALIGN=top >664,8</TD>
       <TD ALIGN=left VALIGN=top >659,2</TD>
       <TD ALIGN=left VALIGN=top >58,6</TD>
       <TD ALIGN=left VALIGN=top >95,7</TD>
       <TD ALIGN=left VALIGN=top >477,1</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >3</TD>
       <TD ALIGN=left VALIGN=top >1236,1</TD>
       <TD ALIGN=left VALIGN=top >1269,8</TD>
       <TD ALIGN=left VALIGN=top >96,4</TD>
       <TD ALIGN=left VALIGN=top >146,2</TD>
       <TD ALIGN=left VALIGN=top >1785,2</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >4</TD>
       <TD ALIGN=left VALIGN=top >1772,9</TD>
       <TD ALIGN=left VALIGN=top >1804,1</TD>
       <TD ALIGN=left VALIGN=top >120,3</TD>
       <TD ALIGN=left VALIGN=top >197,0</TD>
       <TD ALIGN=left VALIGN=top >2582,8</TD>
      </TR>
      <TR ALIGN=left >
       <TD ALIGN=left VALIGN=top >5</TD>
       <TD ALIGN=left VALIGN=top >2179,9</TD>
       <TD ALIGN=left VALIGN=top >2196,8</TD>
       <TD ALIGN=left VALIGN=top >147,7</TD>
       <TD ALIGN=left VALIGN=top >250,9</TD>
       <TD ALIGN=left VALIGN=top >3419,2</TD>
      </TR>
     </TABLE>
    </DIV>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label823 style="border:none;"></a>А.З. Измерение полосы пропускания: программы</P>
    </H1>
    <DIV class=section>
     <P>В этом разделе приведены тексты трех программ, измеряющих полосу пропускания каналов, очередей сообщений Posix и System V. Результаты работы этих программ приведены в табл. А.2 и А.З.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label824 style="border:none;"></a>Измерение полосы пропускания канала</P>
     </H1>
     <P>На рис. А.7 приведена схема описываемой программы.</P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader252" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. А.7. Схема программы измерения полосы пропускания канала</P>
     <BR>
     <P>В листинге А.1 приведен текст первой половины программы bw_pipe, измеряющей полосу пропускания канала.</P>
     <H2><a name=label825 style="border:none;"></a>Листинг А.1. Функция main, измеряющая полосу пропускания канала</H2>
     <P><CODE>//bench/bw_pipe.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  void reader(int, int, int);</CODE></P>
     <P><CODE>3  void writer(int, int);</CODE></P>
     <P><CODE>4  void *buf;</CODE></P>
     <P><CODE>5  int totalnbytes, xfersize;</CODE></P>
     <BR>
     <P><CODE>6  int</CODE></P>
     <P><CODE>7  main(int argc, char **argv)</CODE></P>
     <P><CODE>8  {</CODE></P>
     <P><CODE>9   int i, nLoop, contpipe[2], datapipe[2];</CODE></P>
     <P><CODE>10  pid_t childpid;</CODE></P>
     <P><CODE>11  if (argc != 4)</CODE></P>
     <P><CODE>12   err_quit("usage: bw_pipe &lt;#loops&gt; &lt;#mbytes&gt; &lt;#bytes/write&gt;");</CODE></P>
     <P><CODE>13  nloop = atoi(argv[1]);</CODE></P>
     <P><CODE>14  totalnbytes = atoi(argv[2]) * 1024 * 1024;</CODE></P>
     <P><CODE>15  xfersize = atoi(argv[3]);</CODE></P>
     <P><CODE>16  buf = Valloc(xfersize);</CODE></P>
     <P><CODE>17  Touch(buf, xfersize);</CODE></P>
     <P><CODE>18  Pipe(contpipe);</CODE></P>
     <P><CODE>19  Pipe(datapipe);</CODE></P>
     <P><CODE>20  if ((childpid = Fork()) == 0) {</CODE></P>
     <P><CODE>21   writer(contpipe[0], datapipe[1]); /* child */</CODE></P>
     <P><CODE>22   exit(0);</CODE></P>
     <P><CODE>23  }</CODE></P>
     <P><CODE>24  /* 4parent */</CODE></P>
     <P><CODE>25  Start_time();</CODE></P>
     <P><CODE>26  for (i = 0; i &lt; nloop; i++)</CODE></P>
     <P><CODE>27   reader(contpipe[1], datapipe[0], totalnbytes);</CODE></P>
     <P><CODE>28  printf("bandwidth: %.3f MB/sec\n",</CODE></P>
     <P><CODE>29   totalnbytes / Stop_time() * nloop);</CODE></P>
     <P><CODE>30  kill(childpid, SIGTERM);</CODE></P>
     <P><CODE>31  exit(0);</CODE></P>
     <P><CODE>32 }</CODE></P>
     <H2><a name=label826 style="border:none;"></a>Аргументы командной строки</H2>
     <P>11-15 Аргументы командной строки задают количество повторов (обычно 5), количество передаваемых мегабайтов (если указать 10, будет передано 10×1024×1024 байт) и количество байтов для каждой операции read и write (которое может принимать значения от 1024 до 65536 в наших измерениях).</P>
     <H2><a name=label827 style="border:none;"></a>Выделение буфера и помещение начального значения</H2>
     <P>16-17 Вызов valloc аналогичен malloc, но выделяемая память начинается с границы страницы памяти. Функция touch (листинг А.3) помещает 1 байт данных в каждую страницу буфера, заставляя ядро считать в память все страницы данного буфера. Мы всегда выполняем это перед проведением измерений.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Функция valloc не входит в стандарт Posix.1 и названа устаревшей в Unix 98. Она требовалась в ранних версиях спецификаций Х/Open, но уже не является необходимой. Обертка Valloc вызывает функцию malloc, если valloc недоступна.</P>
     </DIV>
     <H2><a name=label828 style="border:none;"></a>Создание двух каналов</H2>
     <P>18-19 Создаются два канала: contpipe[0] и contpipe[1] используются для синхронизации процессов перед началом передачи, a datapipe[0] и datapipe[1] используются для передачи самих данных.</P>
     <H2><a name=label829 style="border:none;"></a>Вызов fork</H2>
     <P>20-31 Создается дочерний процесс, вызывающий функцию writer, а родительский процесс в это время вызывает функцию reader. Функция reader вызывается nlоор раз. Функция start_time вызывается непосредственно перед началом цикла, a stop_time — сразу после его окончания. Эти функции даны в листинге А.З. Полоса пропускания представляет собой количество байтов, переданных за все проходы цикла, поделенное на время, затраченное на передачу (stop_time возвращает количество микросекунд, прошедшее с момент запуска start_time). Затем дочерний процесс завершается сигналом SIGTERM и программа завершает свою работу. Вторая половина программы приведена в листинге А.2. Она состоит из функций reader и writer.</P>
     <H2><a name=label830 style="border:none;"></a>Листинг А.2. Функции reader и writer</H2>
     <P><CODE>//bench/bw_pipe.cvoid</CODE></P>
     <P><CODE>33 void</CODE></P>
     <P><CODE>34 writer(int contfd, int datafd)</CODE></P>
     <P><CODE>35 {</CODE></P>
     <P><CODE>36  int ntowrite;</CODE></P>
     <P><CODE>37  for(;;) {</CODE></P>
     <P><CODE>38   Read(contfd, &amp;ntowrite, sizeof(ntowrite));</CODE></P>
     <P><CODE>39   while (ntowrite &gt; 0) {</CODE></P>
     <P><CODE>40    Write(datafd, buf, xfersize);</CODE></P>
     <P><CODE>41    ntowrite –= xfersize;</CODE></P>
     <P><CODE>42   }</CODE></P>
     <P><CODE>43  }</CODE></P>
     <P><CODE>44 }</CODE></P>
     <BR>
     <P><CODE>45 void</CODE></P>
     <P><CODE>46 reader(int contfd, int datafd, int nbytes)</CODE></P>
     <P><CODE>47 {</CODE></P>
     <P><CODE>48  ssize_t n;</CODE></P>
     <P><CODE>49  Write(contfd, &amp;nbytes, sizeof(nbytes));</CODE></P>
     <P><CODE>50  while ((nbytes &gt; 0) &amp;&amp;</CODE></P>
     <P><CODE>51   ((n = Read(datafd, buf, xfersize)) &gt; 0)) {</CODE></P>
     <P><CODE>52   nbytes –= n;</CODE></P>
     <P><CODE>53  }</CODE></P>
     <P><CODE>54 }</CODE></P>
     <H2><a name=label831 style="border:none;"></a>Функция writer</H2>
     <P>33-44 Функция writer представляет собой бесконечный цикл, вызываемый дочерним процессом. Он ожидает сообщения родительского процесса о готовности к приему данных, считывая целое число из управляющего канала. Это целое число определяет количество байтов, которое будет записано в канал данных. При получении этого числа дочерний процесс записывает данные в канал, отправляя их родителю. За один вызов write записывается xfersize байтов.</P>
     <H2><a name=label832 style="border:none;"></a>Функция reader</H2>
     <P>45-54 Эта функция вызывается родительским процессом в цикле. Каждый раз при вызове функции в управляющий канал записывается целое число, указывающее дочернему процессу на необходимость помещения соответствующего количества данных в канал данных. Затем функция вызывает read в цикле до тех пор, пока не будут приняты все данные.</P>
     <P>Текст функций start_time, stop_time и touch приведен в листинге А.З.</P>
     <H2><a name=label833 style="border:none;"></a>Листинг А.З. Функции start_sime, stop_time и touch</H2>
     <P><CODE>//lib/timing.с</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  static struct timeval tv_start, tv_stop;</CODE></P>
     <BR>
     <P><CODE>3  int</CODE></P>
     <P><CODE>4  start_time(void)</CODE></P>
     <P><CODE>5  {</CODE></P>
     <P><CODE>6   return(gettimeofday(&amp;tv_start, NULL));</CODE></P>
     <P><CODE>7  }</CODE></P>
     <BR>
     <P><CODE>8  double</CODE></P>
     <P><CODE>9  stop_time(void)</CODE></P>
     <P><CODE>10 {</CODE></P>
     <P><CODE>11  double clockus;</CODE></P>
     <P><CODE>12  if (gettimeofday(&amp;tv_stop, NULL) == –1)</CODE></P>
     <P><CODE>13   return(0.0);</CODE></P>
     <P><CODE>14  tv_sub(&amp;tv_stop, &amp;tv_start);</CODE></P>
     <P><CODE>15  clockus = tv_stop.tv_sec * 1000000.0 + tv_stop.tv_usec;</CODE></P>
     <P><CODE>16  return(clockus);</CODE></P>
     <P><CODE>17 }</CODE></P>
     <BR>
     <P><CODE>18 int</CODE></P>
     <P><CODE>19 touch(void *vptr, int nbytes)</CODE></P>
     <P><CODE>20 {</CODE></P>
     <P><CODE>21  char *cptr;</CODE></P>
     <P><CODE>22  static int pagesize = 0;</CODE></P>
     <P><CODE>23  if (pagesize == 0) {</CODE></P>
     <P><CODE>24   errno = 0;</CODE></P>
     <P><CODE>25 #ifdef _SC_PAGESIZE</CODE></P>
     <P><CODE>26   if ((pagesize = sysconf(_SC_PAGESIZE)) == –1)</CODE></P>
     <P><CODE>27    return(-1);</CODE></P>
     <P><CODE>28 #else</CODE></P>
     <P><CODE>29   pagesize = getpagesize(); /* BSD */</CODE></P>
     <P><CODE>30 #endif</CODE></P>
     <P><CODE>31  }</CODE></P>
     <P><CODE>32  cptr = vptr;</CODE></P>
     <P><CODE>33  while (nbytes &gt; 0) {</CODE></P>
     <P><CODE>34   *cptr = 1;</CODE></P>
     <P><CODE>35   cptr += pagesize;</CODE></P>
     <P><CODE>36   nbytes –= pagesize;</CODE></P>
     <P><CODE>37  }</CODE></P>
     <P><CODE>38  return(0);</CODE></P>
     <P><CODE>39 }</CODE></P>
     <P>Текст функции tv_sub приведен в листинге А.4. Она осуществляет вычитание двух структур timeval, сохраняя результат в первой структуре.</P>
     <H2><a name=label834 style="border:none;"></a>Листинг А.4. Функция tv_sub: вычитание двух структур timeval</H2>
     <P><CODE>//lib/tv_sub.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <BR>
     <P><CODE>2  void</CODE></P>
     <P><CODE>3  tv_sub(struct timeval *out, struct timeval *in)</CODE></P>
     <P><CODE>4  {</CODE></P>
     <P><CODE>5   if ((out-&gt;tv_usec –= in-&gt;tv_usec) &lt; 0) { /* out –= in */</CODE></P>
     <P><CODE>6    --out-&gt;tv_sec;</CODE></P>
     <P><CODE>7    out-&gt;tv_usec += 1000000;</CODE></P>
     <P><CODE>8   }</CODE></P>
     <P><CODE>9   out-&gt;tv_sec –= in-&gt;tv_sec;</CODE></P>
     <P><CODE>10 }</CODE></P>
     <P>На компьютере Sparc под управлением Solaris 2.6 при выполнении программы пять раз подряд получим следующий результат:</P>
     <P><CODE>solaris % <STRONG>bw_pipe 5 10 65536</STRONG></CODE></P>
     <P><CODE>bandwidth: 13.722 MB/sec</CODE></P>
     <P><CODE>solaris % <STRONG>bw_pipe 5 10 65536</STRONG></CODE></P>
     <P><CODE>bandwidth: 13.781 MB/sec</CODE></P>
     <P><CODE>solaris % <STRONG>bw_pipe 5 10 65536</STRONG></CODE></P>
     <P><CODE>bandwidth: 13.685 MB/sec</CODE></P>
     <P><CODE>solaris % <STRONG>bw_pipe 5 10 65536</STRONG></CODE></P>
     <P><CODE>bandwidth: 13.665 MB/sec</CODE></P>
     <P><CODE>solaris % <STRONG>bw_pipe 5 10 65536</STRONG></CODE></P>
     <P><CODE>bandwidth: 13.584 MB/sec</CODE></P>
     <P>Каждый раз мы задаем пять циклов, 10 Мбайт за цикл и 65536 байт за один вызов write или read. Среднее от этих пяти результатов даст величину 13,7 Мбайт в секунду, приведенную в табл. А.2.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label835 style="border:none;"></a>Измерение полосы пропускания очереди сообщений Posix</P>
     </H1>
     <P>В листинге А.5 приведена функция main программы, измеряющей полосу пропускания очереди сообщений Posix. Листинг А.6 содержит функции reader и writer. Эта программа устроена аналогично предыдущей, измерявшей полосу пропускания канала.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Обратите внимание, что в программе приходится указывать максимальное количество сообщений в очереди при ее создании. Мы указываем значение 4. Размер канала IPC может влиять на производительность, потому что записывающий процесс может отправить это количество сообщений, прежде чем будет заблокирован в вызове mq_send, что приведет к переключению контекста на считывающий процесс. Следовательно, производительность программы зависит от этого магического числа. Изменение его с 4 на 8 в Solaris 2.6 никак не влияет на величины, приведенные в табл. А.2, но в Digital Unix 4.0B производительность уменьшается на 12%. Мы могли ожидать, что производительность возрастет с увеличением количества сообщений в очереди, поскольку требуется в два раза меньше переключений контекста. Однако если используется отображение файла в память, это увеличивает размер отображаемого файла в два раза, как и требуемое количество памяти.</P>
     </DIV>
     <H2><a name=label836 style="border:none;"></a>Листинг А.5. Функция main для измерения полосы пропускания очереди сообщений Posix</H2>
     <P><CODE>//bench/bw_pxmsg.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #define NAME "bw_pxmsg"</CODE></P>
     <P><CODE>3  void reader(int, mqd_t, int);</CODE></P>
     <P><CODE>4  void writer(int, mqd_t);</CODE></P>
     <P><CODE>5  void *buf;</CODE></P>
     <P><CODE>6  int totalnbytes, xfersize;</CODE></P>
     <BR>
     <P><CODE>7  int</CODE></P>
     <P><CODE>8  main(int argc, char **argv)</CODE></P>
     <P><CODE>9  {</CODE></P>
     <P><CODE>10  int i, nloop, contpipe[2];</CODE></P>
     <P><CODE>11  mqd_t mq;</CODE></P>
     <P><CODE>12  pid_t childpid;</CODE></P>
     <P><CODE>13  struct mq_attr attr;</CODE></P>
     <P><CODE>14  if (argc != 4)</CODE></P>
     <P><CODE>15   err_quit("usage: bw_pxmsg &lt;#loops&gt; &lt;#mbytes&gt; &lt;#bytes/write&gt;");</CODE></P>
     <P><CODE>16  nloop = atoi(argv[1]);</CODE></P>
     <P><CODE>17  totalnbytes = atoi(argv[2]) * 1024 * 1024;</CODE></P>
     <P><CODE>18  xfersize = atoi(argv[3]);</CODE></P>
     <P><CODE>19  buf = Valloc(xfersize);</CODE></P>
     <P><CODE>20  Touch(buf, xfersize);</CODE></P>
     <P><CODE>21  Pipe(contpipe);</CODE></P>
     <P><CODE>22  mq_unlink(Px_ipc_name(NAME)); /* error OK */</CODE></P>
     <P><CODE>23  attr.mq_maxmsg = 4;</CODE></P>
     <P><CODE>24  attr.mq_msgsize = xfersize;</CODE></P>
     <P><CODE>25  mq = Mq_open(Px_ipc_name(NAME), O_RDWR | O_CREAT, FILE_MODE, &amp;attr);</CODE></P>
     <P><CODE>26  if ((childpid = Fork()) == 0) {</CODE></P>
     <P><CODE>27   writer(contpipe[0], mq); /* child */</CODE></P>
     <P><CODE>28   exit(0);</CODE></P>
     <P><CODE>29  }</CODE></P>
     <P><CODE>30  /* 4parent */</CODE></P>
     <P><CODE>31  Start_time();</CODE></P>
     <P><CODE>32  for (i = 0; i &lt; nloop; i++)</CODE></P>
     <P><CODE>33   reader(contpipe[1], mq, totalnbytes);</CODE></P>
     <P><CODE>34  printf("bandwidth: %.3f MB/sec\n",</CODE></P>
     <P><CODE>35  totalnbytes / Stop_time() * nloop);</CODE></P>
     <P><CODE>36  kill(childpid, SIGTERM);</CODE></P>
     <P><CODE>37  Mq_close(mq);</CODE></P>
     <P><CODE>38  Mq_unlink(Px_ipc_name(NAME));</CODE></P>
     <P><CODE>39  exit(0);</CODE></P>
     <P><CODE>40 }</CODE></P>
     <H2><a name=label837 style="border:none;"></a>Листинг А.6. Функции reader и writer</H2>
     <P><CODE>//bench/bw_pxmsg.c</CODE></P>
     <P><CODE>41 void</CODE></P>
     <P><CODE>42 writer(int contfd, mqd_t mqsend)</CODE></P>
     <P><CODE>43 {</CODE></P>
     <P><CODE>44  int ntowrite;</CODE></P>
     <P><CODE>45  for(;;) {</CODE></P>
     <P><CODE>46   Read(contfd, &amp;ntowrite, sizeof(ntowrite));</CODE></P>
     <P><CODE>47   while (ntowrite &gt; 0) {</CODE></P>
     <P><CODE>48    Mq_send(mqsend, buf, xfersize, 0);</CODE></P>
     <P><CODE>49    ntowrite –= xfersize;</CODE></P>
     <P><CODE>50   }</CODE></P>
     <P><CODE>51  }</CODE></P>
     <P><CODE>52 }</CODE></P>
     <BR>
     <P><CODE>53 void</CODE></P>
     <P><CODE>54 reader(int contfd, mqd_t mqrecv, int nbytes)</CODE></P>
     <P><CODE>55 {</CODE></P>
     <P><CODE>56  ssize_t n;</CODE></P>
     <P><CODE>57  Write(contfd, &amp;nbytes, sizeof(nbytes));</CODE></P>
     <P><CODE>58  while ((nbytes &gt; 0) &amp;&amp;</CODE></P>
     <P><CODE>59   ((n = Mq_receive(mqrecv, buf, xfersize, NULL)) &gt; 0)) {</CODE></P>
     <P><CODE>60   nbytes –= n;</CODE></P>
     <P><CODE>61  }</CODE></P>
     <P><CODE>62 }</CODE></P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label838 style="border:none;"></a>Программа измерения полосы пропускания очереди System V</P>
     </H1>
     <P>В листинге А.7 приведен текст функции main, измеряющей полосу пропускания очередей сообщений System V, а в листинге А.8 <STRONG>—</STRONG>текст функций reader и writer.</P>
     <H2><a name=label839 style="border:none;"></a>Листинг А.7. Функция main для измерения полосы пропускания очереди сообщений System V</H2>
     <P><CODE>//bench/bw_svmsg.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  void reader(int, int, int);</CODE></P>
     <P><CODE>3  void writer(int, int);</CODE></P>
     <P><CODE>4  struct msgbuf *buf;</CODE></P>
     <P><CODE>5  int totalnbytes, xfersize;</CODE></P>
     <BR>
     <P><CODE>6  int</CODE></P>
     <P><CODE>7  main(int argc, char **argv)</CODE></P>
     <P><CODE>8  {</CODE></P>
     <P><CODE>9   int i, nloop, contpipe[2], msqid;</CODE></P>
     <P><CODE>10  pid_t childpid;</CODE></P>
     <P><CODE>11  if (argc != 4)</CODE></P>
     <P><CODE>12   err_quit("usage: bw_svmsg &lt;#loops&gt; &lt;#mbytes&gt; &lt;#bytes/write&gt;");</CODE></P>
     <P><CODE>13  nloop = atoi(argv[1]);</CODE></P>
     <P><CODE>14  totalnbytes = atoi(argv[2]) * 1024 * 1024;</CODE></P>
     <P><CODE>15  xfersize = atoi(argv[3]);</CODE></P>
     <P><CODE>16  buf = Valloc(xfersize);</CODE></P>
     <P><CODE>17  Touch(buf, xfersize);</CODE></P>
     <P><CODE>18  buf-&gt;mtype = 1;</CODE></P>
     <P><CODE>19  Pipe(contpipe);</CODE></P>
     <P><CODE>20  msqid = Msgget(IPC_PRIVATE, IPC_CREAT | SVMSG_MODE);</CODE></P>
     <P><CODE>21  if ((childpid = Fork()) == 0) {</CODE></P>
     <P><CODE>22   writer(contpipe[0], msqid); /* дочерний процесс */</CODE></P>
     <P><CODE>23   exit(0);</CODE></P>
     <P><CODE>24  }</CODE></P>
     <P><CODE>25  Start_time();</CODE></P>
     <P><CODE>26  for (i = 0; i &lt; nloop; i++)</CODE></P>
     <P><CODE>27   reader(contpipe[1], msqid, totalnbytes);</CODE></P>
     <P><CODE>28  printf("bandwidth: %.3f MB/sec\n",</CODE></P>
     <P><CODE>29  totalnbytes / Stop_time() * nloop);</CODE></P>
     <P><CODE>30  kill(childpid, SIGTERM);</CODE></P>
     <P><CODE>31  Msgctl(msqid, IPC_RMID, NULL);</CODE></P>
     <P><CODE>32  exit(0);</CODE></P>
     <P><CODE>33 }</CODE></P>
     <H2><a name=label840 style="border:none;"></a>Листинг А.8. Функции reader и writer</H2>
     <P><CODE>//bench/bw_svmsg.c</CODE></P>
     <P><CODE>34 void</CODE></P>
     <P><CODE>35 writer(int contfd, int msqid)</CODE></P>
     <P><CODE>36 {</CODE></P>
     <P><CODE>37  int ntowrite;</CODE></P>
     <P><CODE>38  for (;;) {</CODE></P>
     <P><CODE>39   Read(contfd, &amp;ntowrite, sizeof(ntowrite));</CODE></P>
     <P><CODE>40   while (ntowrite &gt; 0) {</CODE></P>
     <P><CODE>41    Msgsnd(msqid, buf, xfersize – sizeof(long), 0);</CODE></P>
     <P><CODE>42    ntowrite –= xfersize;</CODE></P>
     <P><CODE>43   }</CODE></P>
     <P><CODE>44  }</CODE></P>
     <P><CODE>45 }</CODE></P>
     <BR>
     <P><CODE>46 void</CODE></P>
     <P><CODE>47 reader(int contfd, int msqid, int nbytes)</CODE></P>
     <P><CODE>48 {</CODE></P>
     <P><CODE>49  ssize_t n;</CODE></P>
     <P><CODE>50  Write(contfd, &amp;nbytes, sizeof(nbytes));</CODE></P>
     <P><CODE>51  while ((nbytes &gt; 0) &amp;&amp;</CODE></P>
     <P><CODE>52   ((n = Msgrcv(msqid, buf, xfersize – sizeof(long), 0, 0)) &gt; 0)) {</CODE></P>
     <P><CODE>53   nbytes –= n + sizeof(long);</CODE></P>
     <P><CODE>54  }</CODE></P>
     <P><CODE>55 }</CODE></P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><STRONG><a name=label841 style="border:none;"></a>Программа измерения полосы пропускания дверей</STRONG></P>
     </H1>
     <P>Программа измерения полосы пропускания интерфейса дверей сложнее, чем предыдущие, поскольку нам нужно вызвать fork перед созданием двери. Родительский процесс создает дверь и с помощью канала оповещает дочерний процесс о том, что ее можно открывать.</P>
     <P>Другое изменение заключается в том, что в отличие от рис. А.7 функция reader не принимает данные. Данные принимаются функцией server, которая является процедурой сервера для данной двери. На рис. А.8 изображена схема программы. </P>
     <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader253" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

     <P>Рис. А.8. Схема программы измерения полосы пропускания дверей</P>
     <BR>
     <P>Поскольку двери поддерживаются только в Solaris, мы упростим программу, предполагая наличие двустороннего канала (раздел 4.4).</P>
     <P>Еще одно изменение вызвано фундаментальным различием между передачей сообщений и вызовом процедуры. В программе, работавшей с очередью сообщений Posix, например, записывающий процесс просто помещал сообщения в очередь в цикле, что осуществляется асинхронно. В какой-то момент очередь будет заполнена или записывающий процесс будет просто приостановлен, и тогда считывающий процесс получит сообщения. Если, например, в очередь помещается 8 сообщений и записывающий процесс помещал в нее 8 сообщений каждый раз, когда получал управление, а считывающий процесс считывал 8 сообщений, отправка N сообщений требовала N/4 переключения контекста. Интерфейс дверей является синхронным: вызывающий процесс блокируется каждый раз при вызове door_call и не может возобновиться до тех пор, пока сервер не завершит работу. Передача N сообщений в этом случае требует N/2 переключений контекста. С той же проблемой мы столкнемся при измерении полосы пропускания вызовов RPC. Несмотря на увеличившееся количество переключений контекста, из рис. А.1 следует, что двери обладают наибольшей полосой пропускания при размере сообщений не более 25 Кбайт.</P>
     <P>В листинге А.9 приведен текст функции main нашей программы. Функции writer, server и reader приведены в листинге А.10.</P>
     <H2><a name=label842 style="border:none;"></a>Листинг А.9. Функция main измерения полосы пропускания интерфейса дверей</H2>
     <P><CODE>//bench/bw_door.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  void reader(int, int);</CODE></P>
     <P><CODE>3  void writer(int);</CODE></P>
     <P><CODE>4  void server(void *, char *, size_t, door_desc_t *, size_t);</CODE></P>
     <P><CODE>5  void *buf;</CODE></P>
     <P><CODE>6  int totalnbytes, xfersize, contpipe[2];</CODE></P>
     <BR>
     <P><CODE>7  int</CODE></P>
     <P><CODE>8  main(int argc, char **argv)</CODE></P>
     <P><CODE>9  {</CODE></P>
     <P><CODE>10  int i, nloop, doorfd;</CODE></P>
     <P><CODE>11  char c;</CODE></P>
     <P><CODE>12  pid_t childpid;</CODE></P>
     <P><CODE>13  ssize_t n;</CODE></P>
     <P><CODE>14  if (argc != 5)</CODE></P>
     <P><CODE>15   err_quit("usage: bw_door &lt;pathname&gt; &lt;#loops&gt; &lt;#mbytes&gt; &lt;#bytes/write&gt;");</CODE></P>
     <P><CODE>16  nloop = atoi(argv[2]);</CODE></P>
     <P><CODE>17  totalnbytes = atoi(argv[3]) * 1024 * 1024;</CODE></P>
     <P><CODE>18  xfersize = atoi(argv[4]);</CODE></P>
     <P><CODE>19  buf = Valloc(xfersize);</CODE></P>
     <P><CODE>20  Touch(buf, xfersize);</CODE></P>
     <P><CODE>21  unlink(argv[1]);</CODE></P>
     <P><CODE>22  Close(Open(argv[1], O_CREAT | O_EXCL | O_RDWR, FILE_MODE));</CODE></P>
     <P><CODE>23  Pipe(contpipe); /* предполагается наличие двустороннего канала SVR4 */</CODE></P>
     <P><CODE>24  if ((childpid = Fork()) == 0) {</CODE></P>
     <P><CODE>25   /* дочерний процесс = клиент */</CODE></P>
     <P><CODE>26   if ((n = Read(contpipe[0], &amp;c, 1)) != 1)</CODE></P>
     <P><CODE>27    err_quit("child: pipe read returned %d", n);</CODE></P>
     <P><CODE>28   doorfd = Open(argv[1], O_RDWR);</CODE></P>
     <P><CODE>29   writer(doorfd);</CODE></P>
     <P><CODE>30   exit(0);</CODE></P>
     <P><CODE>31  }</CODE></P>
     <P><CODE>32  /* родительский процесс = сервер */</CODE></P>
     <P><CODE>33  doorfd = Door_create(server, NULL, 0);</CODE></P>
     <P><CODE>34  Fattach(doorfd, argv[1]);</CODE></P>
     <P><CODE>35  Write(contpipe[1], &amp;c, 1); /* уведомление о готовности двери */</CODE></P>
     <P><CODE>36  Start_time();</CODE></P>
     <P><CODE>37  for (i = 0; i &lt; nloop; i++)</CODE></P>
     <P><CODE>38   reader(doorfd, totalnbytes);</CODE></P>
     <P><CODE>39  printf("bandwidth: %.3f MB/sec\n",</CODE></P>
     <P><CODE>40  totalnbytes / Stop_time() * nloop);</CODE></P>
     <P><CODE>41  kill(childpid, SIGTERM);</CODE></P>
     <P><CODE>42  unlink(argv[1]);</CODE></P>
     <P><CODE>43  exit(0);</CODE></P>
     <P><CODE>44 }</CODE></P>
     <H2><a name=label843 style="border:none;"></a>Листинг A.10. Функции writer, server, reader для интерфейса дверей</H2>
     <P><CODE>//bench/bw_door.c</CODE></P>
     <P><CODE>45 void</CODE></P>
     <P><CODE>46 writer(int doorfd)</CODE></P>
     <P><CODE>47 {</CODE></P>
     <P><CODE>48  int ntowrite;</CODE></P>
     <P><CODE>49  door_arg_t arg;</CODE></P>
     <P><CODE>50  arg.desc_ptr = NULL; /* дескрипторы не передаются */</CODE></P>
     <P><CODE>51  arg.desc_num = 0;</CODE></P>
     <P><CODE>52  arg.rbuf = NULL; /* значения не возвращаются */</CODE></P>
     <P><CODE>53  arg.rsize = 0;</CODE></P>
     <P><CODE>54  for(;;) {</CODE></P>
     <P><CODE>55   Read(contpipe[0], &amp;ntowrite, sizeof(ntowrite));</CODE></P>
     <P><CODE>56   while (ntowrite &gt; 0) {</CODE></P>
     <P><CODE>57    arg.data_ptr = buf;</CODE></P>
     <P><CODE>58    arg.data_size = xfersize;</CODE></P>
     <P><CODE>59    Door_call(doorfd, &amp;arg);</CODE></P>
     <P><CODE>60    ntowrite –= xfersize;</CODE></P>
     <P><CODE>61   }</CODE></P>
     <P><CODE>62  }</CODE></P>
     <P><CODE>63 }</CODE></P>
     <BR>
     <P><CODE>64 static int ntoread, nread;</CODE></P>
     <BR>
     <P><CODE>65 void</CODE></P>
     <P><CODE>66 server(void *cookie, char *argp, size_t arg_size,</CODE></P>
     <P><CODE>67  door_desc_t *dp, size_t n_descriptors)</CODE></P>
     <P><CODE>68 {</CODE></P>
     <P><CODE>69  char c;</CODE></P>
     <P><CODE>70  nread += arg_size;</CODE></P>
     <P><CODE>71  if (nread &gt;= ntoread)</CODE></P>
     <P><CODE>72   Write(contpipe[0], &amp;c, 1); /* запись закончена */</CODE></P>
     <P><CODE>73  Door_return(NULL, 0, NULL, 0);</CODE></P>
     <P><CODE>74 }</CODE></P>
     <BR>
     <P><CODE>75 void</CODE></P>
     <P><CODE>76 reader(int doorfd, int nbytes)</CODE></P>
     <P><CODE>77 {</CODE></P>
     <P><CODE>78  char c;</CODE></P>
     <P><CODE>79  ssize_t n;</CODE></P>
     <P><CODE>80  ntoread = nbytes; /* глобальные переменные процедуры сервера */</CODE></P>
     <P><CODE>81  nread = 0;</CODE></P>
     <P><CODE>82  Write(contpipe[1], &amp;nbytes, sizeof(nbytes));</CODE></P>
     <P><CODE>83  if ((n = Read(contpipe[1], &amp;c, 1)) != 1)</CODE></P>
     <P><CODE>84   err_quit("reader: pipe read returned %d", n);</CODE></P>
     <P><CODE>85 }</CODE></P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label844 style="border:none;"></a>Программа определения полосы пропускания Sun RPC</P>
     </H1>
     <P>Поскольку вызовы процедур в Sun RPC являются синхронными, для них действует то же ограничение, что и для дверей (см. выше). В данном случае проще создать две программы (клиент и сервер), поскольку они создаются автоматически программой rpcgen. В листинге А.11 приведен файл спецификации RPC. Мы объявляем единственную процедуру, принимающую скрытые данные переменной длины в качестве входного аргумента и ничего не возвращающую.</P>
     <P>В листинге А.12 приведен текст программы-клиента, а в листинге А.13 — процедура сервера. Мы указываем протокол в качестве аргумента командной строки при вызове клиента, что позволяет нам измерить скорость работы обоих протоколов.</P>
     <H2><a name=label845 style="border:none;"></a>Листинг А.11. Спецификация RPC для измерения полосы пропускания RPC</H2>
     <P><CODE>//bench/bw_sunrpc.х</CODE></P>
     <P><CODE>1 %#define DEBUG /* сервер выполняется в приоритетном режиме */</CODE></P>
     <BR>
     <P><CODE>2 struct data_in {</CODE></P>
     <P><CODE>3  opaque data&lt;&gt;; /* скрытые данные переменной длины */</CODE></P>
     <P><CODE>4 };</CODE></P>
     <BR>
     <P><CODE>5 program BW_SUNRPC_PROG {</CODE></P>
     <P><CODE>6  version BW_SUNRPC_VERS {</CODE></P>
     <P><CODE>7   void BW_SUNRPC(data_in) = 1;</CODE></P>
     <P><CODE>8  } = 1;</CODE></P>
     <P><CODE>9 } = 0x31230001;</CODE></P>
     <H2><a name=label846 style="border:none;"></a>Листинг A.12. Клиент RPC для измерения полосы пропускания</H2>
     <P><CODE>//bench/bw_sunrpc_client.с</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #include "bw_sunrpc.h"</CODE></P>
     <BR>
     <P><CODE>3  void *buf;</CODE></P>
     <P><CODE>4  int totalnbytes, xfersize;</CODE></P>
     <BR>
     <P><CODE>5  int</CODE></P>
     <P><CODE>6  main(int argc, char **argv)</CODE></P>
     <P><CODE>7  {</CODE></P>
     <P><CODE>8   int i, nloop, ntowrite;</CODE></P>
     <P><CODE>9   CLIENT *cl;</CODE></P>
     <P><CODE>10  data_in in;</CODE></P>
     <P><CODE>11  if (argc != 6)</CODE></P>
     <P><CODE>12   err_quit("usage: bw_sunrpc_client &lt;hostname&gt; &lt;#loops&gt;"</CODE></P>
     <P><CODE>13   " &lt;#mbytes&gt; &lt;#bytes/write&gt; &lt;protocol&gt;");</CODE></P>
     <P><CODE>14  nloop = atoi(argv[2]);</CODE></P>
     <P><CODE>15  totalnbytes = atoi(argv[3]) * 1024 * 1024;</CODE></P>
     <P><CODE>16  xfersize = atoi(argv[4]);</CODE></P>
     <P><CODE>17  buf = Valloc(xfersize);</CODE></P>
     <P><CODE>18  Touch(buf, xfersize);</CODE></P>
     <P><CODE>19  cl = Clnt_create(argv[1], BW_SUNRPC_PROG, BW_SUNRPC_VERS, argv[5]);</CODE></P>
     <P><CODE>20  Start_time();</CODE></P>
     <P><CODE>21  for (i = 0; i &lt; nloop; i++) {</CODE></P>
     <P><CODE>22   ntowrite = totalnbytes;</CODE></P>
     <P><CODE>23   while (ntowrite &gt; 0) {</CODE></P>
     <P><CODE>24    in.data.data_len = xfersize;</CODE></P>
     <P><CODE>25    in.data.data_val = buf;</CODE></P>
     <P><CODE>26    if (bw_sunrpc_1(&amp;in, cl) == NULL)</CODE></P>
     <P><CODE>27     err_quit("%s", clnt_sperror(cl, argv[1]));</CODE></P>
     <P><CODE>28    ntowrite –= xfersize;</CODE></P>
     <P><CODE>29   }</CODE></P>
     <P><CODE>30  }</CODE></P>
     <P><CODE>31  printf("bandwidth: %.3f MB/sec\n",</CODE></P>
     <P><CODE>32   totalnbytes / Stop_time() * nloop);</CODE></P>
     <P><CODE>33  exit(0);</CODE></P>
     <P><CODE>34 }</CODE></P>
     <H2><a name=label847 style="border:none;"></a>Листинг A.13. Процедура сервера для измерения полосы пропускания RPC</H2>
     <P><CODE>//bench/bw_sunrpc_server.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #include "bw_sunrpc.h"</CODE></P>
     <P><CODE>3  #ifndef RPCGEN_ANSIC</CODE></P>
     <P><CODE>4  #define bw_sunrpc_1_svc bw_sunrpc_1</CODE></P>
     <P><CODE>5  #endif</CODE></P>
     <BR>
     <P><CODE>6  void *</CODE></P>
     <P><CODE>7  bw_sunrpc_1_svc(data_in *inp, struct svc_req *rqstp)</CODE></P>
     <P><CODE>8  {</CODE></P>
     <P><CODE>9   static int nbytes;</CODE></P>
     <P><CODE>10  nbytes = inp-&gt;data.data_len;</CODE></P>
     <P><CODE>11  return(&amp;nbytes); /* должен быть ненулевым, но xdr_void игнорирует */</CODE></P>
     <P><CODE>12 }</CODE></P>
    </DIV>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label848 style="border:none;"></a>А.4. Измерение задержки передачи сообщений: программы</P>
    </H1>
    <DIV class=section>
     <P>Приведем текст трех программ, измеряющих задержку при передаче сообщений по каналам, очередям Posix и очередям System V. Данные о производительности, полученные с их помощью, приведены в табл. А.1.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label849 style="border:none;"></a>Программа измерения задержки канала</P>
     </H1>
     <P>Программа для измерения задержки канала приведена в листинге А.14.</P>
     <H2><a name=label850 style="border:none;"></a>Листинг А.14. Программа измерения задержки канала</H2>
     <P><CODE>//bench/lat_pipe.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <BR>
     <P><CODE>2  void</CODE></P>
     <P><CODE>3  doit(int readfd, int writefd)</CODE></P>
     <P><CODE>4  {</CODE></P>
     <P><CODE>5   char c;</CODE></P>
     <P><CODE>6   Write(writefd, &amp;c, 1);</CODE></P>
     <P><CODE>7   if (Read(readfd, &amp;c, 1) != 1)</CODE></P>
     <P><CODE>8    err_quit("read error");</CODE></P>
     <P><CODE>9  }</CODE></P>
     <BR>
     <P><CODE>10 int</CODE></P>
     <P><CODE>11 main(int argc, char **argv)</CODE></P>
     <P><CODE>12 {</CODE></P>
     <P><CODE>13  int i, nloop, pipe1[2], pipe2[2];</CODE></P>
     <P><CODE>14  char c;</CODE></P>
     <P><CODE>15  pid_t childpid;</CODE></P>
     <P><CODE>16  if (argc != 2)</CODE></P>
     <P><CODE>17   err_quit("usage: lat_pipe &lt;#loops&gt;");</CODE></P>
     <P><CODE>18  nloop = atoi(argv[1]);</CODE></P>
     <P><CODE>19  Pipe(pipe1);</CODE></P>
     <P><CODE>20  Pipe(pipe2);</CODE></P>
     <P><CODE>21  if ((childpid = Fork()) == 0) {</CODE></P>
     <P><CODE>22   for(;;) { /* дочерний процесс */</CODE></P>
     <P><CODE>23    if (Read(pipe1[0], &amp;c, 1) != 1)</CODE></P>
     <P><CODE>24     err_quit("read error");</CODE></P>
     <P><CODE>25    Write(pipe2[1], &amp;c, 1);</CODE></P>
     <P><CODE>26   }</CODE></P>
     <P><CODE>27   ехit(0);</CODE></P>
     <P><CODE>28  }</CODE></P>
     <P><CODE>29  /* родительский процесс */</CODE></P>
     <P><CODE>30  doit(pipe2[0], pipe1[1]);</CODE></P>
     <P><CODE>31  Start_time();</CODE></P>
     <P><CODE>32  for (i = 0; i &lt; nloop; i++)</CODE></P>
     <P><CODE>33   doit(pipe2[0], pipe1[1]);</CODE></P>
     <P><CODE>34  printf("latency: %.3f usec\n", Stop_time() / nloop);</CODE></P>
     <P><CODE>35  Kill(childpid, SIGTERM);</CODE></P>
     <P><CODE>36  exit(0);</CODE></P>
     <P><CODE>37 }</CODE></P>
     <H2><a name=label851 style="border:none;"></a>Функция doit</H2>
     <P>2-9 Эта функция запускается родительским процессом. Мы измеряем время ее работы. Она помещает 1 байт в канал, из которого читает дочерний процесс, и считывает 1 байт из другого канала, в который сообщение помещается дочерним процессом. При этом измеряется именно то, что мы назвали задержкой, — время передачи небольшого сообщения туда и обратно.</P>
     <H2><a name=label852 style="border:none;"></a>Создание каналов</H2>
     <P>19-20 Создаются два канала, после чего вызов fork порождает дочерний процесс. При этом образуется схема, изображенная на рис. 4.6 (но без закрытия неиспользуемых дескрипторов каналов). Для этого теста требуются два канала, поскольку каналы являются односторонними, а мы хотим передавать сообщение в обе стороны.</P>
     <H2><a name=label853 style="border:none;"></a>Дочерний процесс отсылает обратно сообщение</H2>
     <P>22-27 Дочерний процесс представляет собой бесконечный цикл, в котором однобайтовое сообщение считывается и отсылается обратно.</P>
     <H2><a name=label854 style="border:none;"></a>Измерение времени работы родительского процесса</H2>
     <P>29-34 Родительский процесс вызывает функцию doit для отправки однобайтового сообщения дочернему процессу и получения ответа. После этого мы имеем гарантию, что оба процесса выполняются. Затем функция doit вызывается в цикле с измерением времени задержки.</P>
     <P>На компьютере Sparc под управлением Solaris 2.6 при запуске программы пять раз подряд мы получим вот что:</P>
     <P><CODE>solaris % <STRONG>lat_pipe 10000</STRONG></CODE></P>
     <P><CODE>latency: 278.633 usec</CODE></P>
     <P><CODE>solaris % <STRONG>lat_pipe 10000</STRONG></CODE></P>
     <P><CODE>latency: 397.810 usec</CODE></P>
     <P><CODE>solaris % <STRONG>lat_pipe 10000</STRONG></CODE></P>
     <P><CODE>latency: 392.567 usec</CODE></P>
     <P><CODE>solaris % <STRONG>lat_pipe 10000</STRONG></CODE></P>
     <P><CODE>latency: 266.572 usec</CODE></P>
     <P><CODE>solaris % <STRONG>lat_pipe 10000</STRONG></CODE></P>
     <P><CODE>latency: 284.559 usec</CODE></P>
     <P>Среднее для пяти попыток составляет 324 микросекунды, и именно это значение приведено в табл. А.1. Это время учитывает два переключения контекста (от родительского процесса к дочернему и обратно), четыре системных вызова (write, read, write, read) и затраты на передачу 1 байта данных по каналу.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label855 style="border:none;"></a>Программа измерения задержки очередей сообщений Posix</P>
     </H1>
     <P>Пpoгрaммa измерения задержки для очередей сообщений Posix приведена в листинге А.15.</P>
     <H2><a name=label856 style="border:none;"></a>Листинг А. 15. Программа измерения задержки для очереди сообщений Posix</H2>
     <P><CODE>//bench/lat_pxmsg.с</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #define NAME1 "lat_pxmsg1"</CODE></P>
     <P><CODE>3  #define NAME2 "lat_pxmsg2"</CODE></P>
     <P><CODE>4  #define MAXMSG 4 /* место для 4096 байт в очереди */</CODE></P>
     <P><CODE>5  #define MSGSIZE 1024</CODE></P>
     <BR>
     <P><CODE>6  void</CODE></P>
     <P><CODE>7  doit(mqd_t mqsend, mqd_t mqrecv)</CODE></P>
     <P><CODE>8  {</CODE></P>
     <P><CODE>9   char buff[MSGSIZE];</CODE></P>
     <P><CODE>10  Mq_send(mqsend, buff, 1.0);</CODE></P>
     <P><CODE>11  if (Mq_receive(mqrecv, buff, MSGSIZE, NULL) != 1)</CODE></P>
     <P><CODE>12   err_quit("mq_receive error");</CODE></P>
     <P><CODE>13 }</CODE></P>
     <BR>
     <P><CODE>14 int</CODE></P>
     <P><CODE>15 main(int argc, char **argv)</CODE></P>
     <P><CODE>16 {</CODE></P>
     <P><CODE>17  int i, nloop;</CODE></P>
     <P><CODE>18  mqd_t mq1, mq2;</CODE></P>
     <P><CODE>19  char buff[MSGSIZE];</CODE></P>
     <P><CODE>20  pid_t childpid;</CODE></P>
     <P><CODE>21  struct mq_attr attr;</CODE></P>
     <P><CODE>22  if (argc != 2)</CODE></P>
     <P><CODE>23   err_quit("usage: lat_pxmsg &lt;#loops&gt;");</CODE></P>
     <P><CODE>24  nloop = atoi(argv[1]);</CODE></P>
     <P><CODE>25  attr.mq_maxmsg = MAXMSG;</CODE></P>
     <P><CODE>26  attr.mq_msgsize = MSGSIZE;</CODE></P>
     <P><CODE>27  mq1 = Mq_open(Px_ipc_name(NAME1), O_RDWR | O_CREAT, FILE_MODE, &amp;attr);</CODE></P>
     <P><CODE>28  mq2 = Mq_open(Px_ipc_name(NAME2), O_RDWR | O_CREAT, FILE_MODE, &amp;attr);</CODE></P>
     <P><CODE>29  if ((childpid = Fork()) == 0) {</CODE></P>
     <P><CODE>30   for(;;) { /* дочерний процесс */</CODE></P>
     <P><CODE>31    if (Mq_receive(mq1, buff, MSGSIZE, NULL) != 1)</CODE></P>
     <P><CODE>32     err_quit("mq_receive error");</CODE></P>
     <P><CODE>33    Mq_send(mq2, buff, 1.0);</CODE></P>
     <P><CODE>34   }</CODE></P>
     <P><CODE>35   exit(0);</CODE></P>
     <P><CODE>36  }</CODE></P>
     <P><CODE>37  /* родительский процесс */</CODE></P>
     <P><CODE>38  doit(mq1, mq2);</CODE></P>
     <P><CODE>39  Start_time();</CODE></P>
     <P><CODE>40  for (i = 0; i &lt; nloop; i++)</CODE></P>
     <P><CODE>41   doit(mq1, mq2);</CODE></P>
     <P><CODE>42  printf("latency: %.3f usec\n", Stop_time() / nloop);</CODE></P>
     <P><CODE>43  Kill(childpid, SIGTERM);</CODE></P>
     <P><CODE>44  Mq_close(mq1);</CODE></P>
     <P><CODE>45  Mq_close(mq2);</CODE></P>
     <P><CODE>46  Mq_unlink(Px_ipc_name(NAMED);</CODE></P>
     <P><CODE>47  Mq_unlink(Px_ipc_name (NAME2));</CODE></P>
     <P><CODE>48  exit(0);</CODE></P>
     <P><CODE>49 }</CODE></P>
     <P>25-28 Создаются две очереди сообщений, каждая из которых используется для передачи данных в одну сторону. Хотя для очередей Posix можно указывать приоритет сообщений, функция mq_receive всегда возвращает сообщение с наивысшим приоритетом, поэтому мы не можем использовать лишь одну очередь для данного приложения.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label857 style="border:none;"></a>Измерение задержки очередей сообщений System V</P>
     </H1>
     <P>В листинге А.16 приведен текст программы измерения времени задержки для очередей сообщений System V.</P>
     <H2><a name=label858 style="border:none;"></a>Листинг А.16. Программа измерения времени задержки для очередей сообщений System V</H2>
     <P><CODE>//bench/lat_svmsg.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  struct msgbuf p2child = { 1, { 0 } }; /* type = 1 */</CODE></P>
     <P><CODE>3  struct msgbuf child2p = { 2, { 0 } }; /* type = 2 */</CODE></P>
     <P><CODE>4  struct msgbuf inbuf;</CODE></P>
     <BR>
     <P><CODE>5  void</CODE></P>
     <P><CODE>6  doit(int msgid)</CODE></P>
     <P><CODE>7  {</CODE></P>
     <P><CODE>8   Msgsnd(msgid, &amp;p2child, 0, 0);</CODE></P>
     <P><CODE>9   if (Msgrcv(msgid, &amp;inbuf, sizeof(inbuf.mtext), 2, 0) != 0)</CODE></P>
     <P><CODE>10   err_quit("msgrcv error");</CODE></P>
     <P><CODE>11 }</CODE></P>
     <BR>
     <P><CODE>12 int</CODE></P>
     <P><CODE>13 main(int argc, char **argv)</CODE></P>
     <P><CODE>14 {</CODE></P>
     <P><CODE>15  int i, nloop, msgid;</CODE></P>
     <P><CODE>16  pid_t childpid;</CODE></P>
     <P><CODE>17  if (argc != 2)</CODE></P>
     <P><CODE>18   err_quit("usage: lat_svmsg &lt;#loops&gt;");</CODE></P>
     <P><CODE>19  nloop = atoi(argv[1]);</CODE></P>
     <P><CODE>20  msgid = Msgget(IPC_PRIVATE, IPC_CREAT | SVMSG_MODE);</CODE></P>
     <P><CODE>21  if ((childpid = Fork()) == 0) {</CODE></P>
     <P><CODE>22   for(;;) { /* дочерний процесс */</CODE></P>
     <P><CODE>23    if (Msgrcv(msgid, &amp;inbuf, sizeof(inbuf.mtext), 1, 0) != 0)</CODE></P>
     <P><CODE>24     err_quit("msgrcv error");</CODE></P>
     <P><CODE>25    Msgsnd(msgid, &amp;child2p, 0, 0);</CODE></P>
     <P><CODE>26   }</CODE></P>
     <P><CODE>27   exit(0);</CODE></P>
     <P><CODE>28  }</CODE></P>
     <P><CODE>29  /* родительский процесс */</CODE></P>
     <P><CODE>30  doit(msgid);</CODE></P>
     <P><CODE>31  Start_time();</CODE></P>
     <P><CODE>32  for (i = 0; i &lt; nloop; i++)</CODE></P>
     <P><CODE>33   doit(msgid);</CODE></P>
     <P><CODE>34  printf("latency: %.3f usec\n", Stop_time() / nloop);</CODE></P>
     <P><CODE>35  Kill(childpid, SIGTERM);</CODE></P>
     <P><CODE>36  Msgctl(msgid, IPC_RMID, NULL);</CODE></P>
     <P><CODE>37  exit(0);</CODE></P>
     <P><CODE>38 }</CODE></P>
     <P>Мы создаем одну очередь, по которой сообщения передаются в обоих направлениях. Сообщения с типом 1 передаются от родительского процесса дочернему, а сообщения с типом 2 — в обратную сторону. Четвертый аргумент при вызове msgrcv в функции doit имеет значение 2, что обеспечивает получение сообщений только данного типа. Аналогично в дочернем процессе четвертый аргумент msgrcv имеет значение 1.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>В разделах 9.3 и 11.3 мы отмечали, что многие структуры, определенные в ядре, нельзя инициализировать статически, поскольку стандарты Posix.1 и Unix 98 гарантируют лишь наличие определенных полей в этих структурах, но не определяют ни их порядок, ни наличие других полей. В этой программе мы инициализируем структуру msgbuf статически, поскольку очереди сообщений System V гарантируют, что эта структура содержит поле типа сообщения long, за которым следуют передаваемые данные.</P>
     </DIV>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label859 style="border:none;"></a>Программа измерения задержки интерфейса дверей</P>
     </H1>
     <P>Пpoгрaммa измерения задержки для интерфейса дверей дана в листинге А.17. Дочерний процесс создает дверь и связывает с ней функцию server. Родительский процесс открывает дверь и вызывает door_call в цикле. В качестве аргумента передается 1 байт данных, и ничего не возвращается.</P>
     <H2><a name=label860 style="border:none;"></a>Листинг А.17. Программа измерения задержки интерфейса дверей</H2>
     <P><CODE>//bench/lat_door.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <BR>
     <P><CODE>2  void</CODE></P>
     <P><CODE>3  server(void *cookie, char *argp, size_t arg_size,</CODE></P>
     <P><CODE>4   door_desc_t *dp, size_t n_descriptors)</CODE></P>
     <P><CODE>5  {</CODE></P>
     <P><CODE>6   char c;</CODE></P>
     <P><CODE>7   Door_return(&amp;c, sizeof(char), NULL, 0);</CODE></P>
     <P><CODE>8  }</CODE></P>
     <BR>
     <P><CODE>9  int</CODE></P>
     <P><CODE>10 main(int argc, char **argv)</CODE></P>
     <P><CODE>11 {</CODE></P>
     <P><CODE>12  int i, nloop, doorfd, contpipe[2];</CODE></P>
     <P><CODE>13  char c;</CODE></P>
     <P><CODE>14  pid_t childpid;</CODE></P>
     <P><CODE>15  door_arg_t arg;</CODE></P>
     <P><CODE>16  if (argc != 3)</CODE></P>
     <P><CODE>17   err_quit("usage: lat_door &lt;pathname&gt; &lt;#loops&gt;");</CODE></P>
     <P><CODE>18  nloop = atoi(argv[2]);</CODE></P>
     <P><CODE>19  unlink(argv[1]);</CODE></P>
     <P><CODE>20  Close(Open(argv[1], O_CREAT | O_EXCL | O_RDWR, FILE_MODE));</CODE></P>
     <P><CODE>21  Pipe(contpipe);</CODE></P>
     <P><CODE>22  if ((childpid = Fork()) == 0) {</CODE></P>
     <P><CODE>23   doorfd = Door_create(server, NULL, 0);</CODE></P>
     <P><CODE>24   Fattach(doorfd, argv[1]);</CODE></P>
     <P><CODE>25   Write(contpipe[1], &amp;c, 1);</CODE></P>
     <P><CODE>26   for(;;) /* дочерний процесс = сервер */</CODE></P>
     <P><CODE>27    pause();</CODE></P>
     <P><CODE>28   exit(0);</CODE></P>
     <P><CODE>29  }</CODE></P>
     <P><CODE>30  arg.data_ptr = &amp;c; /* родительский процесс = клиент */</CODE></P>
     <P><CODE>31  arg.data_size = sizeof(char);</CODE></P>
     <P><CODE>32  arg.desc_ptr = NULL;</CODE></P>
     <P><CODE>33  arg.desc_num = 0;</CODE></P>
     <P><CODE>34  arg.rbuf = &amp;c;</CODE></P>
     <P><CODE>35  arg.rsize = sizeof(char);</CODE></P>
     <P><CODE>36  if (Read(contpipe[0], &amp;c, 1) != 1) /* ждем создания */</CODE></P>
     <P><CODE>37   err_quit("pipe read error");</CODE></P>
     <P><CODE>38  doorfd = Open(argv[1], O_RDWR);</CODE></P>
     <P><CODE>39  Door_call(doorfd, &amp;arg); /* запуск */</CODE></P>
     <P><CODE>40  Start_time();</CODE></P>
     <P><CODE>41  for (i = 0; i &lt; nloop; i++)</CODE></P>
     <P><CODE>42   Door_call(doorfd, &amp;arg);</CODE></P>
     <P><CODE>43  printf("latency: %.3f usec\n", Stop_time() / nloop);</CODE></P>
     <P><CODE>44  Kill(childpid, SIGTERM);</CODE></P>
     <P><CODE>45  unlink(argv[1]);</CODE></P>
     <P><CODE>46  exit(0);</CODE></P>
     <P><CODE>47 }</CODE></P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label861 style="border:none;"></a>Программа измерения времени задержки Sun RPC</P>
     </H1>
     <P>Для измерения времени задержки Sun RPC мы напишем две программы: клиент и сервер, аналогично измерению полосы пропускания. Мы используем старый файл спецификации RPC, но на этот раз клиент вызывает нулевую процедуру сервера. Вспомните упражнение 16.11: эта процедура не принимает никаких аргументов и ничего не возвращает. Это именно то, что нам нужно, чтобы определить задержку. В листинге А.18 приведен текст клиента. Как и в решении упражнения 16.11, нам нужно воспользоваться clnt_call для вызова нулевой процедуры; в заглушке клиента отсутствует необходимая заглушка для этой процедуры.</P>
     <H2><a name=label862 style="border:none;"></a>Листинг А.18. Клиент Sun RPC для измерения задержки</H2>
     <P><CODE>//bench/lat_sunrpc_client.с</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #include "lat_sunrpc.h"</CODE></P>
     <BR>
     <P><CODE>3  int</CODE></P>
     <P><CODE>4  main(int argc, char **argv)</CODE></P>
     <P><CODE>5  {</CODE></P>
     <P><CODE>6   int i, nloop;</CODE></P>
     <P><CODE>7   CLIENT *cl;</CODE></P>
     <P><CODE>8   struct timeval tv;</CODE></P>
     <P><CODE>9   if (argc != 4)</CODE></P>
     <P><CODE>10   err_quit("usage: lat_sunrpc_client &lt;hostname&gt; &lt;#loops&gt; &lt;protocol&gt;");</CODE></P>
     <P><CODE>11  nloop = atoi(argv[2]);</CODE></P>
     <P><CODE>12  cl = Clnt_create(argv[1], BW_SUNRPC_PROG, BW_SUNRPC_VERS, argv[3]);</CODE></P>
     <P><CODE>13  tv.tv_sec = 10;</CODE></P>
     <P><CODE>14  tv.tv_usec = 0;</CODE></P>
     <P><CODE>15  Start_time();</CODE></P>
     <P><CODE>16  for (i = 0; i &lt; nloop; i++) {</CODE></P>
     <P><CODE>17   if (clnt_call(cl, NULLPROC, xdr_void, NULL,</CODE></P>
     <P><CODE>18    xdr_void, NULL, tv) != RPC_SUCCESS)</CODE></P>
     <P><CODE>19    err_quit("%s", clnt_sperror(cl, argv[1]));</CODE></P>
     <P><CODE>20  }</CODE></P>
     <P><CODE>21  printf("latency: %.3f usec\n", Stop_time() / nloop);</CODE></P>
     <P><CODE>22  exit(0);</CODE></P>
     <P><CODE>23 }</CODE></P>
     <P>Мы компилируем сервер с функцией, приведенной в листинге А.13, но она все равно не вызывается. Поскольку мы используем rpcgen для построения клиента и сервера, нам нужно определить хотя бы одну процедуру сервера, но мы не обязаны ее вызывать. Причина, по которой мы используем rpcgen, заключается в том, что она автоматически создает функцию main сервера с нулевой процедурой, которая нам нужна.</P>
    </DIV>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label863 style="border:none;"></a>А.5. Синхронизация потоков: программы</P>
    </H1>
    <DIV class=section>
     <P>Для измерения времени, уходящего на синхронизацию при использовании различных средств, мы создаем некоторое количество потоков (от одного до пяти, согласно табл. А.4 и А.5), каждый из которых увеличивает счетчик в разделяемой памяти большое количество раз, используя различные формы синхронизации для получения доступа к счетчику.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label864 style="border:none;"></a>Взаимные исключения Posix</P>
     </H1>
     <P>В листинге А.19 приведены глобальные переменные и функция main пpoгрaммы, измеряющей быстродействие взаимных исключений Posix.</P>
     <H2><a name=label865 style="border:none;"></a>Листинг А.19. Глобальные переменные и функция main для взаимных исключений Posix</H2>
     <P><CODE>//bench/incr_pxmutex1.с</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #define MAXNTHREADS 100</CODE></P>
     <BR>
     <P><CODE>3  int nloop;</CODE></P>
     <P><CODE>4  struct {</CODE></P>
     <P><CODE>5   pthread_mutex_t mutex;</CODE></P>
     <P><CODE>6   long counter;</CODE></P>
     <P><CODE>7  } shared = {</CODE></P>
     <P><CODE>8   PTHREAD_MUTEX_INITIALIZER</CODE></P>
     <P><CODE>9  };</CODE></P>
     <P><CODE>10 void *incr(void *);</CODE></P>
     <BR>
     <P><CODE>11 int</CODE></P>
     <P><CODE>12 main(int argc, char **argv)</CODE></P>
     <P><CODE>13 {</CODE></P>
     <P><CODE>14  int i, nthreads;</CODE></P>
     <P><CODE>15  pthread_t tid[MAXNTHREADS];</CODE></P>
     <P><CODE>16  if (argc != 3)</CODE></P>
     <P><CODE>17   err_quit("usage: incr_pxmutex1 &lt;#loops&gt; &lt;#threads&gt;");</CODE></P>
     <P><CODE>18  nloop = atoi(argv[1]);</CODE></P>
     <P><CODE>19  nthreads = min(atoi(argv[2]), MAXNTHREADS);</CODE></P>
     <P><CODE>20  /* блокировка взаимного исключения */</CODE></P>
     <P><CODE>21  Pthread_mutex_lock(&amp;shared.mutex);</CODE></P>
     <P><CODE>22  /* создание потоков */</CODE></P>
     <P><CODE>23  Set_concurrency(nthreads);</CODE></P>
     <P><CODE>24  for (i = 0; i &lt; nthreads; i++) {</CODE></P>
     <P><CODE>25   Pthread_create(&amp;tid[i], NULL, incr, NULL);</CODE></P>
     <P><CODE>26  }</CODE></P>
     <P><CODE>27  /* запуск таймера и разблокирование взаимного исключения */</CODE></P>
     <P><CODE>28  Start_time();</CODE></P>
     <P><CODE>29  Pthread_mutex_unlock(&amp;shared.mutex);</CODE></P>
     <P><CODE>30  /* ожидание завершения работы потоков */</CODE></P>
     <P><CODE>31  for (i = 0; i &lt; nthreads; i++) {</CODE></P>
     <P><CODE>32   Pthread_join(tid[i], NULL);</CODE></P>
     <P><CODE>33  }</CODE></P>
     <P><CODE>34  printf("microseconds: %.0f usec\n", Stop_time());</CODE></P>
     <P><CODE>35  if (shared.counter != nloop * nthreads)</CODE></P>
     <P><CODE>36   printf("error: counter = %ld\n", shared, counter);</CODE></P>
     <P><CODE>37  exit(0);</CODE></P>
     <P><CODE>38 }</CODE></P>
     <H2><a name=label866 style="border:none;"></a>Общие данные</H2>
     <P>4-9 Совместно используемые потоками данные состоят из взаимного исключения и счетчика. Взаимное исключение инициализируется статически.</P>
     <H2><a name=label867 style="border:none;"></a>Блокирование взаимного исключения и создание потоков</H2>
     <P>20-26 Основной поток блокирует взаимное исключение перед созданием прочих потоков, чтобы ни один из них не получил это исключение до тех пор, пока все они не будут созданы. Вызывается функция set_concurrency, создаются потоки. Каждый поток выполняет функцию incr, текст которой будет приведен позже. </P>
     <H2><a name=label868 style="border:none;"></a>Запуск таймера и разблокирование взаимного исключения</H2>
     <P>27-36 После создания всех потоков главный поток запускает таймер и освобождает взаимное исключение. Затем он ожидает завершения всех потоков, после чего останавливает таймер и выводит полное время работы. В листинге А.20 приведен текст функции incr, выполняемой каждым из потоков.</P>
     <H2><a name=label869 style="border:none;"></a>Листинг А.20. Функция incr, выполняемая потоками</H2>
     <P><CODE>//bench/incr_pxmutex1.c</CODE></P>
     <P><CODE>39 void *</CODE></P>
     <P><CODE>40 incr(void *arg)</CODE></P>
     <P><CODE>41 {</CODE></P>
     <P><CODE>42  int i;</CODE></P>
     <P><CODE>43  for (i = 0; i &lt; nloop; i++) {</CODE></P>
     <P><CODE>44   Pthread_mutex_lock(&amp;shared.mutex);</CODE></P>
     <P><CODE>45   shared.counter++;</CODE></P>
     <P><CODE>46   Pthread_mutex_unlock(&amp;shared.mutex);</CODE></P>
     <P><CODE>47  }</CODE></P>
     <P><CODE>48  return(NULL);</CODE></P>
     <P><CODE>49 }</CODE></P>
     <H2><a name=label870 style="border:none;"></a>Увеличение счетчика — критическая область кода</H2>
     <P>44-46 Операция увеличения счетчика осуществляется после получения блокировки на взаимное исключение. После этого взаимное исключение разблокируется.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label871 style="border:none;"></a>Блокировки чтения-записи</P>
     </H1>
     <P>Пpoгрaммa, использующая блокировки чтения-записи, является слегка измененной версией программы с взаимными исключениями Posix. Поток должен установить блокировку файла, прежде чем увеличивать общий счетчик.</P>
     <DIV class=cite>
      <P><STRONG>ПРИМЕЧАНИЕ</STRONG></P>
      <P>Существует не так уж много систем, в которых реализованы блокировки чтения-записи, являющиеся частью стандарта Unix 98 и разрабатываемые рабочей группой Posix.1j. Измерения в этом разделе проводились в системе Solaris 2.6 с использованием блокировок, описанных в документации на странице rwlock(3T). Эта реализация обеспечивает тот же набор функций, что и предлагаемые блокировки чтения-записи Posix. Для использования этих функций мы применяем тривиальные функции-обертки.</P>
      <P>В Digital Unix 4.0B мы использовали блокировки чтения-записи поточно-независимых служб, описанные на странице документации tis_rwlock. Мы не приводим листингов с несущественными изменениями, необходимыми для использования этих блокировок.</P>
     </DIV>
     <P>В листинге А.21 приведен текст функции main, а в листинге А.22 — текст функции incr.</P>
     <H2><a name=label872 style="border:none;"></a>Листинг А.21. Функция main для блокировок чтения-записи</H2>
     <P><CODE>//bench/incr_rwlock1.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #include &lt;synch.h&gt; /* Заголовочный файл для Solaris */</CODE></P>
     <BR>
     <P><CODE>3  void Rw_wrlock(rwlock_t *rwptr);</CODE></P>
     <P><CODE>4  void Rw_unlock(rwlock_t *rwptr);</CODE></P>
     <P><CODE>5  #define MAXNTHREADS 100</CODE></P>
     <P><CODE>6  int nloop;</CODE></P>
     <P><CODE>7  struct {</CODE></P>
     <P><CODE>8   rwlock_t rwlock; /* тип данных Solaris */</CODE></P>
     <P><CODE>9   long counter;</CODE></P>
     <P><CODE>10  } shared; /* инициализация О –&gt; USYNC_THREAD */</CODE></P>
     <P><CODE>11  void *incr(void *);</CODE></P>
     <BR>
     <P><CODE>12 int</CODE></P>
     <P><CODE>13 main(int argc, char **argv)</CODE></P>
     <P><CODE>14 {</CODE></P>
     <P><CODE>15  int i, nthreads;</CODE></P>
     <P><CODE>16  pthread_t tid[MAXNTHREADS];</CODE></P>
     <P><CODE>17  if (argc != 3)</CODE></P>
     <P><CODE>18   err_quit("usage: incr_rwlockl &lt;#loops&gt; &lt;#threads&gt;");</CODE></P>
     <P><CODE>19  nloop = atoi(argv[1]);</CODE></P>
     <P><CODE>20  nthreads = min(atoi(argv[2]), MAXNTHREADS);</CODE></P>
     <P><CODE>21  /* получение блокировки на запись */</CODE></P>
     <P><CODE>22  Rw_wrlock(&amp;shared.rwlock);</CODE></P>
     <P><CODE>23  /* создание всех потоков */</CODE></P>
     <P><CODE>24  Set_concurrency(nthreads);</CODE></P>
     <P><CODE>25  for (i = 0; i &lt; nthreads; i++) {</CODE></P>
     <P><CODE>26   Pthread_create(&amp;tid[i], NULL, incr, NULL);</CODE></P>
     <P><CODE>27  }</CODE></P>
     <P><CODE>28  /* запуск таймера и снятие блокировки */</CODE></P>
     <P><CODE>29  Start_time();</CODE></P>
     <P><CODE>30  Rw_unlock(&amp;shared.rwlock);</CODE></P>
     <P><CODE>31  /* ожидание завершения всех потоков */</CODE></P>
     <P><CODE>32  for (i = 0; i &lt; nthreads; i++) {</CODE></P>
     <P><CODE>33   Pthread_join(tid[i], NULL);</CODE></P>
     <P><CODE>34  }</CODE></P>
     <P><CODE>35  printf("microseconds: %.0f usec\n", Stop_time());</CODE></P>
     <P><CODE>36  if (shared.counter != nloop * nthreads)</CODE></P>
     <P><CODE>37   printf("error: counter = %ld\n", shared.counter);</CODE></P>
     <P><CODE>38  exit(0);</CODE></P>
     <P><CODE>39 }</CODE></P>
     <H2><a name=label873 style="border:none;"></a>Листинг А.22. Увеличение общего счетчика с использованием блокировок чтения-записи</H2>
     <P><CODE>//bench/incr_rwlock1.c</CODE></P>
     <P><CODE>40 void *</CODE></P>
     <P><CODE>41 incr(void *arg)</CODE></P>
     <P><CODE>42 {</CODE></P>
     <P><CODE>43  int i;</CODE></P>
     <P><CODE>44  for (i = 0; i &lt; nloop; i++) {</CODE></P>
     <P><CODE>45   Rw_wrlock(&amp;shared.rwlock);</CODE></P>
     <P><CODE>46   shared.counter++;</CODE></P>
     <P><CODE>47   Rw_unlock(&amp;shared.rwlock);</CODE></P>
     <P><CODE>48  }</CODE></P>
     <P><CODE>49  return(NULL);</CODE></P>
     <P><CODE>50 }</CODE></P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label874 style="border:none;"></a>Семафоры Posix, размещаемые в памяти</P>
     </H1>
     <P>Мы измеряем скорость работы семафоров Posix (именованных и размещаемых в памяти). В листинге А.24 приведен текст функции main, а в листинге А.23 — текст функции incr.</P>
     <H2><a name=label875 style="border:none;"></a>Листинг А.23. Увеличение счетчика с использованием семафоров Posix в памяти</H2>
     <P><CODE>//bench/incr_pxsem1.с</CODE></P>
     <P><CODE>37 void *</CODE></P>
     <P><CODE>38 incr(void *arg)</CODE></P>
     <P><CODE>39 {</CODE></P>
     <P><CODE>40  int i;</CODE></P>
     <P><CODE>41  for (i = 0; i &lt; nloop; i++) {</CODE></P>
     <P><CODE>42   Sem_wait(&amp;shared.mutex);</CODE></P>
     <P><CODE>43   shared.counter++;</CODE></P>
     <P><CODE>44   Sem_post(&amp;shared.mutex);</CODE></P>
     <P><CODE>45  }</CODE></P>
     <P><CODE>46  return(NULL);</CODE></P>
     <P><CODE>47 }</CODE></P>
     <H2><a name=label876 style="border:none;"></a>Листинг А.24. Функция main для семафоров Posix, размещаемых в памяти</H2>
     <P><CODE>//bench/incr_pxsem1.с</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #define MAXNTHREADS 100</CODE></P>
     <P><CODE>3  int nloop;</CODE></P>
     <P><CODE>4  struct {</CODE></P>
     <P><CODE>5   sem_t mutex; /* размещаемый в памяти семафор */</CODE></P>
     <P><CODE>6   long counter;</CODE></P>
     <P><CODE>7  } shared;</CODE></P>
     <P><CODE>8  void *incr(void *);</CODE></P>
     <BR>
     <P><CODE>9  int</CODE></P>
     <P><CODE>10 main(int argc, char **argv)</CODE></P>
     <P><CODE>11 {</CODE></P>
     <P><CODE>12  int i, nthreads;</CODE></P>
     <P><CODE>13  pthread_t tid[MAXNTHREADS];</CODE></P>
     <P><CODE>14  if (argc != 3)</CODE></P>
     <P><CODE>15   err_quit("usage: incr_pxseml &lt;#loops&gt; &lt;#threads&gt;");</CODE></P>
     <P><CODE>16  nloop = atoi(argv[1]);</CODE></P>
     <P><CODE>17  nthreads = min(atoi(argv[2]), MAXNTHREADS);</CODE></P>
     <P><CODE>18  /* инициализация размещаемого в памяти семафора 0 */</CODE></P>
     <P><CODE>19  Sem_init(&amp;shared.mutex, 0, 0);</CODE></P>
     <P><CODE>20  /* создание всех потоков */</CODE></P>
     <P><CODE>21  Set_concurrency(nthreads);</CODE></P>
     <P><CODE>22  for (i = 0; i &lt; nthreads; i++) {</CODE></P>
     <P><CODE>23   Pthread_create(&amp;tid[i], NULL, incr, NULL);</CODE></P>
     <P><CODE>24  }</CODE></P>
     <P><CODE>25  /* запуск таймера и разблокирование семафора */</CODE></P>
     <P><CODE>26  Start_time();</CODE></P>
     <P><CODE>27  Sem_post(&amp;shared.mutex);</CODE></P>
     <P><CODE>28  /* ожидание завершения всех потоков */</CODE></P>
     <P><CODE>29  for (i = 0; i &lt; nthreads; i++) {</CODE></P>
     <P><CODE>30   Pthread_join(tid[i], NULL);</CODE></P>
     <P><CODE>31  }</CODE></P>
     <P><CODE>32  printf("microseconds: %.0f usec\n", Stop_time());</CODE></P>
     <P><CODE>33  if (shared.counter != nloop * nthreads)</CODE></P>
     <P><CODE>34   printf("error: counter = %ld\n", shared.counter);</CODE></P>
     <P><CODE>35  exit(0);</CODE></P>
     <P><CODE>36 }</CODE></P>
     <P>18-19 Создается семафор, инициализируемый значением 0. Второй аргумент в вызове sem_init, имеющий значение 0, говорит о том, что семафор используется только потоками вызвавшего процесса.</P>
     <P>20-27 После создания всех потоков запускается таймер и вызывается функция sem_post.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label877 style="border:none;"></a>Именованные семафоры Posix</P>
     </H1>
     <P>В листинге А.26 приведен текст функции main, измеряющей быстродействие именованных семафоров Posix, а в листинге А.25 — соответствующая функция incr.</P>
     <H2><a name=label878 style="border:none;"></a>Листинг А.25. Увеличение общего счетчика с использованием именованного семафора Posix</H2>
     <P><CODE>//bench/incr_pxsem2.c</CODE></P>
     <P><CODE>40 void *</CODE></P>
     <P><CODE>41 incr(void *arg)</CODE></P>
     <P><CODE>42 {</CODE></P>
     <P><CODE>43  int i;</CODE></P>
     <P><CODE>44  for (i = 0; i &lt; nloop; i++) {</CODE></P>
     <P><CODE>45   Sem_wait(shared.mutex);</CODE></P>
     <P><CODE>46   shared.counter++;</CODE></P>
     <P><CODE>47   Sem_post(shared.mutex);</CODE></P>
     <P><CODE>48  }</CODE></P>
     <P><CODE>49  return(NULL);</CODE></P>
     <P><CODE>50 }</CODE></P>
     <H2><a name=label879 style="border:none;"></a>Листинг А.26. Функция main для измерения быстродействия именованных семафоров Posix</H2>
     <P><CODE>//bench/incr_pxsem2.с</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #define MAXNTHREADS 100</CODE></P>
     <P><CODE>3  #define NAME "incr_pxsem2"</CODE></P>
     <BR>
     <P><CODE>4  int nloop;</CODE></P>
     <P><CODE>5  struct {</CODE></P>
     <P><CODE>6   sem_t *mutex; /* указатель на именованный семафор */</CODE></P>
     <P><CODE>7   long counter;</CODE></P>
     <P><CODE>8  } shared;</CODE></P>
     <P><CODE>9  void *incr(void *);</CODE></P>
     <BR>
     <P><CODE>10 int</CODE></P>
     <P><CODE>11 main(int argc, char **argv)</CODE></P>
     <P><CODE>12 {</CODE></P>
     <P><CODE>13  int i, nthreads;</CODE></P>
     <P><CODE>14  pthread_t tid[MAXNTHREADS];</CODE></P>
     <P><CODE>15  if (argc != 3)</CODE></P>
     <P><CODE>16   err_quit("usage: incr_pxsem2 &lt;#loops&gt; &lt;#threads&gt;");</CODE></P>
     <P><CODE>17  nloop = atoi(argv[1]);</CODE></P>
     <P><CODE>18  nthreads = min(atoi(argv[2]), MAXNTHREADS);</CODE></P>
     <P><CODE>19  /* инициализация именованного семафора 0 */</CODE></P>
     <P><CODE>20  sem_unlink(Px_ipc_name(NAME)); /* ошибка – OK */</CODE></P>
     <P><CODE>21  shared.mutex = Sem_open(Px_ipc_name(NAME), O_CREAT | O_EXCL, FILE_MODE, 0);</CODE></P>
     <P><CODE>22  /* создание всех потоков */</CODE></P>
     <P><CODE>23  Set_concurrency(nthreads);</CODE></P>
     <P><CODE>24  for (i = 0; i &lt; nthreads; i++) {</CODE></P>
     <P><CODE>25   Pthread_create(&amp;tid[i], NULL, incr, NULL);</CODE></P>
     <P><CODE>26  }</CODE></P>
     <P><CODE>27  /* запуск таймера и разблокирование семафора */</CODE></P>
     <P><CODE>28  Start_time();</CODE></P>
     <P><CODE>29  Sem_post(shared.mutex);</CODE></P>
     <P><CODE>30  /* ожидание завершения всех потоков */</CODE></P>
     <P><CODE>31  for (i = 0; i &lt; nthreads; i++) {</CODE></P>
     <P><CODE>32   Pthread_join(tid[i], NULL);</CODE></P>
     <P><CODE>33  }</CODE></P>
     <P><CODE>34  printf("microseconds: %.0f usec\n", Stop_time());</CODE></P>
     <P><CODE>35  if (shared.counter != nloop * nthreads)</CODE></P>
     <P><CODE>36   printf("error: counter = %ld\n", shared.counter);</CODE></P>
     <P><CODE>37  Sem_unlink(Px_ipc_name(NAME));</CODE></P>
     <P><CODE>38  exit(0);</CODE></P>
     <P><CODE>39 }</CODE></P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label880 style="border:none;"></a>Семафоры System V</P>
     </H1>
     <P>Функция main программы, измеряющей быстродействие семафоров System V, приведена в листинге А.27, а функция incr показана в листинге А.28.</P>
     <H2><a name=label881 style="border:none;"></a>Листинг А.27. Функция main для измерения быстродействия семафоров System V</H2>
     <P><CODE>//bench/incr_svsem1.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #define MAXNTHREADS 100</CODE></P>
     <BR>
     <P><CODE>3  int nloop;</CODE></P>
     <P><CODE>4  struct {</CODE></P>
     <P><CODE>5   int semid;</CODE></P>
     <P><CODE>6   long counter;</CODE></P>
     <P><CODE>7  } shared;</CODE></P>
     <P><CODE>8  struct sembuf postop, waitop;</CODE></P>
     <P><CODE>9  void *incr(void *);</CODE></P>
     <BR>
     <P><CODE>10 int</CODE></P>
     <P><CODE>11 main(int argc, char **argv)</CODE></P>
     <P><CODE>12 {</CODE></P>
     <P><CODE>13  int i, nthreads;</CODE></P>
     <P><CODE>14  pthread_t tid[MAXNTHREADS];</CODE></P>
     <P><CODE>15  union semun arg;</CODE></P>
     <P><CODE>16  if (argc != 3)</CODE></P>
     <P><CODE>17   err_quit("usage: incr_svseml &lt;#loops&gt; &lt;#threads&gt;");</CODE></P>
     <P><CODE>18  nloop = atoi(argv[1]);</CODE></P>
     <P><CODE>19  nthreads = min(atoi(argv[2]), MAXNTHREADS);</CODE></P>
     <P><CODE>20  /* создание семафора и инициализация его значением 0 */</CODE></P>
     <P><CODE>21  shared.semid = Semget(IPC_PRIVATE, 1, IPC_CREAT | SVSEM_MODE);</CODE></P>
     <P><CODE>22  arg.val =0;</CODE></P>
     <P><CODE>23  Semctl(shared.semid, 0, SETVAL, arg);</CODE></P>
     <P><CODE>24  postop.sem_num = 0; /* инициализация двух структур semop */</CODE></P>
     <P><CODE>25  postop.sem_op = 1;</CODE></P>
     <P><CODE>26  postop.sem_flg = 0;</CODE></P>
     <P><CODE>27  waitop.sem_num = 0;</CODE></P>
     <P><CODE>28  waitop.sem_op = –1;</CODE></P>
     <P><CODE>29  waitop.sem_flg = 0;</CODE></P>
     <P><CODE>30  /* создание всех потоков */</CODE></P>
     <P><CODE>31  Set_concurrency(nthreads);</CODE></P>
     <P><CODE>32  for (i = 0; i &lt; nthreads; i++) {</CODE></P>
     <P><CODE>33   Pthread_create(&amp;tid[i], NULL, incr, NULL);</CODE></P>
     <P><CODE>34  }</CODE></P>
     <P><CODE>35  /* запуск таймера и разблокирование семафора */</CODE></P>
     <P><CODE>36  Start_time();</CODE></P>
     <P><CODE>37  Semop(shared.semid, &amp;postop, 1); /* up by 1 */</CODE></P>
     <P><CODE>38  /* ожидание завершения всех потоков */</CODE></P>
     <P><CODE>39  for (i = 0; i &lt; nthreads; i++) {</CODE></P>
     <P><CODE>40   Pthread_join(tid[i], NULL);</CODE></P>
     <P><CODE>41  }</CODE></P>
     <P><CODE>42  printf("microseconds: %.0f usec\n", Stop_time());</CODE></P>
     <P><CODE>43  if (shared.counter != nloop * nthreads)</CODE></P>
     <P><CODE>44   printf("error: counter = %ld\n", shared, counter);</CODE></P>
     <P><CODE>45  Semctl(shared.semid, 0, IPC_RMID);</CODE></P>
     <P><CODE>46  exit(0);</CODE></P>
     <P><CODE>47 }</CODE></P>
     <H2><a name=label882 style="border:none;"></a>Листинг А.28. Увеличение общего счетчика с использованием семафоров System V</H2>
     <P><CODE>//bench/incr_svsem1.c</CODE></P>
     <P><CODE>48 void *</CODE></P>
     <P><CODE>49 incr(void *arg)</CODE></P>
     <P><CODE>50 {</CODE></P>
     <P><CODE>51  int i;</CODE></P>
     <P><CODE>52  for (i = 0; i &lt; nloop; i++) {</CODE></P>
     <P><CODE>53   Semop(shared.semid, &amp;waitop, 1);</CODE></P>
     <P><CODE>54   shared.counter++;</CODE></P>
     <P><CODE>55   Semop(shared.semid, &amp;postop, 1);</CODE></P>
     <P><CODE>56  }</CODE></P>
     <P><CODE>57  return(NULL);</CODE></P>
     <P><CODE>58 }</CODE></P>
     <P>20-23 Создается семафор с одним элементом, значение которого инициализируется нулем.</P>
     <P>24-29 Инициализируются две структуры semop: одна для увеличения семафора, а другая для ожидания его изменения. Обратите внимание, что поле sem_flg в обеих структурах имеет значение 0: флаг SEM_UNDO не установлен.</P>
     <H2><a name=label883 style="border:none;"></a>Семафоры System V с флагом SEM_UNDO</H2>
     <P>Единственное отличие от пpoгрaммы из листинга А.27 заключается в том, что поле sem_flg структур semop устанавливается равным SEM_UNDO, а не 0. Мы не приводим в книге новый листинг с этим небольшим изменением.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label884 style="border:none;"></a>Блокировка записей fcntl</P>
     </H1>
     <P>Последняя пpoгрaммa использует fcntl для синхронизации. Функция main приведена в листинге А.30. Эта программа будет выполняться успешно только в том случае, если количество потоков равно 1, поскольку блокировка fcntl предназначена для использования между процессами, а не между потоками одного процесса. При указании нескольких потоков каждый из них всегда имеет возможность получить блокировку (то есть вызовы writew_lock не приводят к остановке потока, потому что процесс уже является владельцем блокировки), и конечное значение счетчика оказывается неправильным.</P>
     <P>Функция incr, использующая блокировку записей, приведена в листинге А.29.</P>
     <H2><a name=label885 style="border:none;"></a>Листинг А.29. Увеличение общего счетчика с использованием блокировки записей fcntl</H2>
     <P><CODE>//bench/incr_fcntl1.e</CODE></P>
     <P><CODE>44 void *</CODE></P>
     <P><CODE>45 incr(void *arg)</CODE></P>
     <P><CODE>46 {</CODE></P>
     <P><CODE>47  int i;</CODE></P>
     <P><CODE>48  for (i = 0; i &lt; nloop; i++) {</CODE></P>
     <P><CODE>49   Writew_lock(shared.fd, 0, SEEK_SET, 0);</CODE></P>
     <P><CODE>50   shared.counter++;</CODE></P>
     <P><CODE>51   Un_lock(shared.fd, 0, SEEK_SET, 0);</CODE></P>
     <P><CODE>52  }</CODE></P>
     <P><CODE>53 return(NULL);</CODE></P>
     <P><CODE>54 }</CODE></P>
     <H2><a name=label886 style="border:none;"></a>Листинг А.30. Функция main для измерения производительности блокировки fcntl</H2>
     <P><CODE>//bench/incr_fcntl1.e</CODE></P>
     <P><CODE>4  #include "unpipc.h"</CODE></P>
     <P><CODE>5  #define MAXNTHREADS 100</CODE></P>
     <BR>
     <P><CODE>6  int nloop;</CODE></P>
     <P><CODE>7  struct {</CODE></P>
     <P><CODE>8   int fd;</CODE></P>
     <P><CODE>9   long counter;</CODE></P>
     <P><CODE>10 } shared;</CODE></P>
     <P><CODE>11 void *incr(void *);</CODE></P>
     <BR>
     <P><CODE>12 int</CODE></P>
     <P><CODE>13 main(int argc, char **argv)</CODE></P>
     <P><CODE>14 {</CODE></P>
     <P><CODE>15  int i, nthreads;</CODE></P>
     <P><CODE>16  char *pathname;</CODE></P>
     <P><CODE>17  pthread_t tid[MAXNTHREADS];</CODE></P>
     <P><CODE>18  if (argc != 4)</CODE></P>
     <P><CODE>19   err_quit("usage: incr_fcntll &lt;pathname&gt; &lt;#loops&gt; &lt;#threads&gt;");</CODE></P>
     <P><CODE>20  pathname = argv[1];</CODE></P>
     <P><CODE>21  nloop = atoi(argv[2]);</CODE></P>
     <P><CODE>22  nthreads = min(atoi(argv[3]), MAXNTHREADS);</CODE></P>
     <P><CODE>23  /* создание файла и получение блокировки на запись */</CODE></P>
     <P><CODE>24  shared.fd = Open(pathname, O_RDWR | O_CREAT | O_TRUNC, FILE_MODE);</CODE></P>
     <P><CODE>25  Writew_lock(shared.fd, 0, SEEK_SET, 0);</CODE></P>
     <P><CODE>26  /* создание всех потоков */</CODE></P>
     <P><CODE>27  Set_concurrency(nthreads);</CODE></P>
     <P><CODE>28  for (i = 0; i &lt; nthreads; i++) {</CODE></P>
     <P><CODE>29   Pthread_create(&amp;tid[i], NULL, incr, NULL);</CODE></P>
     <P><CODE>30  }</CODE></P>
     <P><CODE>31  /* запуск таймера и снятие блокировки на запись */</CODE></P>
     <P><CODE>32  Start_time();</CODE></P>
     <P><CODE>33  Un_lock(shared.fd, 0, SEEK_SET, 0);</CODE></P>
     <P><CODE>34  /* ожидание завершения всех потоков */</CODE></P>
     <P><CODE>35  for (i = 0; i &lt; nthreads; i++) {</CODE></P>
     <P><CODE>36   Pthread_join(tid[i], NULL);</CODE></P>
     <P><CODE>37  }</CODE></P>
     <P><CODE>38  printf("microseconds: %.0f usec\n", Stop_time());</CODE></P>
     <P><CODE>39  if (shared.counter != nloop * nthreads)</CODE></P>
     <P><CODE>40   printf("error: counter = %ld\n", shared.counter);</CODE></P>
     <P><CODE>41  Unlink(pathname);</CODE></P>
     <P><CODE>42  exit(0);</CODE></P>
     <P><CODE>43 }</CODE></P>
     <P>15-19 Полное имя создаваемого и используемого для блокировки файла принимается в качестве аргумента командной строки. Это позволяет измерять скорость работы для разных файловых систем. Можно ожидать, что программа будет работать гораздо медленнее при использовании NFS (если она вообще будет работать, то есть если сервер и клиент NFS поддерживают блокировку записей NFS).</P>
    </DIV>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label887 style="border:none;"></a>А.6. Синхронизация процессов: программы</P>
    </H1>
    <DIV class=section>
     <P>В программах предыдущего раздела счетчик использовался несколькими потоками одного процесса. При этом он представлял собой глобальную переменную. Теперь нам нужно изменить эти программы для измерения скорости синхронизации различных процессов.</P>
     <P>Для разделения счетчика между родительским процессом и дочерними мы помещаем его в разделяемую память, выделяемую функцией my_shm, показанной в листинге А.31.</P>
     <H2><a name=label888 style="border:none;"></a>Листинг А.31. Выделение разделяемой памяти под родительский и дочерние процессы</H2>
     <P><CODE>//lib/my_shm.c</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <BR>
     <P><CODE>2  void *</CODE></P>
     <P><CODE>3  my_shm(size_t nbytes)</CODE></P>
     <P><CODE>4  {</CODE></P>
     <P><CODE>5   void *shared;</CODE></P>
     <P><CODE>6  #if defined(MAP_ANON)</CODE></P>
     <P><CODE>7   shared = mmap(NULL, nbytes, PROT_READ | PROT_WRITE,</CODE></P>
     <P><CODE>8   MAP_ANON | MAP_SHARED, –1, 0);</CODE></P>
     <P><CODE>9  #elif defined(HAVE_DEV_ZERO)</CODE></P>
     <P><CODE>10  int fd;</CODE></P>
     <P><CODE>11  /* отображение в память файла /dev/zero */</CODE></P>
     <P><CODE>12  if ((fd = open("/dev/zero", O_RDWR)) == –1)</CODE></P>
     <P><CODE>13   return(MAP_FAILED);</CODE></P>
     <P><CODE>14  shared = mmap(NULL, nbytes, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</CODE></P>
     <P><CODE>15  close(fd);</CODE></P>
     <P><CODE>16 #else</CODE></P>
     <P><CODE>17 # error cannot determine what type of anonymous shared memory to use</CODE></P>
     <P><CODE>18 #endif</CODE></P>
     <P><CODE>19  return(shared); /* ошибка отображения в память */</CODE></P>
     <P><CODE>20 }</CODE></P>
     <P>Если система поддерживает флаг MAP_ANON (раздел 12.4), мы используем этот тип разделяемой памяти. В противном случае используется отображение в память файла /dev/zero (раздел 12.5).</P>
     <P>Последующие изменения зависят от средства синхронизации и от того, что происходит с лежащим в основе этого средства типом данных при вызове fork. Детали описаны в разделе 10.12.</P>
     <P>■ Взаимное исключение Posix: должно храниться в разделяемой памяти (вместе со счетчиком) и инициализироваться с установленным атрибутом PTHREAD_ PROCESS_SHARED. Код программы будет приведен ниже.</P>
     <P>■ Блокировка чтения-записи Posix: должна храниться в разделяемой памяти (вместе со счетчиком) и инициализироваться с установленным атрибутом PTHREAD_PROCESS_SHARED.</P>
     <P>■ Семафоры Posix, размещаемые в памяти: семафор должен храниться в разделяемой памяти (вместе со счетчиком), и вторым аргументом при вызове sem_init должна быть единица (указывающая на то, что семафор используется несколькими процессами).</P>
     <P>■ Именованные семафоры Posix: следует либо вызывать sem_open из родительского и дочерних процессов по отдельности, либо вызывать sem_open в родительском процессе, учитывая, что семафор станет общим после вызова fork.</P>
     <P>■ Семафоры System V: никакого специального кодирования не требуется, поскольку эти семафоры всегда могут использоваться как процессами, так и потоками. Дочерним процессам достаточно знать идентификатор семафора.</P>
     <P>■ Блокировка записей fcntl: изначально предназначена для использования несколькими процессами.</P>
     <P>Мы приведем код только для программы с взаимными исключениями Posix.</P>
    </DIV>
    <DIV class=section>
     <H1>
      <P><a name=label889 style="border:none;"></a>Взаимные исключения Posix между процессами</P>
     </H1>
     <P>Функция main первой программы использует взаимное исключение Posix для обеспечения синхронизации. Текст ее приведен в листинге А.32.</P>
     <H2><a name=label890 style="border:none;"></a>Листинг А.32. Функция main для измерения быстродействия взаимных исключений между процессами</H2>
     <P><CODE>//bench/incr_pmutex5.с</CODE></P>
     <P><CODE>1  #include "unpipc.h"</CODE></P>
     <P><CODE>2  #define MAXNPROC 100</CODE></P>
     <BR>
     <P><CODE>3  int nloop;</CODE></P>
     <P><CODE>4  struct shared {</CODE></P>
     <P><CODE>5   pthread_mutex_t mutex;</CODE></P>
     <P><CODE>6   long counter;</CODE></P>
     <P><CODE>7  } *shared; /* указатель, сама структура в общей памяти */</CODE></P>
     <P><CODE>8  void *incr(void *);</CODE></P>
     <BR>
     <P><CODE>9  int</CODE></P>
     <P><CODE>10 main(int argc, char **argv)</CODE></P>
     <P><CODE>11 {</CODE></P>
     <P><CODE>12  int i, nprocs;</CODE></P>
     <P><CODE>13  pid_t childpid[MAXNPROC];</CODE></P>
     <P><CODE>14  pthread_mutexattr_t mattr;</CODE></P>
     <P><CODE>15  if (argc != 3)</CODE></P>
     <P><CODE>16   err_quit("usage: incr_pxmutex5 &lt;#loops&gt; &lt;#processes&gt;");</CODE></P>
     <P><CODE>17  nloop = atoi(argv[l]);</CODE></P>
     <P><CODE>18  nprocs = min(atoi(argv[2]), MAXNPROC);</CODE></P>
     <P><CODE>19  /* получение разделяемой памяти для родительского и дочерних процессов */</CODE></P>
     <P><CODE>20  shared = My_shm(sizeof(struct shared));</CODE></P>
     <P><CODE>21  /* инициализация взаимного исключения и его блокировка */</CODE></P>
     <P><CODE>22  Pthread_mutexattr_init(&amp;mattr);</CODE></P>
     <P><CODE>23  Pthread_mutexattr_setpshared(&amp;mattr, PTHREAD_PROCESS_SHARED);</CODE></P>
     <P><CODE>24  Pthread_mutex_init(&amp;shared-&gt;mutex, &amp;mattr);</CODE></P>
     <P><CODE>25  Pthread_mutexattr_destroy(&amp;mattr);</CODE></P>
     <P><CODE>26  Pthread_mutex_lock(&amp;shared-&gt;mutex);</CODE></P>
     <P><CODE>27  /* порождение дочерних процессов */</CODE></P>
     <P><CODE>28  for (i = 0; i &lt; nprocs; i++) {</CODE></P>
     <P><CODE>29   if ((childpid[i] = Fork()) == 0) {</CODE></P>
     <P><CODE>30    incr(NULL);</CODE></P>
     <P><CODE>31    exit(0);</CODE></P>
     <P><CODE>32   }</CODE></P>
     <P><CODE>33  }</CODE></P>
     <P><CODE>34  /* родительский процесс: запуск таймера и разблокирование взаимного исключения */</CODE></P>
     <P><CODE>35  Start_time();</CODE></P>
     <P><CODE>36  Pthread_mutex_unlock(&amp;shared-&gt;mutex);</CODE></P>
     <P><CODE>37  /* ожидание завершения всех дочерних процессов */</CODE></P>
     <P><CODE>38  for (i = 0; i &lt; nprocs; i++) {</CODE></P>
     <P><CODE>39   Waitpid(childpid[i], NULL, 0);</CODE></P>
     <P><CODE>40  }</CODE></P>
     <P><CODE>41  printf("microseconds: %.0f usec\n", Stop_time());</CODE></P>
     <P><CODE>42  if (shared-&gt;counter != nloop * nprocs)</CODE></P>
     <P><CODE>43   printf("error: counter = %ld\n", shared-&gt;counter);</CODE></P>
     <P><CODE>44  exit(0);</CODE></P>
     <P><CODE>45 }</CODE></P>
     <P>19-20 Поскольку мы запускаем несколько процессов, структура shared должна располагаться в разделяемой памяти. Мы вызываем функцию my_shm, текст которой приведен в листинге А.31.</P>
     <P>21-26 Поскольку взаимное исключение помещено в разделяемую память, мы не можем статически инициализировать его, поэтому мы вызываем pthread_mutex_init после установки атрибута PTHREAD_PROCESS_SHARED. Взаимное исключение блокируется.</P>
     <P>27-36 После создания дочерних процессов и запуска таймера блокировка снимается.</P>
     <P>37-43 Родительский процесс ожидает завершения всех дочерних, после чего останавливает таймер.</P>
     <H2><a name=label891 style="border:none;"></a>Листинг А.33. Увеличение счетчика с использованием взаимных исключений между процессами</H2>
     <P><CODE>//bench/incr_pxmutex5.с</CODE></P>
     <P><CODE>46 void *</CODE></P>
     <P><CODE>47 incr(void *arg)</CODE></P>
     <P><CODE>48 {</CODE></P>
     <P><CODE>49  int i;</CODE></P>
     <P><CODE>50  for (i = 0; i &lt; nloop; i++) {</CODE></P>
     <P><CODE>51   Pthread_mutex_lock(&amp;shared-&gt;mutex);</CODE></P>
     <P><CODE>52   shared-&gt;counter++;</CODE></P>
     <P><CODE>53   Pthread_mutex_unlock(&amp;shared-&gt;mutex);</CODE></P>
     <P><CODE>54  }</CODE></P>
     <P><CODE>55  return(NULL);</CODE></P>
     <P><CODE>56 }</CODE></P>
    </DIV>
   </DIV>
  </DIV>
  <DIV class=section>
   <H1>
    <P><a name=label892 style="border:none;"></a>ПРИЛОЖЕНИЕ Б</P>
    <P>Основы многопоточного программирования</P>
   </H1>
   <DIV class=section>
    <H1>
     <P><a name=label893 style="border:none;"></a>Б.1. Введение</P>
    </H1>
    <P>В этом приложении приведены основные функции, используемые для работы с потоками. В традиционной модели Unix процесс, которому нужно, чтобы какое-то действие было выполнено не им самим, порождает дочерний процесс вызовом fork. Большая часть сетевых серверов под Unix написана именно так.</P>
    <P>Хотя эта парадигма хорошо работала на протяжении многих лет, вызов fork обладает некоторыми недостатками:</P>
    <P>■ вызов fork ресурсоемок. Память копируется от родительского процесса к дочернему, копируются все дескрипторы и т. д. Существующие реализации используют метод копирования при записи (copy-on-write), что исключает необходимость копирования адресного пространства родительского процесса, пока оно не понадобится клиенту, но, несмотря на эту оптимизацию, вызов fork остается ресурсоемким;</P>
    <P>■ для передачи информации между родительским и дочерним процессами необходимо использовать одну из форм IPC после вызова fork. Передать информацию дочернему процессу легко: это можно сделать до вызова fork. Однако передать ее обратно может быть достаточно сложно.</P>
    <P>Потоки помогают решить обе проблемы. Часто они называются «облегченными процессами» (lightweight processes), поскольку поток проще, чем процесс. Создание потока может занимать по времени меньше одной десятой создания процесса.</P>
    <P>Все потоки одного процесса совместно используют его глобальные переменные, поэтому им легко обмениваться информацией, но это приводит к необходимости синхронизации. Однако общими становятся не только глобальные переменные. Все потоки одного процесса разделяют:</P>
    <P>■ инструкции процесса;</P>
    <P>■ большую часть данных;</P>
    <P>■ открытые файлы (дескрипторы);</P>
    <P>■ обработчики сигналов и вообще настройки для работы с сигналами;</P>
    <P>■ текущий рабочий каталог;</P>
    <P>■ идентификатор пользователя и группы.</P>
    <P>Однако каждый поток имеет свои собственный:</P>
    <P>■ идентификатор потока;</P>
    <P>■ набор регистров, включая PC и указатель стека;</P>
    <P>■ стек (для локальных переменных и адресов возврата);</P>
    <P>■ errno;</P>
    <P>■ маску сигналов;</P>
    <P>■ приоритет.</P>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label894 style="border:none;"></a>Б.2. Основные функции для работы с потоками: создание и завершение</P>
    </H1>
    <P>В этом разделе мы опишем пять основных функций для работы с потоками.</P>
    <H2><a name=label895 style="border:none;"></a>Функция pthread_create</H2>
    <P>При запуске пpoгрaммы вызовом exec создается единственный поток, называемый начальным потоком, или главным (initial thread). Добавочные потоки создаются вызовом pthread_create:</P>
    <P><CODE>#include &lt;pthread.h&gt;</CODE></P>
    <P><CODE>int pthread_create(pthread_t *<EM>tid,</EM> const pthread_attr_t <EM>*attr,</EM> void <EM>*(*func)</EM> (void *), void <EM>*arg</EM>);</CODE></P>
    <P><CODE>/* Возвращает 0 в случае успешного завершения, положительное значение Еххх – в случае ошибки */</CODE></P>
    <P>Каждый поток процесса обладает собственным идентификатором потока, который имеет тип pthread_t. При успешном создании нового потока его идентификатор возвращается через указатель <EM>tid.</EM></P>
    <P>Каждый поток обладает некоторым количеством атрибутов: приоритетом, начальным размером стека, признаком демона и т. п. При создании потока эти атрибуты могут быть указаны с помощью переменной типа pthread_attr_t, значение которой имеет более высокий приоритет, чем значения по умолчанию. Обычно мы используем значения по умолчанию. При этом аргумент <EM>attr</EM> является нулевым указателем.</P>
    <P>Наконец, при создании потока мы должны указать функцию, которую он будет выполнять, — начальную функцию потока (thread start function). Поток запускается вызовом этой функции и завершается либо явно (вызовом pthread_exit), либо неявно (возвратом из этой функции). Адрес функции указывается в аргументе <EM>func,</EM> и вызывается она с единственным аргументом — указателем <EM>arg.</EM> Если функции нужно передать несколько аргументов, следует упаковать их в структуру и передать ее адрес в качестве единственного аргумента начальной функции.</P>
    <P>Обратите внимание на объявления <EM>func</EM> и <EM>arg.</EM> Функция принимает один аргумент — указатель типа void, и возвращает один аргумент — такой же указатель. Это дает нам возможность передать потоку указатель на что угодно и получить в ответ такой же указатель.</P>
    <P>Функции Posix для работы с потоками обычно возвращают 0 в случае успешного завершения работы и ненулевое значение в случае ошибки. В отличие от большинства системных функций, возвращающих –1 в случае ошибки и устанавливающих значение errno равным коду ошибки, функции Pthread возвращают положительный код ошибки. Например, если pthread_create не сможет создать новый поток из-за превышения системного oгрaничeния на потоки, эта функция вернет значение EAGAIN. Функции Pthread не устанавливают значение переменной errno. Несоответствий при их вызове не возникает, поскольку ни один из кодов ошибок не имеет нулевого значения (&lt;sys/errno.h&gt;).</P>
    <H2><a name=label896 style="border:none;"></a>Функция pthread_join</H2>
    <P>Мы можем ожидать завершения какого-либо процесса, вызвав pthread_join. Сравнивая потоки с процессами Unix, можно сказать, что pthread_create аналогична fork, a pthread_join — waitpid:</P>
    <P><CODE>#include &lt;pthread.h&gt;</CODE></P>
    <P><CODE>int pthread_join(pthread_t <EM>tid,</EM> void <EM>**status</EM>);</CODE></P>
    <P><CODE>/* Возвращает 0 в случае успешного завершения, положительное значение Еххх – в случае ошибки */</CODE></P>
    <P>Мы должны указать идентификатор потока, завершения которого ожидаем. К сожалению, невозможно задать режим ожидания завершения нескольких потоков (аналога waitpid с идентификатором процесса –1 нет).</P>
    <P>Если указатель <EM>status</EM> ненулевой, возвращаемое потоком значение (указатель на объект) сохраняется в ячейке памяти, на которую указывает <EM>status.</EM></P>
    <H2><a name=label897 style="border:none;"></a>Функция pthread_self</H2>
    <P>У каждого потока имеется свой идентификатор, уникальный в пределах данного процесса. Идентификатор возвращается pthread_create и используется при вызове pthread_join. Поток может узнать свой собственный идентификатор вызовом pthread_self:</P>
    <P><CODE>#include &lt;pthread.h&gt;</CODE></P>
    <P><CODE>pthread_t pthread_self(void);</CODE></P>
    <P><CODE>/* Возвращает идентификатор вызвавшего потока */</CODE></P>
    <P>Вызов pthread_self является аналогом getpid для процессов Unix.</P>
    <H2><a name=label898 style="border:none;"></a>Функция pthread_detach</H2>
    <P>Поток может являться как присоединяемым (по умолчанию), так и отсоединенным. При завершении присоединяемого потока его идентификатор и статус завершения сохраняются до тех пор, пока какой-либо другой поток данного процесса не вызовет pthread_join. Отсоединенный поток функционирует аналогично процессу-демону. После его завершения все ресурсы освобождаются. Никакой другой поток не может ожидать его завершения. Если имеется необходимость ожидания одним потоком завершения другого, лучше оставить последний присоединяемым.</P>
    <P>Функция pthread_detach делает данный поток отсоединенным:</P>
    <P><CODE>#include &lt;pthread.h&gt;</CODE></P>
    <P><CODE>int pthread_detach(pthread_t <EM>tid</EM>);</CODE></P>
    <P><CODE>/* Возвращает 0 в случае успешного завершения, положительное значение Еххх в случае ошибки */</CODE></P>
    <P>Эта функция вызывается потоком при необходимости изменить собственный статус в форме</P>
    <P><CODE>pthread_detach(pthread_self());</CODE></P>
    <H2><a name=label899 style="border:none;"></a>Функция pthread_exit</H2>
    <P>Одним из способов завершения потока является вызов pthread_exit:</P>
    <P><CODE>#include &lt;pthread.h&gt;</CODE></P>
    <P><CODE>void pthread_exit(void <EM>*status</EM>);</CODE></P>
    <P><CODE>/* ничего не возвращает вызвавшему потоку */</CODE></P>
    <P>Если поток не является отсоединенным, его идентификатор и статус завершения сохраняются для возвращения другому потоку, который может вызвать pthread_join.</P>
    <P>Указатель <EM>status</EM> не должен быть установлен на локальный объект вызвавшего потока (типа автоматической переменной), поскольку этот объект уничтожается при завершении потока.</P>
    <P>Поток может быть завершен двумя другими способами:</P>
    <P>■ начальная функция потока (третий аргумент pthread_create) может вызвать return. Поскольку эта функция должна объявляться как возвращающая указатель на тип void, это возвращаемое значение становится статусом завершения потока;</P>
    <P>■ функция main процесса может завершить работу или один из потоков может вызвать exit или _exit. При этом процесс завершает работу немедленно, вместе со всеми своими потоками.</P>
   </DIV>
  </DIV>
  <DIV class=section>
   <H1>
    <P><a name=label900 style="border:none;"></a>ПРИЛОЖЕНИЕ В</P>
    <P>Вспомогательные исходные коды</P>
   </H1>
   <DIV class=section>
    <H1>
     <P><a name=label901 style="border:none;"></a>В.1. Заголовочный файл unpipc.h</P>
    </H1>
    <P>Почти все программы книги подключают заголовочный файл unpipc.h, приведенный в листинге В.1.<A HREF="#n_1" onmouseover="ShowBookNote('n_1')" onmouseout="HideBookNote('n_1')"><SUP>[1]</SUP></A> Он подключает все стандартные системные заголовки, нужные большинству пpoгрaмм для работы с сетью, вместе с некоторыми общими системными заголовками. Он также определяет константы типа MAXLINE и прототипы функций ANSI С для функций, определенных в тексте (типа px_ipc_name), и для всех используемых в книге оберток. Мы не приводим эти прототипы.</P>
    <H2><a name=label902 style="border:none;"></a>Листинг В.1. Заголовочный файл unpipc.h</H2>
    <P><CODE>//lib/unpipc.h</CODE></P>
    <P><CODE>1   /* Наш заголовочный файл. */</CODE></P>
    <P><CODE>2   #ifndef __unpipc_h</CODE></P>
    <P><CODE>3   #define __unpipc_h</CODE></P>
    <BR>
    <P><CODE>4   #include "../config.h" /* параметры конфигурации ОС */</CODE></P>
    <P><CODE>5   /* "../config.h" создается сценарием configure */</CODE></P>
    <BR>
    <P><CODE>6   /* изменяя список директив #include, нужно изменять файлы</CODE></P>
    <P><CODE>7    ../aclocal.m4 и ../configure.in. чтобы работал сценарий configure */</CODE></P>
    <P><CODE>8   #include &lt;sys/types.h&gt; /* базовые типы данных */</CODE></P>
    <P><CODE>9   #include &lt;sys/time.h&gt; /* структура timeval{} для select() */</CODE></P>
    <BR>
    <P><CODE>10  #include &lt;time.h&gt; /* timespec{} для pselect() */</CODE></P>
    <P><CODE>11  #include &lt;errno.h&gt;</CODE></P>
    <P><CODE>12  #include &lt;fcntl.h&gt; /* отключение блокировки */</CODE></P>
    <P><CODE>13  #include &lt;limits.h&gt; /* PIPE_BUF */</CODE></P>
    <P><CODE>14  #include &lt;signal.h&gt;</CODE></P>
    <P><CODE>15  #include &lt;stdio.h&gt;</CODE></P>
    <P><CODE>16  #include &lt;stdlib.h&gt;</CODE></P>
    <P><CODE>17  #include &lt;string.h&gt;</CODE></P>
    <P><CODE>18  #include &lt;sys/stat.h&gt; /* константы режима доступа к файлу S_xxx */</CODE></P>
    <P><CODE>19  #include &lt;unistd.h&gt;</CODE></P>
    <P><CODE>20  #include &lt;sys/wait.h&gt;</CODE></P>
    <BR>
    <P><CODE>21  #ifdef HAVE_MQUEUE_H</CODE></P>
    <P><CODE>22  #include &lt;mqueue.h&gt; /* очереди сообщений Posix */</CODE></P>
    <P><CODE>23  #endif</CODE></P>
    <BR>
    <P><CODE>24  #ifdef HAVE_SEMAPHORE_H</CODE></P>
    <P><CODE>25  #include &lt;semaphore.h&gt; /* семафоры Posix */</CODE></P>
    <P><CODE>26  #ifndef SEM_FAILED</CODE></P>
    <P><CODE>27  #define SEM_FAILED ((sem_t *)(-1))</CODE></P>
    <P><CODE>28  #endif</CODE></P>
    <P><CODE>29  #endif</CODE></P>
    <BR>
    <P><CODE>30  #ifdef HAVE_SYS_MMAN_H</CODE></P>
    <P><CODE>31  #include &lt;sys/mman.h&gt; /* разделяемая память Posix */</CODE></P>
    <P><CODE>32  #endif</CODE></P>
    <BR>
    <P><CODE>33  #ifndef MAP_FAILED</CODE></P>
    <P><CODE>34  #define MAP_FAILED ((void *)(-1))</CODE></P>
    <P><CODE>35  #endif</CODE></P>
    <BR>
    <P><CODE>36  #ifdef HAVE_SYS_IPC_H</CODE></P>
    <P><CODE>37  #include &lt;sys/ipc.h&gt; /* System V IPC */</CODE></P>
    <P><CODE>38  #endif</CODE></P>
    <BR>
    <P><CODE>39  #ifdef HAVE_SYS_MSG_H</CODE></P>
    <P><CODE>40  #include &lt;sys/msg.h&gt; /* очереди сообщений System V */</CODE></P>
    <P><CODE>41  #endif</CODE></P>
    <BR>
    <P><CODE>42  #ifdef HAVE_SYS_SEM_H</CODE></P>
    <P><CODE>43  #ifdef __bsdi__</CODE></P>
    <P><CODE>44  #undef HAVE_SYS_SEM_H /* тонкий момент: прототип semctl() в BSDI's содержит ошибки*/</CODE></P>
    <P><CODE>45  #else</CODE></P>
    <P><CODE>46  #include &lt;sys/sem.h&gt; /* семафоры System V */</CODE></P>
    <P><CODE>47  #endif</CODE></P>
    <P><CODE>48  #ifndef HAVE_SEMUN_UNION /* $$.It semun$$ */</CODE></P>
    <P><CODE>49  union semun { /* определение объединения для semctl() */</CODE></P>
    <P><CODE>50   int val;</CODE></P>
    <P><CODE>51   struct semid_ds *buf;</CODE></P>
    <P><CODE>52   unsigned short *array;</CODE></P>
    <P><CODE>53  };</CODE></P>
    <P><CODE>54  #endif</CODE></P>
    <P><CODE>55  #endif /* HAVE_SYS_SEM_H */</CODE></P>
    <BR>
    <P><CODE>56  #ifdef HAVE_SYS_SHM_H</CODE></P>
    <P><CODE>57  #include &lt;sys/shm.h&gt; /* разделяемая память System V */</CODE></P>
    <P><CODE>58  #endif</CODE></P>
    <BR>
    <P><CODE>59  #ifdef HAVE_SYS_SELECT_H</CODE></P>
    <P><CODE>60  #include &lt;sys/select.h&gt; /* для удобства */</CODE></P>
    <P><CODE>61  #endif</CODE></P>
    <BR>
    <P><CODE>62  #ifdef HAVE_POLL_H</CODE></P>
    <P><CODE>63  #include &lt;poll.h&gt; /* для удобства */</CODE></P>
    <P><CODE>64  #endif</CODE></P>
    <BR>
    <P><CODE>65  #ifdef HAVE_STROPTS_H</CODE></P>
    <P><CODE>66  #include &lt;stropts.h&gt; /* для удобства */</CODE></P>
    <P><CODE>67  #endif</CODE></P>
    <BR>
    <P><CODE>68  #ifdef HAVE_STRINGS_H</CODE></P>
    <P><CODE>69  #include &lt;strings.h&gt; /* для удобства */</CODE></P>
    <P><CODE>70  #endif</CODE></P>
    <BR>
    <P><CODE>71  /* Следующие три заголовочных файла нужны для ioctl файлов и сокетов:</CODE></P>
    <P><CODE>72   * &lt;sys/ioctl.h&gt;, &lt;sys/filio.h&gt;, и &lt;sys/sockio.h&gt;.</CODE></P>
    <P><CODE>73   */</CODE></P>
    <P><CODE>74  #ifdef HAVE_SYS_IOCTL_H</CODE></P>
    <P><CODE>75  #include &lt;sys/ioctl.h&gt;</CODE></P>
    <P><CODE>76  #endif</CODE></P>
    <P><CODE>77  #ifdef HAVE_SYS_FILIO_H</CODE></P>
    <P><CODE>78  #include &lt;sys/filio.h&gt;</CODE></P>
    <P><CODE>79  #endif</CODE></P>
    <BR>
    <P><CODE>80  #ifdef HAVE_PTHREAD_H</CODE></P>
    <P><CODE>81  #include &lt;pthread.h&gt;</CODE></P>
    <P><CODE>82  #endif</CODE></P>
    <P><CODE>83  #ifdef HAVE_DOOR_H</CODE></P>
    <P><CODE>84  #include &lt;door.h&gt; /* интерфейс дверей Solaris */</CODE></P>
    <P><CODE>85  #endif</CODE></P>
    <P><CODE>86  #ifdef HAVE_RPC_RPC_H</CODE></P>
    <P><CODE>87  #ifdef _PSX4_NSPACE_H_TS /* баги Digital Unix 4.0b */</CODE></P>
    <P><CODE>88  #undef SUCCESS</CODE></P>
    <P><CODE>89  #endif</CODE></P>
    <P><CODE>90  #include &lt;rpc/rpc.h&gt; /* Sun RPC */</CODE></P>
    <P><CODE>91  #endif</CODE></P>
    <BR>
    <P><CODE>92  /* Определяем bzero() как макрос, если его нет в стандартной библиотеке С */</CODE></P>
    <P><CODE>93  #ifndef HAVE_BZERO</CODE></P>
    <P><CODE>94  #define bzero(ptr,n) memset(ptr, 0, n)</CODE></P>
    <P><CODE>95  #endif</CODE></P>
    <BR>
    <P><CODE>96  /* Posix.1g требует, чтобы INFTIM определялось в &lt;poll.h&gt;. но во многих системах эта</CODE></P>
    <P><CODE>97     константа все еще определяется в &lt;sys/stropts.h&gt;. Нам не нужно подключать все</CODE></P>
    <P><CODE>98     функции для работы с потоками, поэтому мы определяем INFTM здесь. Это стандартное</CODE></P>
    <P><CODE>99     значение, но нет гарантий, что оно равно –1 */</CODE></P>
    <P><CODE>100 #ifndef INFTIM</CODE></P>
    <P><CODE>101 #define INFTIM (-1) /* неограниченное время опроса */</CODE></P>
    <P><CODE>102 #ifdef HAVE_POLL_H</CODE></P>
    <P><CODE>103 #define INFTIM_UNPH /* чтобы из файла unpxti.h узнать, что константа определена */</CODE></P>
    <P><CODE>104 #endif</CODE></P>
    <P><CODE>105 #endif</CODE></P>
    <BR>
    <P><CODE>106 /* Прочие константы */</CODE></P>
    <P><CODE>107 #ifndef РАТН_МАХ /* должна быть в &lt;limits.h&gt; */</CODE></P>
    <P><CODE>108 #define PATH_MAX 1024 /* максимальное количество символов в полном имени файла */</CODE></P>
    <P><CODE>109 #endif</CODE></P>
    <P><CODE>110 #define MAX_PATH 1024</CODE></P>
    <P><CODE>111 #define MAXLINE 4096 /* максимальная длина строки */</CODE></P>
    <P><CODE>112 #define BUFFSI2E 8192 /* объем буфера чтения и записи */</CODE></P>
    <P><CODE>113 #define FILE_MODE (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)</CODE></P>
    <P><CODE>114  /* разрешения по умолчанию для новых файлов */</CODE></P>
    <P><CODE>115 #define DIR_MODE (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)</CODE></P>
    <P><CODE>116  /* разрешения по умолчанию для новых каталогов */</CODE></P>
    <P><CODE>117 #define SVMSG_MODE (MSG_R | MSG_W | MSG_R&gt;&gt;3 | MSG_R&gt;&gt;6)</CODE></P>
    <P><CODE>118  /* разрешения по умолчанию для новых очередей сообщений System V */</CODE></P>
    <P><CODE>119 #define SVSEM_MODE (SEM_R | SEM_A | SEM_R&gt;&gt;3 | SEM_R&gt;&gt;6)</CODE></P>
    <P><CODE>120  /* разрешения по умолчанию для новых семафоров System V */</CODE></P>
    <P><CODE>121 #define SVSHM_MODE (SHM_R | SHM_W | SHM_R&gt;&gt;3 | SHM_R&gt;&gt;6)</CODE></P>
    <P><CODE>122  /* разрешения по умолчанию для новой разделяемой памяти System V */</CODE></P>
    <BR>
    <P><CODE>123 typedef void Sigfunc(int); /* для обработчиков сигналов */</CODE></P>
    <P><CODE>124 #ifdef HAVE_SIGINFO_T_STRUCT</CODE></P>
    <P><CODE>125 typedef void Sigfunc_rt(int, siginfo_t*, void*);</CODE></P>
    <P><CODE>126 #endif</CODE></P>
    <BR>
    <P><CODE>127 #define min(a,b) ((a) &lt; (b) ? (a) : (b))</CODE></P>
    <P><CODE>128 #define max(a,b) ((a) &gt; (b) ? (a) : (b))</CODE></P>
    <P><CODE>129 #ifndef HAVE_TIMESPEC_STRUCT</CODE></P>
    <P><CODE>130 struct timespec {</CODE></P>
    <P><CODE>131  time_t tv_sec; /* секунды */</CODE></P>
    <P><CODE>132  long tv_nsec; /* и наносекунды */</CODE></P>
    <P><CODE>133 };</CODE></P>
    <P><CODE>134 #endif</CODE></P>
    <BR>
    <P><CODE>135 /*</CODE></P>
    <P><CODE>136 В функциях-обертках open(), mq_open(), sem_open() мы обрабатываем</CODE></P>
    <P><CODE>137 дополнительные аргументы с помощью макросов va_XXX().</CODE></P>
    <P><CODE>138 Один из аргументов имеет тип mode_t, что приводит</CODE></P>
    <P><CODE>139 к ошибке в BSD/OS, где для этого типа используются</CODE></P>
    <P><CODE>140 16-разрядные целые. При вызове обертки</CODE></P>
    <P><CODE>141 компилятор преобразовывает 16-разрядное целое</CODE></P>
    <P><CODE>142 в 32-разрядное. Поэтому и необходимо то.</CODE></P>
    <P><CODE>143 что сделано ниже.</CODE></P>
    <P><CODE>144 */</CODE></P>
    <P><CODE>145 #ifdef __bsdi__</CODE></P>
    <P><CODE>146 #define va_mode_t int</CODE></P>
    <P><CODE>147 #else</CODE></P>
    <P><CODE>148 #define va_mode_t mode_t</CODE></P>
    <P><CODE>149 #endif</CODE></P>
    <BR>
    <P><CODE>150 /* макросы блокировки записей */</CODE></P>
    <P><CODE>151 #define read_lock(fd, offset, whence, len) \</CODE></P>
    <P><CODE>152  lock_reg(fd, F_SETLK, F_RDLCK, offset, whence, len)</CODE></P>
    <P><CODE>153 #define readw_lock(fd, offset, whence, len) \</CODE></P>
    <P><CODE>154  lock_reg(fd, F_SETLKW, F_RDLCK, offset, whence, len)</CODE></P>
    <P><CODE>155 #define write_lock(fd, offset, whence, len) \</CODE></P>
    <P><CODE>156  lock_reg(fd, F_SETLK, F_WRLCK, offset, whence, len)</CODE></P>
    <P><CODE>157 #define writew_lock(fd, offset, whence, len) \</CODE></P>
    <P><CODE>158  lock_reg(fd, F_SETLKW, F_WRLCK, offset, whence, len)</CODE></P>
    <P><CODE>159 #define un_lock(fd, offset, whence, len) \</CODE></P>
    <P><CODE>160  lock_reg(fd, F_SETLK, F_UNLCK, offset, whence, len)</CODE></P>
    <P><CODE>161 #define is_read_lockable(fd, offset, whence, len) \</CODE></P>
    <P><CODE>162  lock_test(fd, F_RDLCK, offset, whence, len)</CODE></P>
    <P><CODE>163 #define is_write_lockable(fd, offset, whence, len) \</CODE></P>
    <P><CODE>164  lock_test(fd. F_WRLCK, offset, whence, len)</CODE></P>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label903 style="border:none;"></a>B.2. Заголовочный файл config.h</P>
    </H1>
    <P>Для подготовки пpoгрaмм в этой книге использовалась утилита GNU autoconf, которая помогает сделать их более переносимыми. Она доступна по адресу ftp://prep.ai.mit.edu/pub/gnu. Утилита создает сценарий configure, который следует запустить после того, как вы зaгрyзитe пpoгрaммy из Сети. Этот сценарий определяет возможности вашей системы: поддерживаются ли очереди System V, определен ли тип uint8_t, определена ли функция gethostname и т. д. В процессе работы он создает заголовочный файл config.h, который включается нашим unpipc.h перед всеми остальными. В листинге В.2 приведен пример заголовочного файла config.h для системы Solaris 2.6 и компилятора gcc.</P>
    <P>Строки, начинающиеся с #define, описывают функции, поддерживаемые в системе. Закомментированные строки соответствуют неподдерживаемым функциям.</P>
    <H2><a name=label904 style="border:none;"></a>Листинг В.2. Заголовочный файл config.h для Solaris 2.6</H2>
    <P><CODE>//sparc-sun-solaris2.6/config.h</CODE></P>
    <P><CODE>1  /* config.h. Автоматически создается сценарием configure. */</CODE></P>
    <P><CODE>2  /* Константы следует указывать только тогда, когда есть соответствующий заголовочный файл */</CODE></P>
    <P><CODE>3  #define CPU_VENDOR_OS "sparc-sun-solaris2.6"</CODE></P>
    <P><CODE>4  #define HAVE_DOOR_H 1 /* &lt;door.h&gt; */</CODE></P>
    <P><CODE>5  #define HAVE_MQUEUE_H 1 /* &lt;mqueue.h&gt; */</CODE></P>
    <P><CODE>6  #define HAVE_POLL_H 1 /*&lt;poll.h&gt;*/</CODE></P>
    <P><CODE>7  #define HAVE_PTHREAD_H 1 /* &lt;pthread.h&gt; */</CODE></P>
    <P><CODE>8  #define HAVE_RPC_RPC_H 1 /* &lt;rpc/rpc.h&gt; */</CODE></P>
    <P><CODE>9  #define HAVE_SEMAPHORE_H 1 /* semaphore.h&gt; */</CODE></P>
    <P><CODE>10 #define HAVE_STRINGS_H 1 /* &lt;strings.h&gt; */</CODE></P>
    <P><CODE>11 #define HAVE_SYS_FILIO_H 1 /* &lt;sys/filio.h&gt; */</CODE></P>
    <P><CODE>12 #define HAVE_SYS_IOCTL_H 1 /* &lt;sys/ioctl.h&gt; */</CODE></P>
    <P><CODE>13 #define HAVE_SYS_IPC_H 1 /* &lt;sys/ipc.h&gt; */</CODE></P>
    <P><CODE>14 #define HAVE_SYS_MMAN_H 1 /* &lt;sys/mman.h&gt; */</CODE></P>
    <P><CODE>15 #define HAVE_SYS_MSG_H 1 /* &lt;sys/msg.h&gt; */</CODE></P>
    <P><CODE>16 #define HAVE_SYS_SEM_H 1 /* &lt;sys/sem.h&gt; */</CODE></P>
    <P><CODE>17 #define HAVE_SYS_SHM_H 1 /* &lt;sys/shm.h&gt; */</CODE></P>
    <P><CODE>18 #define HAVE_SYS_SELECT_H 1 /* &lt;sys/select.h&gt; */</CODE></P>
    <P><CODE>19 /* #undef HAVE_SYS_SYSCTL_H */ /* &lt;sys/sysctl.h&gt; */</CODE></P>
    <P><CODE>20 #define HAVE_SYS_TIME_H 1 /* &lt;sys/time.h&gt; */</CODE></P>
    <BR>
    <P><CODE>21 /* Определена, если можно подключить &lt;time.h&gt; вместе с &lt;sys/time.h&gt; */</CODE></P>
    <P><CODE>22 #define TIME_WITH_SYS_TIME 1</CODE></P>
    <BR>
    <P><CODE>23 /* Определены, если имеются соответствующие функции */</CODE></P>
    <P><CODE>24 #define HAVE_BZERO 1</CODE></P>
    <P><CODE>25 #define HAVE_FATTACH 1</CODE></P>
    <P><CODE>26 #define HAVE_POLL 1</CODE></P>
    <P><CODE>27 /* #undef HAVE_PSELECT */</CODE></P>
    <P><CODE>28 #define HAVE_SIGWAIT 1</CODE></P>
    <P><CODE>29 #define HAVE_VALLOC 1</CODE></P>
    <P><CODE>30 #define HAVE_VSNPRINTF 1</CODE></P>
    <BR>
    <P><CODE>31 /* Определены, если прототипы функций есть в заголовках */</CODE></P>
    <P><CODE>32 #define HAVE_GETHOSTNAME_PROTO 1 /* &lt;unistd.h&gt; */</CODE></P>
    <P><CODE>33 #define HAVE_GETRUSAGE_PROTO 1 /* &lt;sys/resource.h&gt; */</CODE></P>
    <P><CODE>34 /* #undef HAVE_PSELECT_PROTO */ /* &lt;sys/select.h&gt; */</CODE></P>
    <P><CODE>35 #define HAVE SHM_OPEN_PROTO 1 /* &lt;sys/mman.h&gt; */</CODE></P>
    <P><CODE>36 #define HAVE_SNPRINTF_PROTO 1 /* &lt;stdio.h&gt; */</CODE></P>
    <P><CODE>37 #define HAVE_THR_SETCONCURRENCY_PROTO 1 /* &lt;thread.h&gt; */</CODE></P>
    <BR>
    <P><CODE>38 /* Определены, если определены соответствующие структуры */</CODE></P>
    <P><CODE>39 #define HAVE_SIGINFO_T_STRUCT 1 /* &lt;signal.h&gt; */</CODE></P>
    <P><CODE>40 #define HAVE_TIMESPEC_STRUCT 1 /* &lt;time.h&gt; */</CODE></P>
    <P><CODE>41 /* #undef HAVE_SEMUN_UNION */ /* &lt;sys/sem.h&gt; */</CODE></P>
    <BR>
    <P><CODE>42 /* Устройства */</CODE></P>
    <P><CODE>43 #define HAVE_DEV_ZERO 1</CODE></P>
    <BR>
    <P><CODE>44 /* Для соответствующих типов данных */</CODE></P>
    <P><CODE>45 /* #undef int8_t */ /* &lt;sys/types.h&gt; */</CODE></P>
    <P><CODE>46 /* #undef intl6_t */ /* &lt;sys/types.h&gt; */</CODE></P>
    <P><CODE>47 /* #undef int32_t */ /* &lt;sys/types.h&gt; */</CODE></P>
    <P><CODE>48 /* #undef uint8_t */ /* &lt;sys/types.h&gt; */</CODE></P>
    <P><CODE>49 /* #undef uintl6_t */ /* &lt;sys/types.h&gt; */</CODE></P>
    <P><CODE>50 /* #undef uint32_t */ /* &lt;sys/types.n&gt; */</CODE></P>
    <P><CODE>51 /* #undef size_t */ /* &lt;sys/types.h&gt; */</CODE></P>
    <P><CODE>52 /* #undef ssize_t */ /* &lt;sys/types.h&gt; */</CODE></P>
    <BR>
    <P><CODE>53 #define POSIX_IPC_PREFIX "/"</CODE></P>
    <P><CODE>54 #define RPCGEN_ANSIC 1 /* определена, если rpcgen поддерживает параметр –С */</CODE></P>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label905 style="border:none;"></a>В.З. Стандартные функции вывода сообщений об ошибках</P>
    </H1>
    <P>Мы определили свой набор функций, используемых во всех программах книги для обработки ситуаций с возникновением ошибок. Причина, по которой мы создаем эти функции, заключается в том, что теперь мы можем писать команды в одну строку:</P>
    <P><CODE>if (условие_ошибки) err_sys(формат printf с произвольным количеством аргументов);</CODE></P>
    <P>вместо:</P>
    <P><CODE>if (условие_ошибки) {</CODE></P>
    <P><CODE> char buff[200];</CODE></P>
    <P><CODE> snprintf(buff, sizeof(buff), формат printf с произвольным количеством аргументов);</CODE></P>
    <P><CODE> perror(buff);</CODE></P>
    <P><CODE> exit(1);</CODE></P>
    <P><CODE>}</CODE></P>
    <P>Функции обработки ошибок используют возможности работы со списком аргументов переменной длины, определенные стандартом ANSI С. В разделе 7.3 [ 11 ] вы можете узнать подробности.</P>
    <P>В таблице В.1 приведены отличия между различными функциями обработки ошибок. Если глобальное целое daemon_proc отлично от нуля, сообщение передается демону syslog с указанным уровнем (см. главу 12 [24]); в противном случае сообщение выводится в стандартный поток сообщений об ошибках.</P>
    <BR>
    <P>Таблица В.1. Функции обработки ошибок</P>
    <TABLE>
     <TR ALIGN=left >
      <TH ALIGN=left VALIGN=top >Функция</TH>
      <TH ALIGN=left VALIGN=top >strerror(errno)?</TH>
      <TH ALIGN=left VALIGN=top >Завершение?</TH>
      <TH ALIGN=left VALIGN=top >Уровень syslog</TH>
     </TR>
     <TR ALIGN=left >
      <TD ALIGN=left VALIGN=top >err_dump</TD>
      <TD ALIGN=left VALIGN=top >Да</TD>
      <TD ALIGN=left VALIGN=top >abort();</TD>
      <TD ALIGN=left VALIGN=top >LOG_ERR</TD>
     </TR>
     <TR ALIGN=left >
      <TD ALIGN=left VALIGN=top >err_msg</TD>
      <TD ALIGN=left VALIGN=top >Нет</TD>
      <TD ALIGN=left VALIGN=top >return;</TD>
      <TD ALIGN=left VALIGN=top >LOG_INFO</TD>
     </TR>
     <TR ALIGN=left >
      <TD ALIGN=left VALIGN=top >err_quit</TD>
      <TD ALIGN=left VALIGN=top >Нет</TD>
      <TD ALIGN=left VALIGN=top >exit(1);</TD>
      <TD ALIGN=left VALIGN=top >LOG_ERR</TD>
     </TR>
     <TR ALIGN=left >
      <TD ALIGN=left VALIGN=top >err_ret</TD>
      <TD ALIGN=left VALIGN=top >Да</TD>
      <TD ALIGN=left VALIGN=top >return;</TD>
      <TD ALIGN=left VALIGN=top >LOG_INFO</TD>
     </TR>
     <TR ALIGN=left >
      <TD ALIGN=left VALIGN=top >err_sys</TD>
      <TD ALIGN=left VALIGN=top >Да</TD>
      <TD ALIGN=left VALIGN=top >exit(1);</TD>
      <TD ALIGN=left VALIGN=top >LOG_ERR</TD>
     </TR>
    </TABLE>
    <P>В листинге В.3 приведен текст функций из табл. В.1.</P>
    <H2><a name=label906 style="border:none;"></a>Листинг В.3. Функции обработки ошибок</H2>
    <P><CODE>//lib/error.с</CODE></P>
    <P><CODE>1  #include "unpipc.h"</CODE></P>
    <P><CODE>2  #include &lt;stdarg.h&gt; /* заголовочный файл ANSI С */</CODE></P>
    <P><CODE>3  #include &lt;syslog.h&gt; /* для демона syslog() */</CODE></P>
    <BR>
    <P><CODE>4  int daemon_proc; /* устанавливается отличным от нуля daemon_init() */</CODE></P>
    <P><CODE>5  static void err_doit(int, int, const char*, va_list);</CODE></P>
    <BR>
    <P><CODE>6  /* Нефатальная ошибка при системном вызове.</CODE></P>
    <P><CODE>7   * Вывод сообщения и возврат из функции. */</CODE></P>
    <P><CODE>8  void</CODE></P>
    <P><CODE>9  err_ret(const char *fmt, ...)</CODE></P>
    <P><CODE>10 {</CODE></P>
    <P><CODE>11  va_list ар;</CODE></P>
    <P><CODE>12  va_start(ap, fmt);</CODE></P>
    <P><CODE>13  err_doit(1, LOG_INFO, fmt, ap);</CODE></P>
    <P><CODE>14  va_end(ap);</CODE></P>
    <P><CODE>15  return;</CODE></P>
    <P><CODE>16 }</CODE></P>
    <BR>
    <P><CODE>17 /* Фатальная ошибка при системном вызове.</CODE></P>
    <P><CODE>18  * Вывод сообщения и завершение работы. */</CODE></P>
    <P><CODE>19 void</CODE></P>
    <P><CODE>20 err_sys(const char *fmt, ...)</CODE></P>
    <P><CODE>21 {</CODE></P>
    <P><CODE>22  va_list ap;</CODE></P>
    <P><CODE>23  va_start(ap, fmt);</CODE></P>
    <P><CODE>24  err_doit(1, LOG_ERR, fmt, ар);</CODE></P>
    <P><CODE>25  va_end(ap);</CODE></P>
    <P><CODE>26  exit(1);</CODE></P>
    <P><CODE>27 }</CODE></P>
    <BR>
    <P><CODE>28 /* Фатальная ошибка при системном вызове.</CODE></P>
    <P><CODE>29  * Вывод сообщения, сохранение дампа памяти, завершение работы. */</CODE></P>
    <P><CODE>30 void</CODE></P>
    <P><CODE>31 err_dump(const char *fmt, ...)</CODE></P>
    <P><CODE>32 {</CODE></P>
    <P><CODE>33  va_list ар;</CODE></P>
    <P><CODE>34  va_start(ap, fmt);</CODE></P>
    <P><CODE>35  err_doit(1, LOG_ERR, fmt, ap);</CODE></P>
    <P><CODE>36  va_end(ap);</CODE></P>
    <P><CODE>37  abort(); /* сохранение дампа и завершение */</CODE></P>
    <P><CODE>38  exit(1); /* досюда не должно дойти */</CODE></P>
    <P><CODE>39 }</CODE></P>
    <BR>
    <P><CODE>40 /* Нефатальная ошибка не при системном вызове.</CODE></P>
    <P><CODE>41  * Вывод сообщения и возврат. */</CODE></P>
    <P><CODE>42 void</CODE></P>
    <P><CODE>43 err_msg(const char *fmt, ...)</CODE></P>
    <P><CODE>44 {</CODE></P>
    <P><CODE>45  va_list ap;</CODE></P>
    <P><CODE>46  va_start(ap, fmt);</CODE></P>
    <P><CODE>47  err_doit(0, LOG_INFO, fmt, ap);</CODE></P>
    <P><CODE>48  va_end(ap);</CODE></P>
    <P><CODE>49  return;</CODE></P>
    <P><CODE>50 }</CODE></P>
    <BR>
    <P><CODE>51 /* Фатальная ошибка не при системном вызове.</CODE></P>
    <P><CODE>52  * Вывод сообщения и возврат. */</CODE></P>
    <P><CODE>53 void</CODE></P>
    <P><CODE>54 err_quit(const char *fmt, ...)</CODE></P>
    <P><CODE>55 {</CODE></P>
    <P><CODE>56  va_list ap;</CODE></P>
    <P><CODE>57  va_start(ap, fmt);</CODE></P>
    <P><CODE>58  err_doit(0, LOG_ERR, fmt, ap);</CODE></P>
    <P><CODE>59  va_end(ap);</CODE></P>
    <P><CODE>60  exit(1);</CODE></P>
    <P><CODE>61 }</CODE></P>
    <BR>
    <P><CODE>62 /* Вывод сообщения и возврат.</CODE></P>
    <P><CODE>63  * Вызывающий указывает "errnoflag" и "level". */</CODE></P>
    <P><CODE>64 static void</CODE></P>
    <P><CODE>65 err_doit(int errnoflag, int level, const char *fmt, va_list ap)</CODE></P>
    <P><CODE>66 {</CODE></P>
    <P><CODE>67  int errno_save, n;</CODE></P>
    <P><CODE>68  char buf[MAXLINE];</CODE></P>
    <P><CODE>69  errno_save = errno; /* значение может понадобиться вызвавшему */</CODE></P>
    <P><CODE>70 #ifdef HAVE_VSNPRINTF</CODE></P>
    <P><CODE>71  vsnprintf(buf, sizeof(buf), fmt, ар); /* защищенный вариант */</CODE></P>
    <P><CODE>72 #else</CODE></P>
    <P><CODE>73  vsprintf(buf, fmt, ар); /* незащищенный вариант <EM>*/</EM></CODE></P>
    <P><CODE>74 #endif</CODE></P>
    <P><CODE>75  n = strlen(buf);</CODE></P>
    <P><CODE>76  if (errnoflag)</CODE></P>
    <P><CODE>77   snprintf(buf+n, sizeof(buf)-n, ": %s", strerror(errno_save));</CODE></P>
    <P><CODE>78  strcat(buf, "\n");</CODE></P>
    <P><CODE>79  if (daemon_proc) {</CODE></P>
    <P><CODE>80   syslog(level, buf);</CODE></P>
    <P><CODE>81  } else {</CODE></P>
    <P><CODE>82   fflush(stdout); /* если stdout и stderr одинаковы */</CODE></P>
    <P><CODE>83   fputs(buf, stderr);</CODE></P>
    <P><CODE>84   fflush(stderr);</CODE></P>
    <P><CODE>85  }</CODE></P>
    <P><CODE>86  return;</CODE></P>
    <P><CODE>87 }</CODE></P>
   </DIV>
  </DIV>
  <DIV class=section>
   <H1>
    <P><a name=label907 style="border:none;"></a>ПРИЛОЖЕНИЕ Г</P>
    <P>Решения некоторых упражнений</P>
   </H1>
   <DIV class=section>
    <H1>
     <P><a name=label908 style="border:none;"></a>Глава 1</P>
    </H1>
    <P>1. В обоих процессах нужно лишь указать флаг O_APPEND при вызове функции open или режим дополнения файла при вызове fopen. Ядро гарантирует, что данные будут дописываться в конец файла. Это самая простая форма синхронизации доступа к файлу. На с. 60-61 [21] об этом рассказывается более подробно. Синхронизация становится проблемой при обновлении имеющихся в файле данных, как это происходит в базах данных.</P>
    <P>2. Обычно встречается что-нибудь вроде:</P>
    <P><CODE>#ifdef REENTRANT</CODE></P>
    <P><CODE>#define errno (*_errno())</CODE></P>
    <P><CODE>#else</CODE></P>
    <P><CODE>extern int errno;</CODE></P>
    <P><CODE>#endif</CODE></P>
    <P>Если определена константа _REENTRANT, обращение к errno приводит к вызову функции _errno, возвращающей адрес переменной errno вызвавшего потока. Эта переменная, скорее всего, хранится в области собственных данных этого потока (раздел 23.5 [24]). Если константа REENTRANT не определена, переменная errno является глобальной.</P>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label909 style="border:none;"></a>Глава 2</P>
    </H1>
    <P>1. Эти два бита могут менять действующий идентификатор пользователя и/или группы выполняющейся программы. Идентификаторы используются в разделе 2.4.</P>
    <P>2. Сначала следует указать флаги O_CREAT | O_EXCL, и если вызов окажется успешным, будет создан новый объект. Если вызов вернет ошибку EEXIST, объект уже существует и программа должна вызвать open еще раз, без флага O_CREAT или O_EXCL Второй вызов должен оказаться успешным, но есть вероятность, что он вернет ошибку ENOENT, если какой-либо другой поток или процесс удалит объект в промежутке между этими двумя вызовами.</P>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label910 style="border:none;"></a>Глава 3</P>
    </H1>
    <P>1. Текст пpoгрaммы приведен в листинге Г.1.<A HREF="#n_1" onmouseover="ShowBookNote('n_1')" onmouseout="HideBookNote('n_1')"><SUP>[1]</SUP></A></P>
    <H2><a name=label911 style="border:none;"></a>Листинг Г.1. Вывод идентификатора и порядкового номера слота</H2>
    <P><CODE>//svmsg/slotseq.c</CODE></P>
    <P><CODE>1  #include "unpipc.h"</CODE></P>
    <BR>
    <P><CODE>2  int</CODE></P>
    <P><CODE>3  main(int argc, char **argv)</CODE></P>
    <P><CODE>4  {</CODE></P>
    <P><CODE>5   int i, msqid;</CODE></P>
    <P><CODE>6   struct msqid_ds info;</CODE></P>
    <P><CODE>7   for (i = 0; i &lt; 10; i++) {</CODE></P>
    <P><CODE>8    msqid = Msgget(IPC_PRIVATE, SVMSG_MODE | IPC_CREAT);</CODE></P>
    <P><CODE>9    Msgctl(msqid, IPC_STAT, &amp;info);</CODE></P>
    <P><CODE>10   printf("msqid = %d, seq = %lu\n", msqid, info.msg_perm.seq);</CODE></P>
    <P><CODE>11   Msgctl(msqid, IPC_RMID, NULL);</CODE></P>
    <P><CODE>12  }</CODE></P>
    <P><CODE>13  exit(0);</CODE></P>
    <P><CODE>14 }</CODE></P>
    <P>2. Первый вызов msgget задействует первую свободную очередь сообщений, порядковый номер которой имеет значение 20 после двукратного запуска программы из листинга 3.2, и вернет идентификатор 1000. Если предположить, что следующая доступная очередь сообщений никогда ранее не использовалась, ее порядковый номер будет иметь значение 0, а возвращаться будет идентификатор 1.</P>
    <P>3. Программа приведена в листинге Г.2.</P>
    <H2><a name=label912 style="border:none;"></a>Листинг Г.2. Проверка использования маски создания файла функцией msgget</H2>
    <P><CODE>//svmsg/testumask.c</CODE></P>
    <P><CODE>1 #include "unpipc.h"</CODE></P>
    <BR>
    <P><CODE>2 int</CODE></P>
    <P><CODE>3 main(int argc, char **argv)</CODE></P>
    <P><CODE>4 {</CODE></P>
    <P><CODE>5  Msgget(IPC_PRIVATE, 0666 | IPC_CREAT | IPC_EXCL);</CODE></P>
    <P><CODE>6  unlink("/tmp/fifo.1");</CODE></P>
    <P><CODE>7  Mkfifo("/tmp/fifo.1", 0666);</CODE></P>
    <P><CODE>8  exit(0);</CODE></P>
    <P><CODE>9 }</CODE></P>
    <P>Запустив эту пpoгрaммy, мы увидим, что маска создания файла имеет значение 2 (снять бит записи для прочих пользователей) и этот бит оказывается снятым для канала FIFO, но не для очереди сообщений:</P>
    <P><CODE>solaris % <STRONG>umask</STRONG></CODE></P>
    <P><CODE>02</CODE></P>
    <P><CODE>solaris % <STRONG>testumask</STRONG></CODE></P>
    <P><CODE>solaris % <STRONG>ls –l /tmp/fifo.1</STRONG></CODE></P>
    <P><CODE>prw-rw-r-- 1 rstevens other1 0 Mar 25 16:05 /tmp/fifo.1</CODE></P>
    <P><CODE>solaris % <STRONG>ipcs –q</STRONG></CODE></P>
    <P><CODE>IPC status from &lt;running system&gt; as of Wed Mar 25 16:06:03 1998</CODE></P>
    <P><CODE>T ID  KEY       MODE      OWNER    GROUP</CODE></P>
    <P><CODE>Message Queues:</CODE></P>
    <P><CODE>q 200 00000000 –rw-rw-rw– rstevens other1</CODE></P>
    <P>4. При использовании ftok имеется вероятность того, что для двух полных имен получится один и тот же ключ. При использовании IPC_PRIVATE сервер знает, что он создает новую очередь, но в этом случае ему нужно записать ее идентификатор в какой-либо файл, чтобы клиенты могли его считать.</P>
    <P>5. Вот один из способов обнаружения коллизий:</P>
    <P><CODE>solaris % <STRONG>find / –links 1 –not –type l – print | xargs –n1 ftok1 &gt; temp.1</STRONG></CODE></P>
    <P><CODE>solaris % <STRONG>wc –l temp.1</STRONG></CODE></P>
    <P><CODE>109351 temp.1</CODE></P>
    <P><CODE>solaris % <STRONG>sort +0 –1 temp.1 | nawk '{ if (lastkey== $1) print lastline, $0 lastline = $0 lastkey = $1 }' &gt; temp.2</STRONG></CODE></P>
    <P><CODE>solaris % <STRONG>wc –l temp.2 82188 temp.2</STRONG></CODE></P>
    <P>Программа find игнорирует файлы, на которые имеется несколько ссылок (поскольку у всех ссылок одинаковый номер узла), и символические ссылки (поскольку функция stat возвращает информацию для файла, на который ссылка указывает). Большой процент коллизий (75,2%) вызван тем, что в Solaris 2.x используется только 12 бит номера узла. Поэтому в файловых системах с числом файлов более 4096 количество коллизий может быть велико. Например, файлы с номерами 4096, 8192, 12288 и 16384 будут иметь один и тот же ключ IPC (если все они принадлежат одной файловой системе).</P>
    <P>Мы запустили эту программу в той же файловой системе, но используя функцию ftok из BSD/OS, которая добавляет номер узла к ключу целиком, и получили всего 849 коллизий (менее 1%).</P>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label913 style="border:none;"></a>Глава 4</P>
    </H1>
    <P>1. Если бы дескриптор fd[1] остался открытым в дочернем процессе при завершении родительского, его операция read для этого дескриптора не вернула бы признак конца файла, потому что дескриптор был бы еще открыт в дочернем процессе. Закрытие fd[1] гарантирует, что после завершения родительского процесса все его дескрипторы закрываются и вызов read для fd[1] возвращает 0.</P>
    <P>2. Если поменять местами порядок вызовов, другой процесс сможет создать канал FIFO в промежутке между вызовами open и mkfifo, в результате чего последний вернет ошибку.</P>
    <P>3. Если выполнить</P>
    <P><CODE>solaris % <STRONG>mainopen 2&gt;temp.stderr</STRONG></CODE></P>
    <P><CODE>/etc/ntp.conf &gt; /myfile</CODE></P>
    <P><CODE>solaris % <STRONG>cat temp.stderr</STRONG></CODE></P>
    <P><CODE>sh: /myfile: cannot create</CODE></P>
    <P>мы увидим, что popen срабатывает успешно, но fgets считывает символ конца файла. Сообщение об ошибке записывается интерпретатором в стандартный поток сообщений об ошибках.</P>
    <P>5. Измените первый вызов open, указав флаг отключения блокировки:</P>
    <P><CODE>readfifo = Open(SERV_FIFO, O_RDONLY | O_NONBLOCK, 0);</CODE></P>
    <P>Возврат из этого вызова произойдет немедленно, как и из следующего вызова open, поскольку канал уже открыт на чтение. Чтобы избежать ошибки при вызове readline, флаг O_NONBLOCK для дескриптора readfifo следует снять, перед тем как вызывать эту функцию.</P>
    <P>6. Если клиент откроет свой канал на чтение перед открытием канала сервера, все зависнет. Единственный способ избежать блокировки заключается в вызове open для этих двух каналов в порядке, показанном в листинге 4.11, или в использовании флага отключения блокировки.</P>
    <P>7. Исчезновение пишущего процесса воспринимается считывающим как конец файла.</P>
    <P>8. В листинге Г.3 приведен текст соответствующей программы.</P>
    <H2><a name=label914 style="border:none;"></a>Листинг Г.З. Возвращает ли fstat количество байтов в канале FIFO?</H2>
    <P><CODE>//pipe/test1l.c</CODE></P>
    <P><CODE>1  #include "unpipc.h"</CODE></P>
    <BR>
    <P><CODE>2  int</CODE></P>
    <P><CODE>3  main(int argc, char **argv)</CODE></P>
    <P><CODE>4  {</CODE></P>
    <P><CODE>5   int fd[2],</CODE></P>
    <P><CODE>6   char buff[7];</CODE></P>
    <P><CODE>7   struct stat info;</CODE></P>
    <P><CODE>8   if (argc != 2)</CODE></P>
    <P><CODE>9    err_quit("usage: test1 &lt;pathname&gt;");</CODE></P>
    <P><CODE>10  Mkfifo(argv[1], FILE_MODE);</CODE></P>
    <P><CODE>11  fd[0] = Open(argv[1], O_RDONLY | O_NONBLOCK);</CODE></P>
    <P><CODE>12  fd[1] = Open(argv[1], O_WRONLY | O_NONBLOCK);</CODE></P>
    <P><CODE>13  /* 4check sizes when FIFO is empty */</CODE></P>
    <P><CODE>14  Fstat(fd[0], &amp;info);</CODE></P>
    <P><CODE>15  printf("fd[0]: st_size = %ld\n", (long) info.st_size);</CODE></P>
    <P><CODE>16  Fstat(fd[1], &amp;info);</CODE></P>
    <P><CODE>17  printf("fd[1]: st_size = %ld\n", (long) info.st_size);</CODE></P>
    <P><CODE>18  Write(fd[1], buff, sizeof(buff));</CODE></P>
    <P><CODE>19  Fstat(fd[0], &amp;info);</CODE></P>
    <P><CODE>20  printf("fd[0]: st_size = %ld\n", (long) info.st_size);</CODE></P>
    <P><CODE>21  Fstat(fd[1], &amp;info);</CODE></P>
    <P><CODE>22  printf("fd[1]: st_size = %ld\n", (long) info.st_size);</CODE></P>
    <P><CODE>23  exit(0);</CODE></P>
    <P><CODE>24 }</CODE></P>
    <P>9. Вызов select возвращает информацию о возможности записи в дескриптор, но вызов write приводит к отправке сигнала SIGPIPE. Это описано в книге [24, с. 153-155]; когда возникает ошибка чтения или записи, select возвращает информацию о том, что дескриптор доступен, а собственно ошибка возвращается уже вызовами read или write. В листинге Г.4 приведен текст соответствующей пpoгрaммы.</P>
    <H2><a name=label915 style="border:none;"></a>Листинг Г.4. Что возвращает select при закрытии другого конца канала?</H2>
    <P><CODE>//pipe/test2.c</CODE></P>
    <P><CODE>1  #include "unpipc.h"</CODE></P>
    <BR>
    <P><CODE>2  int</CODE></P>
    <P><CODE>3  main(int argc, char **argv)</CODE></P>
    <P><CODE>4  {</CODE></P>
    <P><CODE>5   int fd[2], n;</CODE></P>
    <P><CODE>6   pid_t childpid;</CODE></P>
    <P><CODE>7   fd_set wset;</CODE></P>
    <P><CODE>8   Pipe(fd);</CODE></P>
    <P><CODE>9   if ((childpid = Fork()) == 0) { /* child */</CODE></P>
    <P><CODE>10   printf("child closing pipe read descriptor\n");</CODE></P>
    <P><CODE>11   Close(fd[0]);</CODE></P>
    <P><CODE>12   sleep(6);</CODE></P>
    <P><CODE>13   exit(0);</CODE></P>
    <P><CODE>14  }</CODE></P>
    <P><CODE>15  /* 4parent */</CODE></P>
    <P><CODE>16  Close(fd[0]); /* для двустороннего канала */</CODE></P>
    <P><CODE>17  sleep(3);</CODE></P>
    <P><CODE>18  FD_ZERO(&amp;wset);</CODE></P>
    <P><CODE>19  FD_SET(fd[1], &amp;wset);</CODE></P>
    <P><CODE>20  n = select(fd[1] + 1, NULL, &amp;wset, NULL, NULL);</CODE></P>
    <P><CODE>21  printf("select returned %d\n", n);</CODE></P>
    <P><CODE>22  if (FD_ISSET(fd[1], &amp;wset)) {</CODE></P>
    <P><CODE>23   printf("fd[1] writable\n");</CODE></P>
    <P><CODE>24   Write(fd[1], "hello", 5);</CODE></P>
    <P><CODE>25  }</CODE></P>
    <P><CODE>26  exit(0);</CODE></P>
    <P><CODE>27 }</CODE></P>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label916 style="border:none;"></a>Глава 5</P>
    </H1>
    <P>1. Сначала создайте очередь, не указывая никаких атрибутов, а затем вызовите mq_getattr для получения атрибутов по умолчанию. Затем удалите очередь и создайте ее снова, используя значения по умолчанию для всех неуказанных атрибутов.</P>
    <P>2. Для второго сообщения сигнал не отправляется, поскольку регистрация снимается после отправки первого сигнала.</P>
    <P>3. Для второго сообщения сигнал не отправляется, поскольку в момент отправки этого сообщения очередь не была пуста.</P>
    <P>4. Компилятор GNU С в системе Solaris 2.6 (в котором обе константы определены как вызовы sysconf) возвращает ошибки:</P>
    <P><CODE>test1.c:13: warning: int format, long int arg (arg 2)</CODE></P>
    <P><CODE>test1.c:13: warning: int format, long int arg (arg 3)</CODE></P>
    <P>5. В Solaris 2.6 мы указываем 1000000 сообщений по 10 байт в каждом. При этом создается файл размером 20000536 байт, что соответствует результатам, полученным с помощью пpoгрaммы 5.4: 10 байт данных на сообщение, 8 байт дополнительной информации (возможно, указатели), еще 2 байта добавочной информации (возможно, дополнение до кратного 4) и 536 байт добавочных данных на весь файл. Перед вызовом mq_open размер программы, выводимый ps, равнялся 1052 Кбайт, а после создания очереди размер вырос до 20 Мбайт. Это заставляет предположить, что очереди сообщений Posix реализованы через отображение файлов в память, и mq_open отображает файл в адресное пространство вызвавшего процесса. Аналогичные результаты получаются в Digital Unix 4.0B.</P>
    <P>6. Размер аргумента, равный нулю, не вызывает проблем с функциями ANSI С memXXX. В оригинале стандарта 1989 года Х3.159-1989 (ISO/IEC 9899:1990) ничего не говорилось по этому поводу (как и в документации), но в Technical Corrigendum Number 1 явно говорится, что указание размера 0 не вызовет проблем (но аргументы и указатели при этом должны быть правильными). Вообще, за информацией по языку С лучше всего обращаться по адресу http://www.lysator.liu.se/c/.</P>
    <P>7. Для двустороннего взаимодействия процессов требуется наличие двух очередей сообщений (см. например, листинг А.15). Если бы мы изменили листинг 4.4 для использования очередей сообщений Posix вместо каналов, мы бы увидели, что родительский процесс считывает то, что сам же и отправил.</P>
    <P>8. Взаимное исключение и условная переменная помещаются в отображаемый файл, совместно используемый всеми процессами, открывающими очередь. Очередь может быть открыта и другими процессами, поэтому при закрытии дескриптора очереди взаимное исключение и условная переменная не уничтожаются.</P>
    <P>9. Массиву нельзя присвоить значение другого массива с помощью знака равенства в языке С, а вот структуре можно.</P>
    <P>10. Функция main проводит большую часть времени заблокированной в вызове select, ожидая возможности чтения из конца канала. Каждый раз при получении сигнала возврат из обработчика прерывает вызов select, что приводит к возврату ошибки EINTR. Чтобы избежать этой проблемы, функция-обертка Select проверяет возврат данного кода ошибки и снова вызывает select, как показано в листинге Г.5. В книге [24, с. 124] вы можете найти более подробный рассказ о прерывании системных вызовов.</P>
    <H2><a name=label917 style="border:none;"></a>Листинг Г.5. Обертка Select, обрабатывающая возврат EINTR</H2>
    <P><CODE>//lib/wrapunix.c</CODE></P>
    <P><CODE>313 int</CODE></P>
    <P><CODE>314 Select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,</CODE></P>
    <P><CODE>315  struct timeval *timeout)</CODE></P>
    <P><CODE>316 {</CODE></P>
    <P><CODE>317  int n;</CODE></P>
    <P><CODE>318 again:</CODE></P>
    <P><CODE>319  if ( (n = select(nfds, readfds, writefds, exceptfds, timeout)) &lt; 0) {</CODE></P>
    <P><CODE>320   if (errno == EINTR)</CODE></P>
    <P><CODE>321    goto again;</CODE></P>
    <P><CODE>322  else</CODE></P>
    <P><CODE>323   err_sys("select error");</CODE></P>
    <P><CODE>324  } else if (n == 0 &amp;&amp; timeout == NULL)</CODE></P>
    <P><CODE>325   err_quit("select returned 0 with no timeout");</CODE></P>
    <P><CODE>326  return(n); /* возвращаем 0 по тайм-ауту */</CODE></P>
    <P><CODE>327 }</CODE></P>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label918 style="border:none;"></a>Глава 6</P>
    </H1>
    <P>1. Оставшиеся программы должны принимать идентификатор очереди в числовом виде (вместо полного имени). Это изменение можно осуществить путем добавления нового аргумента командной строки или с помощью предположения, что полное имя, состоящее из одних цифр, является не именем файла, а идентификатором очереди. Поскольку большинство имен файлов, передаваемых ftok, являются абсолютными, они заведомо содержат по крайней мере один нецифровой символ (слэш), и это предположение является вполне корректным.</P>
    <P>2. Передача сообщений с типом 0 запрещена, а клиент никогда не может иметь идентификатор 1, поскольку этот идентификатор обычно принадлежит процессу init.</P>
    <P>3. При использовании единственной очереди на рис. 6.2 злоумышленник мог повлиять на все прочие процессы-клиенты. Если у каждого клиента есть своя очередь (рис. 6.3), злоумышленник портит только свою.</P>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label919 style="border:none;"></a>Глава 7</P>
    </H1>
    <P>2. Вероятно, процесс завершит работу, прежде чем потребитель успеет сделать все, что нужно, поскольку вызов exit завершает все выполняющиеся потоки.</P>
    <P>3. В Solaris 2.6 удаление вызова функций типа destroy приводит к утечке памяти, из чего становится ясно, что функции init осуществляют динамическое выделение памяти. В Digital Unix 4.0B такого не наблюдается, что указывает на разницу в реализации. Тем не менее вызывать функции destroy все равно нужно. С точки зрения реализации в Digital Unix 4.0B используется переменная типа attr_t как объект, содержащий атрибуты, а в Solaris 2.6 эта переменная представляет собой указатель на динамически создаваемый объект.</P>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label920 style="border:none;"></a>Глава 9</P>
    </H1>
    <P>1. В зависимости от системы может потребоваться увеличивать счетчик до значений, больших 20, чтобы наблюдать ошибку.</P>
    <P>2. Для отключения буферизации стандартного потока мы добавляем строку</P>
    <P><CODE>setvbuf(stdout, NULL, _IONBF, 0);</CODE></P>
    <P>к функции main перед циклом for. Это не должно ни на что влиять, поскольку вызов printf только один и строка завершается символом перевода. Обычно стандартный поток вывода буферизуется построчно, поэтому в любом случае один вызов printf превращается в один системный вызов write.</P>
    <P>3. Заменим printf на</P>
    <P><CODE>snprintf(line, sizeof(line), "%s: pid = 3.1d, seq# = %d\n", argv[0], (long) pid, seqno);</CODE></P>
    <P><CODE>for (ptr = line; (c = *ptr++) != 0) putchar(c);</CODE></P>
    <P>и объявим с как целое, a ptr — как char*. Если мы вызвали setvbuf для отключения буферизации стандартного потока вывода, библиотека будет делать системный вызов для вывода каждого символа. На это требуется больше времени, что дает ядру больше возможностей на переключение контекста между процессами. Такая программа должна давать больше ошибок.</P>
    <P>4. Поскольку несколько процессов могут заблокировать на чтение одну и ту же область файла, в нашем примере это эквивалентно полному отсутствию блокировок.</P>
    <P>5. Ничего не изменится, поскольку флаг отключения блокировки для дескриптора никак не влияет на работу рекомендательной блокировки fcntl. Блокирование процесса при вызове fcntl определяется типом команды: F_SETLKW (которая блокируется всегда) или F_SETLK (которая не блокируется никогда).</P>
    <P>6. Пpoгрaммa loopfcntlnonb работает как положено, поскольку, как мы показали в предыдущем примере, флаг отключения блокировки никак не влияет на блокировку fcntl. Однако этот флаг влияет на работу loopnonenonb, которая не пользуется блокировкой. Как говорилось в разделе 9.5, неблокируемый вызов write или read для файла с включенной обязательной блокировкой приводит к возврату ошибки EAGAIN. Мы увидим одно из следующих сообщений:</P>
    <P><CODE>read error: Resource temporarily unavailable</CODE></P>
    <P><CODE>write error: Resource temporarily unavailable</CODE></P>
    <P>и мы можем проверить, что это сообщение соответствует EAGAIN, выполнив</P>
    <P><CODE>solaris % <STRONG>grep Resource /usr/include/sys/errno.h</STRONG></CODE></P>
    <P><CODE>#define EAGAIN 11 /* Resource temporarily unavailable */</CODE></P>
    <P>7. В Solaris 2.6 обязательная блокировка увеличивает время работы на 16%, а время процессора — на 20%. Пользовательское время процессора остается прежним, поскольку проверка осуществляется в ядре, а не в процессе.</P>
    <P>8. Блокировки выдаются процессам, а не потокам.</P>
    <P>9. Если бы работала другая копия демона, а мы открыли бы файл с флагом O_TRUNC, это привело бы к удалению идентификатора процесса из файла. Мы не имеем права укорачивать файл, пока не убедимся, что данная копия является единственной.</P>
    <P>10. Лучше использовать SEEK_SET. Проблема с SEEK_CUR заключается в том, что этот вариант зависит от текущего положения в файле, устанавливаемого 1 seek. Однако если мы вызываем 1 seek, а потом fcntl, мы делаем одну операцию в два вызова и существует вероятность, что другой процесс в промежутке между вызовами изменит текущий сдвиг вызовом lseek. Вспомните, что все потоки используют общие дескрипторы. Аналогично, если указать SEEK_END, другой процесс может дописать данные к файлу, прежде чем мы получим блокировку, и тогда она уже не будет распространяться на весь файл.</P>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label921 style="border:none;"></a>Глава 10</P>
    </H1>
    <P>1. Вот результат работы в Solaris 2.6:</P>
    <P><CODE>solaris % <STRONG>deadlock 100</STRONG></CODE></P>
    <P><CODE>prod: calling sem_wait(nempty) <EM>i=0 у производителя</EM></CODE></P>
    <P><CODE>prod: got sem_wait(nempty)</CODE></P>
    <P><CODE>prod: calling sem_wait(mutex)</CODE></P>
    <P><CODE>prod: got sem_wait(mutex), storing 0</CODE></P>
    <P><CODE>prod: calling sem_wait(nempty) <EM>i=1 у производителя</EM></CODE></P>
    <P><CODE>prod: got sem_wait(nempty)</CODE></P>
    <P><CODE>prod: calling sem_wait(mutex)</CODE></P>
    <P><CODE>prod: got sem_wait(mutex), storing 1</CODE></P>
    <P><CODE>prod: calling sem_wait(nempty) <EM>начало следующего цикла, но места больше нет,</EM></CODE></P>
    <P><CODE><EM>                               поэтому происходит переключение контекста</EM></CODE></P>
    <P><CODE>cons: calling sem_wait(mutex) <EM>i=0</EM></CODE></P>
    <P><CODE>cons: got sem_wait(mutex)</CODE></P>
    <P><CODE>cons: calling sem_wait(nstored)</CODE></P>
    <P><CODE>cons: got sem_wait(nstored)</CODE></P>
    <P><CODE>cons: fetched 0</CODE></P>
    <P><CODE>cons: calling sem_wait(mutex) <EM>i=1</EM></CODE></P>
    <P><CODE>cons: got sem_wait(mutex)</CODE></P>
    <P><CODE>cons: calling sem_wait(nstored)</CODE></P>
    <P><CODE>cons: got sem_wait(nstored)</CODE></P>
    <P><CODE>cons: fetched 1</CODE></P>
    <P><CODE>cons: calling sem_wait(mutex)</CODE></P>
    <P><CODE>cons: got sem_wait(mutex)</CODE></P>
    <P><CODE>cons: calling sem_wait(nstored) <EM>здесь блокируется потребитель. Навсегда.</EM></CODE></P>
    <P><CODE>prod: got sem_wait(nempty)</CODE></P>
    <P><CODE>prod: calling sem_wait(mutex)   <EM>а здесь блокируется производитель.</EM></CODE></P>
    <P>2. Это не вызывает проблем с учетом правил, которые были указаны при описании sem_open: если семафор уже существует, он не инициализируется. Поэтому только первая из четырех программ, вызывающих sem_open, инициализирует семафор.</P>
    <P>3. Это проблема. Семафор автоматически закрывается при завершении процесса, но значение его не изменяется. Это не дает другим пpoгрaммaм получить блокировку, и все зависает.</P>
    <P>4. Если мы не инициализируем дескрипторы значением –1, их значение оказывается неизвестным, поскольку malloc не инициализирует выделяемую память. Поэтому если один из вызовов open возвращает ошибку, вызовы close под меткой error могут закрыть какой-нибудь используемый процессом дескриптор. Инициализируя дескрипторы значением –1, мы можем быть уверены, что вызовы close не дадут результата (помимо возвращения игнорируемой ошибки), если дескриптор еще не был открыт.</P>
    <P>5. Существует вероятность, что close будет вызвана для нормального дескриптора и вернет ошибку, изменив значение errno. Поэтому нам нужно сохранить это значение в другой переменной, чтобы оно не изменилось из-за побочного эффекта.</P>
    <P>6. В этой функции ситуация гонок не возникает, поскольку mkfifo возвращает ошибку, если канал уже существует. Если два процесса вызывают эту функцию одновременно, канал FIFO создается только один раз. Второй вызов mkfifо приведет к возврату EEXIST.</P>
    <P>7. В пpoгрaммe из листинга 10.22 ситуация гонок, описанная в связи с листингом 10.28, не возникает, поскольку инициализация семафора осуществляется записью данных в канал. Если процесс, создавший канал, приостанавливается ядром после создания, но перед записью данных, второй процесс откроет этот канал и заблокируется в вызове sem_wait, поскольку только что созданный канал будет пуст (пока первый процесс не поместит в него данные).</P>
    <P>8. В листинге Г.6 приведена тестовая программа. Реализации Solaris 2.6 и Digital Unix 4.0B обнаруживают прерывание перехватываемым сигналом и возвращают ошибку EINTR.</P>
    <H2><a name=label922 style="border:none;"></a>Листинг Г.6. Возвращает ли sem_wait ошибку EINTR?</H2>
    <P><CODE>//pxsem/testeintr.c</CODE></P>
    <P><CODE>1  #include "unpipc.h"</CODE></P>
    <P><CODE>2  #define NAME "testeintr"</CODE></P>
    <P><CODE>3  static void sig_alrm(int);</CODE></P>
    <BR>
    <P><CODE>4  int</CODE></P>
    <P><CODE>5  main(int argc, char **argv)</CODE></P>
    <P><CODE>6  {</CODE></P>
    <P><CODE>7   sem_t *sem1, sem2;</CODE></P>
    <P><CODE>8   /* именованный семафор */</CODE></P>
    <P><CODE>9   sem_unlink(Px_ipc_name(NAME));</CODE></P>
    <P><CODE>10  sem1 = Sem_open(Px_ipc_name(NAME), O_RDWR | O_CREAT | О_EXCL,</CODE></P>
    <P><CODE>11   FILE_MODE, 0);</CODE></P>
    <P><CODE>12  Signal(SIGALRM, sig_alrm);</CODE></P>
    <P><CODE>13  alarm(2);</CODE></P>
    <P><CODE>14  if (sem_wait(sem1) == 0)</CODE></P>
    <P><CODE>15   printf("sem_wait returned 0?\n");</CODE></P>
    <P><CODE>16  else</CODE></P>
    <P><CODE>17   err_ret("sem_wait error");</CODE></P>
    <P><CODE>18  Sem_close(sem1);</CODE></P>
    <P><CODE>19  /* размещаемый в памяти семафор */</CODE></P>
    <P><CODE>20  Sem_init(&amp;sem2, 1, 0);</CODE></P>
    <P><CODE>21  alarm(2);</CODE></P>
    <P><CODE>22  if (sem_wait(&amp;sem2) == 0)</CODE></P>
    <P><CODE>23   printf("sem_wait returned 0?\n");</CODE></P>
    <P><CODE>24  else</CODE></P>
    <P><CODE>25   err_ret("sem_wait error");</CODE></P>
    <P><CODE>26  Sem_destroy(&amp;sem2);</CODE></P>
    <P><CODE>27  exit(0);</CODE></P>
    <P><CODE>28 }</CODE></P>
    <BR>
    <P><CODE>29 static void</CODE></P>
    <P><CODE>30 sig_alrm(int signo)</CODE></P>
    <P><CODE>31 {</CODE></P>
    <P><CODE>32  printf("SIGALRM caught\n");</CODE></P>
    <P><CODE>33  return;</CODE></P>
    <P><CODE>34 }</CODE></P>
    <P>Реализация с использованием FIFO возвращает EINTR, поскольку sem_wait блокируется в вызове read, который должен возвращать такую ошибку. Реализация с использованием отображения в память ошибки не возвращает, поскольку sem_wait блокируется в вызове pthread_cond_wait, а эта функция не возвращает такой ошибки. Реализация с использованием семафоров System V возвращает ошибку EINTR, поскольку sem_wait блокируется в вызове semop, которая возвращает эту ошибку.</P>
    <P>9. Реализация с использованием каналов (листинг 10.25) является защищенной, поскольку таковой является операция write. Реализация с отображением в память защищенной не является, поскольку функции pthread_XXX не являются защищенными и не могут вызываться из обработчика сигналов. Реализация с семафорами System V (листинг 10.41) также не является защищенной, поскольку semop не является защищенной функцией согласно Unix 98.</P>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label923 style="border:none;"></a>Глава 11</P>
    </H1>
    <P>1. Нужно изменить только одну строку:</P>
    <P><CODE>&lt; semid = Semget(Ftok(argv[optind], 0), 0, 0);</CODE></P>
    <P><CODE>…</CODE></P>
    <P><CODE><EM>&gt;</EM> semid = atol(argv[optind]);</CODE></P>
    <P>2. Вызов ftok вернет ошибку, что приведет к завершению работы обертки Ftok. Функция my_lock могла бы вызывать ftok перед semget, проверять, не возвращается ли ошибка ENOENT, а затем создавать файл, если он не существует.</P>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label924 style="border:none;"></a>Глава 12</P>
    </H1>
    <P>1. Размер файла увеличится еще на 4096 байт (до 36864), но обращение к новому концу файла (36863) может привести к отправке сигнала SIGSEGV, поскольку размер области отображения в памяти равен 32768 байт. Причина, по которой мы говорим «может», а не «должен», — в неопределенности размера страницы памяти.</P>
    <P>2. На рис. Г.1 показана схема с очередью сообщений System V, а на рис. Г.2 — с очередью сообщений Posix. Вызовы memcpy в отправителе происходят внутри функций mq_send (листинг 5.26), а в получателе — внутри mq_receive (листинг 5.28).</P>
    <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader263" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

    <P>Рис. Г.1. Отправка сообщений в очередь System V</P>
    <BR>
    <center><IMG SRC="http://www.e-reading.ws/illustrations/148/148368-Any2FbImgLoader264" alt="UNIX: взаимодействие процессов" style="max-width:90%;max-height:90%;" /></center>

    <P>Рис. Г.2. Отправка сообщений через очередь Posix, реализованную с mmap</P>
    <BR>
    <P>3. Любой вызов read для /dev/zero возвращает запрошенное количество нулей. Данные, помещаемые в этот файл, попросту сбрасываются (аналогично /dev/null).</P>
    <P>4.  В результате в файле получится 4 байта — все нули (предполагается 32-разрядное целое).</P>
    <P>5. В листинге Г.7 приведен текст нашей программы.</P>
    <H2><a name=label925 style="border:none;"></a>Листинг Г.7. Использование select с очередями System V</H2>
    <P><CODE>//shm/svmsgread.c</CODE></P>
    <P><CODE>1  #include "unpipc.h"</CODE></P>
    <P><CODE>2  #define MAXMSG (8192 + sizeof(long))</CODE></P>
    <BR>
    <P><CODE>3  int</CODE></P>
    <P><CODE>4  main(int argc, char **argv)</CODE></P>
    <P><CODE>5  {</CODE></P>
    <P><CODE>6   int pipe1[2], pipe2[2], mqid;</CODE></P>
    <P><CODE>7   char c;</CODE></P>
    <P><CODE>8   pid_t childpid;</CODE></P>
    <P><CODE>9   fd_set rset;</CODE></P>
    <P><CODE>10  ssize_t n, nread;</CODE></P>
    <P><CODE>11  struct msgbuf *buff;</CODE></P>
    <P><CODE>12  if (argc != 2)</CODE></P>
    <P><CODE>13   err_quit("usage: svmsgread &lt;pathname&gt;");</CODE></P>
    <P><CODE>14  Pipe(pipe1); /* двусторонняя связь */</CODE></P>
    <P><CODE>15  Pipe(pipe2);</CODE></P>
    <P><CODE>16  buff = My_shm(MAXMSG); /* неименованная разделяемая память */</CODE></P>
    <P><CODE>17  if ((childpid = Fork()) == 0) {</CODE></P>
    <P><CODE>18   Close(pipe1[1]); /* child */</CODE></P>
    <P><CODE>19   Close(pipe2[0]);</CODE></P>
    <P><CODE>20   mqid = Msgget(Ftok(argv[1], 0), MSG_R);</CODE></P>
    <P><CODE>21   for(;;) {</CODE></P>
    <P><CODE>22    /* блокируется в ожидании, извещает родительский процесс */</CODE></P>
    <P><CODE>23    nread = Msgrcv(mqid, buff, MAXMSG, 0, 0);</CODE></P>
    <P><CODE>24    Write(pipe2[1], &amp;nread, sizeof(ssize_t));</CODE></P>
    <P><CODE>25    /* ожидает разрешения родительского процесса */</CODE></P>
    <P><CODE>26    if ((n = Read(pipe1[0], &amp;c, 1)) != 1)</CODE></P>
    <P><CODE>27     err_quit("child: read on pipe returned %d", n);</CODE></P>
    <P><CODE>28   }</CODE></P>
    <P><CODE>29   exit(0);</CODE></P>
    <P><CODE>30  } /* $$.bp$$ */</CODE></P>
    <P><CODE>31  /* parent */</CODE></P>
    <P><CODE>32  Close(pipe1[0]);</CODE></P>
    <P><CODE>33  Close(pipe2[1]);</CODE></P>
    <P><CODE>34  FD_ZERO(&amp;rset);</CODE></P>
    <P><CODE>35  FD_SET(pipe2[0], &amp;rset);</CODE></P>
    <P><CODE>36  for(;;) {</CODE></P>
    <P><CODE>37   if ((n = select(pipe2[0] + 1, &amp;rset, NULL, NULL, NULL)) != 1)</CODE></P>
    <P><CODE>38    err_sys("select returned %d", n);</CODE></P>
    <P><CODE>39   if (FD_ISSET(pipe2[0], &amp;rset)) {</CODE></P>
    <P><CODE>40    n = Read(pipe2[0], &amp;nread, sizeof(ssize_t)); /* *INDENT-OFF* */</CODE></P>
    <P><CODE>41    if (n != sizeof(ssize_t))</CODE></P>
    <P><CODE>42     err_quit("parent: read on pipe returned %d", n); /* *INDENT-ON* */</CODE></P>
    <P><CODE>43    printf("read %d bytes, type = %ld\n", nread, buff-&gt;mtype);</CODE></P>
    <P><CODE>44    Write(pipe1[1], &amp;c, 1);</CODE></P>
    <P><CODE>45   } else</CODE></P>
    <P><CODE>47  }</CODE></P>
    <P><CODE>46  err_quit("pipe2[0] not ready");</CODE></P>
    <P><CODE>48  Kill(childpid, SIGTERM);</CODE></P>
    <P><CODE>49  exit(0);</CODE></P>
    <P><CODE>50 }</CODE></P>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label926 style="border:none;"></a>Глава 13</P>
    </H1>
    <P>1. В листинге Г.8 приведен текст измененной версии листинга 12.6, а в листинге Г.9 — текст новой версии листинга 12.7. Обратите внимание, что в первой пpoгрaммe мы устанавливаем размер объекта вызовом ftruncate; lseek и write использовать для этого нельзя.</P>
    <H2><a name=label927 style="border:none;"></a>Листинг Г.8. Отображение с точным указанием размера файла</H2>
    <P><CODE>//pxshra/test1.c</CODE></P>
    <P><CODE>1  #include "unpipc.h"</CODE></P>
    <BR>
    <P><CODE>2  int</CODE></P>
    <P><CODE>3  main(int argc, char **argv)</CODE></P>
    <P><CODE>4  {</CODE></P>
    <P><CODE>5   int fd, i;</CODE></P>
    <P><CODE>6   char *ptr;</CODE></P>
    <P><CODE>7   size_t shmsize, mmapsize, pagesize;</CODE></P>
    <P><CODE>8   if (argc != 4)</CODE></P>
    <P><CODE>9    err_quit("usage: test1 &lt;name&gt; &lt;shmsize&gt; &lt;mmapsize&gt;");</CODE></P>
    <P><CODE>10  shmsize = atoi(argv[2]);</CODE></P>
    <P><CODE>11  mmapsize = atoi(argv[3]);</CODE></P>
    <P><CODE>12  /* открываем shm: создание или урезание; установка размера */</CODE></P>
    <P><CODE>13  fd = Shm_open(Px_ipc_name(argv[1]), O_RDWR | O_CREAT | O_TRUNC,</CODE></P>
    <P><CODE>14   FILE_MODE);</CODE></P>
    <P><CODE>15  Ftruncate(fd, shmsize); /* $$.bp$S */</CODE></P>
    <P><CODE>16  ptr = Mmap(NULL, mmapsize, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</CODE></P>
    <P><CODE>17  Close(fd);</CODE></P>
    <P><CODE>18  pagesize = Sysconf(_SC_PAGESIZE);</CODE></P>
    <P><CODE>19  printf("PAGESIZE = %ld\n", (long) pagesize);</CODE></P>
    <P><CODE>20  for (i = 0; i &lt; max(shmsize, mmapsize); i += pagesize) {</CODE></P>
    <P><CODE>21   printf("ptr[%d] = %d\n", i, ptr[i]);</CODE></P>
    <P><CODE>22   ptr[i] = 1;</CODE></P>
    <P><CODE>23   printf("ptr[%d] = %d\n", i + pagesize – 1, ptr[i + pagesize – 1]);</CODE></P>
    <P><CODE>24   ptr[i + pagesize – 1] = 1;</CODE></P>
    <P><CODE>25  }</CODE></P>
    <P><CODE>26  printf("ptr[%d] =%d\n", i, ptr[i]);</CODE></P>
    <P><CODE>27  exit(0);</CODE></P>
    <P><CODE>28 }</CODE></P>
    <H2><a name=label928 style="border:none;"></a>Листинг Г.9. Отображение в память с возможностью роста файла</H2>
    <P><CODE>//pxshm/test2.c</CODE></P>
    <P><CODE>1  #include "unpipc.h"</CODE></P>
    <P><CODE>2  #define FILE "test.data"</CODE></P>
    <P><CODE>3  #define SIZE 32768</CODE></P>
    <BR>
    <P><CODE>4  int</CODE></P>
    <P><CODE>5  main(int argc, char **argv)</CODE></P>
    <P><CODE>6  {</CODE></P>
    <P><CODE>7   int fd, i;</CODE></P>
    <P><CODE>8   char *ptr;</CODE></P>
    <P><CODE>9   /* создаем или урезаем, отображаем */</CODE></P>
    <P><CODE>10  fd = Shm_open(Px_ipc_name(FILE), O_RDWR | O_CREAT | O_TRUNC, FILE_MODE);</CODE></P>
    <P><CODE>11  ptr = Mmap(NULL, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);</CODE></P>
    <P><CODE>12  for (i = 4096; i &lt;= SIZE; i += 4096) {</CODE></P>
    <P><CODE>13   printf("setting shm size to %d\n", i);</CODE></P>
    <P><CODE>14   Ftruncate(fd, i);</CODE></P>
    <P><CODE>15   printf("ptr[%d] = %d\n", i-1, ptr[i-1]);</CODE></P>
    <P><CODE>16  }</CODE></P>
    <P><CODE>17  exit(0);</CODE></P>
    <P><CODE>18 }</CODE></P>
    <P>2. Одна из возможных проблем при использовании *ptr++ заключается в том, что указатель, возвращенный mmap, изменяется, что может помешать впоследствии вызвать munmap. Если этот указатель еще понадобится, лучше его сохранить или вовсе не изменять.</P>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label929 style="border:none;"></a>Глава 14</P>
    </H1>
    <P>1. Нужно изменить только одну строку:</P>
    <P><CODE>13с13</CODE></P>
    <P><CODE>&lt; id = Shmget(Ftok(argv[1], 0), 0, SVSHM_MORE);</CODE></P>
    <P><CODE>…</CODE></P>
    <P><CODE>&gt; id = atol(argv[1]);</CODE></P>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label930 style="border:none;"></a>Глава 15</P>
    </H1>
    <P>1. Аргументы будут иметь размер data_size + (desc_numxsizeof(door_desc_t)) байт.</P>
    <P>2. Вызывать fstat не нужно. Если дескриптор не указывает на дверь, вызов door_infо возвращает ошибку EBADF:</P>
    <P><CODE>solaris % <STRONG>doorinfo /etc/passwd</STRONG></CODE></P>
    <P><CODE>door_info error: Bad file number</CODE></P>
    <P>3. Документация содержит неверные сведения. Стандарт Posix утверждает, что функция sleep приведет к приостановке вызвавшего <EM>потока.</EM></P>
    <P>4. Результат непредсказуем (хотя, скорее всего, будет выполнен дамп памяти), поскольку адрес процедуры сервера, связанной с дверью, в новом процессе будет указывать на совершенно случайную область памяти.</P>
    <P>5. При завершении door_call из-за перехвата сигнала сервер следует уведомить об этом, поскольку поток, работающий с этим клиентом, получит запрос на отмену выполнения. В связи с листингом 15.18 мы говорили, что отмена для создаваемых библиотекой потоков по умолчанию отключена, следовательно, поток завершен не будет. Вместо этого происходит досрочный возврат из вызова sleep(6) в процедуре сервера, но она продолжает выполняться.</P>
    <P>6. Вот что мы увидим:</P>
    <P><CODE>solaris % <STRONG>server6 /tmp/door6</STRONG></CODE></P>
    <P><CODE>my_thread: created sever thread 4</CODE></P>
    <P><CODE>door_bind error: Bad file number</CODE></P>
    <P>Запустив сервер 20 раз подряд, мы получим 5 сообщений об ошибке. Предсказать такую ошибку заранее нельзя.</P>
    <P>7. Нет. Все, что нужно, — включать возможность отмены каждый раз при вызове процедуры сервера, как мы делали в листинге 15.26. Хотя в этом случае и приходится вызывать pthread_setcancelstate каждый раз при запуске процедуры сервера, накладные расходы, скорее всего, будут невелики.</P>
    <P>8. Чтобы проверить это, изменим код одного из серверов (скажем, из листинга 15.6) так, чтобы он вызывал door_revoke из процедуры сервера. Поскольку аргументом door_revoke является дескриптор двери, его придется сделать глобальным. Вот что получится при запуске клиента (из листинга 15.1) два раза подряд:</P>
    <P><CODE>solaris % <STRONG>client8 /tmp/door8 88</STRONG></CODE></P>
    <P><CODE>result: 7744</CODE></P>
    <P><CODE>solaris % <STRONG>client8 /tmp/door8 99</STRONG></CODE></P>
    <P><CODE>door_call error: Bad file number</CODE></P>
    <P>Первый вызов завершается успешно, что подтверждает наше предположение насчет door_revoke. Второй вызов возвращает ошибку EBADF.</P>
    <P>9. Чтобы не делать дескриптор fd глобальным, мы воспользуемся указателем cookiе, который можем передать door_create и который затем будет передаваться процедуре сервера при каждом вызове. В листинге Г.10 приведен текст сервера.</P>
    <H2><a name=label931 style="border:none;"></a>Листинг Г.10. Использование указателя cookie для избавления от глобальных переменных</H2>
    <P><CODE>//doors/server9.c</CODE></P>
    <P><CODE>1  #include "unpipc.h"</CODE></P>
    <BR>
    <P><CODE>2  void</CODE></P>
    <P><CODE>3  servproc(void *cookie, char *dataptr, size_t datasize,</CODE></P>
    <P><CODE>4   door_desc_t *descptr, size_t ndesc)</CODE></P>
    <P><CODE>5  {</CODE></P>
    <P><CODE>6   long arg, result;</CODE></P>
    <P><CODE>7   Door_revoke(*((int *) cookie));</CODE></P>
    <P><CODE>8   arg = *((long *) dataptr);</CODE></P>
    <P><CODE>9   printf("thread id %ld, arg = %ld\n", pr_thread_id(NULL), arg);</CODE></P>
    <P><CODE>10  result = arg * arg;</CODE></P>
    <P><CODE>11  Door_return((char *) &amp;result, sizeof(result), NULL, 0);</CODE></P>
    <P><CODE>12 }</CODE></P>
    <BR>
    <P><CODE>13 int</CODE></P>
    <P><CODE>14 main(int argc, char **argv)</CODE></P>
    <P><CODE>15 {</CODE></P>
    <P><CODE>16  int fd;</CODE></P>
    <P><CODE>17  if (argc != 2)</CODE></P>
    <P><CODE>18   err_quit("usage: server9 &lt;server-pathname&gt;");</CODE></P>
    <P><CODE>19  fd = Door_create(servproc, &amp;fd, 0);</CODE></P>
    <P><CODE>20  unlink(argv[1]);</CODE></P>
    <P><CODE>21  Close(Open(argv[1], O_CREAT | O_RDWR, FILE MODE));</CODE></P>
    <P><CODE>22  Fattach(fd, argv[1]);</CODE></P>
    <P><CODE>23  for(;;)</CODE></P>
    <P><CODE>24   pause();</CODE></P>
    <P><CODE>25 }</CODE></P>
    <P>Мы легко могли бы изменить листинги 5.17 и 5.18, поскольку указатель cookie доступен функции my_thread (через структуру door_info_t), которая передает указатель на эту структуру создаваемому потоку (которому нужно знать дескриптор для вызова door_bind).</P>
    <P>10. В этом примере атрибуты потока не меняются, поэтому их достаточно инициализировать лишь единожды (в функции main).</P>
   </DIV>
   <DIV class=section>
    <H1>
     <P><a name=label932 style="border:none;"></a>Глава 16</P>
    </H1>
    <P>1. Программа отображения портов (port mapper) не проверяет серверы на работоспособность во время регистрации. После завершения сервера отображения остаются в силе, в чем мы можем убедиться с помощью пpoгрaммы rpcinfо. Поэтому клиент, связывающийся с программой отображения портов, получит информацию, которая была актуальной до завершения сервера. Когда клиент попытается связаться с сервером по TCP, библиотека RPC получит RST в ответ на пакет SYN (предполагается, что другие процессы не успели подключиться к порту завершенного сервера), что приведет к возврату ошибки функцией clnt_create. Вызов по протоколу UDP будет успешен (поскольку устанавливать соединение не нужно), но при отправке дейтаграмм через устаревший порт ответ получен не будет и функция клиента выйдет по тайм-ауту.</P>
    <P>2. Библиотека RPC возвращает первый ответ сервера клиенту сразу по получении, то есть через 20 секунд после вызова клиента. Следующий ответ будет храниться в сетевом буфере для данной конечной точки до тех пор, пока эта точка не будет закрыта или не будет выполнена операция чтения из нее библиотекой RPC. Предположим, что клиент отправит второй вызов серверу сразу после получения первого ответа. Если потерь в сети не произойдет, следующей прибывшей дeйтaгрaммoй будет ответ сервера на повторно переданную клиентом дейтаграмму. Но библиотека RPC проигнорирует этот ответ, поскольку XID будет совпадать с первым вызовом процедуры, который не может быть равным XID для второго вызова.</P>
    <P>3. Соответствующая структура в С — это char c[10], но она будет закодирована XDR как десять 4-байтовых целых. Если вы хотите использовать строку фиксированной длины, используйте скрытый тип данных фиксированной длины.</P>
    <P>4. Вызов xdr_data возвращает FALSE, поскольку вызов xdr_string (прочитайте содержимое файла data_xdr.c) возвращает FALSE.</P>
    <P>Максимальная длина строки указывается в качестве последнего аргумента xdr_string. Если максимальная длина не указана, этот аргумент принимает значение 0 в дополнительном коде (2³²–1 для 32-разрядного целого).</P>
    <P>5. Пoдпpoгрaммы XDR проверяют наличие достаточного объема свободной памяти в буфере для кодирования данных и возвращают ошибку FALSE при переполнении буфера. К сожалению, отличить одну ошибку от другой для подпpoгрaмм XDR невозможно.</P>
    <P>6. В принципе, можно сказать, что использование последовательных номеров в TCP для обнаружения повторов эквивалентно кэшу повторных запросов, поскольку эти последовательные номера позволяют обнаружить любой устаревший сегмент. Для конкретного соединения (IP-адреса и порта клиента) размер этого кэша соответствует половине 32-разрядного последовательного номера TCP, то есть 2³¹ или 2 Гбайт.</P>
    <P>7. Поскольку все пять значений для конкретного запроса должны в точности равняться пяти значениям в кэше, первое сравнение должно выполняться для того поля, которое может отличаться с наибольшей вероятностью. Реальный порядок сравнений в пакете TI-RPC таков: (1) XID, (2) номер процедуры, (3) номер версии, (4) номер программы, (5) адрес клиента. Разумно сравнивать XID в первую очередь, поскольку именно это значение меняется от запроса к запросу.</P>
    <P>8. На рис. 16.5 имеется двенадцать 4-байтовых полей, начиная с поля флага и длины и включая 4 байта на аргумент типа long. Получается 48 байт. При использовании нулевой аутентификации данные о пользователе и проверочные данные будут отсутствовать. При этом они займут по 8 байтов: 4 байта на тип аутентификации (AUTH_NONE) и 4 байта на длину аутентификационных данных (0).</P>
    <P>В переданном ответе (взгляните на рис. 16.7, но помните, что используется протокол TCP, поэтому 4 байта флага и длины будут идти перед XID) будет восемь 4-байтовых полей, начиная с поля флага и длины и заканчивая результатом типа long. Вместе они дают 32 байта.</P>
    <P>При использовании UDP единственное отличие будет заключаться в отсутствии поля флага и длины (4 байта). При этом размер запроса будет 44 байта, а ответа — 28 байтов, что можно проверить с помощью tcpdump.</P>
    <P>9. Да. Отличие в обработке аргументов у клиента и сервера не зависит от пакетов, передаваемых по сети. Функция main клиента вызывает функцию заглушки для отправки пакета, а функция main сервера вызывает функцию заглушки сервера для обработки этого пакета. Передаваемая по сети запись RPC определяется протоколом RPC, и ее содержимое остается неизменным вне зависимости от того, поддерживается ли многопоточность.</P>
    <P>10. Библиотека XDR выделяет место под эти строки (динамически). Мы можем проверить это, добавив следующую строку к пpoгрaммe read:</P>
    <P><CODE>printf(sbrk()= %p, buff = %p, in.vstring_arg = %p\n", sbrk(NULL), buff, in.vstring_arg);</CODE></P>
    <P>Функция sbrk возвращает текущий адрес вершины сегмента данных программы, а функция malloc обычно выделяет память непосредственно под этим адресом. Запустив программу, получим:</P>
    <P><CODE>sbrk() = 29638, buff = 25е48, in.vstring_arg = 27e58</CODE></P>
    <P>Это показывает, что указатель vstring_arg указывает на область, выделенную mallос. Буфер buff размером 8192 байта занимает адреса с 0х25е48 по 0х27е47, а строка помещается непосредственно под ним.</P>
    <P>11. В листинге Г.11 приведен текст программы-клиента. Обратите внимание, что последним аргументом clnt_call является сама структура timeval, а не указатель на нее. Также отметьте, что третий и пятый аргументы clnt_call должныбыть ненулевыми указателями на подпрограммы XDR, поэтому мы указываем в этих аргументах xdr_void (функция, которая ничего не делает). Вы можете проверить, что именно так нужно вызывать функцию без аргументов и возвращаемых значений, написав тривиальный файл спецификации RPC, определяющий такую функцию, запустив rpcgen и посмотрев на содержимое созданной заглушки клиента.</P>
    <H2><a name=label933 style="border:none;"></a>Листинг Г.11. Клиент, вызывающий нулевую процедуру сервера</H2>
    <P><CODE>//sunrpc/square10/client.c</CODE></P>
    <P><CODE>1  #include "unpipc.h" /* our header */</CODE></P>
    <P><CODE>2  #include "square.h" /* generated by rpcgen */</CODE></P>
    <BR>
    <P><CODE>3  int</CODE></P>
    <P><CODE>4  main(int argc, char **argv)</CODE></P>
    <P><CODE>5  {</CODE></P>
    <P><CODE>6   CLIENT *cl;</CODE></P>
    <P><CODE>7   struct timeval tv;</CODE></P>
    <P><CODE>8   if (argc != 3)</CODE></P>
    <P><CODE>9    err_quit("usage: client &lt;hostname&gt; &lt;protocol&gt;");</CODE></P>
    <P><CODE>10  cl = Clnt_create(argv[1], SQUARE_PROG, SQUARE_VERS, argv[2]);</CODE></P>
    <P><CODE>11  tv.tv_sec = 10;</CODE></P>
    <P><CODE>12  tv.tv_usec = 0;</CODE></P>
    <P><CODE>13  if (clnt_call(cl, NULLPROC, xdr_void, NULL,</CODE></P>
    <P><CODE>14   xdr_void, NULL, tv) != RPC_SUCCESS)</CODE></P>
    <P><CODE>15  err_quit("%s", clnt_sperror(cl, argv[1]));</CODE></P>
    <P><CODE>16  exit(0);</CODE></P>
    <P><CODE>17 }</CODE></P>
    <P>12. Получающийся размер дейтаграммы UDP (65536+20+дополнительные расходы RPC) превосходит 65535 — максимальный размер дейтаграммы в IPv4. В табл. А.2 отсутствуют значения для Sun RPC с использованием UDP для сообщений размером 16384 и 32768, поскольку старая реализация RPCSRC 4.0 ограничивала размер дейтаграммы UDP некоторым значением около 9000 байт.</P>
   </DIV>
  </DIV>
  <DIV class=section>
   <H1>
    <P><a name=label934 style="border:none;"></a>Литература</P>
   </H1>
   <P>Для книг, статей и других источников, имеющих электронные версии, указаны адреса сайтов. Они могут меняться, поэтому следите за списком обновлений на сайте автора книги http://www.kohala.com/~rstevens.</P>
   <P>1. <EM>Bach M.J.</EM> The Design of the UNIX Operating System //Prentice Hall, Englewood Cliffs, N.J., 1986.</P>
   <P>2. <EM>Birrell A. D., Nelson B.J.</EM> Implementing Remote Procedure Calls //ACM Transactions on Computer Systems, vol. 2, no. 1, pp. 39-59 (Feb.), 1984.</P>
   <P>3. <EM>Butenhorf D. R.</EM> Programming with POSIX Threads //Addison-Wesley, Reading, Mass, 1997.</P>
   <P>4. <EM>Corbin J. R.</EM> The Art of Distributed Applications: Programming Techniques for Remote Procedure Calls //Springer-Verlag, New-York, 1991.</P>
   <P>5. <EM>Garfinkel S. L, Spafford E. H.</EM> Practical UNIX and Internet Security, Second Edition //O'Reilly &amp; Associates, Sebastopol, Calif, 1996.</P>
   <P>6. <EM>GoodheartВ.,Cox J.</EM> The Magi Garden Explained: The Internals of UNIX System V Release 4, An Open Systems Design //Prentice Hall, Englewood Cliffs, N.J., 1994.</P>
   <P>7. <EM>Hamilton. G., Kougiouris P.</EM> The Spring Nucleus: A Mikrokernel for Objects // Proceedings of the 1993 Summer USENIX Conference, pp. 147-159, Cincinnati Oh, 1993.</P>
   <P>http://www.kohala.com/~rstevens/papers.others/springnucleus.1993.ps</P>
   <P>8. IEEE 1996. Information Technology — Portable Operating System Interface (POSIX) – Part 1: System Application Program Interface (API) //IEEE Std 1003.1, 1996 Edition, Insitute of Electrical and Electonics Enibeers, Piscataway, N.J. (July).</P>
   <P>Данная версия Posix.1 (называемая также ISO/IEC 9945-1: 1996) содержит базовый интерфейс API (1990), расширения реального времени 1003.1b (1993), программные потоки Pthreads 1003.1с (1995) и технические поправки 1003.1i (1995). Чтобы сделать заказ, обратитесь на сайт http://www.ieee.org. К сожалению, стандарты IEEE не распространяются свободно через Интернет.</P>
   <P>9. <EM>Josey A.</EM> Go Solo 2: The Authorized Guide to Version 2 of the Single UNIX Specification //Prentice Hall, Upper Saddle River, N. J., ed. 1997.</P>
   <P>По адресу http://www.UNIX-systems.org/online.html можно найти множество спецификаций Unix (например, все технические руководства).</P>
   <P>10. <EM>Kernighan В.W., Pike R.</EM> The UNIX Programming Environment //Prentice Hall, Englewood Cliffs, N. J., 1984.11.       </P>
   <P>11. <EM>KernighanВ.W., Ritchie D. M.</EM> The С Programming Language, Second Edition // Prentice Hall, Englewood Cliffs, N.J., 1988.</P>
   <P>12. <EM>Kleiman S., Shah D., Smaalders B.</EM> Programming with Threads //Prentice Hall, Upper Saddle River, N. J., 1996.</P>
   <P>13. <EM>LewisВ., Berg D.J.</EM> Multithreaded Programming with Pthreads //Prentice Hall, Upper Saddle River, N. J., 1998.</P>
   <P>14. <EM>McKusick M. K., Bostic K., Karels M.J., Quaterman J. S.</EM> The Design and Implementation of the 4.4BSD Operating System //Addison-Wesley, Reading, Mass, 1996.</P>
   <P>15. <EM>McVoy L, Staelin С.</EM> lmbench: Portable Tools for Performance Analysis //Proceedings of the 1996 Winter Technical Conference, pp. 279-294, San Diego, Calif, 1996.</P>
   <P>Комплект средств для тестирования можно загрузить с сайта http:// www.bitmover.com/lmbench вместе с книгой.</P>
   <P>16. <EM>Rochkind M.J.</EM> Advanced UNIX Programming //Prentice Hall, Englewood Cliffs, N.J., 1985.</P>
   <P>17. <EM>Salus P. H.</EM> A Quarter Century of Unix //Addison-Wesley, Reading, Mass, 1994.</P>
   <P>18. <EM>Srinivasan R.</EM> RPC: Remote Procedure Call Protocol Specification Version 2 // RFC 1831, 18 pages (Aug.), 1995.</P>
   <P>19. <EM>Srinivasan R.</EM> XDR: External Data Representation Standard //RFC 1832, 24 pages (Aug.), 1995.</P>
   <P>20. <EM>Srinivasan R.</EM> Binding Protocols foe ONC RPC Version 2 //RFC 1833, 14 pages (Aug.), 1995.</P>
   <P>21. <EM>Stevens W. R.</EM> Advanced Programming in the UNIX Environment //Addison-Wesley, Reading, Mass, 1992.</P>
   <P>22. <EM>Stevens W. R.</EM> TCP/IP Illustrated, Volume 1: The Protocols //Addison-Wesley, Reading, Mass, 1994.</P>
   <P>23. <EM>Stevens W. R.</EM> TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP, and the UNIX Domain Protocols //Addison-Wesley, Reading, Mass, 1996.</P>
   <P>24. <EM>Stevens W. R.</EM> UNIX Network Programming, Volume 1, Second Edition, Networking APIs: Sockets and XTI //Prentice Hall, Upper Saddle River, N.J., 1998.</P>
   <P>25. <EM>Vahalia U.</EM> UNIX Internals: The New Frontiers //Prentice Hall, Upper Saddle River, N.J., 1996.</P>
   <P>26. <EM>White J. E.</EM> A High-Level Framework for Network-Based Resource Sharing // RFC 707, 27 pages (Dec), 1975.</P>
   <P>http://www.kohala.com/~rstevens/papers.others/rfc707.txt</P>
   <P>27. <EM>Wright G. R., Stevens W. R.</EM> TCP/IP Illustrated, Volume 2: The Implementation // Addison-Wesley, Reading, Mass, 1995.</P>
  </DIV>
 </DIV><DIV class=bookbody>
  <H1>
   <P><a name=label935 style="border:none;"></a>Примечания</P>
  </H1>
  <DIV class=section ID=n_1 >
   <H1>
    <P>1</P>
   </H1>
   <P>Все исходные тексты, опубликованные в этой книге, вы можете найти по адресу http://www.piter.com/download.</P>
  </DIV>
  <DIV class=section ID=n_2 >
   <H1>
    <P>2</P>
   </H1>
   <P>Проблема о порядке байтов в слове сродни проблеме лилипутов из «Путешествий Гулливера» Д. Свифта, которые никак не могли договориться, с какого конца начинать есть яйцо. Именно оттуда англоязычные программисты взяли термины little-endian (остроконечник) и big-endian (тупоконечник), подразумевая «little-end-first» и «big-end-first» (младший или старший байт идет первым). — <EM>Примеч. перев.</EM></P>
  </DIV>
 </DIV><br><center><script type="text/javascript"><!--
google_ad_client = "pub-0321943928525350";
/* 728x90, bookreader */
google_ad_slot = "0629089296";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<br></center><hr size=1><form name=bookfooter><div id=bookfooterid class=bookfooter><a href="http://www.e-reading.ws/">на главную</a> | <a href="http://www.e-reading.ws/listbooks.php?list=4" rel="nofollow">моя полка</a> | <a rel="author" href="http://www.e-reading.ws/bookbyauthor.php?author=51353">Стивенс Уильям</a> | <a href="http://www.e-reading.ws/book.php?book=148368">UNIX: взаимодействие процессов</a> <span id="scrollpercent"></span> | <select name=contents onchange="GotoContent();">
<option value=0>Содержание</option>
<option value=1>Уильям Стивенс UNIX: взаимодействие процессов МАСТЕР-КЛ</option>
<option value=2>Предисловие</option>
<option value=3>Введение</option>
<option value=4>Изменения со времени первого издания</option>
<option value=5>Кому адресована эта книга?</option>
<option value=6>Исходный код и опечатки</option>
<option value=7>Благодарности</option>
<option value=8>Выходные сведения</option>
<option value=9>От издательства</option>
<option value=10>ЧАСТЬ 1 ВВЕДЕНИЕ В IPC UNIX</option>
<option value=11>ГЛАВА 1 Обзор средств взаимодействия процессов Unix</option>
<option value=12>1.1. Введение</option>
<option value=13>1.2. Процессы, потоки и общий доступ к информации</option>
<option value=14>Потоки</option>
<option value=15>1.3. Живучесть объектов IPC</option>
<option value=16>1.4. Пространства имен</option>
<option value=17>1.5. Действие команд fork, exec и exit на объекты IPC</option>
<option value=18>1.6. Обработка ошибок: функции-обертки</option>
<option value=19>Листинг 1.1. Функция-обертка к функции sem_post</option>
<option value=20>Листинг 1.2. Реализация обертки к функции pthread_mutex_lock</option>
<option value=21>Значение errno</option>
<option value=22>1.7. Стандарты Unix</option>
<option value=23>Posix</option>
<option value=24>The Open Group</option>
<option value=25>Версии Unix и переносимость</option>
<option value=26>1.8. Комментарий к примерам IPC</option>
<option value=27>1.9. Резюме</option>
<option value=28>Упражнения</option>
<option value=29>ГЛАВА 2 Posix IPC</option>
<option value=30>2.1. Введение</option>
<option value=31>2.2. Имена IPC</option>
<option value=32>Функция px_ipc_name</option>
<option value=33>Листинг 2.1. Функция px_ipc_name в нашей реализации.</option>
<option value=34>2.3. Создание и открытие каналов IPC</option>
<option value=35>2.4. Разрешения IPC</option>
<option value=36>2.5. Резюме</option>
<option value=37>Упражнения</option>
<option value=38>ГЛАВА 3 System V IPC</option>
<option value=39>3.1. Введение</option>
<option value=40>3.2. Ключи типа key_t и функция ftok</option>
<option value=41>Пример</option>
<option value=42>Листинг 3.1 [1] . Получение и вывод информации о файле и со</option>
<option value=43>3.3. Структура ipc_perm</option>
<option value=44>3.4. Создание и открытие каналов IPC</option>
<option value=45>3.5. Разрешения IPC</option>
<option value=46>3.6. Повторное использование идентификаторов</option>
<option value=47>Листинг 3.2. Вывод идентификатора очереди сообщений дес</option>
<option value=48>3.7. Программы ipcs и ipcrm</option>
<option value=49>3.8. Ограничения ядра</option>
<option value=50>3.9. Резюме</option>
<option value=51>Упражнения</option>
<option value=52>ЧАСТЬ 2 ОБМЕН СООБЩЕНИЯМИ</option>
<option value=53>ГЛАВА 4 Именованные и неименованные каналы</option>
<option value=54>4.1. Введение</option>
<option value=55>4.2. Приложение типа клиент-сервер</option>
<option value=56>4.3. Программные каналы</option>
<option value=57>Пример</option>
<option value=58>Листинг 4.1. Функция main для приложения клиент-сервер, ис</option>
<option value=59>Создание каналов, вызов fork</option>
<option value=60>Использование waitpid дочерним процессом</option>
<option value=61>Листинг 4.2. Функция client для приложения типа клиент-серв</option>
<option value=62>Считывание полного имени из стандартного потока ввода</option>
<option value=63>Копирование из канала в стандартный поток вывода</option>
<option value=64>Листинг 4.3. Функция server для приложения клиент-сервер с </option>
<option value=65>Считывание полного имени файла из канала</option>
<option value=66>Открытие файла, обработка возможной ошибки</option>
<option value=67>Копирование из файла в канал</option>
<option value=68>4.4. Двусторонние каналы</option>
<option value=69>Листинг 4.4. Двусторонняя связь через двусторонний кана</option>
<option value=70>4.5. Функции popen и pclose</option>
<option value=71>Пример</option>
<option value=72>Листинг 4.5. Клиент-сервер с использованием popen</option>
<option value=73>4.6. Именованные каналы (FIFO)</option>
<option value=74>Пример</option>
<option value=75>Листинг 4.6. Функция main приложения клиент-сервер, исполь</option>
<option value=76>Создание двух FIFO</option>
<option value=77>Пример: неродственные клиент и сервер</option>
<option value=78>Листинг 4.7. Функция main независимого сервера</option>
<option value=79>Листинг 4.8. Заголовочный файл fifo.h, используемый и клиен</option>
<option value=80>Листинг 4.9. Функция main независимого клиента</option>
<option value=81>4.7. Некоторые свойства именованных и неименованных кан</option>
<option value=82>4.8. Один сервер, несколько клиентов</option>
<option value=83>Листинг 4.10. Сервер, обслуживающий несколько клиентов с</option>
<option value=84>Создание канала и открытие его только для записи и тол</option>
<option value=85>Считывание запроса от клиента</option>
<option value=86>Анализ запроса клиента</option>
<option value=87>Открытие файла и отправка его в FIFO клиента</option>
<option value=88>Листинг 4.11. Клиент, связывающийся с сервером (листинг 4.</option>
<option value=89>Создание канала</option>
<option value=90>Формирование строки запроса</option>
<option value=91>Открытие канала сервера и отправка запроса</option>
<option value=92>Прием содержимого файла или сообщения об ошибке от сер</option>
<option value=93>Атомарность записи в FIFO</option>
<option value=94>FIFO и NFS</option>
<option value=95>4.9. Последовательные и параллельные серверы</option>
<option value=96>Атака типа «отказ в обслуживании»</option>
<option value=97>4.10. Потоки и сообщения</option>
<option value=98>Листинг 4.12. Структура mymesg и сопутствующие определения</option>
<option value=99>Листинг 4.13. Функция mesg_send</option>
<option value=100>Листинг 4.14. Функция mesg_recv</option>
<option value=101>Листинг 4.15. Функция client с использованием сообщений</option>
<option value=102>Считывание имени файла и отправка его серверу</option>
<option value=103>Считывание содержимого файла или сообщения об ошибке </option>
<option value=104>Листинг 4.16. Функция server, использующая сообщения</option>
<option value=105>Считывание имени файла из канала IPC, открытие файла</option>
<option value=106>Отправка файла клиенту</option>
<option value=107>4.11. Ограничения программных каналов и FIFO</option>
<option value=108>Листинг 4.17. Определение значений PIPE_BUF и OPEN_MAX во время в</option>
<option value=109>4.12. Резюме</option>
<option value=110>Упражнения</option>
<option value=111>ГЛАВА 5 Очереди сообщений Posix</option>
<option value=112>5.1. Введение</option>
<option value=113>5.2. Функции mq_open, mq_close, mq_unlink</option>
<option value=114>Пример: программа mqcreate1</option>
<option value=115>Листинг 5.1. Создание очереди сообщений (указан флаг O_EXCL</option>
<option value=116>Пример: программа mqunlink</option>
<option value=117>Листинг 5.2. Удаление очереди из системы: mqunlink</option>
<option value=118>5.3. Функции mq_getattr и mq_setattr</option>
<option value=119>Пример: программа mqgetattr</option>
<option value=120>Листинг 5.3. Получение и вывод значений атрибутов очере</option>
<option value=121>Пример: программа mqcreate</option>
<option value=122>Листинг 5.4. Усовершенствованная программа mqcreate</option>
<option value=123>5.4. Функции mqsend и mqreceive</option>
<option value=124>Пример: программа mqsend</option>
<option value=125>Листинг 5.5. Программа mqsend</option>
<option value=126>Пример: программа mqreceive</option>
<option value=127>Листинг 5.6. Программа mqreceive</option>
<option value=128>Параметр -n запрещает блокировку</option>
<option value=129>Открытие очереди и получение атрибутов</option>
<option value=130>5.5. Ограничения очередей сообщений</option>
<option value=131>Пример: программа mqsysconf</option>
<option value=132>Листинг 5.7. Получение ограничений очередей с помощью sys</option>
<option value=133>5.6. Функция mq_notify</option>
<option value=134>Пример: простая программа с уведомлением</option>
<option value=135>Листинг 5.8. Отправка sigusr1 при помещении сообщения в пус</option>
<option value=136>Объявление глобальных переменных</option>
<option value=137>Открытие очереди, получение атрибутов, выделение буфе</option>
<option value=138>Установка обработчика сигнала, включение уведомления</option>
<option value=139>Бесконечный цикл</option>
<option value=140>Получение сигнала, считывание сообщения</option>
<option value=141>Сигналы Posix: функции типа Async-Signal-Safe</option>
<option value=142>Пример: уведомление сигналом</option>
<option value=143>Глобальная переменная</option>
<option value=144>Открытие очереди сообщений</option>
<option value=145>Инициализация наборов сигналов</option>
<option value=146>Установка обработчика сигнала, включение уведомления</option>
<option value=147>Листинг 5.9. Обработчик сигнала устанавливает флаг для </option>
<option value=148>Ожидание установки флага обработчиком</option>
<option value=149>Перерегистрация и считывание сообщения</option>
<option value=150>Пример: уведомление сигналом с отключением блокировки</option>
<option value=151>Листинг 5.10. Использование уведомления с помощью сигна</option>
<option value=152>Открытие очереди сообщений в режиме отключенной блоки</option>
<option value=153>Считывание всех сообщений из очереди</option>
<option value=154>Пример: уведомление с использованием sigwait вместо обраб</option>
<option value=155>Листинг 5.11. Использование mq_notify совместно с sigwait</option>
<option value=156>Инициализация набора сигналов и блокировка SIGUSR1</option>
<option value=157>Ожидание сигнала</option>
<option value=158>Пример: очереди сообщений Posix и функция select</option>
<option value=159>Листинг 5.12. Использование уведомления с помощью сигна</option>
<option value=160>Создание канала</option>
<option value=161>Вызов select</option>
<option value=162>Обработчик сигнала</option>
<option value=163>Пример: запуск нового потока</option>
<option value=164>Листинг 5.13. Функция mq_notify, запускающая новый программн</option>
<option value=165>5.7. Сигналы реального времени Posix</option>
<option value=166>Пример</option>
<option value=167>Листинг 5.14. Тестовая программа, иллюстрирующая работу </option>
<option value=168>Вывод номеров сигналов реального времени</option>
<option value=169>Вызов fork и блокирование трех сигналов реального време</option>
<option value=170>Установка обработчика сигнала</option>
<option value=171>Ожидание порождения сигналов родительским процессом, </option>
<option value=172>Родительский процесс отправляет девять сигналов</option>
<option value=173>Обработчик сигнала</option>
<option value=174>Функция signal _rt</option>
<option value=175>Листинг 5.15. Функция signal_rt с поддержкой реального време</option>
<option value=176>Упрощение прототипа функции с использованием typedef</option>
<option value=177>Указание функции-обработчика</option>
<option value=178>Установка SA_SIGINFO</option>
<option value=179>5.8. Реализация с использованием отображения в память</option>
<option value=180>Тип mqd_t</option>
<option value=181>Листинг 5.16. Заголовочный файл mqueue.h</option>
<option value=182>Структура mq_hdr</option>
<option value=183>Структура msg_hdr</option>
<option value=184>Структура mq_info</option>
<option value=185>Макрос MSGSIZE</option>
<option value=186>Функция mq_open</option>
<option value=187>Листинг 5.17. Функция mq_open: первая часть</option>
<option value=188>Обработка списка аргументов переменного размера</option>
<option value=189>Создание новой очереди сообщений</option>
<option value=190>Обработка потенциальной ситуации гонок</option>
<option value=191>Проверка атрибутов</option>
<option value=192>Листинг 5.18. Вторая часть функции mq_open: инициализация но</option>
<option value=193>Установка размера файла</option>
<option value=194>Отображение файла в память</option>
<option value=195>Выделение памяти под структуру mq_info</option>
<option value=196>Инициализация структуры mq_hdr</option>
<option value=197>Инициализация взаимного исключения и условной переме</option>
<option value=198>Сброс бита user-execute</option>
<option value=199>Листинг 5.19. Третья часть функции mq_open: открытие существ</option>
<option value=200>Открытие существующей очереди сообщений</option>
<option value=201>Проверка готовности очереди</option>
<option value=202>Отображение файла в память; создание и инициализация с</option>
<option value=203>Обработка ошибок</option>
<option value=204>Функция mq_close</option>
<option value=205>Листинг 5.20. Функция mq_close</option>
<option value=206>Получение указателей на структуры</option>
<option value=207>Сброс регистрации вызвавшего процесса</option>
<option value=208>Отключение отображения файла и освобождение памяти</option>
<option value=209>Функция mq_unlink</option>
<option value=210>Листинг 5.21. Функция mq_unlink</option>
<option value=211>Функция mq_getattr</option>
<option value=212>Листинг 5.22. Функция mq_getattr</option>
<option value=213>Блокирование взаимного исключения</option>
<option value=214>Функция mq_setattr</option>
<option value=215>Считывание текущих атрибутов</option>
<option value=216>Изменение mq_flags</option>
<option value=217>Листинг 5.23. Функция mq_setattr</option>
<option value=218>Функция mq_notify</option>
<option value=219>Листинг 5.24. Функция mq_notify</option>
<option value=220>Снятие процесса с регистрации</option>
<option value=221>Регистрация вызвавшего процесса</option>
<option value=222>Функция mq_send</option>
<option value=223>Инициализация</option>
<option value=224>Проверка очереди на пустоту и отправка уведомления</option>
<option value=225>Проверка заполненности очереди</option>
<option value=226>Листинг 5.25. Функция mq_send: первая половина</option>
<option value=227>Листинг 5.25. Функция mq_send: вторая половина</option>
<option value=228>Получение индекса свободного блока</option>
<option value=229>Копирование сообщения</option>
<option value=230>Помещение нового сообщения в соответствующее место св</option>
<option value=231>Пробуждение любого процесса, заблокированного в вызов</option>
<option value=232>Функция mq_receive</option>
<option value=233>Проверка полноты очереди</option>
<option value=234>Листинг 5.27.Функция mq_receive: первая половина</option>
<option value=235>Листинг 5.28. Функция mq_receive: вторая половина</option>
<option value=236>Возвращение сообщения вызвавшему процессу</option>
<option value=237>Разблокирование процесса, заблокированного в вызове mq</option>
<option value=238>5.9. Резюме</option>
<option value=239>Упражнения</option>
<option value=240>ГЛАВА 6 Очереди сообщений System V</option>
<option value=241>6.1. Введениеы</option>
<option value=242>6.2. Функция msgget</option>
<option value=243>6.3. Функция msgsnd</option>
<option value=244>6.4. Функция msgrcv</option>
<option value=245>6.5. Функция msgctl</option>
<option value=246>Пример</option>
<option value=247>Листинг 6.1. [1] Пример использования функции msgctl с коман</option>
<option value=248>6.6. Простые примеры</option>
<option value=249>Программа msgcreate</option>
<option value=250>Листинг 6.2. Создание очереди сообщений System V</option>
<option value=251>Программа msgsnd</option>
<option value=252>Листинг 6.3. Помещение сообщения в очередь System V</option>
<option value=253>Программа msgrcv</option>
<option value=254>Листинг 6.4. Считывание сообщения из очереди System V</option>
<option value=255>Программа msgrmid</option>
<option value=256>Листинг 6.5. Удаление очереди сообщений System V</option>
<option value=257>Примеры</option>
<option value=258>Программа msgrcvid</option>
<option value=259>Листинг 6.6. Считывание из очереди сообщений System V с изве</option>
<option value=260>6.7. Пример программы клиент-сервер</option>
<option value=261>Листинг 6.7. Заголовочный файл svmsg.h для программы клиент</option>
<option value=262>Листинг 6.8. Функция main программы-сервера, использующей </option>
<option value=263>Листинг 6.9. Функция main программы-клиента, использующей </option>
<option value=264>Листинг 6.10. Функция mesg_send, работающая с очередью сообще</option>
<option value=265>Листинг 6.11. Функция mesg_recv, работающая с очередью сообще</option>
<option value=266>6.8. Мультиплексирование сообщений</option>
<option value=267>Пример: одна очередь на приложение</option>
<option value=268>Листинг 6.12. Функция main сервера</option>
<option value=269>Листинг 6.13. Функция server</option>
<option value=270>Листинг 6.14. Функция main клиента</option>
<option value=271>Листинг 6.15. Функция client</option>
<option value=272>Пример: одна очередь для каждого клиента</option>
<option value=273>Листинг 6.16. Функция main клиента</option>
<option value=274>Листинг 6.17. Функция client</option>
<option value=275>Установка обработчика сигнала для SIGCHLD</option>
<option value=276>Листинг 6.18. Обработчик сигнала SIGCHLD, вызывающий waitpid</option>
<option value=277>Листинг 6.19. Функция server</option>
<option value=278>Листинг 6.20. Функция-обертка Mesg_recv, обрабатывающая прер</option>
<option value=279>6.9. Использование select и poll с очередями сообщений</option>
<option value=280>6.10. Ограничения, накладываемые на очереди сообщений</option>
<option value=281>Пример</option>
<option value=282>Листинг 6.21. Определение системных ограничений для оче</option>
<option value=283>Определение максимального размера сообщения</option>
<option value=284>Сколько сообщений различного размера может быть помещ</option>
<option value=285>Сколько идентификаторов может быть открыто одновреме</option>
<option value=286>6.11. Резюме</option>
<option value=287>Упражнения</option>
<option value=288>ЧАСТЬ 3 СИНХРОНИЗАЦИЯ</option>
<option value=289>ГЛАВА 7 Взаимные исключения и условные переменные</option>
<option value=290>7.1. Введение</option>
<option value=291>7.2. Взаимные исключения: установка и снятие блокировки</option>
<option value=292>7.3. Схема производитель-потребитель</option>
<option value=293>Листинг 7.1. [1] Функция main</option>
<option value=294>Совместное использование глобальных переменных поток</option>
<option value=295>Аргументы командной строки</option>
<option value=296>Установка уровня параллельности</option>
<option value=297>Создание процессов-производителей</option>
<option value=298>Ожидание завершения работы производителей, запуск пот</option>
<option value=299>Листинг 7.2. Функции produce и consume</option>
<option value=300>Формирование данных</option>
<option value=301>Потребитель проверяет содержимое массива</option>
<option value=302>7.4. Блокировка и ожидание</option>
<option value=303>Листинг 7.3. Функция main: запуск потребителя сразу после </option>
<option value=304>Листинг 7.4. Функции consume и consume_wait</option>
<option value=305>Потребитель должен ждать</option>
<option value=306>Ожидание производителей</option>
<option value=307>7.5. Условные переменные: ожидание и сигнализация</option>
<option value=308>Переменные производителя и взаимное исключение объед</option>
<option value=309>Листинг 7.5. Глобальные переменные: использование услов</option>
<option value=310>Листинг 7.6. Функции produce и consume</option>
<option value=311>Помещение очередного элемента в массив</option>
<option value=312>Уведомление потребителя</option>
<option value=313>Потребитель ждет, пока значение nready.nready не станет отли</option>
<option value=314>Исключение конфликтов блокировок</option>
<option value=315>7.6. Условные переменные: время ожидания и широковещате</option>
<option value=316>7.7. Атрибуты взаимных исключений и условных переменных</option>
<option value=317>Завершение процесса, заблокировавшего ресурс</option>
<option value=318>7.8. Резюме</option>
<option value=319>Упражнения</option>
<option value=320>ГЛАВА 8 Блокировки чтения-записи</option>
<option value=321>8.1. Введение</option>
<option value=322>8.2. Получение и сброс блокировки чтения-записи</option>
<option value=323>8.3. Атрибуты блокировки чтения-записи</option>
<option value=324>8.4. Реализация с использованием взаимных исключений и </option>
<option value=325>Тип данных pthread_rwlock_t</option>
<option value=326>Листинг 8.1. Определение типа данных pthread_rwlock_t</option>
<option value=327>Функция pthread_rwlock_init</option>
<option value=328>Листинг 8.2. Функция pthread_rwlock_init: инициализация блокиров</option>
<option value=329>Функция pthread_rwlock destroy</option>
<option value=330>Листинг 8.З. Функция pthread_rwlock_destroy: уничтожение блокиров</option>
<option value=331>Функция pthread_rwlock_rdlock</option>
<option value=332>Листинг 8.4. Функция pthread_rwlock_rdlock: получение блокировки н</option>
<option value=333>Функция pthread_rwlock_tryrdlock</option>
<option value=334>Листинг 8.5. Функция pthread_rwlock_tryrdlock: попытка заблокироват</option>
<option value=335>Функция pthread_rwlock_wrlock</option>
<option value=336>Листинг 8.6. Функция pthread_rwlock_wrlock: получение блокировки н</option>
<option value=337>Функция pthread_rwlock_trywrlock</option>
<option value=338>Листинг 8.7. Функция pthread_rwlock_trywrlock: попытка получения бл</option>
<option value=339>Функция pthread _rwlock_unlock</option>
<option value=340>Листинг 8.8. Функция pthread_rwlock_unlock: разблокирование ресур</option>
<option value=341>8.5. Отмена выполнения потоков</option>
<option value=342>Пример</option>
<option value=343>Создание двух потоков</option>
<option value=344>Ожидание завершения потоков</option>
<option value=345>Листинг 8.9. Тестовая программа, иллюстрирующая отмену </option>
<option value=346>Функция thread1</option>
<option value=347>Функция thread2</option>
<option value=348>Листинг 8.10. Функция rwlock_cancelrdwait: обработчик для блокиро</option>
<option value=349>Листинг 8.11. Функция rwlock_cancelwrwait: обработчик для блокиро</option>
<option value=350>8.6. Резюме</option>
<option value=351>Упражнения</option>
<option value=352>ГЛАВА 9 Блокирование записей</option>
<option value=353>9.1. Введение</option>
<option value=354>Листинг 9.1. Функции, не осуществляющие блокировку</option>
<option value=355>Листинг 9.2. Функция main для примеров с блокировкой файла</option>
<option value=356>9.2. Блокирование записей и файлов</option>
<option value=357>История</option>
<option value=358>9.3. Блокирование записей с помощью fcntl по стандарту Posix</option>
<option value=359>Пример</option>
<option value=360>Листинг 9.3. Блокировка записей fcntl по стандарту Posix</option>
<option value=361>Пример: упрощение с помощью макросов</option>
<option value=362>Листинг 9.4. Вызов fcntl для получения и снятия блокировки</option>
<option value=363>Листинг 9.5. Вызов fcntl для проверки состояния блокировки</option>
<option value=364>9.4. Рекомендательная блокировка</option>
<option value=365>Пример: несотрудничающие процессы</option>
<option value=366>9.5. Обязательная блокировка</option>
<option value=367>Пример</option>
<option value=368>9.6. Приоритет чтения и записи</option>
<option value=369>Пример: блокировка на чтение при наличии в очереди бло</option>
<option value=370>Листинг 9.6. Определение возможности установки блокиро</option>
<option value=371>Родительский процесс открывает файл и получает блокир</option>
<option value=372>Первый дочерний процесс</option>
<option value=373>Второй дочерний процесс</option>
<option value=374>Родительский процесс блокирует ресурс 5 секунд</option>
<option value=375>Пример: имеют ли приоритет запросы на запись перед зап</option>
<option value=376>Листинг 9.7. Есть ли у писателей приоритет перед читател</option>
<option value=377>Родительский процесс создает файл и устанавливает бло</option>
<option value=378>Первый дочерний процесс</option>
<option value=379>Второй дочерний процесс</option>
<option value=380>9.7. Запуск единственного экземпляра демона</option>
<option value=381>Листинг 9.8. Гарантия выполнения единственного экземпл</option>
<option value=382>Открытие и блокирование файла</option>
<option value=383>Запись идентификатора процесса в файл</option>
<option value=384>9.8. Блокирование файлов</option>
<option value=385>Листинг 9.9. Функции блокировки с использованием open с фл</option>
<option value=386>9.9. Блокирование в NFS</option>
<option value=387>9.10. Резюме</option>
<option value=388>Упражнения</option>
<option value=389>ГЛАВА 10 Семафоры Posix</option>
<option value=390>10.1. Введение</option>
<option value=391>Листинг 10.1. Сравнение бинарных семафоров и взаимных ис</option>
<option value=392>Листинг 10.2. Псевдокод для задачи производителя и потре</option>
<option value=393>10.2. Функции sem_open, sem_close и sem_unlink</option>
<option value=394>10.3. Функции sem_wait и sem_trywait</option>
<option value=395>10.4. Функции sem_post и sem_getvalue</option>
<option value=396>10.5. Простые примеры</option>
<option value=397>Программа semcreate</option>
<option value=398>Листинг 10.3. [1] Создание именованного семафора</option>
<option value=399>Создание семафора</option>
<option value=400>Закрытие семафора</option>
<option value=401>Программа semunlink</option>
<option value=402>Листинг 10.4. Удаление именованного семафора</option>
<option value=403>Программа semgetvalue</option>
<option value=404>Листинг 10.5. Получение и вывод значения семафора</option>
<option value=405>Открытие семафора</option>
<option value=406>Программа semwait</option>
<option value=407>Листинг 10.6. Ожидание изменения значения семафора и выв</option>
<option value=408>Программа sempost</option>
<option value=409>Листинг 10.7. Увеличение значения семафора</option>
<option value=410>Примеры</option>
<option value=411>10.6. Задача производителей и потребителей</option>
<option value=412>Листинг 10.8. Функция main для решения задачи производител</option>
<option value=413>Глобальные переменные</option>
<option value=414>Создание семафоров</option>
<option value=415>Создание двух потоков</option>
<option value=416>Листинг 10.9. Функции produce и consume</option>
<option value=417>Производитель ожидает освобождения места в буфере</option>
<option value=418>Производитель помещает элемент в буфер</option>
<option value=419>Потребитель ожидает изменения семафора nstored</option>
<option value=420>Зависание</option>
<option value=421>10.7. Блокирование файлов</option>
<option value=422>Листинг 10.10. Блокирование файла с помощью именованных </option>
<option value=423>10.8. Функции sem_init и sem_destroy</option>
<option value=424>Пример</option>
<option value=425>Листинг 10.11. Задача производителей и потребителей с ис</option>
<option value=426>Выделение семафоров</option>
<option value=427>Вызов sem_init</option>
<option value=428>10.9. Несколько производителей, один потребитель</option>
<option value=429>Листинг 10.12. Функция main задачи с несколькими производи</option>
<option value=430>Глобальные переменные</option>
<option value=431>Общая структура</option>
<option value=432>Новые аргументы командной строки</option>
<option value=433>Запуск всех потоков</option>
<option value=434>Листинг 10.13. Функция, выполняемая всеми потоками-произ</option>
<option value=435>Взаимное исключение между потоками-производителями</option>
<option value=436>Завершение производителей</option>
<option value=437>Листинг 10.14. Функция, выполняемая потоком-потребителем</option>
<option value=438>10.10. Несколько производителей, несколько потребителей</option>
<option value=439>Листинг 10.15. Глобальные переменные</option>
<option value=440>Глобальные переменные и общая структура</option>
<option value=441>Листинг 10.16. Функция main для версии с несколькими произв</option>
<option value=442>Листинг 10.17. Функция, выполняемая всеми потоками-потре</option>
<option value=443>Завершение потоков-потребителей</option>
<option value=444>10.11. Несколько буферов</option>
<option value=445>Листинг 10.18. Глобальные переменные и функция main</option>
<option value=446>Объявление нескольких буферов</option>
<option value=447>Открытие входного файла</option>
<option value=448>Листинг 10.19. Функции produce и consume</option>
<option value=449>Пустая критическая область</option>
<option value=450>Считывание данных и увеличение семафора nstored</option>
<option value=451>Поток-потребитель</option>
<option value=452>10.12. Использование семафоров несколькими процессами</option>
<option value=453>10.13. Ограничения на семафоры</option>
<option value=454>Пример: программа semsysconf</option>
<option value=455>Листинг 10.20. Вызов sysconf для получения ограничений на се</option>
<option value=456>10.14. Реализация с использованием FIFO</option>
<option value=457>Листинг 10.21. Заголовочный файл semaphore.h</option>
<option value=458>Тип данных sem_t</option>
<option value=459>Функция sem_open</option>
<option value=460>Листинг 10.22. Функция sem_open</option>
<option value=461>Создание нового sсемафора</option>
<option value=462>Создание нового канала FIFO</option>
<option value=463>Выделение памяти под тип sem_t и открытие FIFO на чтение и з</option>
<option value=464>Инициализация значения созданного семафора</option>
<option value=465>Функция sem_close</option>
<option value=466>Листинг 10.23. Функция sem_close</option>
<option value=467>Функция sem_unlink</option>
<option value=468>Листинг 10.24. Функция sem_unlink</option>
<option value=469>Функция sem_post</option>
<option value=470>Листинг 10.25. Функция sem_post</option>
<option value=471>Функция sem_wait</option>
<option value=472>Листинг 10.26. Функция sem_wait</option>
<option value=473>10.15. Реализация с помощью отображения в память</option>
<option value=474>Тип sem_t</option>
<option value=475>Листинг 10.27. Заголовочный файл semaphore.h</option>
<option value=476>Функция sem_open</option>
<option value=477>Листинг 10.28. Функция sem_open: первая половина</option>
<option value=478>Работа со списком аргументов переменной длины</option>
<option value=479>Создание нового семафора и обработка потенциальной си</option>
<option value=480>Установка размера файла</option>
<option value=481>Отображение содержимого файла в память</option>
<option value=482>Инициализация структуры sem_t</option>
<option value=483>Инициализация значения семафора</option>
<option value=484>Сброс бита user-execute</option>
<option value=485>Листинг 10.29. Функция sem_open: вторая половина</option>
<option value=486>Открытие существующего семафора</option>
<option value=487>Удостоверимся, что семафор проинициализирован</option>
<option value=488>Возврат кодов ошибок</option>
<option value=489>Функция sem_close</option>
<option value=490>Листинг 10.30. Функция sem_close</option>
<option value=491>Функция sem_unlink</option>
<option value=492>Листинг 10.31. Функция sem_unlink</option>
<option value=493>Функция sem_post</option>
<option value=494>Листинг 10.32. Функция sem_post</option>
<option value=495>Функция sem_wait</option>
<option value=496>Листинг 10.33. Функция sem_wait</option>
<option value=497>Функция sem_trywait</option>
<option value=498>Листинг 10.34. Функция sem_trywait</option>
<option value=499>Функция sem_getvalue</option>
<option value=500>Листинг 10.35. Функция sem_getvalue</option>
<option value=501>10.16. Реализация с использованием семафоров System V</option>
<option value=502>Листинг 10.36. Заголовочный файл semaphore.h</option>
<option value=503>Тип данных sem_t</option>
<option value=504>Функция sem_open</option>
<option value=505>Листинг 10.37. Функция sem_open: первая часть</option>
<option value=506>Создание нового семафора и работа со списком аргумент</option>
<option value=507>Создание вспомогательного файла и преобразование пол</option>
<option value=508>Создание набора семафоров System V с одним элементом</option>
<option value=509>Инициализация семафора</option>
<option value=510>Проверка начального значения</option>
<option value=511>Листинг 10.38. Функция sem_open: вторая половина</option>
<option value=512>Открытие существующего семафора</option>
<option value=513>Ожидание инициализации семафора</option>
<option value=514>Возврат кода ошибки</option>
<option value=515>Выделение памяти под sem_t</option>
<option value=516>Функция sem_close</option>
<option value=517>Листинг 10.39. Функция sem_close</option>
<option value=518>Функция sem_unlink</option>
<option value=519>Листинг 10.40. Функция sem_unlink</option>
<option value=520>Получение ключа System V по полному имени</option>
<option value=521>Функция sem_post</option>
<option value=522>Листинг 10.41. Функция sem_post</option>
<option value=523>Функция sem_wait</option>
<option value=524>Листинг 10.42. Функция sem_wait</option>
<option value=525>Функция sem_trywait</option>
<option value=526>Листинг 10.43. Функция sem_trywait</option>
<option value=527>Функция sem_getvalue</option>
<option value=528>Листинг 10.44. Функция sem_getvalue</option>
<option value=529>10.17. Резюме</option>
<option value=530>Упражнения</option>
<option value=531>ГЛАВА 11 Семафоры System V</option>
<option value=532>11.1. Введение</option>
<option value=533>11.2. Функция semget</option>
<option value=534>Инициализация значения семафора</option>
<option value=535>11.3. Функция semop</option>
<option value=536>11.4. Функция semctl</option>
<option value=537>11.5. Простые программы</option>
<option value=538>Программа semcreate</option>
<option value=539>Листинг 11.1. Программа semcreate</option>
<option value=540>Программа semrmid</option>
<option value=541>Листинг 11.2. Программа semrmid</option>
<option value=542>Программа semsetvalues</option>
<option value=543>Получение количества семафоров в наборе</option>
<option value=544>Установка всех значений</option>
<option value=545>Листинг 11.3. Программа semsetvalues</option>
<option value=546>Программа semgetvalues</option>
<option value=547>Получение количества семафоров в наборе</option>
<option value=548>Получение всех значений</option>
<option value=549>Листинг 11.4. Программа semgetvalues</option>
<option value=550>Программа semops</option>
<option value=551>Параметры командной строки</option>
<option value=552>Выделение памяти под набор операций</option>
<option value=553>Выполнение операций</option>
<option value=554>Листинг 11.5. Программа semops</option>
<option value=555>Примеры</option>
<option value=556>11.6. Блокирование файлов</option>
<option value=557>Листинг 11.6. Блокировка файлов с помощью семафоров System V</option>
<option value=558>Попытка исключающего создания</option>
<option value=559>Семафор уже существует, мы его открываем</option>
<option value=560>Ожидание инициализации семафора</option>
<option value=561>Инициализация структур sembuf</option>
<option value=562>11.7. Ограничения семафоров System V</option>
<option value=563>Пример</option>
<option value=564>Листинг 11.7. Определение системных ограничений на сема</option>
<option value=565>11.8. Резюме</option>
<option value=566>Упражнения</option>
<option value=567>ЧАСТЬ 4 РАЗДЕЛЯЕМАЯ ПАМЯТЬ</option>
<option value=568>ГЛАВА 12 Введение в разделяемую память</option>
<option value=569>12.1. Введение</option>
<option value=570>Листинг 12.1. Увеличение глобального счетчика родительс</option>
<option value=571>Создание и инициализация семафора</option>
<option value=572>Отключение буферизации стандартного потока вывода и в</option>
<option value=573>12.2. Функции mmap, munmap и msync</option>
<option value=574>Почему вообще используется отображение в память?</option>
<option value=575>12.3. Увеличение счетчика в отображаемом в память файле</option>
<option value=576>Листинг 12.2. Родительский и дочерний процессы увеличив</option>
<option value=577>Новый аргумент командной строки</option>
<option value=578>Вызов mmap и закрытие дескриптора</option>
<option value=579>fork</option>
<option value=580>Листинг 12.3. Счетчик и семафор размещены в разделяемой </option>
<option value=581>Определение структуры, хранящейся в разделяемой памят</option>
<option value=582>Отображаем в память</option>
<option value=583>Инициализация семафора</option>
<option value=584>12.4. Неименованное отображение в память в 4.4BSD</option>
<option value=585>Листинг 12.4. Отображение в память в 4.4BSD</option>
<option value=586>12.5. Отображение в память в SVR4 с помощью /dev/zero</option>
<option value=587>Листинг 12.5. Отображение памяти в SVR4 с помощью /dev/zero</option>
<option value=588>12.6. Обращение к объектам, отображенным в память</option>
<option value=589>Листинг 12.6. Отображение файла: размер файла совпадает </option>
<option value=590>Аргументы командной строки</option>
<option value=591>Создание, открытие, урезание файла; установка его разм</option>
<option value=592>Отображение файла в память</option>
<option value=593>Вывод размера страницы памяти</option>
<option value=594>Чтение и запись в область отображения</option>
<option value=595>Листинг 12.7. Отображение увеличивающегося файла в памя</option>
<option value=596>Открытие файла</option>
<option value=597>Увеличение размера файла</option>
<option value=598>12.7. Резюме</option>
<option value=599>Упражнения</option>
<option value=600>ГЛАВА 13 Разделяемая память Posix</option>
<option value=601>13.1. Введение</option>
<option value=602>13.2. Функции shm_open и shm_unlink</option>
<option value=603>13.3. Функции ftruncate и fstat</option>
<option value=604>13.4. Простые программы</option>
<option value=605>Программа shmcreate</option>
<option value=606>Листинг 13.1. Создание объекта разделяемой памяти Posix ук</option>
<option value=607>Программа shmunlink</option>
<option value=608>Листинг 13.2. Удаление имени объекта разделяемой памяти </option>
<option value=609>Программа shmwrite</option>
<option value=610>Листинг 13.3. Заполнение разделяемой памяти</option>
<option value=611>Программа shmread</option>
<option value=612>Листинг 13.4. Проверка значений в разделяемой памяти</option>
<option value=613>Примеры</option>
<option value=614>Пример</option>
<option value=615>Листинг 13.5. Разделяемая память может начинаться с разн</option>
<option value=616>13.5. Увеличение общего счетчика</option>
<option value=617>Листинг 13.6. Программа, создающая и инициализирующая об</option>
<option value=618>Создание объекта разделяемой памяти</option>
<option value=619>Создание и инициализация семафора</option>
<option value=620>Завершение работы процесса</option>
<option value=621>Листинг 13.7. Программа, увеличивающая значение счетчик</option>
<option value=622>Открытие области разделяемойпамяти</option>
<option value=623>Открытие семафора</option>
<option value=624>Блокирование семафора и увеличение счетчика</option>
<option value=625>13.6. Отправка сообщений на сервер</option>
<option value=626>Листинг 13.8. Заголовочный файл, определяющий содержимо</option>
<option value=627>Основные семафоры и переменные</option>
<option value=628>Счетчик переполнений</option>
<option value=629>Сдвиги сообщений и их содержимое</option>
<option value=630>Листинг 13.9. Сервер, считывающий сообщения из разделяем</option>
<option value=631>Создание объекта разделяемой памяти</option>
<option value=632>Инициализация массива сдвигов</option>
<option value=633>Инициализация семафоров</option>
<option value=634>Ожидание сообщения , вывод его содержимого</option>
<option value=635>Обработка переполнений</option>
<option value=636>Листинг 13.10. Клиент, помещающий сообщения в разделяему</option>
<option value=637>Аргументы командной строки</option>
<option value=638>Открытие и отображение разделяемой памяти</option>
<option value=639>Отправка сообщений</option>
<option value=640>13.7. Резюме</option>
<option value=641>Упражнения</option>
<option value=642>ГЛАВА 14 Разделяемая память System V</option>
<option value=643>14.1. Введение</option>
<option value=644>14.2. Функция shmget</option>
<option value=645>14.3. Функция shmat</option>
<option value=646>14.4. Функция shmdt</option>
<option value=647>14.5. Функция shmctl</option>
<option value=648>14.6. Простые программы</option>
<option value=649>Программа shmget</option>
<option value=650>Листинг 14.1. Создание сегмента разделяемой памяти System V </option>
<option value=651>Программа shmrmid</option>
<option value=652>Листинг 14.2. Удаление сегмента разделяемой памяти system V </option>
<option value=653>Программа shmwrite</option>
<option value=654>Листинг 14.3. Заполнение сегмента разделяемой памяти по</option>
<option value=655>Программа shmread</option>
<option value=656>Листинг 14.4. Проверка значений в сегменте разделяемой п</option>
<option value=657>Примеры</option>
<option value=658>14.7. Ограничения, накладываемые на разделяемую память</option>
<option value=659>Пример</option>
<option value=660>Листинг 14.5. Определение системных ограничений на разд</option>
<option value=661>14.8. Резюме</option>
<option value=662>Упражнение</option>
<option value=663>ЧАСТЬ 5 УДАЛЕННЫЙ ВЫЗОВ ПРОЦЕДУР</option>
<option value=664>ГЛАВА 15 Двери</option>
<option value=665>15.1. Введение</option>
<option value=666>Пример</option>
<option value=667>Листинг 15.1 .Клиент передает серверу длинное целое для </option>
<option value=668>Открываем дверь</option>
<option value=669>Подготовка аргументов и указателя на результат</option>
<option value=670>Вызов процедуры на сервере и вывод результата</option>
<option value=671>Листинг 15.2. Сервер, возводящий длинное целое в квадрат</option>
<option value=672>Процедура сервера</option>
<option value=673>Создание дескриптора двери и связывание с ним файла</option>
<option value=674>Главный поток сервера ничего не делает</option>
<option value=675>15.2. Функция door_call</option>
<option value=676>15.3. Функция door_create</option>
<option value=677>15.4. Функция door_return</option>
<option value=678>15.5. Функция door_cred</option>
<option value=679>15.6. Функция door_info</option>
<option value=680>15.7. Примеры</option>
<option value=681>Функция door_info</option>
<option value=682>Листинг 15.3. Вывод информации о двери</option>
<option value=683>Буфер результатов слишком мал</option>
<option value=684>Листинг 15.4. Вывод адреса полученного результата</option>
<option value=685>Функция door_cred и информация о клиенте</option>
<option value=686>Листинг 15.5. Процедура сервера, получающая информацию о</option>
<option value=687>Автоматическое управление потоками сервера</option>
<option value=688>Листинг 15.6. Процедура сервера, выводящая идентификато</option>
<option value=689>Листинг 15.7. Функция pr_thread_id: возвращает небольшой целоч</option>
<option value=690>Автоматическое управление потоками сервера: нескольк</option>
<option value=691>Листинг 15.8. Заголовочный файл squareproc.h</option>
<option value=692>Листинг 15.9. Заголовочный файл sqrtproc.h</option>
<option value=693>Листинг 15.10. Клиент, вызывающий две процедуры</option>
<option value=694>Листинг 15.11. Две процедуры сервера</option>
<option value=695>Листинг 15.12. Функция main сервера</option>
<option value=696>Атрибут DOOR_UNREF для серверов</option>
<option value=697>Листинг 15.13. Процедура сервера, обрабатывающая специал</option>
<option value=698>Листинг 15.14. Сервер, не закрывающий дескриптор двери</option>
<option value=699>15.8. Передача дескрипторов</option>
<option value=700>Пример</option>
<option value=701>Листинг 15.15. Клиент для сервера, передающего дескрипто</option>
<option value=702>Открываем дверь, считываем полное имя файла</option>
<option value=703>Подготовка аргументов и указателя на буфер возврата</option>
<option value=704>Вызов процедуры сервера и проверка результатов</option>
<option value=705>Считывание дескриптора и копирование файла</option>
<option value=706>Листинг 15.16. Процедура сервера, открывающая файл и возв</option>
<option value=707>Открытие файла для клиента</option>
<option value=708>Успешное открытие файла</option>
<option value=709>15.9. Функция door server_create</option>
<option value=710>Листинг 15.17. Функция main для примера с управлением пулом</option>
<option value=711>Листинг 15.18. Функции управления потоками</option>
<option value=712>Процедура создания сервера</option>
<option value=713>Функция, запускающая поток</option>
<option value=714>Ожидание присваивания дескриптору правильного значен</option>
<option value=715>Отключение отмены потока</option>
<option value=716>Связывание потока с дверью</option>
<option value=717>Делаем поток доступным клиенту</option>
<option value=718>Листинг 15.19. Процедура сервера</option>
<option value=719>15.10. Функции door_bind, door unbind и door_revoke</option>
<option value=720>15.11. Досрочное завершение клиента или сервера</option>
<option value=721>Досрочное завершение сервера</option>
<option value=722>Листинг 15.20. Процедура сервера, завершающая работу сра</option>
<option value=723>Непрерываемость системного вызова door_call</option>
<option value=724>Листинг 15.21. Процедура сервера делает паузу в 6 секунд</option>
<option value=725>Листинг 15.22. Клиент, перехватывающий сигнал SIGCHLD</option>
<option value=726>Идемпотентные и неидемпотентные процедуры</option>
<option value=727>Листинг 15.23. Процедура сервера, выводящая свой идентиф</option>
<option value=728>Листинг 15.24. Клиент, вызывающий door_call еще раз, после пер</option>
<option value=729>Досрочное завершение клиента</option>
<option value=730>Листинг 15.25. Клиент, досрочно завершающий работу после </option>
<option value=731>Листинг 15.26. Процедура сервера, обрабатывающая досрочн</option>
<option value=732>15.12. Резюме</option>
<option value=733>Упражнения</option>
<option value=734>ГЛАВА 16 Пакет Sun RPC</option>
<option value=735>16.1. Введение</option>
<option value=736>Пример</option>
<option value=737>Листинг 16.1. Файл спецификации RPC</option>
<option value=738>Определение аргумента и возвращаемого значения</option>
<option value=739>Определение программы, версии и процедуры</option>
<option value=740>Листинг 16.2. Функция main клиента, делающего удаленный вы</option>
<option value=741>Подключение заголовочного файла, создаваемого rpcgen</option>
<option value=742>Объявление дескриптора клиента</option>
<option value=743>Получение дескриптора клиента</option>
<option value=744>Вызов удаленной процедуры и вывод результата</option>
<option value=745>Листинг 16.3. Процедура сервера, вызываемая с помощью Sun R</option>
<option value=746>Аргументы процедуры</option>
<option value=747>Выполнение и возврат</option>
<option value=748>История</option>
<option value=749>16.2. Многопоточность</option>
<option value=750>Листинг 16.4. Процедура сервера с 5-секундной паузой</option>
<option value=751>Листинг 16.5. Функция main клиента многопоточного сервера</option>
<option value=752>Объявление переменной для помещения результата</option>
<option value=753>Новый аргумент в вызове процедуры</option>
<option value=754>Листинг 16.6. Процедура многопоточного сервера</option>
<option value=755>Новые аргументы и возвращаемое значение</option>
<option value=756>Новая функция, освобождающая память XDR</option>
<option value=757>16.3. Привязка сервера</option>
<option value=758>Inetd и серверы RPC</option>
<option value=759>16.4. Аутентификация</option>
<option value=760>Листинг 16.7. Клиент, осуществляющий аутентификацию unix</option>
<option value=761>Листинг 16.8. Процедура сервера, запрашивающая аутентиф</option>
<option value=762>16.5. Тайм-аут и повторная передача</option>
<option value=763>Листинг 16.9. Клиент, получающий и печатающий значения в</option>
<option value=764>Используемый протокол является аргументом командной </option>
<option value=765>Получение значения общего тайм-аута</option>
<option value=766>Попытка получения тайм-аута повтора</option>
<option value=767>Управление соединением по TCP</option>
<option value=768>Листинг 16.10. Клиент для изучения свойств соединения по </option>
<option value=769>Идентификатор транзакций</option>
<option value=770>Кэш повторных ответов</option>
<option value=771>16.6. Семантика вызовов</option>
<option value=772>16.7. Досрочное завершение сервера или клиента</option>
<option value=773>Досрочное завершение сервера</option>
<option value=774>Досрочное завершение клиента</option>
<option value=775>16.8. XDR: представление внешних данных</option>
<option value=776>Пример: использование XDR без RPC</option>
<option value=777>Листинг 16.11. Файл спецификации XDR</option>
<option value=778>Объявление перечисления и размеченного объединения</option>
<option value=779>Объявление структуры</option>
<option value=780>Листинг 16.12. Заголовочный файл data.h, созданный rpcgen из фа</option>
<option value=781>Листинг 16.13. Инициализация структуры и кодирование ее </option>
<option value=782>Инициализация элементов структуры ненулевыми значени</option>
<option value=783>Выделение буфера</option>
<option value=784>Создание потока XDR в памяти</option>
<option value=785>Кодирование структуры</option>
<option value=786>Получение размера кодированных данных и запись их в по</option>
<option value=787>Листинг 16.14. Считывание структуры data из формата XDR</option>
<option value=788>Выделение правильно расположенного буфера</option>
<option value=789>Создание потока XDR, инициализация буфера, декодировани</option>
<option value=790>Вывод значений полей структуры</option>
<option value=791>Освобождение выделенной под XDR памяти</option>
<option value=792>Пример: вычисление размера буфера</option>
<option value=793>Листинг 16.15. Спецификация XDR для простой структуры</option>
<option value=794>Листинг 16.16. Программа, вычисляющая размер буфера XDR</option>
<option value=795>Пример: необязательные данные</option>
<option value=796>Листинг 16.17. Файл спецификации XDR, иллюстрирующий спосо</option>
<option value=797>Объявление объединения с булевским дискриминантом</option>
<option value=798>Объявление массива переменной длины</option>
<option value=799>Объявление указателя XDR</option>
<option value=800>Листинг 16.18. Заголовочный файл, получившийся в результ</option>
<option value=801>Листинг 16.19. Ни одно из значений не будет закодировано</option>
<option value=802>Присваивание значений</option>
<option value=803>Выделение буфера и кодирование</option>
<option value=804>Вывод содержимого буфера XDR</option>
<option value=805>Листинг 16.20. Присваивание значений аргументам из листи</option>
<option value=806>Присваивание значений</option>
<option value=807>Пример: обработка связного списка</option>
<option value=808>Листинг 16.21. Спецификация XDR для связного списка пар им</option>
<option value=809>Листинг 16.22. Заголовочный файл, созданный программой rpc</option>
<option value=810>Листинг 16.23. Инициализация, кодирование связного списк</option>
<option value=811>Инициализация связного списка</option>
<option value=812>16.9. Форматы пакетов RPC</option>
<option value=813>16.10. Резюме</option>
<option value=814>Упражнения</option>
<option value=815>Эпилог</option>
<option value=816>ПРИЛОЖЕНИЕ А Измерение производительности</option>
<option value=817>А.1. Введение</option>
<option value=818>А.2. Результаты</option>
<option value=819>Результаты измерения полосы пропускания сообщений</option>
<option value=820>Результаты измерения задержки</option>
<option value=821>Результаты синхронизации потоков</option>
<option value=822>Результаты синхронизации процессов</option>
<option value=823>А.З. Измерение полосы пропускания: программы</option>
<option value=824>Измерение полосы пропускания канала</option>
<option value=825>Листинг А.1. Функция main, измеряющая полосу пропускания </option>
<option value=826>Аргументы командной строки</option>
<option value=827>Выделение буфера и помещение начального значения</option>
<option value=828>Создание двух каналов</option>
<option value=829>Вызов fork</option>
<option value=830>Листинг А.2. Функции reader и writer</option>
<option value=831>Функция writer</option>
<option value=832>Функция reader</option>
<option value=833>Листинг А.З. Функции start_sime, stop_time и touch</option>
<option value=834>Листинг А.4. Функция tv_sub: вычитание двух структур timeval</option>
<option value=835>Измерение полосы пропускания очереди сообщений Posix</option>
<option value=836>Листинг А.5. Функция main для измерения полосы пропускани</option>
<option value=837>Листинг А.6. Функции reader и writer</option>
<option value=838>Программа измерения полосы пропускания очереди System V</option>
<option value=839>Листинг А.7. Функция main для измерения полосы пропускани</option>
<option value=840>Листинг А.8. Функции reader и writer</option>
<option value=841>Программа измерения полосы пропускания дверей</option>
<option value=842>Листинг А.9. Функция main измерения полосы пропускания ин</option>
<option value=843>Листинг A.10. Функции writer, server, reader для интерфейса дверей</option>
<option value=844>Программа определения полосы пропускания Sun RPC</option>
<option value=845>Листинг А.11. Спецификация RPC для измерения полосы пропу</option>
<option value=846>Листинг A.12. Клиент RPC для измерения полосы пропускания</option>
<option value=847>Листинг A.13. Процедура сервера для измерения полосы про</option>
<option value=848>А.4. Измерение задержки передачи сообщений: программы</option>
<option value=849>Программа измерения задержки канала</option>
<option value=850>Листинг А.14. Программа измерения задержки канала</option>
<option value=851>Функция doit</option>
<option value=852>Создание каналов</option>
<option value=853>Дочерний процесс отсылает обратно сообщение</option>
<option value=854>Измерение времени работы родительского процесса</option>
<option value=855>Программа измерения задержки очередей сообщений Posix</option>
<option value=856>Листинг А. 15. Программа измерения задержки для очереди </option>
<option value=857>Измерение задержки очередей сообщений System V</option>
<option value=858>Листинг А.16. Программа измерения времени задержки для </option>
<option value=859>Программа измерения задержки интерфейса дверей</option>
<option value=860>Листинг А.17. Программа измерения задержки интерфейса д</option>
<option value=861>Программа измерения времени задержки Sun RPC</option>
<option value=862>Листинг А.18. Клиент Sun RPC для измерения задержки</option>
<option value=863>А.5. Синхронизация потоков: программы</option>
<option value=864>Взаимные исключения Posix</option>
<option value=865>Листинг А.19. Глобальные переменные и функция main для вза</option>
<option value=866>Общие данные</option>
<option value=867>Блокирование взаимного исключения и создание потоков</option>
<option value=868>Запуск таймера и разблокирование взаимного исключени</option>
<option value=869>Листинг А.20. Функция incr, выполняемая потоками</option>
<option value=870>Увеличение счетчика — критическая область кода</option>
<option value=871>Блокировки чтения-записи</option>
<option value=872>Листинг А.21. Функция main для блокировок чтения-записи</option>
<option value=873>Листинг А.22. Увеличение общего счетчика с использовани</option>
<option value=874>Семафоры Posix, размещаемые в памяти</option>
<option value=875>Листинг А.23. Увеличение счетчика с использованием сема</option>
<option value=876>Листинг А.24. Функция main для семафоров Posix, размещаемых в</option>
<option value=877>Именованные семафоры Posix</option>
<option value=878>Листинг А.25. Увеличение общего счетчика с использовани</option>
<option value=879>Листинг А.26. Функция main для измерения быстродействия и</option>
<option value=880>Семафоры System V</option>
<option value=881>Листинг А.27. Функция main для измерения быстродействия с</option>
<option value=882>Листинг А.28. Увеличение общего счетчика с использовани</option>
<option value=883>Семафоры System V с флагом SEM_UNDO</option>
<option value=884>Блокировка записей fcntl</option>
<option value=885>Листинг А.29. Увеличение общего счетчика с использовани</option>
<option value=886>Листинг А.30. Функция main для измерения производительнос</option>
<option value=887>А.6. Синхронизация процессов: программы</option>
<option value=888>Листинг А.31. Выделение разделяемой памяти под родитель</option>
<option value=889>Взаимные исключения Posix между процессами</option>
<option value=890>Листинг А.32. Функция main для измерения быстродействия в</option>
<option value=891>Листинг А.33. Увеличение счетчика с использованием взаи</option>
<option value=892>ПРИЛОЖЕНИЕ Б Основы многопоточного программирования</option>
<option value=893>Б.1. Введение</option>
<option value=894>Б.2. Основные функции для работы с потоками: создание и </option>
<option value=895>Функция pthread_create</option>
<option value=896>Функция pthread_join</option>
<option value=897>Функция pthread_self</option>
<option value=898>Функция pthread_detach</option>
<option value=899>Функция pthread_exit</option>
<option value=900>ПРИЛОЖЕНИЕ В Вспомогательные исходные коды</option>
<option value=901>В.1. Заголовочный файл unpipc.h</option>
<option value=902>Листинг В.1. Заголовочный файл unpipc.h</option>
<option value=903>B.2. Заголовочный файл config.h</option>
<option value=904>Листинг В.2. Заголовочный файл config.h для Solaris 2.6</option>
<option value=905>В.З. Стандартные функции вывода сообщений об ошибках</option>
<option value=906>Листинг В.3. Функции обработки ошибок</option>
<option value=907>ПРИЛОЖЕНИЕ Г Решения некоторых упражнений</option>
<option value=908>Глава 1</option>
<option value=909>Глава 2</option>
<option value=910>Глава 3</option>
<option value=911>Листинг Г.1. Вывод идентификатора и порядкового номера </option>
<option value=912>Листинг Г.2. Проверка использования маски создания фай</option>
<option value=913>Глава 4</option>
<option value=914>Листинг Г.З. Возвращает ли fstat количество байтов в кана</option>
<option value=915>Листинг Г.4. Что возвращает select при закрытии другого ко</option>
<option value=916>Глава 5</option>
<option value=917>Листинг Г.5. Обертка Select, обрабатывающая возврат EINTR</option>
<option value=918>Глава 6</option>
<option value=919>Глава 7</option>
<option value=920>Глава 9</option>
<option value=921>Глава 10</option>
<option value=922>Листинг Г.6. Возвращает ли sem_wait ошибку EINTR?</option>
<option value=923>Глава 11</option>
<option value=924>Глава 12</option>
<option value=925>Листинг Г.7. Использование select с очередями System V</option>
<option value=926>Глава 13</option>
<option value=927>Листинг Г.8. Отображение с точным указанием размера фай</option>
<option value=928>Листинг Г.9. Отображение в память с возможностью роста </option>
<option value=929>Глава 14</option>
<option value=930>Глава 15</option>
<option value=931>Листинг Г.10. Использование указателя cookie для избавлени</option>
<option value=932>Глава 16</option>
<option value=933>Листинг Г.11. Клиент, вызывающий нулевую процедуру серв</option>
<option value=934>Литература</option>
<option value=935>Примечания</option>
</select>
&nbsp; &nbsp; <img src=http://www.e-reading.ws/images/fg.jpg alt="цвет текста" height=16 onClick="DisplaySettings('fgsettings')" style="vertical-align: bottom;"> <select id=fgsettings name=textcolor onchange="ReaderSettings();" style="display: none;">
<option value=0>цвет текста</option><script type="text/javascript" language="javascript">
document.write('<option style="background-color: #FFFFFF;" value="FFFFFF">White</option>');
document.write('<option style="background-color: #C0C0C0;" value="C0C0C0">Silver</option>');
document.write('<option style="background-color: #808080;" value="808080">Grey</option>');
document.write('<option style="background-color: #000000;" value="000000">Black</option>');
document.write('<option style="background-color: #FF0000;" value="FF0000">Red</option>');
document.write('<option style="background-color: #FFFF00;" value="FFFF00">Yellow</option>');
document.write('<option style="background-color: #808000;" value="808000">Olive</option>');
document.write('<option style="background-color: #00FF00;" value="008000">Lime</option>');
document.write('<option style="background-color: #008000;" value="008000">Green</option>');
document.write('<option style="background-color: #0000FF;" value="0000FF">Blue</option>');
document.write('<option style="background-color: #000080;" value="000080">Navy</option>');

document.write('<option style="background-color: #FFFAFA;" value="FFFAFA">Snow</option><option style="background-color: #F8F8FF;" value="F8F8FF">GhostWhite</option><option style="background-color: #F5F5F5;" value="F5F5F5">WhiteSmoke</option><option style="background-color: #DCDCDC;" value="DCDCDC">Gainsboro</option><option style="background-color: #FFFAF0;" value="FFFAF0">FloralWhite</option><option style="background-color: #FDF5E6;" value="FDF5E6">OldLace</option><option style="background-color: #FAF0E6;" value="FAF0E6">Linen</option><option style="background-color: #FAEBD7;" value="FAEBD7">AntiqueWhite</option><option style="background-color: #FFEFD5;" value="FFEFD5">PapayaWhip</option><option style="background-color: #FFEBCD;" value="FFEBCD">BlanchedAlmond</option><option style="background-color: #FFE4C4;" value="FFE4C4">Bisque</option><option style="background-color: #FFDAB9;" value="FFDAB9">PeachPuff</option><option style="background-color: #FFDEAD;" value="FFDEAD">NavajoWhite</option><option style="background-color: #FFE4B5;" value="FFE4B5">Moccasin</option><option style="background-color: #FFF8DC;" value="FFF8DC">Cornsilk</option><option style="background-color: #FFFFF0;" value="FFFFF0">Ivory</option><option style="background-color: #FFFACD;" value="FFFACD">LemonChiffon</option><option style="background-color: #FFF5EE;" value="FFF5EE">Seashell</option><option style="background-color: #F0FFF0;" value="F0FFF0">Honeydew</option><option style="background-color: #F5FFFA;" value="F5FFFA">MintCream</option><option style="background-color: #F0FFFF;" value="F0FFFF">Azure</option><option style="background-color: #F0F8FF;" value="F0F8FF">AliceBlue</option><option style="background-color: #E6E6FA;" value="E6E6FA">lavender</option><option style="background-color: #FFF0F5;" value="FFF0F5">LavenderBlush</option><option style="background-color: #FFE4E1;" value="FFE4E1">MistyRose</option><option style="background-color: #FFFFFF;" value="FFFFFF">White</option><option style="background-color: #000000;" value="000000">Black</option><option style="background-color: #2F4F4F;" value="2F4F4F">DarkSlateGray</option><option style="background-color: #696969;" value="696969">DimGrey</option><option style="background-color: #708090;" value="708090">SlateGrey</option><option style="background-color: #778899;" value="778899">LightSlateGray</option><option style="background-color: #BEBEBE;" value="BEBEBE">Grey</option><option style="background-color: #D3D3D3;" value="D3D3D3">LightGray</option><option style="background-color: #191970;" value="191970">MidnightBlue</option><option style="background-color: #000080;" value="000080">NavyBlue</option><option style="background-color: #6495ED;" value="6495ED">CornflowerBlue</option><option style="background-color: #483D8B;" value="483D8B">DarkSlateBlue</option><option style="background-color: #6A5ACD;" value="6A5ACD">SlateBlue</option><option style="background-color: #7B68EE;" value="7B68EE">MediumSlateBlue</option><option style="background-color: #8470FF;" value="8470FF">LightSlateBlue</option><option style="background-color: #0000CD;" value="0000CD">MediumBlue</option><option style="background-color: #4169E1;" value="4169E1">RoyalBlue</option><option style="background-color: #0000FF;" value="0000FF">Blue</option><option style="background-color: #1E90FF;" value="1E90FF">DodgerBlue</option><option style="background-color: #00BFFF;" value="00BFFF">DeepSkyBlue</option><option style="background-color: #87CEEB;" value="87CEEB">SkyBlue</option><option style="background-color: #87CEFA;" value="87CEFA">LightSkyBlue</option><option style="background-color: #4682B4;" value="4682B4">SteelBlue</option><option style="background-color: #B0C4DE;" value="B0C4DE">LightSteelBlue</option><option style="background-color: #ADD8E6;" value="ADD8E6">LightBlue</option><option style="background-color: #B0E0E6;" value="B0E0E6">PowderBlue</option><option style="background-color: #AFEEEE;" value="AFEEEE">PaleTurquoise</option><option style="background-color: #00CED1;" value="00CED1">DarkTurquoise</option><option style="background-color: #48D1CC;" value="48D1CC">MediumTurquoise</option><option style="background-color: #40E0D0;" value="40E0D0">Turquoise</option><option style="background-color: #00FFFF;" value="00FFFF">Cyan</option><option style="background-color: #E0FFFF;" value="E0FFFF">LightCyan</option><option style="background-color: #5F9EA0;" value="5F9EA0">CadetBlue</option><option style="background-color: #66CDAA;" value="66CDAA">MediumAquamarine</option><option style="background-color: #7FFFD4;" value="7FFFD4">Aquamarine</option><option style="background-color: #006400;" value="006400">DarkGreen</option><option style="background-color: #556B2F;" value="556B2F">DarkOliveGreen</option><option style="background-color: #8FBC8F;" value="8FBC8F">DarkSeaGreen</option><option style="background-color: #2E8B57;" value="2E8B57">SeaGreen</option><option style="background-color: #3CB371;" value="3CB371">MediumSeaGreen</option><option style="background-color: #20B2AA;" value="20B2AA">LightSeaGreen</option><option style="background-color: #98FB98;" value="98FB98">PaleGreen</option><option style="background-color: #00FF7F;" value="00FF7F">SpringGreen</option><option style="background-color: #7CFC00;" value="7CFC00">LawnGreen</option><option style="background-color: #00FF00;" value="00FF00">Green</option><option style="background-color: #7FFF00;" value="7FFF00">Chartreuse</option><option style="background-color: #00FA9A;" value="00FA9A">MedSpringGreen</option><option style="background-color: #ADFF2F;" value="ADFF2F">GreenYellow</option><option style="background-color: #32CD32;" value="32CD32">LimeGreen</option><option style="background-color: #9ACD32;" value="9ACD32">YellowGreen</option><option style="background-color: #228B22;" value="228B22">ForestGreen</option><option style="background-color: #6B8E23;" value="6B8E23">OliveDrab</option><option style="background-color: #BDB76B;" value="BDB76B">DarkKhaki</option><option style="background-color: #EEE8AA;" value="EEE8AA">PaleGoldenrod</option><option style="background-color: #FAFAD2;" value="FAFAD2">LtGoldenrodYello</option><option style="background-color: #FFFFE0;" value="FFFFE0">LightYellow</option><option style="background-color: #FFFF00;" value="FFFF00">Yellow</option><option style="background-color: #FFD700;" value="FFD700">Gold</option><option style="background-color: #EEDD82;" value="EEDD82">LightGoldenrod</option><option style="background-color: #DAA520;" value="DAA520">goldenrod</option><option style="background-color: #B8860B;" value="B8860B">DarkGoldenrod</option><option style="background-color: #BC8F8F;" value="BC8F8F">RosyBrown</option><option style="background-color: #CD5C5C;" value="CD5C5C">IndianRed</option><option style="background-color: #8B4513;" value="8B4513">SaddleBrown</option><option style="background-color: #A0522D;" value="A0522D">Sienna</option><option style="background-color: #CD853F;" value="CD853F">Peru</option><option style="background-color: #DEB887;" value="DEB887">Burlywood</option><option style="background-color: #F5F5DC;" value="F5F5DC">Beige</option><option style="background-color: #F5DEB3;" value="F5DEB3">Wheat</option><option style="background-color: #F4A460;" value="F4A460">SandyBrown</option><option style="background-color: #D2B48C;" value="D2B48C">Tan</option><option style="background-color: #D2691E;" value="D2691E">Chocolate</option><option style="background-color: #B22222;" value="B22222">Firebrick</option><option style="background-color: #A52A2A;" value="A52A2A">Brown</option><option style="background-color: #E9967A;" value="E9967A">DarkSalmon</option><option style="background-color: #FA8072;" value="FA8072">Salmon</option><option style="background-color: #FFA07A;" value="FFA07A">LightSalmon</option><option style="background-color: #FFA500;" value="FFA500">Orange</option><option style="background-color: #FF8C00;" value="FF8C00">DarkOrange</option><option style="background-color: #FF7F50;" value="FF7F50">Coral</option><option style="background-color: #F08080;" value="F08080">LightCoral</option><option style="background-color: #FF6347;" value="FF6347">Tomato</option><option style="background-color: #FF4500;" value="FF4500">OrangeRed</option><option style="background-color: #FF0000;" value="FF0000">Red</option><option style="background-color: #FF69B4;" value="FF69B4">HotPink</option><option style="background-color: #FF1493;" value="FF1493">DeepPink</option><option style="background-color: #FFC0CB;" value="FFC0CB">Pink</option><option style="background-color: #FFB6C1;" value="FFB6C1">LightPink</option><option style="background-color: #DB7093;" value="DB7093">PaleVioletRed</option><option style="background-color: #B03060;" value="B03060">Maroon</option><option style="background-color: #C71585;" value="C71585">MediumVioletRed</option><option style="background-color: #D02090;" value="D02090">VioletRed</option><option style="background-color: #FF00FF;" value="FF00FF">Magenta</option><option style="background-color: #EE82EE;" value="EE82EE">Violet</option><option style="background-color: #DDA0DD;" value="DDA0DD">Plum</option><option style="background-color: #DA70D6;" value="DA70D6">Orchid</option><option style="background-color: #BA55D3;" value="BA55D3">MediumOrchid</option><option style="background-color: #9932CC;" value="9932CC">DarkOrchid</option><option style="background-color: #9400D3;" value="9400D3">DarkViolet</option><option style="background-color: #8A2BE2;" value="8A2BE2">BlueViolet</option><option style="background-color: #A020F0;" value="A020F0">Purple</option><option style="background-color: #9370DB;" value="9370DB">MediumPurple</option><option style="background-color: #D8BFD8;" value="D8BFD8">Thistle</option><option style="background-color: #FFFAFA;" value="FFFAFA">Snow1</option><option style="background-color: #EEE9E9;" value="EEE9E9">Snow2</option><option style="background-color: #CDC9C9;" value="CDC9C9">Snow3</option><option style="background-color: #8B8989;" value="8B8989">Snow4</option><option style="background-color: #FFF5EE;" value="FFF5EE">Seashell1</option><option style="background-color: #EEE5DE;" value="EEE5DE">Seashell2</option><option style="background-color: #CDC5BF;" value="CDC5BF">Seashell3</option><option style="background-color: #8B8682;" value="8B8682">Seashell4</option><option style="background-color: #FFEFDB;" value="FFEFDB">AntiqueWhite1</option><option style="background-color: #EEDFCC;" value="EEDFCC">AntiqueWhite2</option><option style="background-color: #CDC0B0;" value="CDC0B0">AntiqueWhite3</option><option style="background-color: #8B8378;" value="8B8378">AntiqueWhite4</option><option style="background-color: #FFE4C4;" value="FFE4C4">Bisque1</option><option style="background-color: #EED5B7;" value="EED5B7">Bisque2</option><option style="background-color: #CDB79E;" value="CDB79E">Bisque3</option><option style="background-color: #8B7D6B;" value="8B7D6B">Bisque4</option><option style="background-color: #FFDAB9;" value="FFDAB9">PeachPuff1</option><option style="background-color: #EECBAD;" value="EECBAD">PeachPuff2</option><option style="background-color: #CDAF95;" value="CDAF95">PeachPuff3</option><option style="background-color: #8B7765;" value="8B7765">PeachPuff4</option><option style="background-color: #FFDEAD;" value="FFDEAD">NavajoWhite1</option><option style="background-color: #EECFA1;" value="EECFA1">NavajoWhite2</option><option style="background-color: #CDB38B;" value="CDB38B">NavajoWhite3</option><option style="background-color: #8B795E;" value="8B795E">NavajoWhite4</option><option style="background-color: #FFFACD;" value="FFFACD">LemonChiffon1</option><option style="background-color: #EEE9BF;" value="EEE9BF">LemonChiffon2</option><option style="background-color: #CDC9A5;" value="CDC9A5">LemonChiffon3</option><option style="background-color: #8B8970;" value="8B8970">LemonChiffon4</option><option style="background-color: #FFF8DC;" value="FFF8DC">Cornsilk1</option><option style="background-color: #EEE8CD;" value="EEE8CD">Cornsilk2</option><option style="background-color: #CDC8B1;" value="CDC8B1">Cornsilk3</option><option style="background-color: #8B8878;" value="8B8878">Cornsilk4</option><option style="background-color: #FFFFF0;" value="FFFFF0">Ivory1</option><option style="background-color: #EEEEE0;" value="EEEEE0">Ivory2</option><option style="background-color: #CDCDC1;" value="CDCDC1">Ivory3</option><option style="background-color: #8B8B83;" value="8B8B83">Ivory4</option><option style="background-color: #F0FFF0;" value="F0FFF0">Honeydew1</option><option style="background-color: #E0EEE0;" value="E0EEE0">Honeydew2</option><option style="background-color: #C1CDC1;" value="C1CDC1">Honeydew3</option><option style="background-color: #838B83;" value="838B83">Honeydew4</option><option style="background-color: #FFF0F5;" value="FFF0F5">LavenderBlush1</option><option style="background-color: #EEE0E5;" value="EEE0E5">LavenderBlush2</option><option style="background-color: #CDC1C5;" value="CDC1C5">LavenderBlush3</option><option style="background-color: #8B8386;" value="8B8386">LavenderBlush4</option><option style="background-color: #FFE4E1;" value="FFE4E1">MistyRose1</option><option style="background-color: #EED5D2;" value="EED5D2">MistyRose2</option><option style="background-color: #CDB7B5;" value="CDB7B5">MistyRose3</option><option style="background-color: #8B7D7B;" value="8B7D7B">MistyRose4</option><option style="background-color: #F0FFFF;" value="F0FFFF">Azure1</option><option style="background-color: #E0EEEE;" value="E0EEEE">Azure2</option><option style="background-color: #C1CDCD;" value="C1CDCD">Azure3</option><option style="background-color: #838B8B;" value="838B8B">Azure4</option><option style="background-color: #836FFF;" value="836FFF">SlateBlue1</option><option style="background-color: #7A67EE;" value="7A67EE">SlateBlue2</option><option style="background-color: #6959CD;" value="6959CD">SlateBlue3</option><option style="background-color: #473C8B;" value="473C8B">SlateBlue4</option><option style="background-color: #4876FF;" value="4876FF">RoyalBlue1</option><option style="background-color: #436EEE;" value="436EEE">RoyalBlue2</option><option style="background-color: #3A5FCD;" value="3A5FCD">RoyalBlue3</option><option style="background-color: #27408B;" value="27408B">RoyalBlue4</option><option style="background-color: #0000FF;" value="0000FF">Blue1</option><option style="background-color: #0000EE;" value="0000EE">Blue2</option><option style="background-color: #0000CD;" value="0000CD">Blue3</option><option style="background-color: #00008B;" value="00008B">Blue4</option><option style="background-color: #1E90FF;" value="1E90FF">DodgerBlue1</option><option style="background-color: #1C86EE;" value="1C86EE">DodgerBlue2</option><option style="background-color: #1874CD;" value="1874CD">DodgerBlue3</option><option style="background-color: #104E8B;" value="104E8B">DodgerBlue4</option><option style="background-color: #63B8FF;" value="63B8FF">SteelBlue1</option><option style="background-color: #5CACEE;" value="5CACEE">SteelBlue2</option><option style="background-color: #4F94CD;" value="4F94CD">SteelBlue3</option><option style="background-color: #36648B;" value="36648B">SteelBlue4</option><option style="background-color: #00BFFF;" value="00BFFF">DeepSkyBlue1</option><option style="background-color: #00B2EE;" value="00B2EE">DeepSkyBlue2</option><option style="background-color: #009ACD;" value="009ACD">DeepSkyBlue3</option><option style="background-color: #00688B;" value="00688B">DeepSkyBlue4</option><option style="background-color: #87CEFF;" value="87CEFF">SkyBlue1</option><option style="background-color: #7EC0EE;" value="7EC0EE">SkyBlue2</option><option style="background-color: #6CA6CD;" value="6CA6CD">SkyBlue3</option><option style="background-color: #4A708B;" value="4A708B">SkyBlue4</option><option style="background-color: #B0E2FF;" value="B0E2FF">LightSkyBlue1</option><option style="background-color: #A4D3EE;" value="A4D3EE">LightSkyBlue2</option><option style="background-color: #8DB6CD;" value="8DB6CD">LightSkyBlue3</option><option style="background-color: #607B8B;" value="607B8B">LightSkyBlue4</option><option style="background-color: #C6E2FF;" value="C6E2FF">SlateGray1</option><option style="background-color: #B9D3EE;" value="B9D3EE">SlateGray2</option><option style="background-color: #9FB6CD;" value="9FB6CD">SlateGray3</option><option style="background-color: #6C7B8B;" value="6C7B8B">SlateGray4</option><option style="background-color: #CAE1FF;" value="CAE1FF">LightSteelBlue1</option><option style="background-color: #BCD2EE;" value="BCD2EE">LightSteelBlue2</option><option style="background-color: #A2B5CD;" value="A2B5CD">LightSteelBlue3</option><option style="background-color: #6E7B8B;" value="6E7B8B">LightSteelBlue4</option><option style="background-color: #BFEFFF;" value="BFEFFF">LightBlue1</option><option style="background-color: #B2DFEE;" value="B2DFEE">LightBlue2</option><option style="background-color: #9AC0CD;" value="9AC0CD">LightBlue3</option><option style="background-color: #68838B;" value="68838B">LightBlue4</option><option style="background-color: #E0FFFF;" value="E0FFFF">LightCyan1</option><option style="background-color: #D1EEEE;" value="D1EEEE">LightCyan2</option><option style="background-color: #B4CDCD;" value="B4CDCD">LightCyan3</option><option style="background-color: #7A8B8B;" value="7A8B8B">LightCyan4</option><option style="background-color: #BBFFFF;" value="BBFFFF">PaleTurquoise1</option><option style="background-color: #AEEEEE;" value="AEEEEE">PaleTurquoise2</option><option style="background-color: #96CDCD;" value="96CDCD">PaleTurquoise3</option><option style="background-color: #668B8B;" value="668B8B">PaleTurquoise4</option><option style="background-color: #98F5FF;" value="98F5FF">CadetBlue1</option><option style="background-color: #8EE5EE;" value="8EE5EE">CadetBlue2</option><option style="background-color: #7AC5CD;" value="7AC5CD">CadetBlue3</option><option style="background-color: #53868B;" value="53868B">CadetBlue4</option><option style="background-color: #00F5FF;" value="00F5FF">Turquoise1</option><option style="background-color: #00E5EE;" value="00E5EE">Turquoise2</option><option style="background-color: #00C5CD;" value="00C5CD">Turquoise3</option><option style="background-color: #00868B;" value="00868B">Turquoise4</option><option style="background-color: #00FFFF;" value="00FFFF">Cyan1</option><option style="background-color: #00EEEE;" value="00EEEE">Cyan2</option><option style="background-color: #00CDCD;" value="00CDCD">Cyan3</option><option style="background-color: #008B8B;" value="008B8B">Cyan4</option><option style="background-color: #97FFFF;" value="97FFFF">DarkSlateGray1</option><option style="background-color: #8DEEEE;" value="8DEEEE">DarkSlateGray2</option><option style="background-color: #79CDCD;" value="79CDCD">DarkSlateGray3</option><option style="background-color: #528B8B;" value="528B8B">DarkSlateGray4</option><option style="background-color: #7FFFD4;" value="7FFFD4">Aquamarine1</option><option style="background-color: #76EEC6;" value="76EEC6">Aquamarine2</option><option style="background-color: #66CDAA;" value="66CDAA">Aquamarine3</option><option style="background-color: #458B74;" value="458B74">Aquamarine4</option><option style="background-color: #C1FFC1;" value="C1FFC1">DarkSeaGreen1</option><option style="background-color: #B4EEB4;" value="B4EEB4">DarkSeaGreen2</option><option style="background-color: #9BCD9B;" value="9BCD9B">DarkSeaGreen3</option><option style="background-color: #698B69;" value="698B69">DarkSeaGreen4</option><option style="background-color: #54FF9F;" value="54FF9F">SeaGreen1</option><option style="background-color: #4EEE94;" value="4EEE94">SeaGreen2</option><option style="background-color: #43CD80;" value="43CD80">SeaGreen3</option><option style="background-color: #2E8B57;" value="2E8B57">SeaGreen4</option><option style="background-color: #9AFF9A;" value="9AFF9A">PaleGreen1</option><option style="background-color: #90EE90;" value="90EE90">PaleGreen2</option><option style="background-color: #7CCD7C;" value="7CCD7C">PaleGreen3</option><option style="background-color: #548B54;" value="548B54">PaleGreen4</option><option style="background-color: #00FF7F;" value="00FF7F">SpringGreen1</option><option style="background-color: #00EE76;" value="00EE76">SpringGreen2</option><option style="background-color: #00CD66;" value="00CD66">SpringGreen3</option><option style="background-color: #008B45;" value="008B45">SpringGreen4</option><option style="background-color: #00FF00;" value="00FF00">Green1</option><option style="background-color: #00EE00;" value="00EE00">Green2</option><option style="background-color: #00CD00;" value="00CD00">Green3</option><option style="background-color: #008B00;" value="008B00">Green4</option><option style="background-color: #7FFF00;" value="7FFF00">Chartreuse1</option><option style="background-color: #76EE00;" value="76EE00">Chartreuse2</option><option style="background-color: #66CD00;" value="66CD00">Chartreuse3</option><option style="background-color: #458B00;" value="458B00">Chartreuse4</option><option style="background-color: #C0FF3E;" value="C0FF3E">OliveDrab1</option><option style="background-color: #B3EE3A;" value="B3EE3A">OliveDrab2</option><option style="background-color: #9ACD32;" value="9ACD32">OliveDrab3</option><option style="background-color: #698B22;" value="698B22">OliveDrab4</option><option style="background-color: #CAFF70;" value="CAFF70">DarkOliveGreen1</option><option style="background-color: #BCEE68;" value="BCEE68">DarkOliveGreen2</option><option style="background-color: #A2CD5A;" value="A2CD5A">DarkOliveGreen3</option><option style="background-color: #6E8B3D;" value="6E8B3D">DarkOliveGreen4</option><option style="background-color: #FFF68F;" value="FFF68F">Khaki1</option><option style="background-color: #EEE685;" value="EEE685">Khaki2</option><option style="background-color: #CDC673;" value="CDC673">Khaki3</option><option style="background-color: #8B864E;" value="8B864E">Khaki4</option><option style="background-color: #FFEC8B;" value="FFEC8B">LightGoldenrod1</option><option style="background-color: #EEDC82;" value="EEDC82">LightGoldenrod2</option><option style="background-color: #CDBE70;" value="CDBE70">LightGoldenrod3</option><option style="background-color: #8B814C;" value="8B814C">LightGoldenrod4</option><option style="background-color: #FFFFE0;" value="FFFFE0">LightYellow1</option><option style="background-color: #EEEED1;" value="EEEED1">LightYellow2</option><option style="background-color: #CDCDB4;" value="CDCDB4">LightYellow3</option><option style="background-color: #8B8B7A;" value="8B8B7A">LightYellow4</option><option style="background-color: #FFFF00;" value="FFFF00">Yellow1</option><option style="background-color: #EEEE00;" value="EEEE00">Yellow2</option><option style="background-color: #CDCD00;" value="CDCD00">Yellow3</option><option style="background-color: #8B8B00;" value="8B8B00">Yellow4</option><option style="background-color: #FFD700;" value="FFD700">Gold1</option><option style="background-color: #EEC900;" value="EEC900">Gold2</option><option style="background-color: #CDAD00;" value="CDAD00">Gold3</option><option style="background-color: #8B7500;" value="8B7500">Gold4</option><option style="background-color: #FFC125;" value="FFC125">Goldenrod1</option><option style="background-color: #EEB422;" value="EEB422">Goldenrod2</option><option style="background-color: #CD9B1D;" value="CD9B1D">Goldenrod3</option><option style="background-color: #8B6914;" value="8B6914">Goldenrod4</option><option style="background-color: #FFB90F;" value="FFB90F">DarkGoldenrod1</option><option style="background-color: #EEAD0E;" value="EEAD0E">DarkGoldenrod2</option><option style="background-color: #CD950C;" value="CD950C">DarkGoldenrod3</option><option style="background-color: #8B658B;" value="8B658B">DarkGoldenrod4</option><option style="background-color: #FFC1C1;" value="FFC1C1">RosyBrown1</option><option style="background-color: #EEB4B4;" value="EEB4B4">RosyBrown2</option><option style="background-color: #CD9B9B;" value="CD9B9B">RosyBrown3</option><option style="background-color: #8B6969;" value="8B6969">RosyBrown4</option><option style="background-color: #FF6A6A;" value="FF6A6A">IndianRed1</option><option style="background-color: #EE6363;" value="EE6363">IndianRed2</option><option style="background-color: #CD5555;" value="CD5555">IndianRed3</option><option style="background-color: #8B3A3A;" value="8B3A3A">IndianRed4</option><option style="background-color: #FF8247;" value="FF8247">Sienna1</option><option style="background-color: #EE7942;" value="EE7942">Sienna2</option><option style="background-color: #CD6839;" value="CD6839">Sienna3</option><option style="background-color: #8B4726;" value="8B4726">Sienna4</option><option style="background-color: #FFD39B;" value="FFD39B">Burlywood1</option><option style="background-color: #EEC591;" value="EEC591">Burlywood2</option><option style="background-color: #CDAA7D;" value="CDAA7D">Burlywood3</option><option style="background-color: #8B7355;" value="8B7355">Burlywood4</option><option style="background-color: #FFE7BA;" value="FFE7BA">Wheat1</option><option style="background-color: #EED8AE;" value="EED8AE">Wheat2</option><option style="background-color: #CDBA96;" value="CDBA96">Wheat3</option><option style="background-color: #8B7E66;" value="8B7E66">Wheat4</option><option style="background-color: #FFA54F;" value="FFA54F">Tan1</option><option style="background-color: #EE9A49;" value="EE9A49">Tan2</option><option style="background-color: #CD853F;" value="CD853F">Tan3</option><option style="background-color: #8B5A2B;" value="8B5A2B">Tan4</option><option style="background-color: #FF7F24;" value="FF7F24">Chocolate1</option><option style="background-color: #EE7621;" value="EE7621">Chocolate2</option><option style="background-color: #CD661D;" value="CD661D">Chocolate3</option><option style="background-color: #8B4513;" value="8B4513">Chocolate4</option><option style="background-color: #FF3030;" value="FF3030">Firebrick1</option><option style="background-color: #EE2C2C;" value="EE2C2C">Firebrick2</option><option style="background-color: #CD2626;" value="CD2626">Firebrick3</option><option style="background-color: #8B1A1A;" value="8B1A1A">Firebrick4</option><option style="background-color: #FF4040;" value="FF4040">Brown1</option><option style="background-color: #EE3B3B;" value="EE3B3B">Brown2</option><option style="background-color: #CD3333;" value="CD3333">Brown3</option><option style="background-color: #8B2323;" value="8B2323">Brown4</option><option style="background-color: #FF8C69;" value="FF8C69">Salmon1</option><option style="background-color: #EE8262;" value="EE8262">Salmon2</option><option style="background-color: #CD7054;" value="CD7054">Salmon3</option><option style="background-color: #8B4C39;" value="8B4C39">Salmon4</option><option style="background-color: #FFA07A;" value="FFA07A">LightSalmon1</option><option style="background-color: #EE9572;" value="EE9572">LightSalmon2</option><option style="background-color: #CD8162;" value="CD8162">LightSalmon3</option><option style="background-color: #8B5742;" value="8B5742">LightSalmon4</option><option style="background-color: #FFA500;" value="FFA500">Orange1</option><option style="background-color: #EE9A00;" value="EE9A00">Orange2</option><option style="background-color: #CD8500;" value="CD8500">Orange3</option><option style="background-color: #8B5A00;" value="8B5A00">Orange4</option><option style="background-color: #FF7F00;" value="FF7F00">DarkOrange1</option><option style="background-color: #EE7600;" value="EE7600">DarkOrange2</option><option style="background-color: #CD6600;" value="CD6600">DarkOrange3</option><option style="background-color: #8B4500;" value="8B4500">DarkOrange4</option><option style="background-color: #FF7256;" value="FF7256">Coral1</option><option style="background-color: #EE6A50;" value="EE6A50">Coral2</option><option style="background-color: #CD5B45;" value="CD5B45">Coral3</option><option style="background-color: #8B3E2F;" value="8B3E2F">Coral4</option><option style="background-color: #FF6347;" value="FF6347">Tomato1</option><option style="background-color: #EE5C42;" value="EE5C42">Tomato2</option><option style="background-color: #CD4F39;" value="CD4F39">Tomato3</option><option style="background-color: #8B3626;" value="8B3626">Tomato4</option><option style="background-color: #FF4500;" value="FF4500">OrangeRed1</option><option style="background-color: #EE4000;" value="EE4000">OrangeRed2</option><option style="background-color: #CD3700;" value="CD3700">OrangeRed3</option><option style="background-color: #8B2500;" value="8B2500">OrangeRed4</option><option style="background-color: #FF0000;" value="FF0000">Red1</option><option style="background-color: #EE0000;" value="EE0000">Red2</option><option style="background-color: #CD0000;" value="CD0000">Red3</option><option style="background-color: #8B0000;" value="8B0000">Red4</option><option style="background-color: #FF1493;" value="FF1493">DeepPink1</option><option style="background-color: #EE1289;" value="EE1289">DeepPink2</option><option style="background-color: #CD1076;" value="CD1076">DeepPink3</option><option style="background-color: #8B0A50;" value="8B0A50">DeepPink4</option><option style="background-color: #FF6EB4;" value="FF6EB4">HotPink1</option><option style="background-color: #EE6AA7;" value="EE6AA7">HotPink2</option><option style="background-color: #CD6090;" value="CD6090">HotPink3</option><option style="background-color: #8B3A62;" value="8B3A62">HotPink4</option><option style="background-color: #FFB5C5;" value="FFB5C5">Pink1</option><option style="background-color: #EEA9B8;" value="EEA9B8">Pink2</option><option style="background-color: #CD919E;" value="CD919E">Pink3</option><option style="background-color: #8B636C;" value="8B636C">Pink4</option><option style="background-color: #FFAEB9;" value="FFAEB9">LightPink1</option><option style="background-color: #EEA2AD;" value="EEA2AD">LightPink2</option><option style="background-color: #CD8C95;" value="CD8C95">LightPink3</option><option style="background-color: #8B5F65;" value="8B5F65">LightPink4</option><option style="background-color: #FF82AB;" value="FF82AB">PaleVioletRed1</option><option style="background-color: #EE799F;" value="EE799F">PaleVioletRed2</option><option style="background-color: #CD6889;" value="CD6889">PaleVioletRed3</option><option style="background-color: #8B475D;" value="8B475D">PaleVioletRed4</option><option style="background-color: #FF34B3;" value="FF34B3">Maroon1</option><option style="background-color: #EE30A7;" value="EE30A7">Maroon2</option><option style="background-color: #CD2990;" value="CD2990">Maroon3</option><option style="background-color: #8B1C62;" value="8B1C62">Maroon4</option><option style="background-color: #FF3E96;" value="FF3E96">VioletRed1</option><option style="background-color: #EE3A8C;" value="EE3A8C">VioletRed2</option><option style="background-color: #CD3278;" value="CD3278">VioletRed3</option><option style="background-color: #8B2252;" value="8B2252">VioletRed4</option><option style="background-color: #FF00FF;" value="FF00FF">Magenta1</option><option style="background-color: #EE00EE;" value="EE00EE">Magenta2</option><option style="background-color: #CD00CD;" value="CD00CD">Magenta3</option><option style="background-color: #8B008B;" value="8B008B">Magenta4</option><option style="background-color: #FF83FA;" value="FF83FA">Orchid1</option><option style="background-color: #EE7AE9;" value="EE7AE9">Orchid2</option><option style="background-color: #CD69C9;" value="CD69C9">Orchid3</option><option style="background-color: #8B4789;" value="8B4789">Orchid4</option><option style="background-color: #FFBBFF;" value="FFBBFF">Plum1</option><option style="background-color: #EEAEEE;" value="EEAEEE">Plum2</option><option style="background-color: #CD96CD;" value="CD96CD">Plum3</option><option style="background-color: #8B668B;" value="8B668B">Plum4</option><option style="background-color: #E066FF;" value="E066FF">MediumOrchid1</option><option style="background-color: #D15FEE;" value="D15FEE">MediumOrchid2</option><option style="background-color: #B452CD;" value="B452CD">MediumOrchid3</option><option style="background-color: #7A378B;" value="7A378B">MediumOrchid4</option><option style="background-color: #BF3EFF;" value="BF3EFF">DarkOrchid1</option><option style="background-color: #B23AEE;" value="B23AEE">DarkOrchid2</option><option style="background-color: #9A32CD;" value="9A32CD">DarkOrchid3</option><option style="background-color: #68228B;" value="68228B">DarkOrchid4</option><option style="background-color: #9B30FF;" value="9B30FF">Purple1</option><option style="background-color: #912CEE;" value="912CEE">Purple2</option><option style="background-color: #7D26CD;" value="7D26CD">Purple3</option><option style="background-color: #551A8B;" value="551A8B">Purple4</option><option style="background-color: #AB82FF;" value="AB82FF">MediumPurple1</option><option style="background-color: #9F79EE;" value="9F79EE">MediumPurple2</option><option style="background-color: #8968CD;" value="8968CD">MediumPurple3</option><option style="background-color: #5D478B;" value="5D478B">MediumPurple4</option><option style="background-color: #FFE1FF;" value="FFE1FF">Thistle1</option><option style="background-color: #EED2EE;" value="EED2EE">Thistle2</option><option style="background-color: #CDB5CD;" value="CDB5CD">Thistle3</option><option style="background-color: #8B7B8B;" value="8B7B8B">Thistle4</option><option style="background-color: #1C1C1C;" value="1C1C1C">grey11</option><option style="background-color: #363636;" value="363636">grey21</option><option style="background-color: #4F4F4F;" value="4F4F4F">grey31</option><option style="background-color: #696969;" value="696969">grey41</option><option style="background-color: #828282;" value="828282">grey51</option><option style="background-color: #9C9C9C;" value="9C9C9C">grey61</option><option style="background-color: #B5B5B5;" value="B5B5B5">grey71</option><option style="background-color: #CFCFCF;" value="CFCFCF">gray81</option><option style="background-color: #E8E8E8;" value="E8E8E8">gray91</option><option style="background-color: #A9A9A9;" value="A9A9A9">DarkGrey</option><option style="background-color: #00008B;" value="00008B">DarkBlue</option><option style="background-color: #008B8B;" value="008B8B">DarkCyan</option><option style="background-color: #8B008B;" value="8B008B">DarkMagenta</option><option style="background-color: #8B0000;" value="8B0000">DarkRed</option><option style="background-color: #90EE90;" value="90EE90">LightGreen</option>');
</script></select> &nbsp; <img src=http://www.e-reading.ws//images/bg.jpg height=16 onClick="DisplaySettings('bgsettings')" alt="цвет фона" style="vertical-align: bottom;"> <select id=bgsettings name=backgroundcolor onchange="ReaderSettings();" style="display: none;">
<option value=0>цвет фона</option><script type="text/javascript" language="javascript">
document.write('<option style="background-color: #FFFFFF;" value="FFFFFF">White</option>');
document.write('<option style="background-color: #C0C0C0;" value="C0C0C0">Silver</option>');
document.write('<option style="background-color: #808080;" value="808080">Grey</option>');
document.write('<option style="background-color: #000000;" value="000000">Black</option>');
document.write('<option style="background-color: #FF0000;" value="FF0000">Red</option>');
document.write('<option style="background-color: #FFFF00;" value="FFFF00">Yellow</option>');
document.write('<option style="background-color: #808000;" value="808000">Olive</option>');
document.write('<option style="background-color: #00FF00;" value="008000">Lime</option>');
document.write('<option style="background-color: #008000;" value="008000">Green</option>');
document.write('<option style="background-color: #0000FF;" value="0000FF">Blue</option>');
document.write('<option style="background-color: #000080;" value="000080">Navy</option>');

document.write('<option style="background-color: #FFFAFA;" value="FFFAFA">Snow</option><option style="background-color: #F8F8FF;" value="F8F8FF">GhostWhite</option><option style="background-color: #F5F5F5;" value="F5F5F5">WhiteSmoke</option><option style="background-color: #DCDCDC;" value="DCDCDC">Gainsboro</option><option style="background-color: #FFFAF0;" value="FFFAF0">FloralWhite</option><option style="background-color: #FDF5E6;" value="FDF5E6">OldLace</option><option style="background-color: #FAF0E6;" value="FAF0E6">Linen</option><option style="background-color: #FAEBD7;" value="FAEBD7">AntiqueWhite</option><option style="background-color: #FFEFD5;" value="FFEFD5">PapayaWhip</option><option style="background-color: #FFEBCD;" value="FFEBCD">BlanchedAlmond</option><option style="background-color: #FFE4C4;" value="FFE4C4">Bisque</option><option style="background-color: #FFDAB9;" value="FFDAB9">PeachPuff</option><option style="background-color: #FFDEAD;" value="FFDEAD">NavajoWhite</option><option style="background-color: #FFE4B5;" value="FFE4B5">Moccasin</option><option style="background-color: #FFF8DC;" value="FFF8DC">Cornsilk</option><option style="background-color: #FFFFF0;" value="FFFFF0">Ivory</option><option style="background-color: #FFFACD;" value="FFFACD">LemonChiffon</option><option style="background-color: #FFF5EE;" value="FFF5EE">Seashell</option><option style="background-color: #F0FFF0;" value="F0FFF0">Honeydew</option><option style="background-color: #F5FFFA;" value="F5FFFA">MintCream</option><option style="background-color: #F0FFFF;" value="F0FFFF">Azure</option><option style="background-color: #F0F8FF;" value="F0F8FF">AliceBlue</option><option style="background-color: #E6E6FA;" value="E6E6FA">lavender</option><option style="background-color: #FFF0F5;" value="FFF0F5">LavenderBlush</option><option style="background-color: #FFE4E1;" value="FFE4E1">MistyRose</option><option style="background-color: #FFFFFF;" value="FFFFFF">White</option><option style="background-color: #000000;" value="000000">Black</option><option style="background-color: #2F4F4F;" value="2F4F4F">DarkSlateGray</option><option style="background-color: #696969;" value="696969">DimGrey</option><option style="background-color: #708090;" value="708090">SlateGrey</option><option style="background-color: #778899;" value="778899">LightSlateGray</option><option style="background-color: #BEBEBE;" value="BEBEBE">Grey</option><option style="background-color: #D3D3D3;" value="D3D3D3">LightGray</option><option style="background-color: #191970;" value="191970">MidnightBlue</option><option style="background-color: #000080;" value="000080">NavyBlue</option><option style="background-color: #6495ED;" value="6495ED">CornflowerBlue</option><option style="background-color: #483D8B;" value="483D8B">DarkSlateBlue</option><option style="background-color: #6A5ACD;" value="6A5ACD">SlateBlue</option><option style="background-color: #7B68EE;" value="7B68EE">MediumSlateBlue</option><option style="background-color: #8470FF;" value="8470FF">LightSlateBlue</option><option style="background-color: #0000CD;" value="0000CD">MediumBlue</option><option style="background-color: #4169E1;" value="4169E1">RoyalBlue</option><option style="background-color: #0000FF;" value="0000FF">Blue</option><option style="background-color: #1E90FF;" value="1E90FF">DodgerBlue</option><option style="background-color: #00BFFF;" value="00BFFF">DeepSkyBlue</option><option style="background-color: #87CEEB;" value="87CEEB">SkyBlue</option><option style="background-color: #87CEFA;" value="87CEFA">LightSkyBlue</option><option style="background-color: #4682B4;" value="4682B4">SteelBlue</option><option style="background-color: #B0C4DE;" value="B0C4DE">LightSteelBlue</option><option style="background-color: #ADD8E6;" value="ADD8E6">LightBlue</option><option style="background-color: #B0E0E6;" value="B0E0E6">PowderBlue</option><option style="background-color: #AFEEEE;" value="AFEEEE">PaleTurquoise</option><option style="background-color: #00CED1;" value="00CED1">DarkTurquoise</option><option style="background-color: #48D1CC;" value="48D1CC">MediumTurquoise</option><option style="background-color: #40E0D0;" value="40E0D0">Turquoise</option><option style="background-color: #00FFFF;" value="00FFFF">Cyan</option><option style="background-color: #E0FFFF;" value="E0FFFF">LightCyan</option><option style="background-color: #5F9EA0;" value="5F9EA0">CadetBlue</option><option style="background-color: #66CDAA;" value="66CDAA">MediumAquamarine</option><option style="background-color: #7FFFD4;" value="7FFFD4">Aquamarine</option><option style="background-color: #006400;" value="006400">DarkGreen</option><option style="background-color: #556B2F;" value="556B2F">DarkOliveGreen</option><option style="background-color: #8FBC8F;" value="8FBC8F">DarkSeaGreen</option><option style="background-color: #2E8B57;" value="2E8B57">SeaGreen</option><option style="background-color: #3CB371;" value="3CB371">MediumSeaGreen</option><option style="background-color: #20B2AA;" value="20B2AA">LightSeaGreen</option><option style="background-color: #98FB98;" value="98FB98">PaleGreen</option><option style="background-color: #00FF7F;" value="00FF7F">SpringGreen</option><option style="background-color: #7CFC00;" value="7CFC00">LawnGreen</option><option style="background-color: #00FF00;" value="00FF00">Green</option><option style="background-color: #7FFF00;" value="7FFF00">Chartreuse</option><option style="background-color: #00FA9A;" value="00FA9A">MedSpringGreen</option><option style="background-color: #ADFF2F;" value="ADFF2F">GreenYellow</option><option style="background-color: #32CD32;" value="32CD32">LimeGreen</option><option style="background-color: #9ACD32;" value="9ACD32">YellowGreen</option><option style="background-color: #228B22;" value="228B22">ForestGreen</option><option style="background-color: #6B8E23;" value="6B8E23">OliveDrab</option><option style="background-color: #BDB76B;" value="BDB76B">DarkKhaki</option><option style="background-color: #EEE8AA;" value="EEE8AA">PaleGoldenrod</option><option style="background-color: #FAFAD2;" value="FAFAD2">LtGoldenrodYello</option><option style="background-color: #FFFFE0;" value="FFFFE0">LightYellow</option><option style="background-color: #FFFF00;" value="FFFF00">Yellow</option><option style="background-color: #FFD700;" value="FFD700">Gold</option><option style="background-color: #EEDD82;" value="EEDD82">LightGoldenrod</option><option style="background-color: #DAA520;" value="DAA520">goldenrod</option><option style="background-color: #B8860B;" value="B8860B">DarkGoldenrod</option><option style="background-color: #BC8F8F;" value="BC8F8F">RosyBrown</option><option style="background-color: #CD5C5C;" value="CD5C5C">IndianRed</option><option style="background-color: #8B4513;" value="8B4513">SaddleBrown</option><option style="background-color: #A0522D;" value="A0522D">Sienna</option><option style="background-color: #CD853F;" value="CD853F">Peru</option><option style="background-color: #DEB887;" value="DEB887">Burlywood</option><option style="background-color: #F5F5DC;" value="F5F5DC">Beige</option><option style="background-color: #F5DEB3;" value="F5DEB3">Wheat</option><option style="background-color: #F4A460;" value="F4A460">SandyBrown</option><option style="background-color: #D2B48C;" value="D2B48C">Tan</option><option style="background-color: #D2691E;" value="D2691E">Chocolate</option><option style="background-color: #B22222;" value="B22222">Firebrick</option><option style="background-color: #A52A2A;" value="A52A2A">Brown</option><option style="background-color: #E9967A;" value="E9967A">DarkSalmon</option><option style="background-color: #FA8072;" value="FA8072">Salmon</option><option style="background-color: #FFA07A;" value="FFA07A">LightSalmon</option><option style="background-color: #FFA500;" value="FFA500">Orange</option><option style="background-color: #FF8C00;" value="FF8C00">DarkOrange</option><option style="background-color: #FF7F50;" value="FF7F50">Coral</option><option style="background-color: #F08080;" value="F08080">LightCoral</option><option style="background-color: #FF6347;" value="FF6347">Tomato</option><option style="background-color: #FF4500;" value="FF4500">OrangeRed</option><option style="background-color: #FF0000;" value="FF0000">Red</option><option style="background-color: #FF69B4;" value="FF69B4">HotPink</option><option style="background-color: #FF1493;" value="FF1493">DeepPink</option><option style="background-color: #FFC0CB;" value="FFC0CB">Pink</option><option style="background-color: #FFB6C1;" value="FFB6C1">LightPink</option><option style="background-color: #DB7093;" value="DB7093">PaleVioletRed</option><option style="background-color: #B03060;" value="B03060">Maroon</option><option style="background-color: #C71585;" value="C71585">MediumVioletRed</option><option style="background-color: #D02090;" value="D02090">VioletRed</option><option style="background-color: #FF00FF;" value="FF00FF">Magenta</option><option style="background-color: #EE82EE;" value="EE82EE">Violet</option><option style="background-color: #DDA0DD;" value="DDA0DD">Plum</option><option style="background-color: #DA70D6;" value="DA70D6">Orchid</option><option style="background-color: #BA55D3;" value="BA55D3">MediumOrchid</option><option style="background-color: #9932CC;" value="9932CC">DarkOrchid</option><option style="background-color: #9400D3;" value="9400D3">DarkViolet</option><option style="background-color: #8A2BE2;" value="8A2BE2">BlueViolet</option><option style="background-color: #A020F0;" value="A020F0">Purple</option><option style="background-color: #9370DB;" value="9370DB">MediumPurple</option><option style="background-color: #D8BFD8;" value="D8BFD8">Thistle</option><option style="background-color: #FFFAFA;" value="FFFAFA">Snow1</option><option style="background-color: #EEE9E9;" value="EEE9E9">Snow2</option><option style="background-color: #CDC9C9;" value="CDC9C9">Snow3</option><option style="background-color: #8B8989;" value="8B8989">Snow4</option><option style="background-color: #FFF5EE;" value="FFF5EE">Seashell1</option><option style="background-color: #EEE5DE;" value="EEE5DE">Seashell2</option><option style="background-color: #CDC5BF;" value="CDC5BF">Seashell3</option><option style="background-color: #8B8682;" value="8B8682">Seashell4</option><option style="background-color: #FFEFDB;" value="FFEFDB">AntiqueWhite1</option><option style="background-color: #EEDFCC;" value="EEDFCC">AntiqueWhite2</option><option style="background-color: #CDC0B0;" value="CDC0B0">AntiqueWhite3</option><option style="background-color: #8B8378;" value="8B8378">AntiqueWhite4</option><option style="background-color: #FFE4C4;" value="FFE4C4">Bisque1</option><option style="background-color: #EED5B7;" value="EED5B7">Bisque2</option><option style="background-color: #CDB79E;" value="CDB79E">Bisque3</option><option style="background-color: #8B7D6B;" value="8B7D6B">Bisque4</option><option style="background-color: #FFDAB9;" value="FFDAB9">PeachPuff1</option><option style="background-color: #EECBAD;" value="EECBAD">PeachPuff2</option><option style="background-color: #CDAF95;" value="CDAF95">PeachPuff3</option><option style="background-color: #8B7765;" value="8B7765">PeachPuff4</option><option style="background-color: #FFDEAD;" value="FFDEAD">NavajoWhite1</option><option style="background-color: #EECFA1;" value="EECFA1">NavajoWhite2</option><option style="background-color: #CDB38B;" value="CDB38B">NavajoWhite3</option><option style="background-color: #8B795E;" value="8B795E">NavajoWhite4</option><option style="background-color: #FFFACD;" value="FFFACD">LemonChiffon1</option><option style="background-color: #EEE9BF;" value="EEE9BF">LemonChiffon2</option><option style="background-color: #CDC9A5;" value="CDC9A5">LemonChiffon3</option><option style="background-color: #8B8970;" value="8B8970">LemonChiffon4</option><option style="background-color: #FFF8DC;" value="FFF8DC">Cornsilk1</option><option style="background-color: #EEE8CD;" value="EEE8CD">Cornsilk2</option><option style="background-color: #CDC8B1;" value="CDC8B1">Cornsilk3</option><option style="background-color: #8B8878;" value="8B8878">Cornsilk4</option><option style="background-color: #FFFFF0;" value="FFFFF0">Ivory1</option><option style="background-color: #EEEEE0;" value="EEEEE0">Ivory2</option><option style="background-color: #CDCDC1;" value="CDCDC1">Ivory3</option><option style="background-color: #8B8B83;" value="8B8B83">Ivory4</option><option style="background-color: #F0FFF0;" value="F0FFF0">Honeydew1</option><option style="background-color: #E0EEE0;" value="E0EEE0">Honeydew2</option><option style="background-color: #C1CDC1;" value="C1CDC1">Honeydew3</option><option style="background-color: #838B83;" value="838B83">Honeydew4</option><option style="background-color: #FFF0F5;" value="FFF0F5">LavenderBlush1</option><option style="background-color: #EEE0E5;" value="EEE0E5">LavenderBlush2</option><option style="background-color: #CDC1C5;" value="CDC1C5">LavenderBlush3</option><option style="background-color: #8B8386;" value="8B8386">LavenderBlush4</option><option style="background-color: #FFE4E1;" value="FFE4E1">MistyRose1</option><option style="background-color: #EED5D2;" value="EED5D2">MistyRose2</option><option style="background-color: #CDB7B5;" value="CDB7B5">MistyRose3</option><option style="background-color: #8B7D7B;" value="8B7D7B">MistyRose4</option><option style="background-color: #F0FFFF;" value="F0FFFF">Azure1</option><option style="background-color: #E0EEEE;" value="E0EEEE">Azure2</option><option style="background-color: #C1CDCD;" value="C1CDCD">Azure3</option><option style="background-color: #838B8B;" value="838B8B">Azure4</option><option style="background-color: #836FFF;" value="836FFF">SlateBlue1</option><option style="background-color: #7A67EE;" value="7A67EE">SlateBlue2</option><option style="background-color: #6959CD;" value="6959CD">SlateBlue3</option><option style="background-color: #473C8B;" value="473C8B">SlateBlue4</option><option style="background-color: #4876FF;" value="4876FF">RoyalBlue1</option><option style="background-color: #436EEE;" value="436EEE">RoyalBlue2</option><option style="background-color: #3A5FCD;" value="3A5FCD">RoyalBlue3</option><option style="background-color: #27408B;" value="27408B">RoyalBlue4</option><option style="background-color: #0000FF;" value="0000FF">Blue1</option><option style="background-color: #0000EE;" value="0000EE">Blue2</option><option style="background-color: #0000CD;" value="0000CD">Blue3</option><option style="background-color: #00008B;" value="00008B">Blue4</option><option style="background-color: #1E90FF;" value="1E90FF">DodgerBlue1</option><option style="background-color: #1C86EE;" value="1C86EE">DodgerBlue2</option><option style="background-color: #1874CD;" value="1874CD">DodgerBlue3</option><option style="background-color: #104E8B;" value="104E8B">DodgerBlue4</option><option style="background-color: #63B8FF;" value="63B8FF">SteelBlue1</option><option style="background-color: #5CACEE;" value="5CACEE">SteelBlue2</option><option style="background-color: #4F94CD;" value="4F94CD">SteelBlue3</option><option style="background-color: #36648B;" value="36648B">SteelBlue4</option><option style="background-color: #00BFFF;" value="00BFFF">DeepSkyBlue1</option><option style="background-color: #00B2EE;" value="00B2EE">DeepSkyBlue2</option><option style="background-color: #009ACD;" value="009ACD">DeepSkyBlue3</option><option style="background-color: #00688B;" value="00688B">DeepSkyBlue4</option><option style="background-color: #87CEFF;" value="87CEFF">SkyBlue1</option><option style="background-color: #7EC0EE;" value="7EC0EE">SkyBlue2</option><option style="background-color: #6CA6CD;" value="6CA6CD">SkyBlue3</option><option style="background-color: #4A708B;" value="4A708B">SkyBlue4</option><option style="background-color: #B0E2FF;" value="B0E2FF">LightSkyBlue1</option><option style="background-color: #A4D3EE;" value="A4D3EE">LightSkyBlue2</option><option style="background-color: #8DB6CD;" value="8DB6CD">LightSkyBlue3</option><option style="background-color: #607B8B;" value="607B8B">LightSkyBlue4</option><option style="background-color: #C6E2FF;" value="C6E2FF">SlateGray1</option><option style="background-color: #B9D3EE;" value="B9D3EE">SlateGray2</option><option style="background-color: #9FB6CD;" value="9FB6CD">SlateGray3</option><option style="background-color: #6C7B8B;" value="6C7B8B">SlateGray4</option><option style="background-color: #CAE1FF;" value="CAE1FF">LightSteelBlue1</option><option style="background-color: #BCD2EE;" value="BCD2EE">LightSteelBlue2</option><option style="background-color: #A2B5CD;" value="A2B5CD">LightSteelBlue3</option><option style="background-color: #6E7B8B;" value="6E7B8B">LightSteelBlue4</option><option style="background-color: #BFEFFF;" value="BFEFFF">LightBlue1</option><option style="background-color: #B2DFEE;" value="B2DFEE">LightBlue2</option><option style="background-color: #9AC0CD;" value="9AC0CD">LightBlue3</option><option style="background-color: #68838B;" value="68838B">LightBlue4</option><option style="background-color: #E0FFFF;" value="E0FFFF">LightCyan1</option><option style="background-color: #D1EEEE;" value="D1EEEE">LightCyan2</option><option style="background-color: #B4CDCD;" value="B4CDCD">LightCyan3</option><option style="background-color: #7A8B8B;" value="7A8B8B">LightCyan4</option><option style="background-color: #BBFFFF;" value="BBFFFF">PaleTurquoise1</option><option style="background-color: #AEEEEE;" value="AEEEEE">PaleTurquoise2</option><option style="background-color: #96CDCD;" value="96CDCD">PaleTurquoise3</option><option style="background-color: #668B8B;" value="668B8B">PaleTurquoise4</option><option style="background-color: #98F5FF;" value="98F5FF">CadetBlue1</option><option style="background-color: #8EE5EE;" value="8EE5EE">CadetBlue2</option><option style="background-color: #7AC5CD;" value="7AC5CD">CadetBlue3</option><option style="background-color: #53868B;" value="53868B">CadetBlue4</option><option style="background-color: #00F5FF;" value="00F5FF">Turquoise1</option><option style="background-color: #00E5EE;" value="00E5EE">Turquoise2</option><option style="background-color: #00C5CD;" value="00C5CD">Turquoise3</option><option style="background-color: #00868B;" value="00868B">Turquoise4</option><option style="background-color: #00FFFF;" value="00FFFF">Cyan1</option><option style="background-color: #00EEEE;" value="00EEEE">Cyan2</option><option style="background-color: #00CDCD;" value="00CDCD">Cyan3</option><option style="background-color: #008B8B;" value="008B8B">Cyan4</option><option style="background-color: #97FFFF;" value="97FFFF">DarkSlateGray1</option><option style="background-color: #8DEEEE;" value="8DEEEE">DarkSlateGray2</option><option style="background-color: #79CDCD;" value="79CDCD">DarkSlateGray3</option><option style="background-color: #528B8B;" value="528B8B">DarkSlateGray4</option><option style="background-color: #7FFFD4;" value="7FFFD4">Aquamarine1</option><option style="background-color: #76EEC6;" value="76EEC6">Aquamarine2</option><option style="background-color: #66CDAA;" value="66CDAA">Aquamarine3</option><option style="background-color: #458B74;" value="458B74">Aquamarine4</option><option style="background-color: #C1FFC1;" value="C1FFC1">DarkSeaGreen1</option><option style="background-color: #B4EEB4;" value="B4EEB4">DarkSeaGreen2</option><option style="background-color: #9BCD9B;" value="9BCD9B">DarkSeaGreen3</option><option style="background-color: #698B69;" value="698B69">DarkSeaGreen4</option><option style="background-color: #54FF9F;" value="54FF9F">SeaGreen1</option><option style="background-color: #4EEE94;" value="4EEE94">SeaGreen2</option><option style="background-color: #43CD80;" value="43CD80">SeaGreen3</option><option style="background-color: #2E8B57;" value="2E8B57">SeaGreen4</option><option style="background-color: #9AFF9A;" value="9AFF9A">PaleGreen1</option><option style="background-color: #90EE90;" value="90EE90">PaleGreen2</option><option style="background-color: #7CCD7C;" value="7CCD7C">PaleGreen3</option><option style="background-color: #548B54;" value="548B54">PaleGreen4</option><option style="background-color: #00FF7F;" value="00FF7F">SpringGreen1</option><option style="background-color: #00EE76;" value="00EE76">SpringGreen2</option><option style="background-color: #00CD66;" value="00CD66">SpringGreen3</option><option style="background-color: #008B45;" value="008B45">SpringGreen4</option><option style="background-color: #00FF00;" value="00FF00">Green1</option><option style="background-color: #00EE00;" value="00EE00">Green2</option><option style="background-color: #00CD00;" value="00CD00">Green3</option><option style="background-color: #008B00;" value="008B00">Green4</option><option style="background-color: #7FFF00;" value="7FFF00">Chartreuse1</option><option style="background-color: #76EE00;" value="76EE00">Chartreuse2</option><option style="background-color: #66CD00;" value="66CD00">Chartreuse3</option><option style="background-color: #458B00;" value="458B00">Chartreuse4</option><option style="background-color: #C0FF3E;" value="C0FF3E">OliveDrab1</option><option style="background-color: #B3EE3A;" value="B3EE3A">OliveDrab2</option><option style="background-color: #9ACD32;" value="9ACD32">OliveDrab3</option><option style="background-color: #698B22;" value="698B22">OliveDrab4</option><option style="background-color: #CAFF70;" value="CAFF70">DarkOliveGreen1</option><option style="background-color: #BCEE68;" value="BCEE68">DarkOliveGreen2</option><option style="background-color: #A2CD5A;" value="A2CD5A">DarkOliveGreen3</option><option style="background-color: #6E8B3D;" value="6E8B3D">DarkOliveGreen4</option><option style="background-color: #FFF68F;" value="FFF68F">Khaki1</option><option style="background-color: #EEE685;" value="EEE685">Khaki2</option><option style="background-color: #CDC673;" value="CDC673">Khaki3</option><option style="background-color: #8B864E;" value="8B864E">Khaki4</option><option style="background-color: #FFEC8B;" value="FFEC8B">LightGoldenrod1</option><option style="background-color: #EEDC82;" value="EEDC82">LightGoldenrod2</option><option style="background-color: #CDBE70;" value="CDBE70">LightGoldenrod3</option><option style="background-color: #8B814C;" value="8B814C">LightGoldenrod4</option><option style="background-color: #FFFFE0;" value="FFFFE0">LightYellow1</option><option style="background-color: #EEEED1;" value="EEEED1">LightYellow2</option><option style="background-color: #CDCDB4;" value="CDCDB4">LightYellow3</option><option style="background-color: #8B8B7A;" value="8B8B7A">LightYellow4</option><option style="background-color: #FFFF00;" value="FFFF00">Yellow1</option><option style="background-color: #EEEE00;" value="EEEE00">Yellow2</option><option style="background-color: #CDCD00;" value="CDCD00">Yellow3</option><option style="background-color: #8B8B00;" value="8B8B00">Yellow4</option><option style="background-color: #FFD700;" value="FFD700">Gold1</option><option style="background-color: #EEC900;" value="EEC900">Gold2</option><option style="background-color: #CDAD00;" value="CDAD00">Gold3</option><option style="background-color: #8B7500;" value="8B7500">Gold4</option><option style="background-color: #FFC125;" value="FFC125">Goldenrod1</option><option style="background-color: #EEB422;" value="EEB422">Goldenrod2</option><option style="background-color: #CD9B1D;" value="CD9B1D">Goldenrod3</option><option style="background-color: #8B6914;" value="8B6914">Goldenrod4</option><option style="background-color: #FFB90F;" value="FFB90F">DarkGoldenrod1</option><option style="background-color: #EEAD0E;" value="EEAD0E">DarkGoldenrod2</option><option style="background-color: #CD950C;" value="CD950C">DarkGoldenrod3</option><option style="background-color: #8B658B;" value="8B658B">DarkGoldenrod4</option><option style="background-color: #FFC1C1;" value="FFC1C1">RosyBrown1</option><option style="background-color: #EEB4B4;" value="EEB4B4">RosyBrown2</option><option style="background-color: #CD9B9B;" value="CD9B9B">RosyBrown3</option><option style="background-color: #8B6969;" value="8B6969">RosyBrown4</option><option style="background-color: #FF6A6A;" value="FF6A6A">IndianRed1</option><option style="background-color: #EE6363;" value="EE6363">IndianRed2</option><option style="background-color: #CD5555;" value="CD5555">IndianRed3</option><option style="background-color: #8B3A3A;" value="8B3A3A">IndianRed4</option><option style="background-color: #FF8247;" value="FF8247">Sienna1</option><option style="background-color: #EE7942;" value="EE7942">Sienna2</option><option style="background-color: #CD6839;" value="CD6839">Sienna3</option><option style="background-color: #8B4726;" value="8B4726">Sienna4</option><option style="background-color: #FFD39B;" value="FFD39B">Burlywood1</option><option style="background-color: #EEC591;" value="EEC591">Burlywood2</option><option style="background-color: #CDAA7D;" value="CDAA7D">Burlywood3</option><option style="background-color: #8B7355;" value="8B7355">Burlywood4</option><option style="background-color: #FFE7BA;" value="FFE7BA">Wheat1</option><option style="background-color: #EED8AE;" value="EED8AE">Wheat2</option><option style="background-color: #CDBA96;" value="CDBA96">Wheat3</option><option style="background-color: #8B7E66;" value="8B7E66">Wheat4</option><option style="background-color: #FFA54F;" value="FFA54F">Tan1</option><option style="background-color: #EE9A49;" value="EE9A49">Tan2</option><option style="background-color: #CD853F;" value="CD853F">Tan3</option><option style="background-color: #8B5A2B;" value="8B5A2B">Tan4</option><option style="background-color: #FF7F24;" value="FF7F24">Chocolate1</option><option style="background-color: #EE7621;" value="EE7621">Chocolate2</option><option style="background-color: #CD661D;" value="CD661D">Chocolate3</option><option style="background-color: #8B4513;" value="8B4513">Chocolate4</option><option style="background-color: #FF3030;" value="FF3030">Firebrick1</option><option style="background-color: #EE2C2C;" value="EE2C2C">Firebrick2</option><option style="background-color: #CD2626;" value="CD2626">Firebrick3</option><option style="background-color: #8B1A1A;" value="8B1A1A">Firebrick4</option><option style="background-color: #FF4040;" value="FF4040">Brown1</option><option style="background-color: #EE3B3B;" value="EE3B3B">Brown2</option><option style="background-color: #CD3333;" value="CD3333">Brown3</option><option style="background-color: #8B2323;" value="8B2323">Brown4</option><option style="background-color: #FF8C69;" value="FF8C69">Salmon1</option><option style="background-color: #EE8262;" value="EE8262">Salmon2</option><option style="background-color: #CD7054;" value="CD7054">Salmon3</option><option style="background-color: #8B4C39;" value="8B4C39">Salmon4</option><option style="background-color: #FFA07A;" value="FFA07A">LightSalmon1</option><option style="background-color: #EE9572;" value="EE9572">LightSalmon2</option><option style="background-color: #CD8162;" value="CD8162">LightSalmon3</option><option style="background-color: #8B5742;" value="8B5742">LightSalmon4</option><option style="background-color: #FFA500;" value="FFA500">Orange1</option><option style="background-color: #EE9A00;" value="EE9A00">Orange2</option><option style="background-color: #CD8500;" value="CD8500">Orange3</option><option style="background-color: #8B5A00;" value="8B5A00">Orange4</option><option style="background-color: #FF7F00;" value="FF7F00">DarkOrange1</option><option style="background-color: #EE7600;" value="EE7600">DarkOrange2</option><option style="background-color: #CD6600;" value="CD6600">DarkOrange3</option><option style="background-color: #8B4500;" value="8B4500">DarkOrange4</option><option style="background-color: #FF7256;" value="FF7256">Coral1</option><option style="background-color: #EE6A50;" value="EE6A50">Coral2</option><option style="background-color: #CD5B45;" value="CD5B45">Coral3</option><option style="background-color: #8B3E2F;" value="8B3E2F">Coral4</option><option style="background-color: #FF6347;" value="FF6347">Tomato1</option><option style="background-color: #EE5C42;" value="EE5C42">Tomato2</option><option style="background-color: #CD4F39;" value="CD4F39">Tomato3</option><option style="background-color: #8B3626;" value="8B3626">Tomato4</option><option style="background-color: #FF4500;" value="FF4500">OrangeRed1</option><option style="background-color: #EE4000;" value="EE4000">OrangeRed2</option><option style="background-color: #CD3700;" value="CD3700">OrangeRed3</option><option style="background-color: #8B2500;" value="8B2500">OrangeRed4</option><option style="background-color: #FF0000;" value="FF0000">Red1</option><option style="background-color: #EE0000;" value="EE0000">Red2</option><option style="background-color: #CD0000;" value="CD0000">Red3</option><option style="background-color: #8B0000;" value="8B0000">Red4</option><option style="background-color: #FF1493;" value="FF1493">DeepPink1</option><option style="background-color: #EE1289;" value="EE1289">DeepPink2</option><option style="background-color: #CD1076;" value="CD1076">DeepPink3</option><option style="background-color: #8B0A50;" value="8B0A50">DeepPink4</option><option style="background-color: #FF6EB4;" value="FF6EB4">HotPink1</option><option style="background-color: #EE6AA7;" value="EE6AA7">HotPink2</option><option style="background-color: #CD6090;" value="CD6090">HotPink3</option><option style="background-color: #8B3A62;" value="8B3A62">HotPink4</option><option style="background-color: #FFB5C5;" value="FFB5C5">Pink1</option><option style="background-color: #EEA9B8;" value="EEA9B8">Pink2</option><option style="background-color: #CD919E;" value="CD919E">Pink3</option><option style="background-color: #8B636C;" value="8B636C">Pink4</option><option style="background-color: #FFAEB9;" value="FFAEB9">LightPink1</option><option style="background-color: #EEA2AD;" value="EEA2AD">LightPink2</option><option style="background-color: #CD8C95;" value="CD8C95">LightPink3</option><option style="background-color: #8B5F65;" value="8B5F65">LightPink4</option><option style="background-color: #FF82AB;" value="FF82AB">PaleVioletRed1</option><option style="background-color: #EE799F;" value="EE799F">PaleVioletRed2</option><option style="background-color: #CD6889;" value="CD6889">PaleVioletRed3</option><option style="background-color: #8B475D;" value="8B475D">PaleVioletRed4</option><option style="background-color: #FF34B3;" value="FF34B3">Maroon1</option><option style="background-color: #EE30A7;" value="EE30A7">Maroon2</option><option style="background-color: #CD2990;" value="CD2990">Maroon3</option><option style="background-color: #8B1C62;" value="8B1C62">Maroon4</option><option style="background-color: #FF3E96;" value="FF3E96">VioletRed1</option><option style="background-color: #EE3A8C;" value="EE3A8C">VioletRed2</option><option style="background-color: #CD3278;" value="CD3278">VioletRed3</option><option style="background-color: #8B2252;" value="8B2252">VioletRed4</option><option style="background-color: #FF00FF;" value="FF00FF">Magenta1</option><option style="background-color: #EE00EE;" value="EE00EE">Magenta2</option><option style="background-color: #CD00CD;" value="CD00CD">Magenta3</option><option style="background-color: #8B008B;" value="8B008B">Magenta4</option><option style="background-color: #FF83FA;" value="FF83FA">Orchid1</option><option style="background-color: #EE7AE9;" value="EE7AE9">Orchid2</option><option style="background-color: #CD69C9;" value="CD69C9">Orchid3</option><option style="background-color: #8B4789;" value="8B4789">Orchid4</option><option style="background-color: #FFBBFF;" value="FFBBFF">Plum1</option><option style="background-color: #EEAEEE;" value="EEAEEE">Plum2</option><option style="background-color: #CD96CD;" value="CD96CD">Plum3</option><option style="background-color: #8B668B;" value="8B668B">Plum4</option><option style="background-color: #E066FF;" value="E066FF">MediumOrchid1</option><option style="background-color: #D15FEE;" value="D15FEE">MediumOrchid2</option><option style="background-color: #B452CD;" value="B452CD">MediumOrchid3</option><option style="background-color: #7A378B;" value="7A378B">MediumOrchid4</option><option style="background-color: #BF3EFF;" value="BF3EFF">DarkOrchid1</option><option style="background-color: #B23AEE;" value="B23AEE">DarkOrchid2</option><option style="background-color: #9A32CD;" value="9A32CD">DarkOrchid3</option><option style="background-color: #68228B;" value="68228B">DarkOrchid4</option><option style="background-color: #9B30FF;" value="9B30FF">Purple1</option><option style="background-color: #912CEE;" value="912CEE">Purple2</option><option style="background-color: #7D26CD;" value="7D26CD">Purple3</option><option style="background-color: #551A8B;" value="551A8B">Purple4</option><option style="background-color: #AB82FF;" value="AB82FF">MediumPurple1</option><option style="background-color: #9F79EE;" value="9F79EE">MediumPurple2</option><option style="background-color: #8968CD;" value="8968CD">MediumPurple3</option><option style="background-color: #5D478B;" value="5D478B">MediumPurple4</option><option style="background-color: #FFE1FF;" value="FFE1FF">Thistle1</option><option style="background-color: #EED2EE;" value="EED2EE">Thistle2</option><option style="background-color: #CDB5CD;" value="CDB5CD">Thistle3</option><option style="background-color: #8B7B8B;" value="8B7B8B">Thistle4</option><option style="background-color: #1C1C1C;" value="1C1C1C">grey11</option><option style="background-color: #363636;" value="363636">grey21</option><option style="background-color: #4F4F4F;" value="4F4F4F">grey31</option><option style="background-color: #696969;" value="696969">grey41</option><option style="background-color: #828282;" value="828282">grey51</option><option style="background-color: #9C9C9C;" value="9C9C9C">grey61</option><option style="background-color: #B5B5B5;" value="B5B5B5">grey71</option><option style="background-color: #CFCFCF;" value="CFCFCF">gray81</option><option style="background-color: #E8E8E8;" value="E8E8E8">gray91</option><option style="background-color: #A9A9A9;" value="A9A9A9">DarkGrey</option><option style="background-color: #00008B;" value="00008B">DarkBlue</option><option style="background-color: #008B8B;" value="008B8B">DarkCyan</option><option style="background-color: #8B008B;" value="8B008B">DarkMagenta</option><option style="background-color: #8B0000;" value="8B0000">DarkRed</option><option style="background-color: #90EE90;" value="90EE90">LightGreen</option>');
</script></select>  &nbsp; <img src=http://www.e-reading.ws/images/size.jpg height=16 onClick="DisplaySettings('sizesettings')" alt="размер шрифта" style="vertical-align: bottom;"> <select id=sizesettings name=fsize onchange="ReaderSettings();" style="display: none;">
<option value=0>размер шрифта</option><option value=6>6</option><option value=7>7</option><option value=8>8</option><option value=9>9</option><option value=10>10</option><option value=11>11</option><option value=12>12</option><option value=13>13</option><option value=14>14</option><option value=15>15</option><option value=16>16</option><option value=17>17</option><option value=18>18</option><option value=19>19</option><option value=20>20</option><option value=21>21</option><option value=22>22</option><option value=23>23</option><option value=24>24</option><option value=25>25</option><option value=26>26</option><option value=27>27</option><option value=28>28</option><option value=29>29</option><option value=30>30</option><option value=31>31</option><option value=32>32</option></select> &nbsp; <img src=http://www.e-reading.ws/images/save.jpg height=16 onClick="DisplaySettings('savesettings')" alt="сохранить книгу" style="vertical-align: bottom;"> <div id=savesettings style="display: none;"><a href="http://www.e-reading.ws/download.php?book=148368"  rel="nofollow">fb2</a> <a href="http://www.e-reading.ws/txt.php/148368/%D0%A1%D1%82%D0%B8%D0%B2%D0%B5%D0%BD%D1%81_-_UNIX%3A_%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2.txt" rel="nofollow">txt</a> <a href=http://www.e-reading.ws/bookreader.php/save/148368/%D0%A1%D1%82%D0%B8%D0%B2%D0%B5%D0%BD%D1%81_-_UNIX%3A_%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2.html rel="nofollow">html</a>   <a href="http://www.e-reading.ws/epub.php/148368/%D0%A1%D1%82%D0%B8%D0%B2%D0%B5%D0%BD%D1%81_-_UNIX%3A_%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2.epub" rel="nofollow">epub</a></div><div id=note class=booknote style="display: inline;"><br><b>Текст книги загружен, загружаются изображения<blink>…</blink></b></div></div></form>
<script>
/* Book notes */
var booknotes = new Array();
booknotes['n_1']='1 Все исходные тексты, опубликованные в этой книге, вы можете найти по адресу http://www.piter.com/download.';
booknotes['n_2']='2 Проблема о порядке байтов в слове сродни проблеме лилипутов из «Путешествий Гулливера» Д. Свифта, которые никак не могли договориться, с какого конца начинать есть  яйцо. Именно оттуда англоязычные программисты взяли термины little-endian (остроконечник) и big-endian (тупоконечник), подразумевая «little-end-first» и «big-end-first» (младший или старши й байт идет первым). — Примеч. перев.';

	function ShowBookNote( noteid )
	{
			document.getElementById('note').innerHTML = '<br>'+booknotes[noteid];
			showlayer('note');
	}

	function HideBookNote( noteid )
	{
			document.getElementById('note').innerHTML = '';
			hidelayer('note');
	}

	document.bgColor='ffffff';
document.fgColor='363636';
var b=document.getElementsByTagName('p');
for( i=0; i<b.length; i++ )
{
	b[i].style.fontSize = '14px';
}
</script><div xmlns:v="http://rdf.data-vocabulary.org/#" typeof="v:Review-aggregate" style="text-align:right;padding-bottom:10px"><div property="v:itemreviewed"></div> Всего проголосовало: <span style="font-weight:bold" property="v:votes">11</span> <div style="display:inline" rel="v:rating">Средний рейтинг <span style="font-weight:bold" property="v:average">4.3</span> из <span property="v:best">5</span></div></div><p style="font-size: 12px;"><br><br><form action="http://www.e-reading.ws/book.php"><input type=hidden name=book value=148368><span style="font-size: 12px;">Оцените эту книгу</span> <select name=rating style="font-size: 12px;"><option>-</option><option value=5>Отлично</option><option value=4>Хорошо</option><option value=3>Так себе</option><option value=2>Плохо</option><option value=1>Отвратительно</option></select> &nbsp; <input type=submit value=" отправить " style="font-size: 12px;"></forum><br><br></p><div id="complaintdiv" charset="Windows-1251"></div>
<script type="text/javascript" language="JavaScript">
function loadcomplaintdiv()
{
   if (xmlHttp.readyState == 4)
   {
      var response = xmlHttp.responseText;
	  document.getElementById('complaintdiv').innerHTML = response;
   }
}
function DisplayBlock( id )
{
	state='unknown';
	if (document.all) { 
    	eval( "if( document.all." + id +" ) state=document.all." + id + ".style.display");
        }
	if (document.layers) { 
    	if( document.layers[id] ) state=document.layers[id].display;
	}
	if (document.getElementById && !document.all) {
    	maxwell_smart = document.getElementById(id);
    	if( maxwell_smart ) state=maxwell_smart.style.display;
	}
	if( state == 'none' ) state='block';
	else state='none'; 
	if (document.all) { 
    	eval( "if( document.all." + id +" ) document.all." + id + ".style.display = state");
	}
	if (document.layers) {
    	if( document.layers[id] ) document.layers[id].display = state;
	}
	if (document.getElementById && !document.all) {
    	maxwell_smart = document.getElementById(id);
    	if( maxwell_smart ) maxwell_smart.style.display = state;
	}
}


xmlHttp.open("GET", "http://www.e-reading.ws/complaint-book.ru.php?bookid=148368", true);
xmlHttp.onreadystatechange = loadcomplaintdiv;
xmlHttp.send(null);



</script>


<!-- pageversion: 13/08/2014:23:12:06 +0300 v=1020 k=www.e-reading.ws/bookreader.php/save/148368/%D0%A1%D1%82%D0%B8%D0%B2%D0%B5%D0%BD%D1%81_-_UNIX%3A_%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D0%B2.htmlru -->
<script type="text/javascript" language="javascript">

tableruler();

</script>
<br><br><br><br><br><br>

<br><br>
    <noindex>
        <!--LiveInternet counter-->
        <script type="text/javascript"><!--
        document.write("<a href='http://www.liveinternet.ru/click' "+"target=_blank><img src='//counter.yadro.ru/logo?14.11;' title='LiveInternet:     24"+" ,   24    ' "+"border='0' width='88' height='31'><\/a>"); 
        //-->
        </script>
        <!--/LiveInternet-->
    </noindex>

<br><br><br><br>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-15280114-1']);
  _gaq.push(['_setDomainName', 'e-reading.org.ua']);
  _gaq.push(['_setAllowLinker', true]);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>



