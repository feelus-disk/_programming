<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (Win95; I) [Netscape]">
   <TITLE>Цепочечные команды</TITLE>
<!версия HTML-стандарта>
<!начало html-документа>
<!заголовок html-документа>
<!заголовок страницы>
</HEAD>
<BODY BGCOLOR="#CFFFFF">
<!базовый размер символов (для всего документа><!тело html-документа><!C-HR SIZE=5 WIDTH=60%><A NAME="Цепочечные"></A>
<H2>
<FONT SIZE=+0>Цепочечные команды</FONT></H2>
<FONT SIZE=+0>Эти команды также называют командами <I>обработки строк символов</I>.
Названия почти синонимичны.</FONT>
<BR><FONT SIZE=+0>Отличие в том, что под <I>строкой символов</I> здесь
понимается последовательность байт, а <I>цепочка</I> — это более общее
название для случаев, когда элементы последовательности имеют размер больше
байта — слово или двойное слово.</FONT>
<BR><FONT SIZE=+0>Таким образом, цепочечные команды позволяют проводить
действия над блоками памяти, представляющими собой последовательности элементов
следующего размера:</FONT>
<UL>
<LI>
<FONT SIZE=+0>8 бит — байт;</FONT></LI>

<LI>
<FONT SIZE=+0>16 бит — слово;</FONT></LI>

<LI>
<FONT SIZE=+0>32 бита — двойное слово.</FONT></LI>
</UL>


<P><FONT SIZE=+0>Содержимое этих блоков для микропроцессора не имеет никакого
значения. Это могут быть символы, числа и все что угодно. Главное, чтобы
размерность элементов совпадала с одной из перечисленных и эти элементы
находились в соседних ячейках памяти.</FONT>

<P><FONT SIZE=+0>Всего в системе команд микропроцессора имеется семь <I>операций-примитивов</I>
обработки цепочек.</FONT>
<BR><FONT SIZE=+0>Каждая из них реализуется в микропроцессоре тремя командами,
в свою очередь, каждая из этих команд работает с соответствующим размером
элемента — байтом, словом или двойным словом.</FONT>
<BR><FONT SIZE=+0>Особенность всех цепочечных команд в том, что они, кроме
обработки текущего элемента цепочки, осуществляют еще и <B>автоматическое
продвижение</B> к следующему элементу данной цепочки.</FONT>

<P><FONT SIZE=+0>Перечислим операции-примитивы и команды, с помощью которых
они реализуются, а затем подробно их рассмотрим:</FONT>
<UL>
<LI>
<FONT SIZE=+0><I>пересылка цепочки</I>:</FONT></LI>

<UL><FONT SIZE=+0><B><A HREF="#movs">movs</A></B> 
<B>адрес_приемника,адрес_источника</B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#movs">movsb</A></B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#movs">movsw</A></B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#movs">movsd</A></B></FONT></UL>

<LI>
<FONT SIZE=+0><I>сравнение цепочек</I>:</FONT></LI>

<UL><FONT SIZE=+0><B><A HREF="#cmps">cmps</A></B> <B>адрес_приемника,адрес_источника</B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#cmps">cmpsb</A></B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#cmps">cmpsw</A></B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#cmps">cmpsd</A></B></FONT></UL>

<LI>
<FONT SIZE=+0><I>сканирование цепочки</I>:</FONT></LI>

<UL><FONT SIZE=+0><B><A HREF="#scas">scas</A></B> <B>адрес_приемника</B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#scas">scasb</A></B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#scas">scasw</A></B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#scas">scasd</A></B></FONT></UL>

<LI>
<FONT SIZE=+0><I>загрузка элемента из цепочки</I>:</FONT></LI>

<UL><FONT SIZE=+0><B><A HREF="#lods">lods</A></B> <B>адрес_источника</B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#lods">lodsb</A></B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#lods">lodsw</A></B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#lods">lodsd</A></B></FONT></UL>

<LI>
<FONT SIZE=+0><I>сохранение элемента в цепочке</I>:</FONT></LI>

<UL><FONT SIZE=+0><B><A HREF="#stos">stos</A></B> <B>адрес_приемника</B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#stos">stosb</A></B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#stos">stosw</A></B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#stos">stosd</A></B></FONT></UL>

<LI>
<FONT SIZE=+0><I>получение элементов цепочки из порта ввода-вывода</I>:</FONT></LI>

<UL><FONT SIZE=+0><B><A HREF="#ins">ins</A></B> <B>адрес_приемника,номер_порта</B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#ins">insb</A></B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#ins">insw</A></B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#ins">insd</A></B></FONT></UL>

<LI>
<FONT SIZE=+0><I>вывод элементов цепочки в порт ввода-вывода</I>:</FONT></LI>

<UL><FONT SIZE=+0><B><A HREF="#outs">outs</A></B> <B>номер_порта,адрес_источника</B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#outs">outsb</A></B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#outs">outsw</A></B></FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#outs">outsd</A></B></FONT></UL>
</UL>
<FONT SIZE=+0>Логически к этим командам нужно отнести и так называемые
<B>префиксы повторения</B>. Вспомните <A HREF="../Занятие_6/Зан_06.htm#ФорматМашиннойКоманды">формат
машинной команды</A> и его первые необязательные байты префиксов. Один
из возможных типов префиксов — это <I>префиксы повторения</I>. Они предназначены
для использования цепочечными командами.</FONT>

<P><FONT SIZE=+0>Префиксы повторения имеют свои мнемонические обозначения:</FONT>
<BLOCKQUOTE><FONT SIZE=+0><B>rep</B></FONT>
<BR><FONT SIZE=+0><B>repe</B> или <B>repz</B></FONT>
<BR><FONT SIZE=+0><B>repne</B> или <B>repnz</B></FONT></BLOCKQUOTE>


<P><FONT SIZE=+0>Эти префиксы повторения указываются перед нужной цепочечной
командой в поле метки.</FONT>
<BR><FONT SIZE=+0>Цепочечная команда без префикса выполняется один раз.
Размещение префикса перед цепочечной командой заставляет ее выполняться
в цикле.</FONT>

<P><FONT SIZE=+0>Отличия приведенных префиксов в том, на каком основании
принимается решение о циклическом выполнении цепочечной команды: <I>по
состоянию регистра ecx/cx или по флагу нуля zf</I>:</FONT>
<UL>
<LI>
<FONT SIZE=+0>префикс повторения <B>rep</B> (REPeat). Этот префикс используется
с командами, реализующими операции-примитивы пересылки и сохранения элементов
цепочек — соответственно, <B>movs</B> и <B>stos</B>.</FONT></LI>

<BR><FONT SIZE=+0>Префикс <B>rep</B> заставляет данные команды выполняться,
пока <I>содержимое в ecx/cx не станет равным 0</I>.</FONT>
<BR><FONT SIZE=+0>При этом цепочечная команда, перед которой стоит префикс,
<I>автоматически уменьшает содержимое ecx/cx на единицу</I>. Та же команда,
но без префикса, этого не делает;</FONT>
<LI>
<FONT SIZE=+0>префиксы повторения <B>repe</B> или <B>repz</B> (REPeat while
Equal or Zero). Эти префиксы являются абсолютными синонимами.</FONT></LI>

<BR><FONT SIZE=+0>Они заставляют цепочечную команду выполняться до тех
пор, пока <I>содержимое ecx/cx не равно нулю или флаг zf равен 1</I>.</FONT>
<BR><FONT SIZE=+0>Как только одно из этих условий нарушается, управление
передается следующей команде программы. Благодаря возможности анализа флага
zf, наиболее эффективно эти префиксы можно использовать с командами cmps
и scas для поиска отличающихся элементов цепочек.</FONT>
<LI>
<FONT SIZE=+0>префиксы повторения <B>repne</B> или <B>repnz</B> (REPeat
while Not Equal or Zero). Эти префиксы также являются абсолютными синонимами.
Их действие на цепочечную команду несколько отличается от действий префиксов
repe/repz. Префиксы repne/repnz заставляют цепочечную команду циклически
выполняться до тех пор, пока <I>содержимое ecx/cx не равно нулю или флаг
zf равен нулю</I>.</FONT></LI>

<BR><FONT SIZE=+0>При невыполнении одного из этих условий работа команды
прекращается.</FONT>
<BR><FONT SIZE=+0>Данные префиксы также можно использовать с командами
cmps и scas, но для поиска совпадающих элементов цепочек.</FONT></UL>
<FONT SIZE=+0>Следующий важный момент, связанный с цепочечными командами,
заключается в <I>особенностях формирования физического адреса</I> операндов
адрес_источника и адрес_приемника.</FONT>
<BR><FONT SIZE=+0><B>Цепочка-источник</B>, адресуемая операндом <I>адрес_источника</I>,
<U>может</U> находиться в текущем сегменте данных, определяемом регистром
<B>ds</B>.</FONT>
<BR><FONT SIZE=+0><B>Цепочка-приемник</B>, адресуемая операндом <I>адрес_приемника</I>,
<U>должна</U> быть в дополнительном сегменте данных, адресуемом сегментным
регистром <B>es</B>.</FONT>
<BR><FONT SIZE=+0>Важно отметить, что допускается <I>замена</I> (с помощью
префикса замены сегмента) только регистра <B>ds</B>, регистр es подменять
нельзя.</FONT>
<BR><FONT SIZE=+0>Вторые части адресов - <I>смещения цепочек</I> — также
находятся в строго определенных местах.</FONT>
<BR><FONT SIZE=+0>Для <B>цепочки-источника</B> это регистр <B>esi/si</B>
(Source Index register — индексный регистр источника).</FONT>
<BR><FONT SIZE=+0>Для <B>цепочки-получателя</B> это регистр <B>edi/di</B>
(Destination Index register - индексный регистр приемника).</FONT>
<BR><FONT SIZE=+0>Таким образом, полные физические адреса для операндов
цепочечных команд следующие:</FONT>
<UL>
<LI>
<FONT SIZE=+0>адрес_источника — пара <B>ds:esi/si</B>;</FONT></LI>

<LI>
<FONT SIZE=+0>адрес_приемника — пара <B>es:edi/di</B>.</FONT></LI>
</UL>
<FONT SIZE=+0>Вы, наверное обратили внимание на то, что все семь групп
команд, реализующих цепочечные операции-примитивы, имеют похожий по структуре
набор команд.</FONT>
<BR><FONT SIZE=+0>В каждом из этих наборов присутствует одна команда с
явным указанием операндов и три команды, не имеющие операндов.</FONT>
<BR><FONT SIZE=+0>На самом деле, набор команд микропроцессора имеет соответствующие
машинные команды только для цепочечных команд ассемблера без операндов.
Команды с операндами транслятор ассемблера использует только для определения
типов операндов.</FONT>
<BR><FONT SIZE=+0>После того как выяснен тип элементов цепочек по их описанию
в памяти, генерируется одна из трех машинных команд для каждой из цепочечных
операций. По этой причине все регистры, содержащие адреса цепочек, должны
быть инициализированы заранее, в том числе и для команд, допускающих явное
указание операндов.</FONT>
<BR><FONT SIZE=+0>В силу того, что цепочки адресуются однозначно, нет особого
смысла применять команды с операндами. Главное, что вы должны запомнить,
— <I>правильная загрузка регистров указателями обязательно требуется до
выдачи любой цепочечной команды</I>.</FONT>

<P><FONT SIZE=+0>Последний важный момент, касающийся всех цепочечных команд,
— это <I>направление обработки цепочки</I>. Есть две возможности:</FONT>
<UL>
<LI>
<FONT SIZE=+0>от начала цепочки к ее концу, то есть в направлении возрастания
адресов;</FONT></LI>

<LI>
<FONT SIZE=+0>от конца цепочки к началу, то есть в направлении убывания
адресов.</FONT></LI>
</UL>
<FONT SIZE=+0>Как мы увидим ниже, цепочечные команды сами выполняют модификацию
регистров, адресующих операнды, обеспечивая тем самым автоматическое продвижение
по цепочке. Количество байт, на которые эта модификация осуществляется,
определяется кодом команды. А вот знак этой модификации определяется значением
флага направления <B>df</B> (Direction Flag) в регистре eflags/flags:</FONT>
<UL>
<LI>
<FONT SIZE=+0>если <B>df = 0</B>, то значение индексных регистров esi/si
и edi/di будет автоматически увеличиваться (операция инкремента) цепочечными
командами, то есть обработка будет осуществляться в направлении возрастания
адресов;</FONT></LI>

<LI>
<FONT SIZE=+0>если <B>df = 1</B>, то значение индексных регистров esi/si
и edi/di будет автоматически уменьшаться (операция декремента) цепочечными
командами, то есть обработка будет идти в направлении убывания адресов.</FONT></LI>
</UL>
<FONT SIZE=+0>Состоянием флага <B>df</B> можно управлять с помощью двух
команд, не имеющих операндов:</FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#cld">cld</A></B>
(Clear Direction Flag) — очистить флаг направления. Команда сбрасывает
флаг направления df в 0.</FONT>
<BR><FONT SIZE=+0><B><A HREF="../../Text/Command.htm#std">std</A></B>
(Set Direction Flag) — установить флаг направления. Команда устанавливает
флаг направления df в 1.</FONT>

<P><FONT SIZE=+0>Это вся информация, касающаяся общих свойств цепочечных
команд. Далее мы более подробно рассмотрим каждую операцию-примитив и команды,
которые ее реализуют. При этом более подробно мы будем рассматривать одну
команду в каждой группе цепочечных команд — команду с операндами. Это будет
делаться из тех соображений, что это более общая команда в смысле ограничений,
накладываемых на типы операндов.&nbsp;</FONT><A NAME="movs"></A>
<H3>
<FONT SIZE=+0>Операция пересылки цепочек</FONT></H3>
<FONT SIZE=+0>Команды, реализующие эту операцию-примитив, производят копирование
элементов из одной области памяти (цепочки) в другую. Размер элемента определяется
применяемой командой.</FONT>

<P><FONT SIZE=+0>Система команд TASM предоставляет программисту четыре
команды, работающие с разными размерами элементов цепочки:</FONT>
<BLOCKQUOTE><FONT SIZE=+0><B>movs адрес_приемника,адрес_источника</B> (MOVe
String) — переслать цепочку;</FONT>
<BR><FONT SIZE=+0><B>movsb</B> (MOVe String Byte) — переслать цепочку байт;</FONT>
<BR><FONT SIZE=+0><B>movsw</B> (MOVe String Word) — переслать цепочку слов;</FONT>
<BR><FONT SIZE=+0><B>movsd</B> (MOVe String Double word) — переслать цепочку
двойных слов.</FONT></BLOCKQUOTE>

<H4>
<FONT SIZE=+0>Команда movs:</FONT></H4>
<FONT SIZE=+0><B><A HREF="../../Text/Command.htm#movs">movs</A></B>
<B>адрес_приемника,адрес_источника</B></FONT>
<BR><FONT SIZE=+0>Команда копирует байт, слово или двойное слово из цепочки,
адресуемой операндом адрес_источника, в цепочку, адресуемую операндом адрес_приемника.</FONT>
<BR><FONT SIZE=+0>Размер пересылаемых элементов ассемблер определяет, исходя
из атрибутов идентификаторов, указывающих на области памяти приемника и
источника. К примеру, если эти идентификаторы были определены директивой
db, то пересылаться будут байты, если идентификаторы были определены с
помощью директивы dd, то пересылке подлежат 32-битовые элементы, то есть
двойные слова.</FONT>
<BR><FONT SIZE=+0>Ранее уже было отмечено, что для цепочечных команд с
операндами, к которым относится и команда пересылки <B>movs адрес_приемника,адрес_источника</B>,
не существует машинного аналога.</FONT>
<BR><FONT SIZE=+0>При трансляции в зависимости от типа операндов транслятор
преобразует ее в одну из трех машинных команд:</FONT>
<BR><FONT SIZE=+0><B>movsb, movsw </B>или<B> movsd</B>.</FONT>

<P><FONT SIZE=+0>Сама по себе команда movs пересылает только один элемент,
исходя из его типа, и модифицирует значения регистров esi/si и edi/di.
Если перед командой написать префикс <B>rep</B>, то одной командой можно
переслать до 64 Кбайт данных (если размер адреса в сегменте 16 бит — use16)
или до 4 Гбайт данных (если размер адреса в сегменте 32 бит - use32).</FONT>
<BR><FONT SIZE=+0>Число пересылаемых элементов должно быть загружено в
<I>счетчик</I> — регистр <B>cx</B> (use16) или <B>ecx</B> (use32).</FONT>

<P><FONT SIZE=+0>Перечислим набор действий, которые нужно выполнить в программе
для того, чтобы выполнить пересылку последовательности элементов из одной
области памяти в другую с помощью команды movs.</FONT>
<BR><FONT SIZE=+0>В общем случае этот набор действий можно рассматривать
как типовой для выполнения любой цепочечной команды:</FONT>
<UL>
<LI>
<FONT SIZE=+0>Установить значение флага df в зависимости от того, в каком
направлении будут обрабатываться элементы цепочки — в направлении возрастания
или убывания адресов.</FONT></LI>

<LI>
<FONT SIZE=+0>Загрузить указатели на адреса цепочек в памяти в пары регистров
ds:(e)si и es: (e)di.</FONT></LI>

<LI>
<FONT SIZE=+0>Загрузить в регистр ecx/cx количество элементов, подлежащих
обработке.</FONT></LI>

<LI>
<FONT SIZE=+0>Выдать команду movs с префиксом rep.</FONT></LI>
</UL>
<FONT SIZE=+0>На примере листинга 1 рассмотрим, как эти действия реализуются
программно. В этой программе производится пересылка символов из одной строки
в другую. Строки находятся в одном сегменте памяти. Для пересылки используется
команда-примитив movs с префиксом повторения rep.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
Листинг 1 Пересылка строк командой movs
;prg_11_1.asm
MASM
MODEL&nbsp;&nbsp; small
STACK&nbsp;&nbsp; 256
.data
source&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Тестируемая строка','$'
;строка-источник
dest&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 19 DUP (' ')&nbsp;&nbsp;&nbsp; ;строка-приёмник
.code
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assume&nbsp; ds:@data,es:@data
main:&nbsp;&nbsp; ;точка входа в программу
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,@data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;загрузка сегментных регистров
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds,ax&nbsp;&nbsp; ;настройка регистров DS и ES
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;на адрес сегмента данных
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es,ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp; ;сброс флага DF — обработка строки от начала к концу
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; si,source&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;загрузка в si смещения строки-источника
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; di,dest ;загрузка в DS смещения строки-приёмника
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,20&nbsp;&nbsp; ;для префикса rep — счетчик повторений (длина строки)
rep&nbsp;&nbsp;&nbsp;&nbsp; movs&nbsp;&nbsp;&nbsp; dest,source&nbsp;&nbsp;&nbsp;&nbsp; ;пересылка строки
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,dest
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h&nbsp; ;вывод на экран строки-приёмника
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h
exit:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,4c00h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h
end&nbsp;&nbsp;&nbsp;&nbsp; main</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<A NAME="cmps"></A>
<H3>
<FONT SIZE=+0>Операция сравнения цепочек</FONT></H3>
<FONT SIZE=+0>Команды, реализующие эту операцию-примитив, производят сравнение
элементов цепочки-источника с элементами цепочки-приемника. Здесь ситуация
с набором команд и методами работы с ними аналогична операции-примитиву
пересылки цепочек.</FONT>
<BR><FONT SIZE=+0>TASM предоставляет программисту четыре команды сравнения
цепочек, работающие с разными размерами элементов цепочки:</FONT>
<BLOCKQUOTE><FONT SIZE=+0><B>cmps адрес_приемника,адрес_источника</B>(CoMPare
String) — сравнить строки;</FONT>
<BR><FONT SIZE=+0><B>cmpsb</B> (CoMPare String Byte) — сравнить строку
байт;</FONT>
<BR><FONT SIZE=+0><B>cmpsw</B> (CoMPare String Word) — сравнить строку
слов;</FONT>
<BR><FONT SIZE=+0><B>cmpsd</B> (CoMPare String Double word) — сравнить
строку двойных слов.</FONT></BLOCKQUOTE>

<H4>
<FONT SIZE=+0>Команда cmps</FONT></H4>
<FONT SIZE=+0>Синтаксис команды cmps:</FONT>
<BR><FONT SIZE=+0><B>cmps адрес_приемника,адрес_источника</B></FONT>
<BR><FONT SIZE=+0>Здесь:</FONT>
<UL>
<LI>
<FONT SIZE=+0><I>адрес_источника</I> определяет <B>цепочку-источник</B>
в сегменте данных. Адрес цепочки должен быть заранее загружен в пару <B>ds:esi/si</B>;</FONT></LI>

<LI>
<FONT SIZE=+0><I>адрес_приемника</I> определяет <B>цепочку-приемник</B>.
Цепочка должна находиться в дополнительном сегменте, и ее адрес должен
быть заранее загружен в пару <B>es:edi/di</B>.</FONT></LI>
</UL>
<FONT SIZE=+0>Алгоритм работы команды cmps заключается в последовательном
выполнении вычитания <U>(элемент цепочки-источника — элемент цепочки-получателя)</U>
над очередными элементами обеих цепочек.</FONT>
<BR><FONT SIZE=+0>Принцип выполнения вычитания командой cmps аналогичен
команде сравнения cmp. Она, так же, как и cmp, производит вычитание элементов,
не записывая при этом результата, и устанавливает флаги zf, sf и of.</FONT>
<BR><FONT SIZE=+0>После выполнения вычитания очередных элементов цепочек
командой cmps, индексные регистры esi/si и edi/di <I>автоматически изменяются
в соответствии со значением флага df на значение, равное размеру элемента
сравниваемых цепочек</I>.</FONT>
<BR><FONT SIZE=+0>Чтобы заставить команду cmps выполняться несколько раз,
то есть производить последовательное сравнение элементов цепочек, необходимо
перед командой cmps определить префикс повторения.</FONT>
<BR><FONT SIZE=+0>С командой cmps можно использовать префикс повторения
<B>repe/repz</B> или <B>repne/repnz</B>:</FONT>
<UL>
<LI>
<FONT SIZE=+0>repe или repz — если необходимо организовать сравнение до
тех пор, пока не будет выполнено одно из двух условий:</FONT></LI>

<UL>
<LI>
<FONT SIZE=+0>достигнут конец цепочки (содержимое ecx/cx равно нулю);</FONT></LI>

<LI>
<FONT SIZE=+0>в цепочках встретились разные элементы (флаг zf стал равен
нулю);</FONT></LI>
</UL>

<LI>
<FONT SIZE=+0>repne или repnz — если нужно проводить сравнение до тех пор,
пока:</FONT></LI>

<UL>
<LI>
<FONT SIZE=+0>не будет достигнут конец цепочки (содержимое ecx/cx равно
нулю);</FONT></LI>

<LI>
<FONT SIZE=+0>в цепочках встретились одинаковые элементы (флаг zf стал
равен единице).</FONT></LI>
</UL>
</UL>
<FONT SIZE=+0>Таким образом, выбрав подходящий префикс, удобно использовать
команду cmps для поиска одинаковых или различающихся элементов цепочек.</FONT>
<BR><FONT SIZE=+0>Выбор префикса определяется причиной, которая приводит
к выходу из цикла. Таких причин может быть две для каждого из префиксов.
Для определения конкретной причины наиболее подходящим является способ,
использующий команду условного перехода <B>jcxz</B>. Ее работа заключается
в анализе содержимого регистра ecx/cx, и если оно равно нулю, то управление
передается на метку, указанную в качестве операнда jcxz. Так как в регистре
ecx/cx содержится счетчик повторений для цепочечной команды, имеющей любой
из префиксов повторения, то, анализируя ecx/cx, можно определить причину
выхода из зацикливания цепочечной команды. Если значение в ecx/cx <I>не
равно нулю</I>, то это означает, что выход произошел по причине совпадения
либо несовпадения очередных элементов цепочек.</FONT>
<BR><FONT SIZE=+0>Существует возможность еще больше конкретизировать информацию
о причине, приведшей к окончанию операции сравнения. Сделать это можно
с помощью команд условной передачи управления (табл. 1 и 2).</FONT>

<P><FONT SIZE=+0><B>Таблица 1. </B>Сочетание команд условной передачи управления
с результатами команды cmps (для чисел со знаком)</FONT>

<P><CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD ALIGN=CENTER>Причина прекращения операции сравнения</TD>

<TD>Команда условного перехода, реализующая переход по этой причине</TD>
</TR>

<TR>
<TD ALIGN=CENTER>операнд_источник > операнд_приемник</TD>

<TD ALIGN=CENTER>jg</TD>
</TR>

<TR>
<TD ALIGN=CENTER>операнд_источник = операнд_приемник</TD>

<TD ALIGN=CENTER>je</TD>
</TR>

<TR>
<TD ALIGN=CENTER>операнд_источник &lt;> операнд_приемник</TD>

<TD ALIGN=CENTER>jne</TD>
</TR>

<TR>
<TD ALIGN=CENTER>операнд_источник &lt; операнд_приемник</TD>

<TD ALIGN=CENTER>jl</TD>
</TR>

<TR>
<TD ALIGN=CENTER>операнд_источник &lt;= операнд_приемник</TD>

<TD ALIGN=CENTER>jle</TD>
</TR>

<TR>
<TD ALIGN=CENTER>операнд_источник >= операнд_приемник</TD>

<TD ALIGN=CENTER>jge</TD>
</TR>
</TABLE></CENTER>
<P><B><FONT SIZE=+0>Таблица 2.</FONT></B><FONT SIZE=+0> Сочетание команд условной
передачи управления с результатами команды cmps (для чисел без знака)</FONT>
<P><CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD ALIGN=CENTER>Причина прекращения операции сравнения</TD>

<TD>Команда условного перехода, реализующая переход по этой причине</TD>
</TR>

<TR>
<TD ALIGN=CENTER>операнд_источник > операнд_приемник</TD>

<TD ALIGN=CENTER>ja</TD>
</TR>

<TR>
<TD ALIGN=CENTER>операнд_источник = операнд_приемник</TD>

<TD ALIGN=CENTER>je</TD>
</TR>

<TR>
<TD ALIGN=CENTER>операнд_источник &lt;> операнд_приемник</TD>

<TD ALIGN=CENTER>jne</TD>
</TR>

<TR>
<TD ALIGN=CENTER>операнд_источник &lt; операнд_приемник</TD>

<TD ALIGN=CENTER>jb</TD>
</TR>

<TR>
<TD ALIGN=CENTER>операнд_источник &lt;= операнд_приемник</TD>

<TD ALIGN=CENTER>jbe</TD>
</TR>

<TR>
<TD ALIGN=CENTER>операнд_источник >= операнд_приемник</TD>

<TD ALIGN=CENTER>jae</TD>
</TR>
</TABLE></CENTER>
<P>
<P><FONT SIZE=+0>Как определить местоположение очередных совпавших или не
совпавших элементов в цепочках?</FONT>

<P><FONT SIZE=+0>Вспомните, что после каждой итерации цепочечная команда
автоматически осуществляет инкремент/декремент значения адреса в соответствующих
индексных регистрах. Поэтому после выхода из цикла в этих регистрах будут
находиться адреса элементов, находящихся в цепочке <B>после (!) элементов</B>,
которые послужили причиной выхода из цикла.</FONT>
<BR><FONT SIZE=+0>Для получения истинного адреса этих элементов необходимо
скорректировать содержимое индексных регистров, увеличив либо уменьшив
значение в них на длину элемента цепочки.</FONT>
<BR><FONT SIZE=+0>В качестве примера рассмотрим программу из листинга 2,
которая сравнивает две строки, находящиеся в одном сегменте. Используется
команда cmps. Префикс повторения - repe.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;Листинг 2. Сравнение двух строк командой cmps
&lt;1> ;prg_11_2.asm
&lt;2> MODEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; small
&lt;3> STACK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 256
&lt;4> .data
&lt;5> match&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0ah,0dh,'Строки совпадают.','$'
&lt;6> failed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0ah,0dh,'Строки не совпадают','$'
&lt;7> string1&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '0123456789',0ah,0dh,'$';исследуемые строки
&lt;8> string2&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '0123406789','$'
&lt;9> .code
&lt;10> ASSUME&nbsp;&nbsp;&nbsp;&nbsp; ds:@data,es:@data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;привязка DS и ES к сегменту данных
&lt;11> main:
&lt;12>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,@data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;загрузка сегментных регистров
&lt;13>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds,ax
&lt;14>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es,ax&nbsp;&nbsp; ;настройка ES на DS
&lt;15> ;вывод на экран исходных строк string1 и string2
&lt;16>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h
&lt;17>&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,string1
&lt;18>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h
&lt;19>&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,string2
&lt;20>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h
&lt;21> ;сброс флага DF — сравнение в направлении возрастания&nbsp; адресов
&lt;22>&nbsp;&nbsp;&nbsp; cld
&lt;23>&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; si,string1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;загрузка в si смещения string1
&lt;24>&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; di,string2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;загрузка в di смещения string2
&lt;25>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,10&nbsp;&nbsp; ;длина строки для префикса repe
&lt;26> ;сравнение строк (пока сравниваемые элементы строк равны)
&lt;27> ;выход при обнаружении не совпавшего элемента
&lt;28> cycl:
&lt;29>&nbsp;&nbsp;&nbsp; repe&nbsp;&nbsp;&nbsp; cmps&nbsp;&nbsp;&nbsp; string1,string2
&lt;30>&nbsp;&nbsp;&nbsp; jcxz&nbsp;&nbsp;&nbsp; equal&nbsp;&nbsp; ;cx=0, то есть строки совпадают
&lt;31>&nbsp;&nbsp;&nbsp; jne&nbsp;&nbsp;&nbsp;&nbsp; not_match&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;если не равны — переход на not_match
&lt;32> equal:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;иначе, если совпадают, то
&lt;33>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h&nbsp; ;вывод сообщения
&lt;34>&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,match
&lt;35>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h
&lt;36>&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp; exit&nbsp;&nbsp;&nbsp; ;выход
&lt;37> not_match:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;не совпали
&lt;38>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h
&lt;39>&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,failed
&lt;40>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;вывод сообщения
&lt;41> ;теперь, чтобы обработать не совпавший элемент в
&nbsp;строке, необходимо уменьшить значения регистров si и di
&lt;42>&nbsp;&nbsp;&nbsp; dec&nbsp;&nbsp;&nbsp;&nbsp; si
&lt;43>&nbsp;&nbsp;&nbsp; dec&nbsp;&nbsp;&nbsp;&nbsp; di
&lt;44> ;сейчас в ds:si и es:di адреса несовпавших элементов
&lt;45> ;здесь вставить код по обработке несовпавшего элемента
&lt;46> ;после этого продолжить поиск в строке:
&lt;47>&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp;&nbsp; si
&lt;48>&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp;&nbsp; di
&lt;49>&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp; cycl
&lt;50> exit:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;выход
&lt;51>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,4c00h
&lt;52>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h
&lt;53> end&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; main&nbsp;&nbsp;&nbsp; ;конец программы</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>Программа достаточно прозрачна, только два момента, на мой
взгляд, требуют пояснения:</FONT>
<UL>
<LI>
<FONT SIZE=+0><I>во-первых</I>, строки 42 и 43, в которых мы скорректировали
адреса очередных элементов для получения адресов несовпавших элементов.
Вы должны понимать, что если сравниваются цепочки с элементами слов или
двойных слов, то корректировать содержимое esi/si и edi/di нужно на 2 и
4 байта соответственно;</FONT></LI>

<LI>
<FONT SIZE=+0><I>во-вторых</I>, строки 47–49. Смысл их в том, что для просмотра
оставшейся части строк необходимо установить указатели на следующие элементы
строк за последними несовпавшими. После этого можно повторить весь процесс
просмотра и обработки несовпавших элементов в оставшихся частях строк.&nbsp;</FONT><A NAME="scas"></A></LI>

<H3>
<FONT SIZE=+0>Операция сканирования цепочек</FONT></H3>
<FONT SIZE=+0>Команды, реализующие эту операцию-примитив, производят поиск
некоторого значения в области памяти. Логически эта область памяти рассматривается
как последовательность (цепочка) элементов фиксированной длины размером
8, 16 или 32 бит.</FONT>
<BR><FONT SIZE=+0>Искомое значение предварительно должно быть помещено
в регистр <B>al/ax/eax</B>. Выбор конкретного регистра из этих трех должен
быть согласован с размером элементов цепочки, в которой осуществляется
поиск.</FONT>

<P><FONT SIZE=+0>Система команд микропроцессора предоставляет программисту
четыре команды сканирования цепочки.</FONT>
<BR><FONT SIZE=+0>Выбор конкретной команды определяется размером элемента:</FONT>
<UL><FONT SIZE=+0><B>scas адрес_приемника</B> (SCAning String) — сканировать
цепочку;</FONT>
<BR><FONT SIZE=+0><B>scasb</B> (SCAning String Byte) — сканировать цепочку
байт;</FONT>
<BR><FONT SIZE=+0><B>scasw</B> (SCAning String Word) — сканировать цепочку
слов;</FONT>
<BR><FONT SIZE=+0><B>scasd</B> (SCAning String Double Word) — сканировать
цепочку двойных слов.</FONT></UL>

<H4>
<FONT SIZE=+0>Команда scas</FONT></H4>
<FONT SIZE=+0><B>scas адрес_приемника</B></FONT>
<BR><FONT SIZE=+0>Команда имеет один операнд, обозначающий местонахождение
цепочки в дополнительном сегменте (адрес цепочки должен быть заранее сформирован
в <B>es:edi/di</B>).</FONT>
<BR><FONT SIZE=+0>Транслятор анализирует тип идентификатора <I>адрес_приемника</I>,
который обозначает цепочку в сегменте данных, и формирует одну из трех
машинных команд <B>scasb, scasw или scasd</B>.</FONT>
<BR><FONT SIZE=+0>Условие поиска для каждой из этих трех команд находится
в строго определенном месте. Так, если цепочка описана с помощью директивы
db, то искомый элемент должен быть байтом и находиться в al, а сканирование
цепочки осуществляется командой scasb; если цепочка описана с помощью директивы
dw, то это — слово в ax, и поиск ведется командой scasw; если цепочка описана
с помощью директивы dd, то это — двойное слово в eax, и поиск ведется командой
scasd. Принцип поиска тот же, что и в команде сравнения cmps, то есть последовательное
выполнение вычитания</FONT>
<BR><FONT SIZE=+0><U>(содержимое_регистра_аккумулятора - содержимое_очередного_элемента_цепочки)</U>.</FONT>
<BR><FONT SIZE=+0>В зависимости от результатов вычитания производится установка
флагов, при этом сами операнды не изменяются.</FONT>
<BR><FONT SIZE=+0>Так же, как и в случае команды cmps, с командой scas
удобно использовать префиксы <B>repe/repz</B> или <B>repne/repnz</B>:</FONT>
<UL>
<LI>
<FONT SIZE=+0><B>repe</B> или <B>repz</B> — если нужно организовать поиск
до тех пор, пока не будет выполнено одно из двух условий:</FONT></LI>

<UL>
<LI>
<FONT SIZE=+0>достигнут конец цепочки (содержимое ecx/cx равно 0);</FONT></LI>

<LI>
<FONT SIZE=+0>в цепочке встретился элемент, отличный от элемента в регистре
al/ax/eax;</FONT></LI>
</UL>

<LI>
<FONT SIZE=+0><B>repne</B> или <B>repnz</B> — если нужно организовать поиск
до тех пор, пока не будет выполнено одно из двух условий:</FONT></LI>

<UL>
<LI>
<FONT SIZE=+0>достигнут конец цепочки (содержимое ecx/cx равно 0);</FONT></LI>

<LI>
<FONT SIZE=+0>в цепочке встретился элемент, совпадающий с элементом в регистре
al/ax/eax.</FONT></LI>
</UL>
</UL>
<FONT SIZE=+0>Таким образом, команда scas с префиксом repe/repz позволяет
найти элемент цепочки, <I>отличающийся</I> по значению от заданного в аккумуляторе.</FONT>
<BR><FONT SIZE=+0>Команда scas с префиксом <I>repne/repnz</I> позволяет
найти элемент цепочки, совпадающий по значению с элементом в аккумуляторе.</FONT>

<P><FONT SIZE=+0>В качестве примера рассмотрим листинг 3, который производит
поиск символа в строке.</FONT>
<BR><FONT SIZE=+0>В программе используется команда-примитив scas.</FONT>
<BR><FONT SIZE=+0>Символ задается явно (строка 20).</FONT>
<BR><FONT SIZE=+0>Префикс повторения — repne.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;Листинг 3. Поиск символа в строке командой scas
&lt;1> ;prg_11_3.asm
&lt;2> MASM
&lt;3> MODEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; small
&lt;4> STACK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 256
&lt;5> .data
&lt;6> ;тексты сообщений
&lt;7> fnd db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0ah,0dh,'Символ найден! ','$'
&lt;8> nochar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0ah,0dh,'Символ не найден.','$'
&lt;9> ;строка для поиска
&lt;10> string&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Поиск символа в этой строке.',0ah,0dh,'$'
&lt;11> .code
&lt;12> ASSUME&nbsp;&nbsp;&nbsp;&nbsp; ds:@data,es:@data
&lt;13> main:
&lt;14>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,@data
&lt;15>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds,ax
&lt;16>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es,ax&nbsp;&nbsp; ;настройка ES на DS
&lt;17>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h
&lt;18>&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,string
&lt;19>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;вывод сообщения string
&lt;20>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,'а'&nbsp; ;символ для поиска — `а`(кириллица)
&lt;21>&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;сброс флага df
&lt;22>&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; di,string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;загрузка в es:di смещения строки
&lt;23>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,29&nbsp;&nbsp; ;для префикса repne — длина строки
&lt;24> ;поиск в строке (пока искомый символ и символ в строке не совпадут)
&lt;25> ;выход при первом совпадении
&lt;26> repne&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scas&nbsp;&nbsp;&nbsp; string
&lt;27>&nbsp;&nbsp;&nbsp; je&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; found&nbsp;&nbsp; ;если равны — переход на обработку,
&lt;28> failed:&nbsp;&nbsp;&nbsp; ;иначе выполняем некоторые действия
&lt;29> ;вывод сообщения о том, что символ не найден
&lt;30>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h
&lt;31>&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,nochar
&lt;32>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;вывод сообщения nochar
&lt;33>&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp; exit&nbsp;&nbsp;&nbsp; ;на выход
&lt;34> found:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;совпали
&lt;35>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h
&lt;36>&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,fnd
&lt;37>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h ;вывод сообщения fnd
&lt;38> ;теперь, чтобы узнать место, где совпал элемент в&nbsp; строке,
&lt;39> ;необходимо уменьшить значение в регистре di и&nbsp; вставить нужный обработчик
&lt;40> ;&nbsp; dec&nbsp;&nbsp;&nbsp;&nbsp; di
&lt;41> ... вставьте обработчик
&lt;42> exit:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;выход
&lt;43>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,4c00h
&lt;44>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h
&lt;45> end&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; main</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<A NAME="lods"></A>
<H3>
<FONT SIZE=+0>Загрузка элемента цепочки в аккумулятор</FONT></H3>
<FONT SIZE=+0>Эта операция-примитив позволяет извлечь элемент цепочки и
поместить его в регистр-аккумулятор al, ax или eax. Эту операцию удобно
использовать вместе с поиском (сканированием) с тем, чтобы, найдя нужный
элемент, извлечь его (например, для изменения).</FONT>
<BR><FONT SIZE=+0>Возможный размер извлекаемого элемента определяется применяемой
командой.</FONT>

<P><FONT SIZE=+0>Программист может использовать четыре команды загрузки
элемента цепочки в аккумулятор, работающие с элементами разного размера:</FONT>
<UL><FONT SIZE=+0><B>lods адрес_источника </B>(LOaD String) — загрузить
элемент из цепочки в регистр-аккумулятор al/ax/eax;</FONT>
<BR><FONT SIZE=+0><B>lodsb</B> (LOaD String Byte) — загрузить байт из цепочки
в регистр al;</FONT>
<BR><FONT SIZE=+0><B>lodsw</B> (LOaD String Word) — загрузить слово из
цепочки в регистр ax;</FONT>
<BR><FONT SIZE=+0><B>lodsd</B> (LOaD String Double Word) — загрузить двойное
слово из цепочки в регистр eax.</FONT></UL>
<FONT SIZE=+0>Рассмотрим работу этих команд на примере lods.</FONT>
<H4>
<FONT SIZE=+0>Команда lods</FONT></H4>
<FONT SIZE=+0><B>lods адрес_источника</B> (LOaD String) — загрузить элемент
из цепочки в аккумулятор <B>al/ax/eax</B>.</FONT>
<BR><FONT SIZE=+0>Команда имеет один операнд, обозначающий строку в основном
сегменте данных. Работа команды заключается в том, чтобы извлечь элемент
из цепочки по адресу, соответствующему содержимому пары регистров <B>ds:esi/si</B>,
и поместить его в регистр <B>eax/ax/al</B>. При этом содержимое esi/si
подвергается инкременту или декременту (в зависимости от состояния флага
df) на значение, равное размеру элемента.</FONT>
<BR><FONT SIZE=+0>Эту команду удобно использовать после команды <B>scas</B>,
локализующей местоположение искомого элемента в цепочке.</FONT>
<BR><FONT SIZE=+0>Префикс повторения в этой команде может и не понадобиться
— все зависит от логики программы.</FONT>

<P><FONT SIZE=+0>В качестве примера рассмотрим листинг 4. Программа сравнивает
командой cmps две цепочки байт в памяти string1 и string2 и помещает первый
несовпавший байт из string2 в регистр al. Для загрузки этого байта в регистр-аккумулятор
al используется команда lods. Префикса повторения в команде lods нет, так
как он попросту не нужен.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
Листинг 4. Использование lods для загрузки байта в регистр al
&lt;1> ;prg_11_4.asm
&lt;2> MASM
&lt;3> MODEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; small
&lt;4> STACK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 256
&lt;5> .data
&lt;6> ;строки&nbsp;&nbsp;&nbsp;&nbsp; для&nbsp;&nbsp;&nbsp;&nbsp; сравнения
&lt;7> string1&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Поиск символа в этой строке.',0ah,0dh,'$'
&lt;8> string2&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Поиск символа не в этой строке.',0ah,0dh,'$'
&lt;9> mes_eq&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Строки совпадают.',0ah,0dh,'$'
&lt;10> fnddb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Несовпавший элемент в регистре al',0ah,0dh,'$'
&lt;11> .code
&lt;12> ;привязка ds и es к сегменту данных
&lt;13> assume&nbsp;&nbsp;&nbsp;&nbsp; ds:@data,es:@data
&lt;14> main:
&lt;15>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,@data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;загрузка сегментных регистров
&lt;16>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds,ax
&lt;17>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es,ax&nbsp;&nbsp; ;настройка es на ds
&lt;18>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h
&lt;19>&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,string1
&lt;20>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;вывод string1
&lt;21>&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,string2
&lt;22>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;вывод string2
&lt;23>&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp; ;сброс флага df
&lt;24>&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; di,string1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;загрузка в es:di смещения
&lt;25> ;строки string1
&lt;26>&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; si,string2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;загрузка в ds:si смещения
&lt;27> ;строки string2
&lt;28>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,29&nbsp;&nbsp; ;для префикса repe — длина строки
&lt;29> ;поиск в строке (пока нужный символ и символ в строке не равны)
&lt;30> ;выход — при первом несовпавшем
&lt;31> repe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmps&nbsp;&nbsp;&nbsp; string1,string2
&lt;32>&nbsp;&nbsp;&nbsp; jcxz&nbsp;&nbsp;&nbsp; eql&nbsp;&nbsp;&nbsp;&nbsp; ;если равны — переход на eql
&lt;33>&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp; no_eq&nbsp;&nbsp; ;если не равны — переход на no_eq
&lt;34> eql:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;выводим сообщение о совпадении строк
&lt;35>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h
&lt;36>&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,mes_eq
&lt;37>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;вывод сообщения mes_eq
&lt;38>&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp; exit&nbsp;&nbsp;&nbsp; ;на выход
&lt;39> no_eq:&nbsp;&nbsp;&nbsp;&nbsp; ;обработка несовпадения элементов
&lt;40>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h
&lt;41>&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,fnd
&lt;42>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;вывод сообщения fnd
&lt;43> ;теперь, чтобы извлечь несовпавший элемент из строки
&lt;44> ;в регистр-аккумулятор,
&lt;45> ;уменьшаем значение регистра si и тем самым перемещаемся
&lt;46> ;к действительной позиции элемента в строке
&lt;47>&nbsp;&nbsp;&nbsp; dec&nbsp;&nbsp;&nbsp;&nbsp; si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;команда lods использует ds:si-адресацию
&lt;48> ;теперь ds:si указывает на позицию в string2
&lt;49>&nbsp;&nbsp;&nbsp; lods&nbsp;&nbsp;&nbsp; string2 ;загрузим элемент из строки в AL
&lt;50> ;нетрудно догадаться, что в нашем примере это символ — "н"
&lt;51> exit:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;выход
&lt;52>&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,4c00h
&lt;53>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h
&lt;54> end&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; main
&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<A NAME="stos"></A>
<H3>
<FONT SIZE=+0>Перенос элемента из аккумулятора в цепочку</FONT></H3>
<FONT SIZE=+0>Эта операция-примитив позволяет произвести действие, обратное
команде lods, то есть сохранить значение из регистра-аккумулятора в элементе
цепочки.</FONT>
<BR><FONT SIZE=+0>Эту операцию удобно использовать вместе с операцией поиска
(сканирования) scans и загрузки lods, с тем, чтобы, <I>найдя нужный элемент,
извлечь его в регистр и записать на его место новое значение</I>.</FONT>
<BR><FONT SIZE=+0>Команды, поддерживающие эту операцию-примитив, могут
работать с элементами размером 8, 16 или 32 бит.</FONT>
<BR><FONT SIZE=+0>TASM предоставляет программисту четыре команды сохранения
элемента цепочки из регистра-аккумулятора, работающие с элементами разного
размера:</FONT>
<UL><FONT SIZE=+0><B>stos адрес_приемника</B> (STOre String) — сохранить
элемент из регистра-аккумулятора al/ax/eax в цепочке;</FONT>
<BR><FONT SIZE=+0><B>stosb</B> (STOre String Byte) — сохранить байт из
регистра al в цепочке;</FONT>
<BR><FONT SIZE=+0><B>stosw</B> (STOre String Word) — сохранить слово из
регистра ax в цепочке;</FONT>
<BR><FONT SIZE=+0><B>stosd</B> (STOre String Double Word) - сохранить двойное
слово из регистра eax в цепочке.</FONT></UL>

<H4>
<FONT SIZE=+0>Команда stos</FONT></H4>
<FONT SIZE=+0><B>stos адрес_приемника</B> (STOrage String) — сохранить
элемент из регистра-аккумулятора al/ax/eax в цепочке.</FONT>

<P><FONT SIZE=+0>Команда имеет один операнд <I>адрес_приемника</I>, адресующий
цепочку в дополнительном сегменте данных.</FONT>
<BR><FONT SIZE=+0>Работа команды заключается в том, что она пересылает
элемент из аккумулятора (регистра <B>eax/ax/al</B>) в элемент цепочки по
адресу, соответствующему содержимому пары регистров <B>es:edi/di</B>. При
этом содержимое edi/di подвергаются инкременту или декременту (в зависимости
от состояния флага df) на значение, равное размеру элемента цепочки.</FONT>
<BR><FONT SIZE=+0>Префикс повторения в этой команде может и не понадобиться
— все зависит от логики программы. Например, если использовать префикс
повторения rep, то можно применить команду для инициализации области памяти
некоторым фиксированным значением.</FONT>

<P><FONT SIZE=+0>В качестве примера рассмотрим листинг 5. Программа производит
замену в строке всех символов “а” на другой символ. Символ для замены вводится
с клавиатуры.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
Листинг 5. Замена командой stos символа в строке на вводимый с клавиатуры
;prg_11_5.asm
MASM
MODEL&nbsp;&nbsp; small
STACK&nbsp;&nbsp; 256
.data
;сообщения
fnd&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0ah,0dh,'Символ найден','$'
nochar&nbsp; db 0ah,0dh,'Символ не найден.','$'
mes1&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0ah,0dh,'Исходная строка:','$'
string&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Поиск символа в этой строке.',0ah,0dh,'$' ;строка для поиска
mes2&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0ah,0dh,'Введите символ, на который следует заменить найденный'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0ah,0dh,'$'
mes3&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0ah,0dh,'Новая строка: ','$'
.code
&nbsp;assume ds:@data,es:@data привязка ds и es к сегменту данных
main:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;точка входа в программу
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,@data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;загрузка сегментных регистров
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds,ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es,ax&nbsp;&nbsp; ;настройка es на ds
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,mes1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;вывод сообщения mes1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,string
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;вывод string
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,'а'&nbsp; ;символ для поиска-`а`(кириллица)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;сброс флага df
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; di,string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;загрузка в di смещения string
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,29&nbsp;&nbsp; ;для префикса repne — длина строки
;поиск в строке string до тех пор, пока
;символ в al и очередной символ в строке
;не равны: выход - при первом совпадении
cycl:
repne&nbsp;&nbsp; scas string
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; je&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; found&nbsp;&nbsp; ;если элемент найден то переход на found
failed:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;иначе, если не найден, то вывод сообщения nochar
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,nochar
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp; exit&nbsp;&nbsp;&nbsp; ;переход на выход
found:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,fnd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h ;вывод сообщения об обнаружении символа
;корректируем di для получения значения
;действительной позиции совпавшего элемента
;в строке и регистре al
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dec&nbsp;&nbsp;&nbsp;&nbsp; di
new_char:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;блок замены символа
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,mes2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;вывод сообщения mes2
;ввод символа с клавиатуры
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,01h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;в al — введённый символ
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stos&nbsp;&nbsp;&nbsp; string&nbsp; ;сохраним введённый символ
&nbsp;;(из al) в строке string в позиции старого символа
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ah,09h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,mes3
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp; ;вывод сообщения mes3
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; dx,string
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h ;вывод сообщения string
;переход на поиск следующего символа ‘а’ в
строке
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp;&nbsp; di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;указатель в строке string на следующий,
&nbsp;;после совпавшего, символ
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp; cycl&nbsp;&nbsp;&nbsp; ;на продолжение просмотра string
exit:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;выход
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,4c00h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h
end&nbsp;&nbsp;&nbsp;&nbsp; main&nbsp;&nbsp;&nbsp; ;конец программы</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>Следующие две команды появились впервые в системе команд
микропроцессора i386. Они позволяют организовать эффективную передачу данных
между портами ввода-вывода и цепочками в памяти. Следует отметить, что
эти две команды позволяют достичь скорости передачи данных со скоростью
выше той, которую может обеспечить контроллер DMA (Direct Memory Access
— прямой доступ к памяти). Контроллер DMA — это специальная микросхема,
предназначенная для того, чтобы освободить микропроцессор от управления
процессом ввода-вывода больших массивов данных между внешним устройством
(диском) и памятью.&nbsp;</FONT><A NAME="ins"></A>
<H3>
<FONT SIZE=+0>Ввод элемента цепочки из порта ввода-вывода</FONT></H3>
<FONT SIZE=+0>Данная операция позволяет произвести ввод цепочки элементов
из порта ввода-вывода и реализуется командой ins, имеющей следующий формат:</FONT>

<P><FONT SIZE=+0><B>ins адрес_приемника,номер_порта</B> (Input String)
- ввести элементы из порта ввода-вывода в цепочку.</FONT>

<P><FONT SIZE=+0>Эта команда вводит элемент из порта, номер которого находится
в регистре <B>dx</B>, в элемент цепочки, адрес которого определяется операндом
<I>адрес_приемника</I>.</FONT>
<BR><FONT SIZE=+0>Несмотря на то, что цепочка, в которую вводится элемент,
адресуется указанием этого операнда, ее адрес должен быть явно сформирован
в паре регистров <B>es:edi/di</B>.</FONT>
<BR><FONT SIZE=+0>Размер элементов цепочки должен быть согласован с размерностью
порта — он определяется директивой резервирования памяти, с помощью которой
выделяется память для размещения элементов цепочки.</FONT>
<BR><FONT SIZE=+0>После пересылки команда ins производит коррекцию содержимого
edi/di на величину, равную размеру элемента, участвовавшего в операции
пересылки. Как обычно, при работе цепочечных команд учитывается состояние
флага df.</FONT>
<BR><FONT SIZE=+0>Подобно командам, реализующим рассмотренные выше цепочечные
операции-примитивы, транслятор преобразует команду ins в одну из трех машинных
команд без операндов, работающих с цепочками элементов определенного размера:</FONT>
<UL><FONT SIZE=+0><B>insb (INput String Byte)</B> — ввести из порта цепочку
байт;</FONT>
<BR><FONT SIZE=+0><B>insw (INput String Word)</B> — ввести из порта цепочку
слов;</FONT>
<BR><FONT SIZE=+0><B>insd (INput String Double Word)</B> — ввести из порта
цепочку двойных слов.</FONT></UL>


<P><FONT SIZE=+0>К примеру, выведем 10 байт из области памяти pole в порт
5000h.</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
.data
pole&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 dup (‘ ‘)
.code
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push&nbsp;&nbsp;&nbsp; ds
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop&nbsp;&nbsp;&nbsp;&nbsp; es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;настройка es на ds
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,5000h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; di,pole
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,10
rep&nbsp;&nbsp;&nbsp;&nbsp; insb
...</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<A NAME="outs"></A>
<H4>
<FONT SIZE=+0>Вывод элемента цепочки в порт ввода-вывода</FONT></H4>
<FONT SIZE=+0>Данная операция позволяет произвести вывод элементов цепочки
в порт ввода-вывода. Она реализуется командой outs, имеющей следующий формат:</FONT>
<BR><FONT SIZE=+0><B>outs номер_порта,адрес_источника</B> (Output String)
— вывести элементы из цепочки в порт ввода-вывода.</FONT>

<P><FONT SIZE=+0>Эта команда выводит элемент цепочки в порт, номер которого
находится в регистре <B>dx</B>. Адрес элемента цепочки определяется операндом
<I>адрес_источника</I>. Несмотря на то, что цепочка, из которой выводится
элемент, адресуется указанием этого операнда, значение адреса должно быть
явно сформировано в паре регистров <B>ds:esi/si</B>.</FONT>
<BR><FONT SIZE=+0>Размер структурных элементов цепочки должен быть согласован
с размерностью порта. Он определяется директивой резервирования памяти,
с помощью которой выделяется память для размещения элементов цепочки.</FONT>
<BR><FONT SIZE=+0>После пересылки команда outs производит коррекцию содержимого
esi/si на величину, равную размеру элемента цепочки, участвовавшего в операции
пересылки. При этом, как обычно, учитывается состояние флага df.</FONT>

<P><FONT SIZE=+0>Подобно команде ins, транслятор преобразует команду outs
в одну из трех машинных команд без операндов, работающих с цепочками элементов
определенного размера:</FONT>
<UL><FONT SIZE=+0><B>outsb</B> (OUTput String Byte) — вывести цепочку байт
в порт ввода-вывода;</FONT>
<BR><FONT SIZE=+0><B>outsw</B> (OUTtput String Word) — вывести цепочку
слов в порт ввода-вывода;</FONT>
<BR><FONT SIZE=+0><B>outsd</B> (OUTput String Double Word) — вывести цепочку
двойных слов в порт ввода- вывода.</FONT></UL>


<P><FONT SIZE=+0>В качестве примера рассмотрим фрагмент программы, которая
выводит последовательность символов в порт ввода-вывода, соответствующего
принтеру (номер 378 (lpt1)).</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
.data
str_pech&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Текст для печати'
.code
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,378h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; di,str_pech
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; cx,16
rep&nbsp;&nbsp;&nbsp;&nbsp; outsb
...</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>В заключение напомню, что для организации работы с портами
недостаточно знать их номера и назначение. Не менее важно знать и понимать
алгоритм их работы. Эти сведения можно найти в документации на устройство
(но, к сожалению, далеко не всегда).&nbsp;</FONT>
<HR SIZE=5 WIDTH=80%></UL>

</BODY>
<!конец html-документа>
</HTML>
