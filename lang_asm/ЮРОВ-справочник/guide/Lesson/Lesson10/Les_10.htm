<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (Win95; I) [Netscape]">
   <TITLE>Команды передачи управления</TITLE>
<!версия HTML-стандарта>
<!начало html-документа>
<!заголовок html-документа>
<!заголовок страницы>
</HEAD>
<BODY BGCOLOR="#CFFFFF">
<!базовый размер символов (для всего документа><!тело html-документа><!C-HR SIZE=5 WIDTH=60%><A NAME="ПередачиУправления"></A>
<H2>
<FONT SIZE=+0>Команды передачи управления</FONT></H2>
<FONT SIZE=+0>На предыдущих уроках мы познакомились с некоторыми командами,
из которых формируются <I>линейные</I> участки программы. Каждая из них
в общем случае выполняет некоторые действия по преобразованию или пересылке
данных, после чего микропроцессор передает управление следующей команде.
Но очень мало программ работают таким последовательным образом. Обычно
в программе есть точки, в которых нужно принять решение о том, какая команда
будет выполняться следующей. Это решение может быть</FONT>
<UL>
<LI>
<FONT SIZE=+0><I>безусловным</I> — в данной точке необходимо передать управление
не той команде, которая идет следующей, а другой, которая находится на
некотором удалении от текущей команды;</FONT></LI>

<LI>
<FONT SIZE=+0><I>условным</I> — решение о том, какая команда будет выполняться
следующей, принимается на основе анализа некоторых условий или данных.</FONT></LI>
</UL>
<FONT SIZE=+0>Как вы помните, программа представляет собой последовательность
команд и данных, занимающих определенное пространство оперативной памяти.
Эта пространство памяти может быть либо непрерывным, либо состоять из нескольких
фрагментов.</FONT>
<BR><FONT SIZE=+0>На уроке 5 нами были рассмотрены средства организации
фрагментации кода программы и ее данных на сегменты. То, какая команда
программы должна выполняться следующей, микропроцессор узнает по содержимому
пары регистров <B>cs:(e)ip</B>:</FONT>
<UL>
<LI>
<FONT SIZE=+0><B>cs</B> — сегментный регистр кода, в котором находится
физический (базовый) адрес текущего сегмента кода;</FONT></LI>

<LI>
<FONT SIZE=+0><B>eip/ip</B> — регистр указателя команды, в котором находится
значение, представляющее собой смещение в памяти следующей команды, подлежащей
выполнению, относительно начала текущего сегмента кода.</FONT></LI>

<BR><FONT SIZE=+0>Напомню, почему мы записываем регистры eip/ip через косую
черту. Какой конкретно регистр будет использоваться, зависит от установленного
режима адресации use16 или use32. Если указано use16, то используется ip,
если use32, то используется eip.</FONT>

<P><FONT SIZE=+0>Таким образом, команды передачи управления изменяют содержимое
регистров <B>cs</B> и <B>eip/ip</B>, в результате чего микропроцессор выбирает
для выполнения не следующую по порядку команду программы, а команду в некотором
другом участке программы. Конвейер внутри микропроцессора при этом сбрасывается.</FONT></UL>
<FONT SIZE=+0>По принципу действия, команды микропроцессора, обеспечивающие
организацию переходов в программе, можно разделить на четыре группы:</FONT>
<OL>
<LI>
<FONT SIZE=+0>Команды безусловной передачи управления:</FONT></LI>

<UL>
<LI>
<FONT SIZE=+0><A HREF="#КомандаБезусловногоПерехода">команда безусловного
перехода</A>;</FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#Процедуры">вызова процедуры и возврата из процедуры</A>;</FONT></LI>

<LI>
<FONT SIZE=+0>вызова программных прерываний и возврата из программных прерываний.</FONT></LI>
</UL>

<LI>
<FONT SIZE=+0>Команды <A HREF="#Условные">условной передачи управления</A>:</FONT></LI>

<UL>
<LI>
<FONT SIZE=+0><A HREF="#cmp">команды перехода по результату команды сравнения
<B>cmp</B></A>;</FONT></LI>

<LI>
<FONT SIZE=+0>команды <A HREF="#ПереходПоСостояниюОпределенногоФлага">перехода
по состоянию определенного флага</A>;</FONT></LI>

<LI>
<FONT SIZE=+0>команды <A HREF="#РегистрECX">перехода по содержимому регистра
ecx/cx</A>.</FONT></LI>
</UL>

<LI>
<FONT SIZE=+0>Команды <A HREF="#УправленияЦиклом">управления циклом</A>:</FONT></LI>

<UL>
<LI>
<FONT SIZE=+0>команда <A HREF="#ЦиклСоСчетчикомECX">организации цикла со
счетчиком ecx/cx</A>;</FONT></LI>

<LI>
<FONT SIZE=+0>команда организации цикла со счетчиком ecx/cx с возможностью<A HREF="#ЦиклСоСчетчикомECX_ПоДополнительному">
досрочного выхода из цикла по дополнительному условию</A>.</FONT></LI>
</UL>
</OL>
&nbsp;
<BR>&nbsp;
<BR>&nbsp;

<P><A NAME="Безусловные"></A>
<H3>
<FONT SIZE=+0>Безусловные переходы</FONT></H3>
<FONT SIZE=+0>Предыдущее обсуждение выявило некоторые детали механизма
перехода. Команды перехода модифицируют регистр указателя команды <B>eip/ip</B>
и, возможно, сегментный регистр кода <B>cs</B>. Что именно должно подвергнуться
модификации, зависит:</FONT>
<UL>
<LI>
<FONT SIZE=+0>от типа операнда в команде безусловного перехода (ближний
или дальний);</FONT></LI>

<LI>
<FONT SIZE=+0>от указания перед адресом перехода (в команде перехода) <I>модификатора</I>;
при этом сам адрес перехода может находиться либо непосредственно в команде
(прямой переход), либо в регистре или ячейке памяти (косвенный переход).</FONT></LI>
</UL>


<P><FONT SIZE=+0><I>Модификатор</I> может принимать следующие значения:</FONT>
<UL>
<LI>
<FONT SIZE=+0><B>near ptr</B> — прямой переход на метку внутри текущего
сегмента кода. Модифицируется только регистр eip/ip (в зависимости от заданного
типа сегмента кода use16 или use32) на основе указанного в команде адреса
(метки) или выражения, использующего символ извлечения значения СчА — $;</FONT></LI>

<LI>
<FONT SIZE=+0><B>far ptr</B> — прямой переход на метку в другом сегменте
кода. Адрес перехода задается в виде непосредственного операнда или адреса
(метки) и состоит из 16-битного селектора и 16/32-битного смещения, которые
загружаются, соответственно, в регистры cs и ip/eip;</FONT></LI>

<LI>
<FONT SIZE=+0><B>word ptr</B> — косвенный переход на метку внутри текущего
сегмента кода. Модифицируется (значением смещения из памяти по указанному
в команде адресу, или из регистра) только eip/ip. Размер смещения 16 или
32 бит;</FONT></LI>

<LI>
<FONT SIZE=+0><B>dword ptr</B> — косвенный переход на метку в другом сегменте
кода. Модифицируются (значением из памяти — и только из памяти, из регистра
нельзя) оба регистра, cs и eip/ip. Первое слово/двойное слово этого адреса
представляет смещение и загружается в ip/eip; второе/третье слово загружается
в cs.</FONT></LI>
</UL>
<A NAME="КомандаБезусловногоПерехода"></A>
<H4>
<FONT SIZE=+0>Команда безусловного перехода jmp</FONT></H4>
<FONT SIZE=+0>Синтаксис команды безусловного перехода</FONT>
<BR><FONT SIZE=+0><B>jmp [модификатор] адрес_перехода</B> - безусловный
переход без сохранения информации о точке возврата.</FONT>

<P><FONT SIZE=+0><I>Адрес_перехода</I> представляет собой адрес в виде
метки либо адрес области памяти, в которой находится указатель перехода.</FONT>

<P><FONT SIZE=+0>Всего в системе команд микропроцессора есть несколько
кодов машинных команд безусловного перехода <B>jmp</B>.</FONT>
<BR><FONT SIZE=+0>Их различия определяются дальностью перехода и способом
задания целевого адреса.</FONT>
<BR><FONT SIZE=+0><I>Дальность</I> перехода определяется местоположением
операнда <I>адрес_перехода</I>. Этот адрес может находиться в текущем сегменте
кода или в некотором другом сегменте. В первом случае переход называется
<I>внутрисегментным</I>, или <I>близким</I>, во втором — <I>межсегментным</I>,
или <I>дальним</I>.</FONT>
<BR><FONT SIZE=+0>Внутрисегментный переход предполагает, что изменяется
только содержимое регистра <B>eip/ip</B>.</FONT>
<BR><FONT SIZE=+0>Можно выделить три варианта внутрисегментного использования
команды jmp:</FONT>
<UL>
<LI>
<FONT SIZE=+0>прямой короткий;</FONT></LI>

<LI>
<FONT SIZE=+0>прямой;</FONT></LI>

<LI>
<FONT SIZE=+0>косвенный.</FONT></LI>
</UL>
<A NAME="Процедуры"></A>
<H4>
<FONT SIZE=+0>Процедуры</FONT></H4>
<FONT SIZE=+0>В языке ассемблера есть несколько средств, решающих проблему
дублирования участков программного кода. К ним относятся:</FONT>
<UL>
<LI>
<FONT SIZE=+0>механизм процедур;</FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="../../Тексты/МакросредстваАссемблера.htm#Макроассемблер">макроассемблер;</A></FONT></LI>

<LI>
<FONT SIZE=+0>механизм прерываний.</FONT></LI>
</UL>
<FONT SIZE=+0><B>Процедура</B>, часто называемая также <I>подпрограммой</I>,
— это основная функциональная единица декомпозиции (разделения на несколько
частей) некоторой задачи.</FONT>
<BR><FONT SIZE=+0>Процедура представляет собой группу команд для решения
конкретной подзадачи и обладает средствами получения управления из точки
вызова задачи более высокого уровня и возврата управления в эту точку.</FONT>
<BR><FONT SIZE=+0>В простейшем случае программа может состоять из одной
процедуры. Другими словами, процедуру можно определить как правильным образом
оформленную совокупность команд, которая, будучи однократно описана, при
необходимости может быть вызвана в любом месте программы.</FONT>

<P><FONT SIZE=+0>Для описания последовательности команд в виде процедуры
в языке ассемблера используются две директивы: <B>PROC</B> и <B>ENDP</B>.</FONT>

<P><FONT SIZE=+0>Синтаксис описания процедуры таков (рис. 1).</FONT>
<P><CENTER><IMG SRC="Ris10_03.gif" BORDER=0 ><FONT SIZE=+0></FONT></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 1.</B> Синтаксис описания процедуры в
программе</FONT></I></CENTER>


<P><FONT SIZE=+0>Из рис. 1 видно, что в заголовке процедуры (директиве
PROC) обязательным является только задание имени процедуры. Среди большого
количества операндов директивы PROC следует особо выделить <B>[расстояние]</B>.</FONT>
<BR><FONT SIZE=+0>Этот атрибут может принимать значения <B>near</B> или
<B>far</B> и характеризует возможность обращения к процедуре из другого
сегмента кода. По умолчанию атрибут <B>[расстояние]</B> принимает значение
<B>near</B>.</FONT>

<P><FONT SIZE=+0>Процедура может размещаться в любом месте программы, но
так, чтобы на нее случайным образом не попало управление. Если процедуру
просто вставить в общий поток команд, то микропроцессор будет воспринимать
команды процедуры как часть этого потока и соответственно будет осуществлять
выполнение команд процедуры.</FONT>
<BR><FONT SIZE=+0>Более подробно вопросы, связанные с описанием и использованием
процедур в программах ассемблера, рассматриваются на уроках 10 и 14. Примеры
использования процедур вы можете посмотреть в приложении 7.&nbsp;</FONT><A NAME="Условные"></A>
<H4>
<FONT SIZE=+0>Условные переходы</FONT></H4>
<P.До сих пор мы рассматривали команды перехода с
“безусловным” принципом действия, но в системе команд
микропроцессора есть большая группа команд, умеющих
принимать решение о том, какая команда должна выполняться
следующей. Решение принимается в зависимости от
определенных условий. Условие определяется выбором
конкретной команды перехода.
<BR><FONT SIZE=+0>Микропроцессор
имеет 18 команд условного перехода (см. “Описание команд”). Эти команды
позволяют проверить:</FONT>
<UL>
<LI>
<FONT SIZE=+0>отношение между операндами со знаком (“больше — меньше”);</FONT></LI>

<LI>
<FONT SIZE=+0>отношение между операндами без знака (“выше — ниже”)2;</FONT></LI>

<LI>
<FONT SIZE=+0>состояния арифметических флагов zf, sf, cf, of, pf (но не
af).</FONT></LI>
</UL>
<FONT SIZE=+0>Команды условного перехода имеют одинаковый синтаксис:</FONT>
<BR><FONT SIZE=+0><B>jcc метка_перехода</B></FONT>

<P><FONT SIZE=+0>Как видно, мнемокод всех команд начинается с “<B>j</B>”
— от слова <I>jump</I> (прыжок), <I>cc</I> — определяет конкретное условие,
анализируемое командой.</FONT>
<BR><FONT SIZE=+0>Что касается операнда <I>метка_перехода</I>, то эта метка
может находится только в пределах текущего сегмента кода, <U>межсегментная
передача управления в условных переходах не допускается</U>. В связи с
этим отпадает вопрос о модификаторе, который присутствовал в синтаксисе
команд безусловного перехода. В ранних моделях микропроцессора (i8086,
i80186 и i80286) команды условного перехода могли осуществлять только короткие
переходы — на расстояние от –128 до +127 байт от команды, следующей за
командой условного перехода. Начиная с модели микропроцессора 80386 это
ограничение снято, но, как видите, только в пределах текущего сегмента
кода.</FONT>

<P><FONT SIZE=+0>Для того чтобы принять решение о том, куда будет передано
управление командой условного перехода, предварительно должно быть сформировано
условие, на основании которого и будет приниматься решение о передаче управления.</FONT>
<BR><FONT SIZE=+0>Источниками такого условия могут быть:</FONT>
<UL>
<LI>
<FONT SIZE=+0>любая команда, изменяющая состояние арифметических флагов;</FONT></LI>

<LI>
<FONT SIZE=+0>команда сравнения <B>cmp</B>, сравнивающая значения двух
операндов;</FONT></LI>

<LI>
<FONT SIZE=+0>состояние регистра ecx/cx.</FONT></LI>
</UL>
<FONT SIZE=+0>Обсудим эти варианты, чтобы разобраться с тем, как работают
команды условного перехода.&nbsp;</FONT><A NAME="cmp"></A>
<H4>
<FONT SIZE=+0>Команда сравнения cmp</FONT></H4>
<FONT SIZE=+0>Команда сравнения <B>cmp</B> имеет интересный принцип работы.
Он абсолютно такой же, как и у команды вычитания.</FONT>
<BR><FONT SIZE=+0><B>sub операнд_1,операнд_2</B>. Команда <B>cmp</B> так
же, как и команда <B>sub</B>, выполняет вычитание операндов и устанавливает
флаги. Единственное, чего она не делает — это запись результата вычитания
на место первого операнда.</FONT>

<P><FONT SIZE=+0>Синтаксис команды cmp:</FONT>
<BR><FONT SIZE=+0><B>cmp операнд_1,операнд_2</B> (compare) — сравнивает
два операнда и по результатам сравнения устанавливает флаги.</FONT>

<P><FONT SIZE=+0>Флаги, устанавливаемые командой <B>cmp</B>, можно анализировать
специальными командами условного перехода. Прежде чем мы их рассмотрим,
уделим немного внимания мнемонике этих команд условного перехода (табл.
1). Понимание обозначений при формировании названия команд условного перехода
(элемент в названии команды <B>jcc</B>, обозначенный нами <B>cc</B>) облегчит
их запоминание и дальнейшее практическое использование.</FONT>

<P><FONT SIZE=+0><B>Таблица 1.</B> Значение аббревиатур в названии команды
jcc</FONT>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>Мнемоническое обозначение</TD>

<TD>Английский</TD>

<TD>Русский</TD>

<TD>Тип операндов</TD>
</TR>

<TR>
<TD>E e</TD>

<TD>equal</TD>

<TD>Равно</TD>

<TD>Любые</TD>
</TR>

<TR>
<TD>N n</TD>

<TD>not</TD>

<TD>Не</TD>

<TD>Любые</TD>
</TR>

<TR>
<TD>G g</TD>

<TD>greater</TD>

<TD>Больше</TD>

<TD>Числа со знаком</TD>
</TR>

<TR>
<TD>L l</TD>

<TD>less</TD>

<TD>Меньше</TD>

<TD>Числа со знаком</TD>
</TR>

<TR>
<TD>A a</TD>

<TD>above</TD>

<TD>Выше, в смысле “больше”</TD>

<TD>Числа без знака</TD>
</TR>

<TR>
<TD>B b</TD>

<TD>below</TD>

<TD>Ниже, в смысле “меньше”</TD>

<TD>Числа без знака</TD>
</TR>
</TABLE></CENTER>
<FONT SIZE=+0><B>Таблица 2.</B> Перечень команд условного перехода для
команды <B>cmp операнд_1,операнд_2</B></FONT>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>Типы операндов</TD>

<TD>Мнемокод команды условного перехода</TD>

<TD>Критерий условного перехода</TD>

<TD>Значения флагов для осществления перехода</TD>
</TR>

<TR>
<TD>Любые&nbsp;</TD>

<TD>je&nbsp;</TD>

<TD>операнд_1 = операнд_2&nbsp;</TD>

<TD>zf = 1&nbsp;</TD>
</TR>

<TR>
<TD>Любые&nbsp;</TD>

<TD>jne&nbsp;</TD>

<TD>операнд_1&lt;>операнд_2&nbsp;</TD>

<TD>zf = 0&nbsp;</TD>
</TR>

<TR>
<TD>Со знаком&nbsp;</TD>

<TD>jl/jnge&nbsp;</TD>

<TD>операнд_1 &lt; операнд_2&nbsp;</TD>

<TD>sf &lt;> of</TD>
</TR>

<TR>
<TD>Со знаком&nbsp;</TD>

<TD>jle/jng&nbsp;</TD>

<TD>операнд_1 &lt;= операнд_2&nbsp;</TD>

<TD>sf &lt;> of or zf = 1&nbsp;</TD>
</TR>

<TR>
<TD>Со знаком&nbsp;</TD>

<TD>jg/jnle&nbsp;</TD>

<TD>операнд_1 > операнд_2&nbsp;</TD>

<TD>sf = of and zf = 0</TD>
</TR>

<TR>
<TD>Со знаком&nbsp;</TD>

<TD>jge/jnl&nbsp;</TD>

<TD>операнд_1 => операнд_2&nbsp;</TD>

<TD>sf = of&nbsp;</TD>
</TR>

<TR>
<TD>Без знака&nbsp;</TD>

<TD>jb/jnae&nbsp;</TD>

<TD>операнд_1 &lt; операнд_2&nbsp;</TD>

<TD>cf = 1&nbsp;</TD>
</TR>

<TR>
<TD>Без знака&nbsp;</TD>

<TD>jbe/jna&nbsp;</TD>

<TD>операнд_1 &lt;= операнд_2&nbsp;</TD>

<TD>cf = 1 or zf=1&nbsp;</TD>
</TR>

<TR>
<TD>Без знака&nbsp;</TD>

<TD>ja/jnbe&nbsp;</TD>

<TD>операнд_1 > операнд_2&nbsp;</TD>

<TD>cf = 0 and zf = 0&nbsp;</TD>
</TR>

<TR>
<TD>Без знака&nbsp;</TD>

<TD>jae/jnb&nbsp;</TD>

<TD>операнд_1 => операнд_2&nbsp;</TD>

<TD>cf = 0&nbsp;</TD>
</TR>
</TABLE></CENTER>
<FONT SIZE=+0>Не удивляйтесь тому обстоятельству, что одинаковым значениям
флагов соответствует несколько разных мнемокодов команд условного перехода
(они отделены друг от друга косой чертой в табл. 2).</FONT>
<BR><FONT SIZE=+0>Разница в названии обусловлена желанием разработчиков
микропроцессора облегчить использование команд условного перехода в сочетании
с определенными группами команд. Поэтому разные названия отражают скорее
различную функциональную направленность. Тем не менее, то, что эти команды
реагируют на одни и те же флаги делает их абсолютно эквивалентными и равноправными
в программе. Поэтому в табл. 2 они сгруппированы не по названиям, а по
значениям флагов (условиям), на которые они реагируют.&nbsp;</FONT><A NAME="ПереходПоСостояниюОпределенногоФлага"></A>
<H3>
<FONT SIZE=+0>Команды условного перехода и флаги</FONT></H3>
<FONT SIZE=+0>Мнемоническое обозначение некоторых команд условного перехода
отражает название флага, с которым они работают, и имеет следующую структуру:
первым идет символ “<B>j</B>” (<I>jump</I>, переход), вторым — либо обозначение
флага, либо символ отрицания “<B>n</B>”, после которого стоит название
флага.</FONT>
<BR><FONT SIZE=+0>Такая структура команды отражает ее назначение.</FONT>
<BR><FONT SIZE=+0>Если символа “n” нет, то проверяется состояние флага,
и если он равен 1, производится переход на метку перехода.</FONT>
<BR><FONT SIZE=+0>Если символ “n” присутствует, то проверяется состояние
флага на равенство 0, и в случае успеха производится переход на метку перехода.</FONT>
<BR><FONT SIZE=+0>Мнемокоды команд, названия флагов и условия переходов
приведены в табл. 3.</FONT>
<BR><FONT SIZE=+0>Эти команды можно использовать после любых команд, изменяющих
указанные флаги.</FONT>

<P><FONT SIZE=+0><B>Таблица 3.</B> Команды условного перехода и флаги</FONT>
<CENTER><TABLE BORDER=5 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR>
<TD>Название флага&nbsp;</TD>

<TD>Номер бита в eflags/flag</TD>

<TD>Команда условного перехода&nbsp;</TD>

<TD>Значение флага для осуществления перехода</TD>
</TR>

<TR>
<TD>Флаг переноса cf&nbsp;</TD>

<TD>1&nbsp;</TD>

<TD>jc&nbsp;</TD>

<TD>cf = 1&nbsp;</TD>
</TR>

<TR>
<TD>Флаг четности pf&nbsp;</TD>

<TD>2&nbsp;</TD>

<TD>jp&nbsp;</TD>

<TD>pf = 1&nbsp;</TD>
</TR>

<TR>
<TD>Флаг нуля zf&nbsp;</TD>

<TD>6&nbsp;</TD>

<TD>jz&nbsp;</TD>

<TD>zf = 1&nbsp;</TD>
</TR>

<TR>
<TD>Флаг знака sf&nbsp;</TD>

<TD>7&nbsp;</TD>

<TD>js&nbsp;</TD>

<TD>sf = 1&nbsp;</TD>
</TR>

<TR>
<TD>Флаг переполнения of&nbsp;</TD>

<TD>11&nbsp;</TD>

<TD>jo&nbsp;</TD>

<TD>of = 1&nbsp;</TD>
</TR>

<TR>
<TD>Флаг переноса cf&nbsp;</TD>

<TD>1&nbsp;</TD>

<TD>jnc&nbsp;</TD>

<TD>cf = 0&nbsp;</TD>
</TR>

<TR>
<TD>Флаг четности pf&nbsp;</TD>

<TD>2&nbsp;</TD>

<TD>jnp&nbsp;</TD>

<TD>pf = 0&nbsp;</TD>
</TR>

<TR>
<TD>Флаг нуля zf&nbsp;</TD>

<TD>6&nbsp;</TD>

<TD>jnz&nbsp;</TD>

<TD>zf = 0&nbsp;</TD>
</TR>

<TR>
<TD>Флаг знака sf&nbsp;</TD>

<TD>7&nbsp;</TD>

<TD>jns&nbsp;</TD>

<TD>sf = 0&nbsp;</TD>
</TR>

<TR>
<TD>Флаг переполнения of&nbsp;</TD>

<TD>11&nbsp;</TD>

<TD>jno&nbsp;</TD>

<TD>of = 0&nbsp;</TD>
</TR>

<TR>
<TD></TD>

<TD></TD>

<TD></TD>

<TD></TD>
</TR>
</TABLE></CENTER>
<FONT SIZE=+0>Если внимательно посмотреть на табл. 2 и 3, видно, что многие
команды условного перехода в них являются эквивалентными, так как в основе
и тех, и других лежит анализ одинаковых флагов.&nbsp;</FONT><A NAME="РегистрECX"></A>
<H3>
<FONT SIZE=+0>Команды условного перехода и регистр ecx/cx</FONT></H3>
<FONT SIZE=+0>Архитектура микропроцессора предполагает специфическое использование
многих регистров.</FONT>
<BR><FONT SIZE=+0>К примеру, регистр <B>eax/ax/al</B> используется как
аккумулятор, а регистры <B>bp, sp</B> - для работы со стеком.</FONT>
<BR><FONT SIZE=+0>Регистр <B>ecx/cx</B> тоже имеет определенное функциональное
назначение — он выполняет роль <I>счетчика</I> в командах управления циклами
и при работе с цепочками символов. Возможно, что функционально команду
условного перехода, связанную с регистром <B>ecx/cx</B>, правильнее было
бы отнести к этой группе команд.</FONT>
<BR><FONT SIZE=+0>Синтаксис этой команды условного перехода таков:</FONT>
<BR><FONT SIZE=+0><B>jcxz метка_перехода</B> (Jump if cx is Zero) — переход,
если cx ноль;</FONT>
<BR><FONT SIZE=+0><B>jecxz</B> метка_перехода (Jump Equal ecx Zero) — переход,
если <B>ecx</B> ноль.</FONT>

<P><FONT SIZE=+0>Эти команды очень удобно использовать при организации
цикла и при работе с цепочками символов.</FONT>
<BR><FONT SIZE=+0>Нужно отметить ограничение, свойственное команде <B>jcxz/jecxz</B>.
В отличие от других команд условной передачи управления, команда <B>jcxz/jecxz</B>
<U>может адресовать только короткие переходы</U> — на –128 байт или на
+127 байт от следующей за ней команды.&nbsp;</FONT><A NAME="УправленияЦиклом"></A>
<H3>
<FONT SIZE=+0>Организация циклов</FONT></H3>
<FONT SIZE=+0>Цикл, как известно, представляет собой важную алгоритмическую
структуру, без использования которой не обходится, наверное, ни одна программа.</FONT>
<BR><FONT SIZE=+0>Организовать циклическое выполнение некоторого участка
программы можно, к примеру, используя команды условной передачи управления
или команду безусловного перехода jmp. При такой организации цикла все
операции по его организации выполняются “вручную”. Но, учитывая важность
такого алгоритмического элемента, как цикл, разработчики микропроцессора
ввели в систему команд группу из трех команд, облегчающую программирование
циклов. Эти команды также используют регистр <B>ecx/cx</B> как <I>счетчик
цикла</I>.</FONT>
<BR><FONT SIZE=+0>Дадим краткую характеристику этим командам:&nbsp;</FONT><A NAME="ЦиклСоСчетчикомECX"></A>

<P><FONT SIZE=+0><B>loop метка_перехода</B> (Loop) — повторить цикл. Команда
позволяет организовать циклы, подобные циклам for в языках высокого уровня
с автоматическим уменьшением счетчика цикла. Работа команды заключается
в выполнении следующих действий:</FONT>
<UL>
<LI>
<FONT SIZE=+0>декремента регистра ecx/cx;</FONT></LI>

<LI>
<FONT SIZE=+0>сравнения регистра ecx/cx с нулем:</FONT></LI>

<UL>
<LI>
<FONT SIZE=+0>если (ecx/cx) > 0, то управление передается на метку перехода;</FONT></LI>

<LI>
<FONT SIZE=+0>если (ecx/cx) = 0, то управление передается на следующую
после loop команду.</FONT></LI>
</UL>
</UL>
<A NAME="ЦиклСоСчетчикомECX_ПоДополнительному"></A>
<BR><FONT SIZE=+0><B>loope/loopz метка_перехода</B> (Loop till cx &lt;>
0 or Zero Flag = 0) — повторить цикл, пока cx &lt;> 0 или zf = 0.</FONT>
<BR><FONT SIZE=+0>Команды loope и loopz — абсолютные синонимы, поэтому
используйте ту команду, которая вам больше нравиться. Работа команд заключается
в выполнении следующих действий:</FONT>
<UL>
<LI>
<FONT SIZE=+0>декремента регистра ecx/cx;</FONT></LI>

<LI>
<FONT SIZE=+0>сравнения регистра ecx/cx с нулем;</FONT></LI>

<LI>
<FONT SIZE=+0>анализа состояния флага нуля zf:</FONT></LI>

<UL>
<LI>
<FONT SIZE=+0>если (ecx/cx) > 0 и zf = 1, управление передается на метку
перехода;</FONT></LI>

<LI>
<FONT SIZE=+0>если (ecx/cx) = 0 или zf = 0, управление передается на следующую
после loop команду.</FONT></LI>
</UL>
</UL>


<P><FONT SIZE=+0><B>loopne/loopnz метка_перехода</B> (Loop till cx &lt;>
0 or Not Zero flag=0) — повторить цикл пока cx &lt;> 0 или zf = 1.</FONT>
<BR><FONT SIZE=+0>Команды loopne и loopnz также абсолютные синонимы. Работа
команд заключается в выполнении следующих действий:</FONT>
<UL>
<LI>
<FONT SIZE=+0>декремента регистра ecx/cx;</FONT></LI>

<LI>
<FONT SIZE=+0>сравнения регистра ecx/cx с нулем;</FONT></LI>

<LI>
<FONT SIZE=+0>анализа состояния флага нуля zf:</FONT></LI>

<UL>
<LI>
<FONT SIZE=+0>если (ecx/cx) > 0 и zf = 0, управление передается на метку
перехода;</FONT></LI>

<LI>
<FONT SIZE=+0>если (ecx/cx)=0 или zf=1, управление передается на следующую
после loop команду.</FONT></LI>
</UL>
</UL>
<FONT SIZE=+0>Команды <B>loope/loopz</B> и <B>loopne/loopnz</B> по принципу
своей работы являются взаимообратными. Они расширяют действие команды <B>loop</B>
тем, что дополнительно анализируют флаг zf, что дает возможность организовать
досрочный выход из цикла, используя этот флаг в качестве индикатора.</FONT>

<P><FONT SIZE=+0>Недостаток команд организации цикла <B>loop, loope/loopz</B>
и <B>loopne/loopnz</B> в том, что они реализуют только короткие переходы
(от –128 до +127 байт). Для работы с длинными циклами придется использовать
команды условного перехода и команду jmp, поэтому постарайтесь освоить
оба способа организации циклов.&nbsp;</FONT>
<HR SIZE=5 WIDTH=80%>
</BODY>
<!конец html-документа>
</HTML>
