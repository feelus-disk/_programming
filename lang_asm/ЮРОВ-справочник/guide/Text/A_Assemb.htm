<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">	<!версия HTML-стандарта>
<HTML>	<!начало html-документа>
<HEAD>	<!заголовок html-документа>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE> Текст на обложку</TITLE>	<!заголовок страницы>
<BASEFONT SIZE=3> <!базовый размер символов (для всего документа>
</HEAD>
<BODY BGCOLOR=#cfFFFF>	<!тело html-документа>
<HR SIZE=5 WIDTH=60%>
 
  <H2>Об ассемблере</H2>
<P>Интересно
проследить, начиная со времени появления первых компьютеров
и   заканчивая   сегодняшним   днем,   за   трансформациями
представлений о языке ассемблера у программистов.
<P>  Когда-то ассемблер был языком,  без  знания  которого  нельзя   было
заставить  компьютер сделать что-либо полезное.  Постепенно
ситуация   менялась.  Появлялись  более  удобные   средства
общения  с  компьютером.  Но, в  отличие  от  других  языков,
ассемблер не умирал, более того он не мог сделать  этого  в
принципе.  Почему? В поисках ответа попытаемся  понять,  что
такое  язык  ассемблера  вообще.
<P>  Если  коротко,  то  <EM> язык
ассемблера</EM>  —  это  символическое  представление  машинного
языка.
<BR>  Все  процессы в машине на самом низком,  аппаратном
уровне    приводятся    в   действие    только    командами
(инструкциями)  машинного  языка.  Отсюда   понятно,   что,
несмотря  на  общее название, язык ассемблера  для  каждого
типа   компьютера  свой.  Это  касается  и  внешнего   вида
программ,  написанных  на ассемблере,  и  идей,  отражением
которых  этот язык является.
<P> По-настоящему решить проблемы,
связанные  с аппаратурой (или даже, более того, зависящие  от
аппаратуры   как,   к  примеру,  повышение   быстродействия
программы),  невозможно без знания ассемблера.
<P>Программист
или  любой  другой  пользователь может  использовать  любые
высокоуровневые  средства, вплоть  до  программ  построения
виртуальных миров и, возможно, даже не подозревать,  что  на
самом деле компьютер выполняет не команды языка, на котором
написана    его    программа,   а   их   трансформированное
представление  в  форме скучной и унылой последовательности
команд   совсем  другого  языка  —  машинного.   А   теперь
представим,    что    у   такого   пользователя    возникла
нестандартная  проблема или просто что-то не заладилось.  К
примеру,   его  программа  должна  работать   с   некоторым
необычным   устройством  или  выполнять  другие   действия,
требующие знания принципов работы аппаратуры компьютера.  И
вот здесь-то и начинается <CITE>совсем другая история...</CITE>. Каким бы
умным ни был программист, каким бы хорошим ни был язык,  на
котором  он  написал  свою  чудную  программу,  без  знания
ассемблера  ему не обойтись. И не случайно практически  все
компиляторы языков высокого уровня содержат средства  связи
своих  модулей  с модулями на ассемблере либо  поддерживают
выход  на  ассемблерный уровень программирования.
<P>  Конечно,
время  компьютерных универсалов уже прошло.  Как  говорится
<CITE>нельзя  объять  необъятное</CITE>. Но есть нечто  общее,  своего
рода  фундамент,  на  котором строится  любое  сколь-нибудь
серьезное  компьютерное образование. Это знания о принципах
работы  компьютера, его архитектуре и языке ассемблера  как
отражении  и  воплощении  этих знаний.  
<P>Типичный  современный компьютер (на базе i486 или  Pentium)
состоит из следующих компонентов (рис. 1).
   <P ALIGN=CENTER>
 <IMG SRC="../Pic/Ris1_1.gif" BORDER=0">
<P ALIGN=CENTER><EM><B>Рис. 1.</B> Компьютер и периферийные устройства</EM>
  <P>Из  рисунка  видно, что компьютер составлен  из  нескольких
физических  устройств, каждое из которых подключено  к  одному
блоку,  называемому <EM>системным</EM>. Если рассуждать  логически,  то
ясно,   что   он   играет   роль  некоторого   координирующего
устройства. Давайте заглянем внутрь системного блока (не нужно
пытаться   проникнуть  внутрь  монитора  —  там   нет   ничего
интересного, к тому же это опасно): открываем корпус  и  видим
какие-то платы, блоки, соединительные провода. Чтобы понять их
функциональное  назначение,  посмотрим  на  структурную  схему
типичного   компьютера  (рис.  2).  Она  не  претендует   на
безусловную  точность и имеет целью лишь показать  назначение,
взаимосвязь    и   типовой   состав   элементов   современного
персонального компьютера.
  <P ALIGN=CENTER>
 <IMG SRC="../Pic/Ris1_2.gif" BORDER=0">
<P ALIGN=CENTER><EM><B>Рис. 2.</B> Структурная схема персонального компьютера</EM>
<P>Обсудим схему на рис. 2 в несколько нетрадиционном стиле.<BR>
   Человеку свойственно, встречаясь с чем-то новым, искать
какие-то ассоциации, которые могут помочь ему познать неизвестное. 
Какие ассоциации вызывает компьютер? У меня, к примеру, компьютер часто 
ассоциируется с самим человеком. Почему? 
<P>У компьютера есть органы восприятия информации из внешнего  мира
—  это  клавиатура, мышь, накопители на магнитных  дисках.  На
рис. 2  эти органы расположены справа от системных  шин.
<BR>  У
компьютера  есть органы “переваривающие” полученную информацию
—  это центральный процессор и оперативная память.
<BR> И, наконец,
у   компьютера   есть   органы   речи,   выдающие   результаты
переработки.   Это   также  некоторые  из  устройств   справа.
<P>Современным компьютерам, конечно, далеко до человека. Их можно
сравнить  с существами, взаимодействующими с внешним миром  на
уровне   большого,   но   ограниченного   набора   безусловных
рефлексов.
<BR>  Этот  набор  рефлексов образует  систему  машинных
команд.   На  каком  бы  высоком  уровне  вы  не  общались   с
компьютером,  в  конечном  итоге  все  сводится  к  скучной  и
однообразной   последовательности  машинных   команд.
<BR>   Каждая
машинная  команда  является  своего  рода  раздражителем   для
возбуждения того или иного безусловного рефлекса.  Реакция  на
этот  раздражитель  всегда  однозначная  и  “зашита”  в  блоке
микрокоманд  в  виде  микропрограммы.  Эта  микропрограмма   и
реализует действия по реализации машинной команды, но  уже  на
уровне  сигналов,  подаваемых на те или иные логические  схемы
компьютера,   тем   самым  управляя  различными   подсистемами
компьютера.   В   этом   состоит   так   называемый    <EM>принцип
микропрограммного управления</EM>. 
<P>Продолжая аналогию  с  человеком,
отметим:   для   того,  чтобы  компьютер  правильно   питался,
придумано  множество операционных систем,  компиляторов  сотен
языков  программирования и т. д. Но все они являются,  по  сути,
лишь  блюдом, на котором по определенным правилам доставляется
пища  (программы) желудку (компьютеру). Только  (вот  досада!)
желудок  компьютера  любит диетическую,  однообразную  пищу  —
подавай  ему  информацию  структурированную,  в  виде   строго
организованных последовательностей нулей и единиц,  комбинации
которых  и  составляют  машинный язык. 
<P>Таким  образом,  внешне
являясь полиглотом, компьютер понимает только один язык — язык
машинных  команд. Конечно, для общения и работы с компьютером,
необязательно   знать   этот  язык,   но   практически   любой
профессиональный  программист рано или поздно  сталкивается  с
необходимостью его изучения. К счастью, программисту не  нужно
пытаться постичь значение различных комбинаций двоичных чисел,
так  как  еще в 50-е годы программисты стали использовать  для
программирования символический аналог машинного языка, который
назвали  языком  <EM>ассемблера</EM>.  Этот  язык  точно  отражает  все
особенности  машинного  языка. Именно поэтому,  в  отличие  от
языков  высокого  уровня,  язык ассемблера  для  каждого  типа
компьютера свой.
<P>Из  всего вышесказанного можно сделать вывод, что, так  как
язык   ассемблера  для  компьютера  “родной”,   то   и   самая
эффективная программа может быть написана только на  нем  (при
условии,  что  ее пишет квалифицированный программист).  Здесь
есть  одно  маленькое “но”:  это очень трудоемкий,  требующий
большого  внимания  и  практического  опыта  процесс.  Поэтому
реально  на  ассемблере  пишут в  основном  программы,
которые  должны  обеспечить эффективную  работу  с  аппаратной
частью.  Иногда  на  ассемблере пишутся критичные  по  времени
выполнения   или   расходованию  памяти   участки   программы.
Впоследствии они оформляются в виде подпрограмм и  совмещаются
с  кодом  на  языке  высокого  уровня.  

<HR SIZE=5 WIDTH=80%>
</BODY>
</HTML>	<!конец html-документа>