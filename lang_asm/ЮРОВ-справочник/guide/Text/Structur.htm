<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (Win95; I) [Netscape]">
   <TITLE>Структура программы на ассемблере</TITLE>
<!версия HTML-стандарта>
<!начало html-документа>
<!заголовок html-документа>
<!заголовок страницы>
</HEAD>
<BODY BGCOLOR="#CFFFFF">
<!базовый размер символов (для всего документа><!тело html-документа>
<HR SIZE=5 WIDTH=60%>
<H2>
<FONT SIZE=+0>Структура программы на ассемблере</FONT></H2>

<UL>
<LI>
<FONT SIZE=+0><A HREF="#СинтаксисАссемблера">Синтаксис ассемблера</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#СтандартныеДирективыСегментации">Стандартные директивы
сегментации</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#УпрощенныеДирективыСегментации">Упрощенные директивы
сегментации</A></FONT></LI>
</UL>
<FONT SIZE=+0>Программа на ассемблере представляет собой совокупность блоков
памяти, называемых <I>сегментами памяти</I>. Программа может состоять из
одного или нескольких таких блоков-сегментов. Каждый сегмент содержит совокупность
предложений языка, каждое из которых занимает отдельную строку кода программы.</FONT>

<P><FONT SIZE=+0>Предложения ассемблера бывают четырех типов:</FONT>
<UL>
<LI>
<FONT SIZE=+0><I>команды или инструкции</I>, представляющие собой символические
аналоги машинных команд.</FONT></LI>

<BR><FONT SIZE=+0>В процессе трансляции инструкции ассемблера преобразуются
в соответствующие команды системы команд микропроцессора;</FONT>
<LI>
<FONT SIZE=+0><I>макрокоманды</I> — оформляемые определенным образом предложения
текста программы, замещаемые во время трансляции другими предложениями;</FONT></LI>

<LI>
<FONT SIZE=+0><I>директивы</I>, являющиеся указанием транслятору ассемблера
на выполнение некоторых действий. У директив нет аналогов в машинном представлении;</FONT></LI>

<LI>
<FONT SIZE=+0><I>строки комментариев</I>, содержащие любые символы, в том
числе и буквы русского алфавита. Комментарии игнорируются транслятором.</FONT></LI>
</UL>
<A NAME="СинтаксисАссемблера"></A>
<H3>
<FONT SIZE=+0>Синтаксис ассемблера</FONT></H3>
<FONT SIZE=+0>Предложения, составляющие программу, могут представлять собой
синтаксическую конструкцию, соответствующую команде, макрокоманде, директиве
или комментарию. Для того чтобы транслятор ассемблера мог распознать их,
они должны формироваться по определенным синтаксическим правилам. Для этого
лучше всего использовать формальное описание синтаксиса языка наподобие
правил грамматики. Наиболее распространенные способы подобного описания
языка программирования — <I>синтаксические диаграммы</I> и <I>расширенные
формы Бэкуса—Наура</I>. Для практического использования более удобны <I>синтаксические
диаграммы</I>. К примеру, синтаксис предложений ассемблера можно описать
с помощью синтаксических диаграмм, показанных на следующих рисунках.</FONT>
<P><CENTER><IMG SRC="../Pic/Ris5_01.gif" BORDER=0 ></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 1. </B>Формат предложения ассемблера</FONT></I></CENTER>

<P><CENTER><IMG SRC="../Pic/Ris5_02.gif" BORDER=0 ></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 2. </B>Формат директив</FONT></I></CENTER>

<P><CENTER><IMG SRC="../Pic/Ris5_03.gif" BORDER=0 ></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 3. </B>Формат команд и макрокоманд</FONT></I></CENTER>


<P><FONT SIZE=+0>На этих рисунках:</FONT>
<UL>
<LI>
<FONT SIZE=+0><I>имя метки</I> — идентификатор, значением которого является
адрес первого байта того предложения исходного текста программы, которое
он обозначает;</FONT></LI>

<LI>
<FONT SIZE=+0><I>имя</I> — идентификатор, отличающий данную директиву от
других одноименных директив. В результате обработки ассемблером определенной
директивы этому имени могут быть присвоены определенные характеристики;</FONT></LI>

<LI>
<FONT SIZE=+0><I>код операции (КОП) и директива</I> — это мнемонические
обозначения соответствующей машинной команды, макрокоманды или директивы
транслятора;</FONT></LI>

<LI>
<FONT SIZE=+0><I>операнды</I> — части команды, макрокоманды или директивы
ассемблера, обозначающие объекты, над которыми производятся действия. Операнды
ассемблера описываются выражениями с числовыми и текстовыми константами,
метками и идентификаторами переменных с использованием знаков операций
и некоторых зарезервированных слов.</FONT></LI>
</UL>
<I><FONT SIZE=+0>Как использовать синтаксические диаграммы?</FONT></I>
<BR><FONT SIZE=+0>Очень просто: для этого нужно всего лишь найти и затем
пройти путь от входа диаграммы (слева) к ее выходу (направо). Если такой
путь существует, то предложение или конструкция синтаксически правильны.
Если такого пути нет, значит эту конструкцию компилятор не примет. При
работе с синтаксическими диаграммами обращайте внимание на направление
обхода, указываемое стрелками, так как среди путей могут быть и такие,
по которым можно идти справа налево. По сути, синтаксические диаграммы
отражают логику работы транслятора при разборе входных предложений программы.</FONT>

<P><FONT SIZE=+0>Допустимыми символами при написании текста программ являются:</FONT>
<OL>
<LI>
<FONT SIZE=+0>все латинские буквы: <B>A—Z</B>,<B> a—z</B>. При этом заглавные
и строчные буквы считаются эквивалентными;</FONT></LI>

<LI>
<FONT SIZE=+0>цифры от <B>0</B> до <B>9</B>;</FONT></LI>

<LI>
<FONT SIZE=+0>знаки <B>?</B>,<B> @</B>,<B> $</B>,<B> _</B>,<B> &amp;</B>;</FONT></LI>

<LI>
<FONT SIZE=+0>разделители <B>, . [ ] ( ) &lt; > { } + / * % ! ' " ? \ =
# ^</B>.</FONT></LI>
</OL>
<FONT SIZE=+0>Предложения ассемблера формируются из <I>лексем</I>, представляющих
собой синтаксически неразделимые последовательности допустимых символов
языка, имеющие смысл для транслятора.</FONT>

<P><FONT SIZE=+0><I>Лексемами</I> являются:</FONT>
<UL>
<LI>
<FONT SIZE=+0><I>идентификаторы</I> — последовательности допустимых символов,
использующиеся для обозначения таких объектов программы, как коды операций,
имена переменных и названия меток. Правило записи идентификаторов заключается
в следующем: идентификатор может состоять из одного или нескольких символов.
В качестве символов можно использовать буквы латинского алфавита, цифры
и некоторые специальные знаки — _, ?, $, @. Идентификатор не может начинаться
символом цифры. Длина идентификатора может быть до 255 символов, хотя транслятор
воспринимает лишь первые 32, а остальные игнорирует. Регулировать длину
возможных идентификаторов можно с использованием опции командной строки
<B>mv</B>. Кроме этого существует возможность указать транслятору на то,
чтобы он различал прописные и строчные буквы либо игнорировал их различие
(что и делается по умолчанию). Для этого применяются опции командной строки
<B>/mu, /ml, /mx</B>;</FONT></LI>

<LI>
<FONT SIZE=+0><I>цепочки символов</I> — последовательности символов, заключенные
в одинарные или двойные кавычки;</FONT></LI>

<LI>
<FONT SIZE=+0><I>целые числа</I> в одной из следующих систем счисления:
<I>двоичной, десятичной, шестнадцатеричной</I>. Отождествление чисел при
записи их в программах на ассемблере производится по определенным правилам:</FONT></LI>

<UL>
<LI TYPE="SQUARE">
<FONT SIZE=+0><B>Десятичные числа</B> не требуют для своего отождествления
указания каких-либо дополнительных символов, например 25 или 139.</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0>Для отождествления в исходном тексте программы <B>двоичных
чисел</B> необходимо после записи нулей и единиц, входящих в их состав,
поставить латинское “<B>b</B>”, например 10010101<B>b</B>.</FONT></LI>

<LI TYPE="SQUARE">
<FONT SIZE=+0><B>Шестнадцатеричные числа</B> имеют больше условностей при
своей записи:</FONT></LI>

<UL>
<LI TYPE="CIRCLE">
<FONT SIZE=+0><I>Во-первых</I>, они состоят из цифр <B>0...9</B>, строчных
и прописных букв латинского алфавита <B>a</B>,<B> b</B>, <B>c</B>,<B> d</B>,<B>
e</B>,<B> f</B> или <B>A</B>,<B> B</B>,<B> C</B>,<B> D</B>,<B> E</B>,<B>
F</B>.</FONT></LI>

<LI TYPE="CIRCLE">
<FONT SIZE=+0><I>Во-вторых</I>, у транслятора могут возникнуть трудности
с распознаванием шестнадцатеричных чисел из-за того, что они могут состоять
как из одних цифр 0...9 (например 190845), так и начинаться с буквы латинского
алфавита (например <B>ef15</B>). Для того чтобы "объяснить" транслятору,
что данная лексема не является десятичным числом или идентификатором, программист
должен специальным образом выделять шестнадцатеричное число. Для этого
на конце последовательности шестнадцатеричных цифр, составляющих шестнадцатеричное
число, записывают латинскую букву “<B>h</B>”. Это обязательное условие.
Если шестнадцатеричное число начинается с буквы, то перед ним записывается
ведущий ноль: <B>0</B>ef15<B>h</B>.</FONT></LI>
</UL>
</UL>
</UL>
<FONT SIZE=+0>Таким образом, мы разобрались с тем, как конструируются предложения
программы ассемблера. Но это лишь самый поверхностный взгляд.</FONT>

<P><FONT SIZE=+0>Практически каждое предложение содержит описание объекта,
над которым или при помощи которого выполняется некоторое действие. Эти
объекты называются <I>операндами</I>.</FONT>
<BR><FONT SIZE=+0>Их можно определить так:</FONT>
<BR><I><FONT SIZE=+0><B>операнды</B> — это объекты (некоторые значения,
регистры или ячейки памяти), на которые действуют инструкции или директивы,
либо это объекты, которые определяют или уточняют действие инструкций или
директив.</FONT></I>

<P><FONT SIZE=+0>Операнды могут комбинироваться с арифметическими, логическими,
побитовыми и атрибутивными операторами для расчета некоторого значения
или определения ячейки памяти, на которую будет воздействовать данная команда
или директива.</FONT>

<P><FONT SIZE=+0>Возможно провести следующую классификацию операндов:</FONT>
<UL>
<LI>
<FONT SIZE=+0><A HREF="#ПостоянныеОперанды">постоянные, или непосредственные,
операнды</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#АдресныеОперанды">адресные операнды</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#ПеремещаемыеОперанды">перемещаемые операнды</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#СчетчикАдреса">счетчик адреса</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#РегистровыйОперанд">регистровый операнд</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#БазовыйИиндексныйОперанды">базовый и индексный
операнды</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#СтруктурныеОперанды">структурные операнды</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#Записи">Записи</A></FONT></LI>
</UL>
<FONT SIZE=+0>Рассмотрим подробнее характеристику операндов из приведенной
классификации:</FONT>
<UL><A NAME="ПостоянныеОперанды"></A>
<LI>
<FONT SIZE=+0><I>Постоянные или непосредственные операнды</I> — число,
строка, имя или выражение, имеющие некоторое фиксированное значение. Имя
не должно быть перемещаемым, то есть зависеть от адреса загрузки программы
в память. К примеру, оно может быть определено операторами <B>equ</B> или
<B>=</B>.</FONT></LI>

<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
num&nbsp;&nbsp;&nbsp;&nbsp; equ&nbsp;&nbsp;&nbsp;&nbsp; 5
imd = num-2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,num&nbsp; ;эквивалентно mov al,5&nbsp;
;5 здесь непосредственный операнд
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add&nbsp;&nbsp;&nbsp;&nbsp; [si],imd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; imd=3 - непосредственный операнд
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;5 - непосредственный операнд
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>В данном фрагменте определяются две константы, которые затем
используются в качестве непосредственных операндов в командах пересылки
mov и сложения add.&nbsp;<A NAME="АдресныеОперанды"></A></FONT>
<LI>
<FONT SIZE=+0><I>Адресные операнды</I> — задают физическое расположение
операнда в памяти с помощью указания двух составляющих адреса: <I>сегмента</I>
и <I>смещения</I> (рис. 4).</FONT></LI>

<P><CENTER><IMG SRC="../Pic/Ris5_04.gif" BORDER=0 ></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 4. </B>Синтаксис описания адресных операндов</FONT></I></CENTER>


<P><FONT SIZE=+0>К примеру:</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,0000h
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds,ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,ds:0000h&nbsp;&nbsp;&nbsp;&nbsp; ;записать слово в ax из области памяти по
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;физическому адресу 0000:0000
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>Здесь третья команда mov имеет адресный операнд.&nbsp;<A NAME="ПеремещаемыеОперанды"></A></FONT>
<LI>
<FONT SIZE=+0><I>Перемещаемые операнды</I> — любые символьные имена, представляющие
некоторые адреса памяти. Эти адреса могут обозначать местоположение в памяти
некоторых инструкции (если операнд — метка) или данных (если операнд —
имя области памяти в сегменте данных).</FONT></LI>

<BR><FONT SIZE=+0>Перемещаемые операнды отличаются от адресных тем, что
они не привязаны к конкретному адресу физической памяти. Сегментная составляющая
адреса перемещаемого операнда неизвестна и будет определена после загрузки
программы в память для выполнения.</FONT>

<P><FONT SIZE=+0>К примеру:</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;
data&nbsp;&nbsp;&nbsp; segment
mas_w&nbsp;&nbsp; dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 25 dup (0)
…
code&nbsp;&nbsp;&nbsp; segment
…
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea&nbsp;&nbsp;&nbsp;&nbsp; si,mas_w&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;mas_w - перемещаемый операнд
&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>В этом фрагменте <I>mas_w</I> — символьное имя, значением
которого является начальный адрес области памяти размером 25 слов. Полный
физический адрес этой области памяти будет известен только после загрузки
программы в память для выполнения.&nbsp;<A NAME="СчетчикАдреса"></A></FONT>
<LI>
<FONT SIZE=+0><I>Счетчик адреса</I> — специфический вид операнда. Он обозначается
знаком <B>$</B>.</FONT></LI>

<BR><FONT SIZE=+0>Специфика этого операнда в том, что когда транслятор
ассемблера встречает в исходной программе этот символ, то он подставляет
вместо него текущее значение счетчика адреса. Значение счетчика адреса,
или, как его иногда называют, <I>счетчика размещения</I>, представляет
собой смещение текущей машинной команды относительно начала сегмента кода.</FONT>
<BR><FONT SIZE=+0>В формате листинга счетчику адреса соответствует вторая
или третья колонка (в зависимости от того, присутствует или нет в листинге
колонка с уровнем вложенности). Если взять в качестве пример любой листинг,
то видно, что при обработке транслятором очередной команды ассемблера счетчик
адреса увеличивается на длину сформированной машинной команды. Важно правильно
понимать этот момент.</FONT>
<BR><FONT SIZE=+0>К примеру, обработка директив ассемблера не влечет за
собой изменения счетчика. Директивы, в отличие от команд ассемблера, —
это лишь указания транслятору на выполнение определенных действий по формированию
машинного представления программы, и для них транслятором не генерируется
никаких конструкций в памяти. В качестве примера использования в команде
значения счетчика адреса можно привести следующий:</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;
&nbsp;jmp $+3 ;безусловный переход на команду mov
&nbsp;cld ;длина команды cld составляет 1 байт
&nbsp;mov al,1
&nbsp;&nbsp;</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>При использовании подобного выражения для перехода не забывайте
о длине самой команды, в которой это выражение используется, так как значение
счетчика адреса соответствует смещению в сегменте команд данной, а не следующей
за ней команды. В нашем примере команда jmp занимает 2 байта. Но будьте
осторожны, длина команды зависит от того, какие в ней используются операнды.
Команда с регистровыми операндами будет короче команды, один из операндов
которой расположен в памяти. В большинстве случаев эту информацию можно
получить, зная формат машинной команды и анализируя колонку листинга с
объектным кодом команды.&nbsp;<A NAME="РегистровыйОперанд"></A></FONT>
<LI>
<FONT SIZE=+0><I>Регистровый операнд</I> — это просто имя регистра. В программе
на ассемблере можно использовать имена всех регистров общего назначения
и большинства системных регистров.</FONT></LI>

<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;
&nbsp;mov al,4 ;константу 4 заносим в регистр al
&nbsp;mov dl,pass+4 ;байт по адресу pass+4 в регистр
dl
&nbsp;add al,dl ;команда с регистровыми
операндами</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<A NAME="БазовыйИиндексныйОперанды"></A>
<LI>
<FONT SIZE=+0><I>Базовый и индексный операнды</I>. Этот тип операндов используется
для реализации <A HREF="../Lesson/Lesson06/Les_06.htm#КосвеннаяБазовая">косвенной
базовой</A>, <A HREF="../Lesson/Lesson06/Les_06.htm#КосвеннаяБазовая">косвенной
индексной адресации</A> или их <A HREF="../Lesson/Lesson06/Les_06.htm#КосвеннаяБазовая">комбинаций</A>
и <A HREF="../Lesson/Lesson06/Les_06.htm#КосвеннаяБазовая">расширений</A>.&nbsp;</FONT><A NAME="СтруктурныеОперанды"></A></LI>

<LI>
<FONT SIZE=+0><I>Структурные операнды</I> используются для доступа к конкретному
элементу сложного типа данных, называемого <I><A HREF="Data.htm#ОпределениеСтруктуры">структурой</A></I>.&nbsp;</FONT><A NAME="Записи"></A></LI>

<LI>
<FONT SIZE=+0><I>Записи</I> (аналогично структурному типу) используются
для доступа к битовому полю некоторой <A HREF="Data.htm#ОпределениеЗаписи">записи</A>.</FONT></LI>
</UL>
<FONT SIZE=+0>Операнды являются элементарными компонентами, из которых
формируется часть машинной команды, обозначающая объекты, над которыми
выполняется операция.</FONT>
<BR><FONT SIZE=+0>В более общем случае операнды могут входить как составные
части в более сложные образования, называемые <I>выражениями</I>.</FONT>
<BR><I><FONT SIZE=+0><B>Выражения</B> представляют собой комбинации операндов
и операторов, рассматриваемые как единое целое</FONT></I><FONT SIZE=+0>.</FONT>

<P><FONT SIZE=+0>Результатом вычисления выражения может быть адрес некоторой
ячейки памяти или некоторое константное (абсолютное) значение.</FONT>

<P><FONT SIZE=+0>Возможные типы операндов мы уже рассмотрели. Перечислим
теперь возможные типы <I>операторов ассемблера</I> и синтаксические правила
формирования выражений ассемблера.</FONT>
<UL>
<LI>
<FONT SIZE=+0><A HREF="#АрифметическиеOператоры">Арифметические операторы</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#ОператорыСдвига">Операторы сдвига</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#ОператорыСравнения">Операторы сравнения</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#ЛогическиеОператоры">Логические операторы</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#ИндексныйОператор">Индексный оператор</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#ОператорПереопределенияТипа">Оператор переопределения
типа</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#ОператорПереопределенияСегмента">Оператор переопределения
сегмента</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#ОператорИменованияТипа">Оператор именования типа
структуры</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#SEG">Оператор получения сегментной составляющей
адреса выражения</A></FONT></LI>

<LI>
<FONT SIZE=+0><A HREF="#Offset">Оператор получения смещения выражения</A></FONT></LI>
</UL>
&nbsp;

<P><FONT SIZE=+0>В <I><A HREF="#Табл_2">табл. 2</A></I> приведены поддерживаемые
языком ассемблера операторы и перечислены их приоритеты. Дадим краткую
характеристику операторов:</FONT>
<UL><A NAME="АрифметическиеOператоры"></A>
<LI>
<FONT SIZE=+0><I>Арифметические операторы</I>. К ним относятся:</FONT></LI>

<UL>
<LI>
<FONT SIZE=+0>унарные “<B>+</B>” и “<B>–</B>”;</FONT></LI>

<LI>
<FONT SIZE=+0>бинарные “<B>+</B>” и “<B>–</B>”;</FONT></LI>

<LI>
<FONT SIZE=+0>умножения “<B>*</B>”;</FONT></LI>

<LI>
<FONT SIZE=+0>целочисленного деления “<B>/</B>”;</FONT></LI>

<LI>
<FONT SIZE=+0>получения остатка от деления “<B>mod</B>”.</FONT></LI>
</UL>
<FONT SIZE=+0>Эти операторы расположены на уровнях приоритета 6, 7, 8 в
<I><A HREF="#Табл_2">табл. 2</A></I>. Например,</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;
tab_size equ 50 ;размер массива в байтах
size_el equ 2 ;размер элементов
…
;вычисляется число элементов массива и заносится в
регистр cx
&nbsp;mov cx,tab_size / size_el ;оператор “/”</FONT></TT></PRE>
</TD>
</TR>
</TABLE>

<P><CENTER><IMG SRC="../Pic/Ris5_05.gif" BORDER=0 ></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 5. </B>Синтаксис арифметических операций</FONT></I></CENTER>

<CENTER><A NAME="ОператорыСдвига"></A></CENTER>

<LI>
<FONT SIZE=+0><I>Операторы сдвига</I> выполняют сдвиг выражения на указанное
количество разрядов (рис. 6). Например,</FONT></LI>

<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;
mask_b equ 10111011
…
mov al,mask_b shr 3 ;al=00010111</FONT></TT></PRE>
</TD>
</TR>
</TABLE>

<P><CENTER><IMG SRC="../Pic/Ris5_06.gif" BORDER=0 ></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 6. </B>Синтаксис операторов сдвига</FONT></I></CENTER>

<CENTER><A NAME="ОператорыСравнения"></A></CENTER>

<LI>
<FONT SIZE=+0><I>Операторы сравнения</I> (возвращают значение “истина”
или “ложь”) предназначены для формирования логических выражений (см. рис.
7 и <I><A HREF="#Табл_1">табл. 1</A></I>). Логическое значение “истина”
соответствует цифровой единице, а “ложь” — нулю. Например,</FONT></LI>

<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
tab_size equ 30 ;размер таблицы
…
&nbsp;mov al,tab_size ge 50 ;загрузка размера
таблицы в al
&nbsp;cmp al,0 ;если tab_size &lt; 50, то
&nbsp;je m1 ;переход на m1
…
m1: …</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>В этом примере если значение tab_size больше или равно 50,
то результат в al равен 0ffh, а если tab_size меньше 50, то al равно 00h.
Команда cmp сравнивает значение al с нулем и устанавливает соответствующие
флаги в flags/eflags. Команда je на основе анализа этих флагов передает
или не передает управление на метку m1.</FONT>
<P><CENTER><IMG SRC="../Pic/Ris5_07.gif" BORDER=0 ></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 7.</B> Синтаксис операторов сравнения</FONT></I></CENTER>

<CENTER><A NAME="Табл_1"></A></CENTER>

<H5>
<FONT SIZE=+0>Таблица 1. Операторы сравнения</FONT></H5>

<CENTER><TABLE BORDER=3 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR ALIGN=CENTER>
<TD>Оператор</TD>

<TD>Значение</TD>
</TR>

<TR ALIGN=CENTER>
<TD>eq</TD>

<TD ALIGN=LEFT>ИСТИНА, если выражение_1 равно выражение_2</TD>
</TR>

<TR ALIGN=CENTER>
<TD>ne</TD>

<TD ALIGN=LEFT>ИСТИНА, если выражение_1 не равно выражение_2</TD>
</TR>

<TR ALIGN=CENTER>
<TD>lt</TD>

<TD ALIGN=LEFT>ИСТИНА, если выражение_1 меньше выражение_2>ИСТИНА, если
выражение_1 не равно выражение_2</TD>
</TR>

<TR ALIGN=CENTER>
<TD>le</TD>

<TD ALIGN=LEFT>ИСТИНА, если выражение_1 меньше или равно выражение_2</TD>
</TR>

<TR ALIGN=CENTER>
<TD>gt</TD>

<TD ALIGN=LEFT>ИСТИНА, если выражение_1 больше выражение_2</TD>
</TR>

<TR ALIGN=CENTER>
<TD>ge</TD>

<TD ALIGN=LEFT>ИСТИНА, если выражение_1 больше или равно выражение_2</TD>
</TR>
</TABLE></CENTER>
<A NAME="ЛогическиеОператоры"></A>
<LI>
<FONT SIZE=+0><I>Логические операторы</I> выполняют над выражениями побитовые
операции (рис. 8). Выражения должны быть абсолютными, то есть такими, численное
значение которых может быть вычислено транслятором. Например:</FONT></LI>

<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
flags&nbsp;&nbsp; equ&nbsp;&nbsp;&nbsp;&nbsp; 10010011
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp; al,flags xor 01h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;al=10010010;пересылка в al поля flags с
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;инвертированным правым битом</FONT></TT></PRE>
</TD>
</TR>
</TABLE>

<P><CENTER><IMG SRC="../Pic/Ris5_08.gif" BORDER=0 ></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 8. </B>Синтаксис логических операторов</FONT></I></CENTER>

<CENTER><A NAME="ИндексныйОператор"></A></CENTER>

<LI>
<FONT SIZE=+0><I>Индексный оператор</I> <B>[ ]</B>. Не удивляйтесь, но
скобки тоже являются оператором, и транслятор их наличие воспринимает как
указание сложить значение <B>выражение_1</B> за этими скобками с <B>выражение_2</B>,
заключенным в скобки (рис. 9). Например,</FONT></LI>

<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,mas[si]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;пересылка слова по адресу mas+(si) в регистр ax</FONT></TT></PRE>
</TD>
</TR>
</TABLE>

<P><CENTER><IMG SRC="../Pic/Ris5_09.gif" BORDER=0 ></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 9.</B> Синтаксис индексного оператора</FONT></I></CENTER>


<P><FONT SIZE=+0>Заметим, что в литературе по ассемблеру принято следующее
обозначение: <I>когда в тексте речь идет о содержимом регистра, то его
название берут в круглые скобки.</I> Мы также будем придерживаться этого
обозначения.</FONT>
<BR><FONT SIZE=+0>К примеру, в нашем случае запись в комментариях последнего
фрагмента программы mas + (si) означает вычисление следующего выражения:
значение смещения символического имени mas плюс содержимое регистра si.</FONT>

<P><A NAME="ОператорПереопределенияТипа"></A>
<LI>
<FONT SIZE=+0><I>Оператор переопределения типа</I> <B>ptr</B> применяется
для переопределения или уточнения типа метки или переменной, определяемых
выражением (рис. 10).</FONT></LI>

<BR><FONT SIZE=+0>Тип может принимать одно из следующих значений: <B>byte,
word, dword, qword, tbyte, near, far</B>. Например,</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">d_wrd&nbsp;&nbsp; dd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; al,byte ptr d_wrd+1 ;пересылка второго байта из двойного слова</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>Поясним этот фрагмент программы. Переменная <I>d_wrd</I>
имеет тип двойного слова. Что делать, если возникнет необходимость обращения
не ко всей переменной, а только к одному из входящих в нее байтов (например,
ко второму)? Если попытаться сделать это командой</FONT>
<BR><FONT SIZE=+0>mov al,d_wrd+1, то транслятор выдаст сообщение о несовпадении
типов операндов. Оператор <B>ptr</B> позволяет непосредственно в команде
переопределить тип и выполнить команду.</FONT>
<P><CENTER><IMG SRC="../Pic/Ris5_10.gif" BORDER=0 ></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 10. </B>Синтаксис оператора переопределения
типа</FONT></I></CENTER>

<CENTER><A NAME="ОператорПереопределенияСегмента"></A></CENTER>

<LI>
<FONT SIZE=+0><I>Оператор переопределения сегмента</I> <B>:</B> (двоеточие)
заставляет вычислять физический адрес относительно конкретно задаваемой
сегментной составляющей: “имя сегментного регистра”, “имя сегмента” из
соответствующей директивы SEGMENT или “имя группы” (рис. 11). Этот момент
очень важен, поэтому поясню его подробнее. При обсуждении сегментации мы
говорили о том, что микропроцессор на аппаратном уровне поддерживает три
типа сегментов — кода, стека и данных. В чем заключается такая аппаратная
поддержка? К примеру, для выборки на выполнение очередной команды микропроцессор
должен обязательно посмотреть содержимое сегментного регистра cs и только
его. А в этом регистре, как мы знаем, содержится (пока еще не сдвинутый)
физический адрес начала сегмента команд. Для получения адреса конкретной
команды микропроцессору остается умножить содержимое cs на 16 (что означает
сдвиг на четыре разряда) и сложить полученное 20-битное значение с 16-битным
содержимым регистра ip. Примерно то же самое происходит и тогда, когда
микропроцессор обрабатывает операнды в машинной команде. Если он видит,
что операнд — это адрес (эффективный адрес, который является только частью
физического адреса), то он знает, в каком сегменте его искать — по умолчанию
это сегмент, адрес начала которого записан в сегментном регистре <I>ds</I>.</FONT></LI>

<BR><FONT SIZE=+0>А что же с сегментом стека? Посмотрите раздел <I><A HREF="CPUmodel.htm">"Программная
модель микропроцессора"</A></I>, там, где мы описывали назначение регистров
общего назначения.</FONT>
<BR><FONT SIZE=+0>В контексте нашего рассмотрения нас интересуют регистры
<I>sp</I> и <I>bp</I>. Если микропроцессор видит в качестве операнда (или
его части, если операнд — выражение) один из этих регистров, то по умолчанию
он формирует физический адрес операнда используя в качестве его сегментной
составляющей содержимое регистра <I>ss</I>. Что подразумевает термин <I>“по
умолчанию”</I>? Вспомните <I>“рефлексы”</I>, о которых мы говорили на уроке
1. Это набор микропрограмм в блоке микропрограммного управления, каждая
из которых выполняет одну из команд в системе машинных команд микропроцессора.
Каждая микропрограмма работает по своему алгоритму. Изменить его, конечно
же, нельзя, но можно чуть-чуть подкорректировать. Делается это с помощью
необязательного поля <I>префикса машинной команды</I> (см. <A HREF="../Lesson/Lesson06/Les_06.htm#ФорматМашиннойКоманды">формат
машинной команды</A>). Если мы согласны с тем, как работает команда, то
это поле отсутствует. Если же мы хотим внести поправку (если, конечно,
она допустима для конкретной команды) в алгоритм работы команды, то необходимо
сформировать соответствующий префикс.</FONT>
<BR><FONT SIZE=+0><I>Префикс</I> представляет собой однобайтовую величину,
численное значение которой определяет ее назначение. Микропроцессор распознает
по указанному значению, что этот байт является префиксом, и дальнейшая
работа микропрограммы выполняется с учетом поступившего указания на корректировку
ее работы. Сейчас нас интересует один из них - <I>префикс замены (переопределения)
сегмента</I>. Его назначение состоит в том, чтобы указать микропроцессору
(а по сути, микропрограмме) на то, что мы не хотим использовать сегмент
по умолчанию. Возможности для подобного переопределения, конечно, ограничены.
Сегмент команд переопределить нельзя, адрес очередной исполняемой команды
однозначно определяется парой cs:ip. А вот сегменты стека и данных — можно.
Для этого и предназначен оператор “<B>:</B>”. Транслятор ассемблера, обрабатывая
этот оператор, формирует соответствующий однобайтовый префикс замены сегмента.
Например,</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">.code
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp&nbsp;&nbsp;&nbsp;&nbsp; met1&nbsp;&nbsp;&nbsp; ;обход обязателен, иначе поле ind
будет трактоваться ;как очередная команда
ind&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;описание поля данных в сегменте команд
met1:
...
mov al,cs:ind ;переопределение сегмента позволяет работать с
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;данными, определенными внутри сегмента кода</FONT></TT></PRE>
</TD>
</TR>
</TABLE>

<P><CENTER><IMG SRC="../Pic/Ris5_11.gif" BORDER=0 ></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 11. </B>Синтаксис оператора переопределения
сегмента</FONT></I></CENTER>

<CENTER><A NAME="ОператорИменованияТипа"></A></CENTER>

<LI>
<FONT SIZE=+0><I>Оператор именования типа</I> <A HREF="Data.htm#ОпределениеСтруктуры">структуры</A>
<B>.</B> (точка) также заставляет транслятор производить определенные вычисления,
если он встречается в выражении.&nbsp;</FONT><A NAME="SEG"></A></LI>

<LI>
<FONT SIZE=+0><I>Оператор получения сегментной составляющей адреса выражения</I>
<B>seg</B> возвращает физический адрес сегмента для выражения (рис. 12),
в качестве которого могут выступать метка, переменная, имя сегмента, имя
группы или некоторое символическое имя.</FONT></LI>

<P><CENTER><IMG SRC="../Pic/Ris5_12.gif" BORDER=0 ></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 12. </B>Синтаксис оператора получения
сегментной составляющей</FONT></I></CENTER>

<CENTER><A NAME="OFFSET"></A><A NAME="Offset"></A></CENTER>

<LI>
<FONT SIZE=+0><I>Оператор получения смещения выражения</I> <B>offset</B>
позволяет получить значение смещения выражения (рис. 13) в байтах относительно
начала того сегмента, в котором выражение определено.</FONT></LI>

<P><CENTER><IMG SRC="../Pic/Ris5_13.gif" BORDER=0 ></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 13. </B>Синтаксис оператора получения
смещения</FONT></I></CENTER>


<P><FONT SIZE=+0>Например,</FONT>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
.data
pole&nbsp;&nbsp;&nbsp; dw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5
...
.code
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,seg&nbsp; pole
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; es,ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; dx,offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pole&nbsp;&nbsp;&nbsp; ;теперь в паре es:dx полный адрес pole</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
&nbsp;</UL>
<A NAME="Табл_2"></A>

<P><FONT SIZE=+0>Как и в языках высокого уровня, выполнение операторов
ассемблера при вычислении выражений осуществляется в соответствии с их
приоритетами (см. табл. 2). Операции с одинаковыми приоритетами выполняются
последовательно слева направо. Изменение порядка выполнения возможно путем
расстановки круглых скобок, которые имеют наивысший приоритет.</FONT>
<H5>
<FONT SIZE=+0>Таблица 2. Операторы и их приоритет</FONT></H5>

<CENTER><TABLE BORDER=3 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR ALIGN=CENTER>
<TD>Оператор</TD>

<TD>Приоритет</TD>
</TR>

<TR ALIGN=CENTER>
<TD>length, size, width, mask, (, ), [, ], &lt;, ></TD>

<TD>1</TD>
</TR>

<TR ALIGN=CENTER>
<TD>.</TD>

<TD>2</TD>
</TR>

<TR ALIGN=CENTER>
<TD>:</TD>

<TD>3</TD>
</TR>

<TR ALIGN=CENTER>
<TD>ptr, offset, seg, type, this</TD>

<TD>4</TD>
</TR>

<TR ALIGN=CENTER>
<TD>high, low</TD>

<TD>5</TD>
</TR>

<TR ALIGN=CENTER>
<TD>+, - (унарные)</TD>

<TD>6</TD>
</TR>

<TR ALIGN=CENTER>
<TD>*, /, mod, shl, shr</TD>

<TD>7</TD>
</TR>

<TR ALIGN=CENTER>
<TD>+, -, (бинарные)</TD>

<TD>8</TD>
</TR>

<TR ALIGN=CENTER>
<TD>eq, ne, lt, le, gt, ge</TD>

<TD>9</TD>
</TR>

<TR ALIGN=CENTER>
<TD>not</TD>

<TD>10</TD>
</TR>

<TR ALIGN=CENTER>
<TD>and</TD>

<TD>11</TD>
</TR>

<TR ALIGN=CENTER>
<TD>or, xor</TD>

<TD>12</TD>
</TR>

<TR ALIGN=CENTER>
<TD>short, type</TD>

<TD>13</TD>
</TR>
</TABLE></CENTER>
<A NAME="СтандартныеДирективыСегментации"></A>
<H3>
<FONT SIZE=+0>Директивы сегментации</FONT></H3>
<FONT SIZE=+0>В ходе предыдущего обсуждения мы выяснили все основные правила
записи команд и операндов в программе на ассемблере. Открытым остался вопрос
о том, как правильно оформить последовательность команд, чтобы транслятор
мог их обработать, а микропроцессор — выполнить.</FONT>

<P><FONT SIZE=+0>При рассмотрении архитектуры микропроцессора мы узнали,
что он имеет шесть сегментных регистров, посредством которых может одновременно
работать:</FONT>
<UL>
<LI>
<FONT SIZE=+0>с одним сегментом кода;</FONT></LI>

<LI>
<FONT SIZE=+0>с одним сегментом стека;</FONT></LI>

<LI>
<FONT SIZE=+0>с одним сегментом данных;</FONT></LI>

<LI>
<FONT SIZE=+0>с тремя дополнительными сегментами данных.</FONT></LI>
</UL>
<FONT SIZE=+0>Еще раз вспомним, что физически сегмент представляет собой
область памяти, занятую командами и (или) данными, адреса которых вычисляются
относительно значения в соответствующем сегментном регистре.</FONT>

<P><FONT SIZE=+0>Синтаксическое описание сегмента на ассемблере представляет
собой конструкцию, изображенную на рис. 14:</FONT>
<P><CENTER><IMG SRC="../Pic/Ris5_14.gif" BORDER=0 ></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 14. </B>Синтаксис описания сегмента</FONT></I></CENTER>


<P><FONT SIZE=+0>Важно отметить, что функциональное назначение сегмента
несколько шире, чем простое разбиение программы на блоки кода, данных и
стека. Сегментация является частью более общего механизма, связанного с
концепцией <I>модульного программирования</I>. Она предполагает унификацию
оформления объектных модулей, создаваемых компилятором, в том числе с разных
языков программирования. Это позволяет объединять программы, написанные
на разных языках. Именно для реализации различных вариантов такого объединения
и предназначены операнды в директиве <B>SEGMENT</B>.</FONT>
<BR><FONT SIZE=+0>Рассмотрим их подробнее.</FONT>
<UL>
<LI>
<FONT SIZE=+0><B><I>Атрибут выравнивания сегмента</I></B> (тип выравнивания)
сообщает компоновщику о том, что нужно обеспечить размещение начала сегмента
на заданной границе. Это важно, поскольку при правильном выравнивании доступ
к данным в процессорах i80х86 выполняется быстрее. Допустимые значения
этого атрибута следующие:</FONT></LI>

<UL>
<LI>
<FONT SIZE=+0><B>BYTE</B> — выравнивание не выполняется. Сегмент может
начинаться с любого адреса памяти;</FONT></LI>

<LI>
<FONT SIZE=+0><B>WORD</B> — сегмент начинается по адресу, кратному двум,
то есть последний (младший) значащий бит физического адреса равен 0 (выравнивание
на границу слова);</FONT></LI>

<LI>
<FONT SIZE=+0><B>DWORD</B> — сегмент начинается по адресу, кратному четырем,
то есть два последних (младших) значащих бита равны 0 (выравнивание на
границу двойного слова);</FONT></LI>

<LI>
<FONT SIZE=+0><B>PARA</B> — сегмент начинается по адресу, кратному 16,
то есть последняя шестнадцатеричная цифра адреса должна быть 0h (выравнивание
на границу параграфа);</FONT></LI>

<LI>
<FONT SIZE=+0><B>PAGE</B> — сегмент начинается по адресу, кратному 256,
то есть две последние шестнадцатеричные цифры должны быть 00h (выравнивание
на границу 256-байтной страницы);</FONT></LI>

<LI>
<FONT SIZE=+0><B>MEMPAGE</B> — сегмент начинается по адресу, кратному 4
Кбайт, то есть три последние шестнадцатеричные цифры должны быть 000h (адрес
следующей 4-Кбайтной страницы памяти).</FONT></LI>


<P><FONT SIZE=+0>По умолчанию тип выравнивания имеет значение <B>PARA</B>.</FONT></UL>
&nbsp;
<LI>
<FONT SIZE=+0><B><I>Атрибут комбинирования сегментов</I></B> (комбинаторный
тип) сообщает компоновщику, как нужно комбинировать сегменты различных
модулей, имеющие одно и то же имя. Значениями атрибута комбинирования сегмента
могут быть:</FONT></LI>

<UL>
<LI>
<FONT SIZE=+0><B>PRIVATE</B> — сегмент не будет объединяться с другими
сегментами с тем же именем вне данного модуля;</FONT></LI>

<LI>
<FONT SIZE=+0><B>PUBLIC</B> — заставляет компоновщик соединить все сегменты
с одинаковыми именами. Новый объединенный сегмент будет целым и непрерывным.
Все адреса (смещения) объектов, а это могут быть, в зависимости от типа
сегмента, команды и данные, будут вычисляться относительно начала этого
нового сегмента;</FONT></LI>

<LI>
<FONT SIZE=+0><B>COMMON</B> — располагает все сегменты с одним и тем же
именем по одному адресу. Все сегменты с данным именем будут перекрываться
и совместно использовать память. Размер полученного в результате сегмента
будет равен размеру самого большого сегмента;</FONT></LI>

<LI>
<FONT SIZE=+0><B>AT xxxx</B> — располагает сегмент по абсолютному адресу
параграфа (параграф — объем памяти, кратный 16; поэтому последняя шестнадцатеричная
цифра адреса параграфа равна 0). Абсолютный адрес параграфа задается выражением
xxx. Компоновщик располагает сегмент по заданному адресу памяти (это можно
использовать, например, для доступа к видеопамяти или области ПЗУ), учитывая
атрибут комбинирования. Физически это означает, что сегмент при загрузке
в память будет расположен, начиная с этого абсолютного адреса параграфа,
но для доступа к нему в соответствующий сегментный регистр должно быть
загружено заданное в атрибуте значение. Все метки и адреса в определенном
таким образом сегменте отсчитываются относительно заданного абсолютного
адреса;</FONT></LI>

<LI>
<FONT SIZE=+0><B>STACK</B> — определение сегмента стека. Заставляет компоновщик
соединить все одноименные сегменты и вычислять адреса в этих сегментах
относительно регистра ss. Комбинированный тип STACK (стек) аналогичен комбинированному
типу PUBLIC, за исключением того, что регистр ss является стандартным сегментным
регистром для сегментов стека. Регистр <I>sp</I> устанавливается на конец
объединенного сегмента стека. Если не указано ни одного сегмента стека,
компоновщик выдаст предупреждение, что стековый сегмент не найден. Если
сегмент стека создан, а комбинированный тип STACK не используется, программист
должен явно загрузить в регистр ss адрес сегмента (подобно тому, как это
делается для регистра <I>ds</I>).</FONT></LI>


<P><FONT SIZE=+0>По умолчанию атрибут комбинирования принимает значение
<B>PRIVATE</B>.</FONT></UL>
&nbsp;
<LI>
<FONT SIZE=+0><B><I>Атрибут класса сегмента</I></B> (тип класса) — это
заключенная в кавычки строка, помогающая компоновщику определить соответствующий
порядок следования сегментов при собирании программы из сегментов нескольких
модулей. Компоновщик объединяет вместе в памяти все сегменты с одним и
тем же именем класса (имя класса, в общем случае, может быть любым, но
лучше, если оно будет отражать функциональное назначение сегмента). Типичным
примером использования имени класса является объединение в группу всех
сегментов кода программы (обычно для этого используется класс “code”).
С помощью механизма типизации класса можно группировать также сегменты
инициализированных и неинициализированных данных;</FONT></LI>

<LI>
<FONT SIZE=+0><B><I>Атрибут размера сегмента</I></B>. Для процессоров i80386
и выше сегменты могут быть 16 или 32-разрядными. Это влияет, прежде всего,
на размер сегмента и порядок формирования физического адреса внутри него.
Атрибут может принимать следующие значения:</FONT></LI>

<UL>
<LI>
<FONT SIZE=+0><B>USE16</B> — это означает, что сегмент допускает 16-разрядную
адресацию. При формировании физического адреса может использоваться только
16-разрядное смещение. Соответственно, такой сегмент может содержать до
64 Кбайт кода или данных;</FONT></LI>

<LI>
<FONT SIZE=+0><B>USE32</B> — сегмент будет 32-разрядным. При формирования
физического адреса может использоваться 32-разрядное смещение. Поэтому
такой сегмент может содержать до 4 Гбайт кода или данных.</FONT></LI>
</UL>
</UL>
<FONT SIZE=+0>Все сегменты сами по себе равноправны, так как директивы
<B>SEGMENT</B> и <B>ENDS</B> не содержат информации о функциональном назначении
сегментов. Для того чтобы использовать их как сегменты кода, данных или
стека, необходимо предварительно сообщить транслятору об этом, для чего
используют специальную директиву <B>ASSUME</B>, имеющую формат, показанный
на рис. 15. Эта директива сообщает транслятору о том, какой сегмент к какому
сегментному регистру привязан. В свою очередь, это позволит транслятору
корректно связывать символические имена, определенные в сегментах. Привязка
сегментов к сегментным регистрам осуществляется с помощью операндов этой
директивы, в которых имя_сегмента должно быть именем сегмента, определенным
в исходном тексте программы директивой <B>SEGMENT</B> или ключевым словом
<B>nothing</B>. Если в качестве операнда используется только ключевое слово
<B>nothing</B>, то предшествующие назначения сегментных регистров аннулируются,
причем сразу для всех шести сегментных регистров. Но ключевое слово <B>nothing</B>
можно использовать вместо аргумента имя сегмента; в этом случае будет выборочно
разрываться связь между сегментом с именем имя сегмента и соответствующим
сегментным регистром (см. рис. 15).</FONT>
<P><CENTER><IMG SRC="../Pic/Ris5_15.gif" BORDER=0 ></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 15.</B> Директива ASSUME</FONT></I><FONT SIZE=+0>&nbsp;</FONT><A NAME="УпрощенныеДирективыСегментации"></A></CENTER>


<P><FONT SIZE=+0>На уроке 3 мы рассматривали пример программы с директивами
сегментации. Эти директивы изначально использовались для оформления программы
в трансляторах MASM и TASM. Поэтому их называют <I>стандартными директивами
сегментации</I>.</FONT>

<P><FONT SIZE=+0>Для простых программ, содержащих по одному сегменту для
кода, данных и стека, хотелось бы упростить ее описание. Для этого в трансляторы
MASM и TASM ввели возможность использования <I>упрощенных директив сегментации</I>.
Но здесь возникла проблема, связанная с тем, что необходимо было как-то
компенсировать невозможность напрямую управлять размещением и комбинированием
сегментов. Для этого совместно с упрощенными директивами сегментации стали
использовать директиву указания модели памяти <B>MODEL</B>, которая частично
стала управлять размещением сегментов и выполнять функции директивы <B>ASSUME</B>
(поэтому при использовании упрощенных директив сегментации директиву ASSUME
можно не использовать). Эта директива связывает сегменты, которые в случае
использования упрощенных директив сегментации имеют предопределенные имена,
с сегментными регистрами (хотя явно инициализировать <I>ds</I> все равно
придется).</FONT>

<P><FONT SIZE=+0>В листинге 1 приведен пример программы с использованием
упрощенных директив сегментации:</FONT>
<BR><A NAME="Листинг_1"></A>
<TABLE BORDER=5 CELLPADDING=2 COLS=1 WIDTH="330" BGCOLOR="#E2E2E2" >
<TR>
<TD>
<PRE><TT><FONT COLOR="#000099">&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Листинг 1. Использование упрощенных директив сегментации
;---------Prg_3_1.asm-------------------------------
masm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;режим работы TASM: ideal или masm
model&nbsp;&nbsp; small&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;модель памяти
.data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;сегмент данных
message db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Введите две шестнадцатеричные цифры,$'
.stack&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;сегмент стека
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 256&nbsp;&nbsp;&nbsp;&nbsp; dup ('?')&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;сегмент стека
.code&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;сегмент кода
main&nbsp;&nbsp;&nbsp; proc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;начало процедуры main
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,@data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;заносим адрес сегмента данных в регистр ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ds,ax&nbsp;&nbsp; ;ax в ds
;далее текст программы (см. сегмента кода в листинге 3.1 книги)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov&nbsp;&nbsp;&nbsp;&nbsp; ax,4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;пересылка 4c00h в регистр ax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; 21h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;вызов прерывания с номером 21h
main&nbsp;&nbsp;&nbsp; endp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;конец процедуры main
end&nbsp;&nbsp;&nbsp;&nbsp; main&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;конец программы с точкой входа main</FONT></TT></PRE>
</TD>
</TR>
</TABLE>
<FONT SIZE=+0>Синтаксис директивы <B>MODEL</B> показан на рис. 16.</FONT>
<P><CENTER><IMG SRC="../Pic/Ris5_16.gif" BORDER=0 ></CENTER>

<P><CENTER><I><FONT SIZE=+0><B>Рис. 16. </B>Синтаксис директивы MODEL</FONT></I></CENTER>


<P><FONT SIZE=+0>Обязательным параметром директивы MODEL является <I>модель
памяти</I>. Этот параметр определяет модель сегментации памяти для программного
модуля. Предполагается, что программный модуль может иметь только определенные
типы сегментов, которые определяются упомянутыми нами ранее <I>упрощенными
директивами описания сегментов</I>. Эти директивы приведены в табл. 3.</FONT>
<H5>
<FONT SIZE=+0>Таблица 3. Упрощенные директивы определения сегмента</FONT></H5>

<CENTER><TABLE BORDER=3 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR ALIGN=CENTER>
<TD>Формат директивы&nbsp;
<BR>(режим MASM)</TD>

<TD>Формат директивы&nbsp;
<BR>(режим IDEAL)</TD>

<TD>Назначение</TD>
</TR>

<TR ALIGN=CENTER>
<TD>.CODE [имя]</TD>

<TD>CODESEG[имя]</TD>

<TD ALIGN=LEFT>Начало или продолжение сегмента кода</TD>
</TR>

<TR ALIGN=CENTER>
<TD>.DATA</TD>

<TD>DATASEG</TD>

<TD ALIGN=LEFT>Начало или продолжение сегмента инициализированных данных.
Также используется для определения данных типа near</TD>
</TR>

<TR ALIGN=CENTER>
<TD>.CONST</TD>

<TD>CONST</TD>

<TD ALIGN=LEFT>Начало или продолжение сегмента постоянных данных (констант)
модуля</TD>
</TR>

<TR ALIGN=CENTER>
<TD>.DATA?</TD>

<TD>UDATASEG</TD>

<TD ALIGN=LEFT>Начало или продолжение сегмента неинициализированных данных.
Также используется для определения данных типа near</TD>
</TR>

<TR ALIGN=CENTER>
<TD>.STACK [размер]</TD>

<TD>STACK [размер]</TD>

<TD ALIGN=LEFT>Начало или продолжение сегмента стека модуля. Параметр [размер]
задает размер стека</TD>
</TR>

<TR ALIGN=CENTER>
<TD>.FARDATA [имя]</TD>

<TD>FARDATA [имя]</TD>

<TD ALIGN=LEFT>Начало или продолжение сегмента инициализированных данных
типа far</TD>
</TR>

<TR ALIGN=CENTER>
<TD>.FARDATA? [имя]</TD>

<TD>UFARDATA [имя]</TD>

<TD ALIGN=LEFT>Начало или продолжение сегмента неинициализированных данных
типа far</TD>
</TR>
</TABLE></CENTER>
<FONT SIZE=+0>Наличие в некоторых директивах параметра <B>[имя]</B> говорит
о том, что возможно определение нескольких сегментов этого типа. С другой
стороны, наличие нескольких видов сегментов данных обусловлено требованием
обеспечить совместимость с некоторыми компиляторами языков высокого уровня,
которые создают разные сегменты данных для инициализированных и неинициализированных
данных, а также констант.</FONT>

<P><FONT SIZE=+0>При использовании директивы <B>MODEL</B> транслятор делает
доступными несколько идентификаторов, к которым можно обращаться во время
работы программы, с тем, чтобы получить информацию о тех или иных характеристиках
данной модели памяти (см. <I><A HREF="#Табл_5">табл. 5</A></I>). Перечислим
эти идентификаторы и их значения (табл. 4).</FONT>
<H5>
<FONT SIZE=+0>Таблица 4. Идентификаторы, создаваемые директивой MODEL</FONT></H5>

<CENTER><TABLE BORDER=3 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR ALIGN=CENTER>
<TD>Имя идентификатора</TD>

<TD>Значение переменной</TD>
</TR>

<TR ALIGN=CENTER>
<TD>@code</TD>

<TD ALIGN=LEFT>Физический адрес сегмента кода</TD>
</TR>

<TR ALIGN=CENTER>
<TD>@data</TD>

<TD ALIGN=LEFT>Физический адрес сегмента данных типа near</TD>
</TR>

<TR ALIGN=CENTER>
<TD>@fardata</TD>

<TD ALIGN=LEFT>Физический адрес сегмента данных типа far</TD>
</TR>

<TR ALIGN=CENTER>
<TD>@fardata?</TD>

<TD ALIGN=LEFT>Физический адрес сегмента неинициализированных данных типа
far</TD>
</TR>

<TR ALIGN=CENTER>
<TD>@curseg</TD>

<TD ALIGN=LEFT>Физический адрес сегмента неинициализированных данных типа
far</TD>
</TR>

<TR ALIGN=CENTER>
<TD>@stack</TD>

<TD ALIGN=LEFT>Физический адрес сегмента стека</TD>
</TR>
</TABLE></CENTER>
<FONT SIZE=+0>Если вы посмотрите на текст <I><A HREF="#Листинг_1">листинга
1</A></I>, то увидите пример использования одного из этих идентификаторов.
Это <B>@data</B>; с его помощью мы получили значение физического адреса
сегмента данных нашей программы.</FONT>

<P><FONT SIZE=+0>Теперь можно закончить обсуждение директивы <B>MODEL</B>.
Операнды директивы <B>MODEL</B> используют для задания модели памяти, которая
определяет набор сегментов программы, размеры сегментов данных и кода,
способ связывания сегментов и сегментных регистров. В табл. 5 приведены
некоторые значения параметра <I>модель памяти</I> директивы <B>MODEL</B>.&nbsp;<A NAME="Табл_5"></A></FONT>
<H5>
<FONT SIZE=+0>Таблица 5. Модели памяти</FONT></H5>

<CENTER><TABLE BORDER=3 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR ALIGN=CENTER>
<TD>Модель</TD>

<TD>Тип кода</TD>

<TD>Тип данных</TD>

<TD>Назначение модели</TD>
</TR>

<TR ALIGN=CENTER>
<TD>TINY</TD>

<TD>near</TD>

<TD>near</TD>

<TD ALIGN=LEFT>Код и данные объединены в одну группу с именем DGROUP.&nbsp;
<BR>Используется для создания программ формата .com.</TD>
</TR>

<TR ALIGN=CENTER>
<TD>SMALL</TD>

<TD>near</TD>

<TD>near</TD>

<TD ALIGN=LEFT>Код занимает один сегмент, данные объединены в одну группу
с именем DGROUP.&nbsp;
<BR>Эту модель обычно используют для большинства программ на ассемблере</TD>
</TR>

<TR ALIGN=CENTER>
<TD>MEDIUM</TD>

<TD>far</TD>

<TD>near</TD>

<TD ALIGN=LEFT>Код занимает несколько сегментов, по одному на каждый объединяемый
программный модуль.&nbsp;
<BR>Все ссылки на передачу управления — типа far.&nbsp;
<BR>Данные объединены в одной группе; все ссылки на них — типа near</TD>
</TR>

<TR ALIGN=CENTER>
<TD>COMPACT</TD>

<TD>near</TD>

<TD>far</TD>

<TD ALIGN=LEFT>Код в одном сегменте;&nbsp;
<BR>ссылка на данные — типа far</TD>
</TR>

<TR ALIGN=CENTER>
<TD>LARGE</TD>

<TD>far</TD>

<TD>far</TD>

<TD>Код в нескольких сегментах, по одному на каждый объединяемый программный
модуль</TD>
</TR>
</TABLE></CENTER>
<FONT SIZE=+0>Параметр модификатор директивы <B>MODEL</B> позволяет уточнить
некоторые особенности использования выбранной модели памяти (табл. 6).</FONT>
<H5>
<FONT SIZE=+0>Таблица 6. Модификаторы модели памяти</FONT></H5>

<CENTER><TABLE BORDER=3 BGCOLOR="#E2E2E2" RULES="ALL" VALIGN="MIDDLE" >
<TR ALIGN=CENTER>
<TD>Значение модификатора</TD>

<TD>Назначение</TD>
</TR>

<TR ALIGN=CENTER>
<TD>use16</TD>

<TD ALIGN=LEFT>Сегменты выбранной модели используются как 16-битные (если
соответствующей директивой указан процессор i80386 или i80486)</TD>
</TR>

<TR ALIGN=CENTER>
<TD>use32</TD>

<TD ALIGN=LEFT>Сегменты выбранной модели используются как 32-битные (если
соответствующей директивой указан процессор i80386 или i80486)</TD>
</TR>

<TR ALIGN=CENTER>
<TD>dos</TD>

<TD ALIGN=LEFT>Программа будет работать в MS-DOS</TD>
</TR>
</TABLE></CENTER>
<FONT SIZE=+0>Необязательные параметры&nbsp;<EM>язык</EM> и&nbsp;<EM>модификатор
языка</EM> определяют некоторые особенности вызова процедур. Необходимость
в использовании этих параметров появляется при написании и связывании программ
на различных языках программирования.</FONT>

<P><FONT SIZE=+0>Описанные нами&nbsp;<EM>стандартные</EM> и&nbsp;<EM>упрощенные
директивы</EM> сегментации не исключают друг друга.&nbsp;<EM>Стандартные
директивы</EM> используются, когда программист желает получить полный контроль
над размещением сегментов в памяти и их комбинированием с сегментами других
модулей.</FONT>

<P><FONT SIZE=+0><EM>Упрощенные директивы</EM> целесообразно использовать
для простых программ и программ, предназначенных для связывания с программными
модулями, написанными на языках высокого уровня. Это позволяет компоновщику
эффективно связывать модули разных языков за счет стандартизации связей
и управления.&nbsp;</FONT>&nbsp;
<HR SIZE=5 WIDTH=80%>
</BODY>
<!конец html-документа>
</HTML>
