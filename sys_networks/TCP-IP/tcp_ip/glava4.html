<html>
<head>
<title>ARP: протокол определения адреса</title>
</head>

<body>
<div>


<p><small><a HREF="index.html"><img SRC="contents.jpg" BORDER="0" WIDTH="94" HEIGHT="20"></a><a HREF="../home.htm"><img SRC="begin.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava5.html"><img SRC="forward.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava3.html"><img SRC="back_b.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a href="index.html"><img SRC="index.jpg" border="0" WIDTH="68" HEIGHT="20"></a></small></p>

<font FACE="Arial" SIZE="4">



<p><a NAME="t040000"></a>Глава 4 ARP: протокол определения

адреса</p>

</font><font FACE="Arial"><font size="3"><u>



<p><b><a NAME="t041000"></a>Введение</p>

</b></u></font>



<p><small>Проблема, которую мы будем обсуждать в этой

главе, заключается в том, что IP адреса имеют

какое-либо значение только в семействе

протоколов TCP/IP. Канальные уровни, такие как Ethernet


или Token ring, имеют собственную схему адресации (в

основном 48-битные адреса); сетевые уровни, в свою

очередь, используют эти канальные уровни. Сеть

Ethernet, может быть использована различными

сетевыми уровнями в одно и то же время.

Компьютеры использующие разные сетевые

протоколы могут находиться на одном и том же

физическом кабеле. </small></p>



<p><small>Когда фрейм Ethernet отправляется от одного

хоста по локальной сети к другому, по его

48-битному Ethernet адресу определяется, к какому

интерфейсу он должен быть доставлен. Драйвер

сетевой платы никогда не смотрит на IP адрес

назначения в IP датаграмме. </small></p>



<p><small>Другими словами возникает необходимость

установить соответствие между двумя различными

формами адресов: 32-битными IP адресами и

каким-либо типом адресов канального уровня. RFC 826 [<a NAME="t041001"></a>Plummer 1982] - официальная спецификация ARP. </small></p>



<p><small>На рисунке 4.1 показаны два протокола,

которые мы рассмотрим в этой и следующей главах: <a NAME="t041002"></a>протокол определения адреса (ARP - address

resolution protocol) и обратный протокол определения

адреса (RARP - reverse address resolution protocol).<a NAME="t041003"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t4_1.jpg" WIDTH="136" HEIGHT="83"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 4.1 Протоколы определения

адреса: ARP и RARP.</small></p>



<p>&nbsp;</p>



<p><small>ARP предоставляет динамическое

сопоставление IP адресов и соответствующих

аппаратных адресов. Мы используем термин

динамическое, так как это происходит

автоматически и обычно не зависит от

используемых прикладных программ или воли

системного администратора. </small></p>



<p><small>RARP, в основном, используется системами без


жестких дисков (бездисковые рабочие станции или X

терминалы), однако здесь требуется ручная

конфигурация с участием системного

администратора. Мы рассмотрим RARP в <a HREF="glava5.html">главе

5</a>.</small></p>

<font size="3"><u><b>



<p><a NAME="t042000"></a>Пример</p>

</b></u></font>



<p><small>Если мы введем команду</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="1">



<p></font><font FACE="Courier New" size="2">% <b>ftp bsdi</p>

</b></font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>будет выполнена следующая

последовательность действий. (См. рисунок 4.2.)</small></p>



<p><small>&nbsp;</small> 



<ol>

  <li><small>Приложение, FTP клиент, вызывает функцию <a NAME="t042006"></a>gethostbyname(3), чтобы конвертировать имя

    хоста (bsdi) в 32-битный IP адрес. Эта функция в DNS (Domain

    Name System) называется <a NAME="t042002"></a>разборщиком (resolver)

    , мы опишем это подробно в <a HREF="glava14.html">главе 14</a>.

    Подобное преобразование осуществляется с

    использованием DNS или, если существует маленькая

    сеть, то с помощью статического файла хостов (<a NAME="t042003"></a>/etc/hosts).</small></li>

  <li><small>FTP клиент требует установить TCP соединение с

    указанным IP адресом.</small></li>

  <li><small>TCP посылает запрос на установление

    соединения удаленному хосту, посылая IP

    датаграммы по указанному IP адресу. (Мы рассмотрим

    как это делается более подробно в <a HREF="glava18.html">главе

    18</a>.)</small></li>

  <li><small>Если хост назначения подключен к сети (Ethernet,

    Token ring, или к другому концу канала точка-точка), IP

    датаграмма может быть послана непосредственно

    хосту. Если хост назначения находится в

    удаленной сети, IP маршрутизатор определяет Internet

    адрес непосредственно подключенного <a NAME="t042004"></a>маршрутизатора

    следующей пересылки, чтобы послать туда IP

    датаграмму. В обоих случаях IP датаграмма

    посылается либо хосту, либо маршрутизатору,

    подключенные непосредственно к данной сети.</small></li>

  <li><small>Если используется Ethernet, посылающий хост

    должен конвертировать 32-битный адрес в 48-битный

    Ethernet адрес. Или другими словами, осуществить

    преобразование из логического Internet адреса в

    соответствующий физический аппаратный адрес.

    Этим занимается ARP. ARP работает в

    широковещательных сетях, где много хостов или

    маршрутизаторов подключено к одной и той же сети.</small></li>

  <li><small>ARP посылает фрейм Ethernet, который называется ARP

    запрос (ARP request), каждому хосту в сети. Подобный

    метод рассылки называется <a NAME="t042005"></a>широковещательным

    запросом (broadcast). На рисунке 4.2 широковещательный

    запрос показан пунктирными линиями. ARP запрос

    содержит IP адрес хоста назначения (имя которого

    bsdi) и запрос &quot;если Вы владелец этого IP адреса,

    пожалуйста сообщите мне Ваш аппаратный адрес&quot;.<a NAME="t042001"></a></small><p>&nbsp;</p>

    </font><p ALIGN="CENTER"><small><img SRC="t4_2.jpg" WIDTH="476" HEIGHT="636"></small></p>

    <font FACE="Arial"><p ALIGN="CENTER"><small>Рисунок 4.2 Реакция ARP на

    ввод пользователя: ftp hostname.</small></p>

    <p>&nbsp;</p>

  </li>

  <li><small>Хост назначения на ARP уровне получает этот

    широковещательный запрос, определяет, что

    отправитель спрашивает именно его IP адрес, и

    отвечает на него ARP откликом (ARP reply). Этот отклик

    содержит IP адрес и соответствующий аппаратный


    адрес.</small></li>

  <li><small>ARP отклик принимается, и IP датаграмма, из-за

    которой начался обмен ARP запрос - ARP отклик, может

    быть послана.</small></li>

  <li><small>IP датаграмма отправляется на хост

    назначения.</small></li>

</ol>



<p>&nbsp;</p>



<p><small>Фундаментальная концепция, заложенная в ARP,

заключается в следующем. Сетевой интерфейс имеет

аппаратный адрес (48-битное значение для Ethernet или

Token ring). Фреймы, которыми обмениваются на

аппаратном уровне, должны адресоваться к

корректному интерфейсу. Однако TCP/IP испоьзует

собственную схему адрессации: 32-битные IP адреса.

Знание IP адреса хоста не позволяет ядру послать

датаграмму этому хосту. Драйвер Ethernet должен

знать аппаратный адрес пункта назначения, чтобы

послать туда данные. В задачу ARP входит

обеспечение динамического соответствия между

32-битными IP адресами и аппаратными адресами,

используемыми различными сетевыми технологиями.

</small></p>



<p><small>Каналы точка-точка не используют ARP. Когда

эти каналы конфигурируются (обычно во время

загрузки), ядру необходимо сказать IP адрес для

каждого конца канала. Аппаратные адреса, такие

как Ethernet адреса, в данном случае не используются.</small></p>

<font size="3"><u><b>



<p><a NAME="t043000"></a>ARP Кэш</p>

</b></u></font>



<p><small>Эффективность функционирования <a NAME="t043001"></a>ARP

во многом зависит от <a NAME="t043002"></a>ARP кэша (ARP cache),

который присутствует на каждом хосте. В кэше

содержатся Internet адреса и соответствующие им

аппаратные адреса. Стандартное время жизни

каждой записи в кэше составляет 20 минут с момента

создания записи. </small></p>



<p><small>Содержимое ARP кэша можно увидеть с

использованием команды <a NAME="t043003"></a>arp(8). Опция <a NAME="t043004"></a>-a показывает все записи, содержащиеся

в кэше:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="1">



<p></font><font FACE="Courier New" size="2">bsdi % <b>arp -a<br>

</b>sun (140.252.13.33) at 8:0:20:3:f6:42<br>

svr4 (140.252.13.34) at 0:0:c0:c2:9b:26</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>48-битные Ethernet адреса приведены в виде шести

шестнадцатиричных чисел, разделенных

двоеточиями. Дополнительные функции команды arp

обсуждаются в разделе <a HREF="#t048000">&quot;Команда arp&quot;</a>

главы 4.</small></p>

<font size="3"><u><b>



<p><a NAME="t044000"></a>Формат пакета ARP </p>

</b></u></font>



<p><small>На рисунке 4.3 показан формат ARP запроса и

формат ARP отклика, в случае использования Ethernet и IP

адресов. (ARP можно использовать в других сетей,

при этом он способен устанавливать соответствие

не только для IP адресов. Первые четыре поля,

следующие за полем типа фрейма, указывают на типы

и размеры заключительных четырех полей.)<a NAME="t044001"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t4_3.jpg" WIDTH="532" HEIGHT="221"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 4.3 Формат ARP запроса или

отклика при работе с Ethernet.</small></p>



<p>&nbsp;</p>



<p><small>Два первых поля в Ethernet заголовке - поля

источника и назначения Ethernet. Специальный адрес

назначения Ethernet, состоящий из всех единиц,

означает широковещательный адрес. Фреймы с таким

адресом будут получены всеми Ethernet интерфейсами

на кабеле. </small></p>



<p><small><a NAME="t044002"></a>Двухбайтовый тип фрейма (frame type)

Ethernet указывает, данные какого типа, пойдут

следом. Для ARP запроса или ARP отклика это поле

содержит 0x0806. </small></p>



<p><small>Выражения аппаратный (hardware) и протокол

(protocol) используются для описания полей в пакетах

ARP. Например, ARP запрос запрашивает аппаратный

адрес (в данном случае Ethernet адрес)

соответствующий адресу протокола (в данном

случае IP адрес).</small></p>



<p><small>Поле hard type указывает на тип аппаратного


адреса. Для Ethernet это значение равно единице. Prot type

указывает тип адреса протокола, к которому будет

приведено соответствие. Для IP адресов

используется значение 0x0800. По своему целевому

назначению это значение соответствует полю типа

во фрейме Ethernet, который содержит IP датаграмму.

(См. рисунок 2.1.) </small></p>



<p><small>Два следующих однобайтных поля, hard size и prot

size, указывают на размеры в байтах аппаратного

адреса и адреса протокола. В ARP запросах и

откликах они составляют 6 для Ethernet и 4 для IP

адреса.</small></p>



<p><small><a NAME="t044003"></a>Поле op указывает на тип

операции: ARP запрос (значение устанавливается в 1),

ARP отклик (2), RARP запрос (3) и RARP отклик (4). (Мы

поговорим о RARP в <a HREF="glava5.html">главе&nbsp;5</a>.) Это поле

необходимо, так как <a NAME="t044004"></a>поля типа фрейма

(frame type) одинаковы для ARP запроса и ARP отклика. </small></p>



<p><small>Следующие четыре поля: <a NAME="t044005"></a>аппаратный

адрес отправителя (Ethernet адрес в данном примере), <a NAME="t044006"></a>адрес протокола (IP адрес), аппаратный

адрес назначения и адрес протокола назначения.

Обратите внимание, что в данном случае

происходит некоторое дублирование информации:

аппаратный адрес отправителя может быть получен

как из Ethernet заголовка, так и из ARP запроса. </small></p>



<p><small>Для ARP запроса все поля заполнены, за

исключением аппаратного адреса назначения.

Когда система получает ARP запрос, который

предназначается ей, она вставляет свой

аппаратный адрес, меняет местами адреса

источника и назначения, устанавливает поле op в

значение 2 и отправляет отклик. </small></p>

<font size="3"><u><b>



<p><a NAME="t045000"></a>Примеры ARP</p>

</b></u></font>



<p><small>В этом разделе мы воспользуемся командой <a NAME="t045010"></a>tcpdump, чтобы посмотреть, как в

действительности работает ARP при запуске

обычного TCP приложения, например, Telnet. В <a HREF="glavaA.htm">приложении А</a> содержится

дополнительная информация о работе программы

tcpdump. </small></p>

<font size="3"><i><b>



<p><a NAME="t045002"></a>Типичный пример</p>

</b></i></font>



<p><small>Чтобы посмотреть как функционирует ARP, мы

запустим команду <a NAME="t045003"></a>telnet, чтобы

подсоединиться к discard (discard server - сервер, не

предоставляющий пользователю никаких услуг)

серверу. </small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>bsdi% <b>arp -a </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; проверяем,

что ARP кэш пуст<br>

bsdi% <b>telnet svr4 discard </b>&nbsp;&nbsp;&nbsp; подсоединяемся к

серверу<br>

Trying 140.252.13.34 ...<br>

Connected to svr4.<br>

Escape character is '^]' .<br>

<b>^] </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; нажимаем

Control и правую квадратную скобку,<br>

telnet&gt; <b>quit </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; чтобы

получить приглашение Telnet и закрыть сессию<br>

Connection closed.<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Пока осуществляются эти действия, мы

запускаем команду tcpdump с опцией <a NAME="t045004"></a>-e на

другом хосте (sun). Это позволит нам посмотреть


аппаратные адреса (48-битные адреса Ethernet).<a NAME="t045005"></a></small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>1 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0:0:c0:6f:2d:40

ff:ff:ff:ff:ff:ff arp 60: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp

who-has svr4 tell bsdi<br>

2 0.002174 (0.0022)&nbsp; 0:0:c0:c2:9b:26 0:0:c0:6f:2d:40 arp 60: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp

reply svr4 is-at 0:0:c0:c2:9b:26<br>

3 0.002831 (0.0007)&nbsp; 0:0:c0:6f:2d:40 0:0:c0:c2:9b:26 ip 60: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1030&gt;svr4.discard:

S 596459521:596459521 (0) <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win

4096 &lt;mss 1024&gt; [tos 0x10]<br>

4 0.007834 (0.0050)&nbsp; 0:0:c0:c2:9b:26 0:0:c0:6f:2d:40 ip 60: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.discard&gt;bsdi.1030:

S 3562228252:3562228252 (0) <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack

596459522 win 4096 &lt;mss 1024&gt;<br>

5 0.009615 (0.0018)&nbsp; 0:0:c0:6f:2d:40 0:0:c0:c2:9b:26 ip 60: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1030&gt;svr4.discard:

. ack 1 win 4096 [tos 0x10]<br>

</p>

</font><font FACE="Arial">



<p><small>Рисунок 4.4 ARP запрос и ARP отклик,

сгенерированные при запросе на Telnet соединение.</small></p>



<p>&nbsp;</p>



<p><small>На <a HREF="glavaA.html#t314001">рисунке А.3</a> в

приложении А показан реальный вывод команды <a NAME="t045006"></a>tcpdump, которую мы запустили на рисунке

4.4. Так как это первый пример вывода tcpdump в тексте,

Вам стоит посмотреть приложение, чтобы увидеть

как мы преобразовали вывод, чтобы он стал более

красивым и читаемым. </small></p>



<p><small>Мы удалили 4 заключительные строки из

вывода tcpdump, которые соответствуют разрыву

соединения (более подробно рассматривается в <a HREF="glava18.html">главе 18</a>), так как они не имеют

отношения к нашему обсуждению. </small></p>



<p><small>В строке 1 приводится аппаратный адрес

источника (bsdi), в данном случае - 0:0:c0:6f:2d:40.

Аппаратный адрес назначения ff:ff:ff:ff:ff:ff,

являющийся широковещательным адресом Ethernet.

Каждый Ethernet интерфейс на кабеле получит фрейм и

обработает его, как показано на рисунке 4.2. </small></p>



<p><small>Следующее поле вывода в строке 1, arp,

означает, что тип фрейма (frame type) установлен в 0x0806,

что означает либо ARP запрос, либо ARP отклик. </small></p>



<p><small>Значение 60, напечатанное после слов arp и ip, в

каждой из 5 строк означает длину фрейма Ethernet. Так

как размер ARP запроса и ARP отклика составляет 42

байта (28 байт - ARP сообщение, 14 байт - Ethernet

заголовок), каждый фрейм дополняется до минимума

Ethernet: 60 байт. </small></p>



<p><small>Если обратиться к рисунку 1.7, то можно

увидеть, что минимальный размер (60 байт) включает

в себя 14-байтный Ethernet заголовок, однако не

включает 4-байтный Ethernet завершитель. В некоторых

книгах минимум приводится как 64 байта, что

включает в себя и Ethernet завершитель. Мы

целенаправленно не включили 14 байт заголовка

Ethernet в минимум из 46 байт, показанных на рисунке 1.7.

Максимальный размер составляет 1500 байт. Обычно

эта величина называется максимальный блок

передачи (MTU - maximum transmission unit) (См. рисунок 2.5). Мы

часто используем понятие MTU, потому что оно

ограничивает размер IP датаграммы, однако оно

никак не связано с минимальным размером.

Большинство драйверов устройств или

интерфейсных плат автоматически дополняют Ethernet

фреймы до минимального размера. IP датаграммы в

строках 3, 4 и 5 (содержащие TCP сегменты) меньше чем

минимум и также будут дополнены до 60 байт. </small></p>



<p><small>Следующее поле в строке 1, &quot;arp кто имеет&quot;

(arp who-has), идентифицирует фрейм как ARP запрос с IP

адресом svr4 в качестве адреса назначения и IP

адресом bsdi в качестве адреса отправителя. tcpdump по

умолчанию приводит имена хостов соответствующие

IP адресам. (В разделе <a HREF="#t047000">&quot;Беспричинный

ARP&quot;</a> мы воспользуемся опцией <a NAME="t045007"></a>-n,

чтобы посмотреть реальные IP адреса в ARP запросе.) </small></p>



<p><small>В строке 2 мы видим, что ARP запрос

распространяется как широковещательный, тогда

как адрес назначения ARP отклика это адрес bsdi

(0:0:c0:6f:2d:40). ARP отклик посылается непосредственно

запрашивающему хосту; он не является

широковещательным. </small></p>



<p><small><a NAME="t045008"></a>tcpdump печатает для этого фрейма

arp reply вместе с именем хоста и аппаратным адресом

отвечающего. </small></p>



<p><small>В строке 3 отправляется первый TCP сегмент,

содержащий требование об установлении

соединения. Аппаратный адрес назначения это

адрес хоста назначения (svr4). Мы рассмотрим этот

сегмент более подробно в <a HREF="glava18.htm">главе 18</a>. </small></p>



<p><small>Число, которое печатается в каждой строке,

после номера строки - это время (в секундах) когда

пакет был принят программой tcpdump. В каждой строке

после первой содержится разница во времени (в

секундах) с предыдущей строкой. Это значение

приводится в скобках. Как видно из рисунка, время

между отправкой ARP запроса и получением ARP

отклика составляет 2,2 мс. Первый TCP сегмент послан

через 0,7 мс после этого. Таким образом, для

динамического определения адреса с

использованием ARP, в данном примере,

потребовалось менее чем 3 мс. </small></p>



<p><small>И последнее на что следует обратить

внимание в выводе tcpdump: мы не увидим ARP запрос от

svr4, когда он посылает свой первый TCP сегмент

(строка&nbsp;4). Дело в том, что svr4 уже имеет данные о

bsdi в своем ARP кэше, так как, когда система получает

ARP запрос, помимо того что она посылает ARP отклик,

она также сохраняет аппаратный адрес и IP адрес

запросившего в своем ARP кэше. Это логично, так как

если запросивший собирается послать IP

датаграмму, то получившему скорее всего придется

отправить ответ на эту датаграмму.</small></p>

<font size="3"><i><b>



<p><a NAME="t045009"></a>ARP запрос на несуществующий хост</p>

</b></i></font>



<p><small>Что произойдет, если запрашиваемый хост

выключен или не существует вообще? Попробуем

указать несуществующий Internet адрес -

идентификатор сети и идентификатор подсети

будет от нашего локального Ethernet, однако

указанного идентификатора хоста не существует.

На рисунке 3.10 мы видели, что идентификаторов

хостов с 36-го по 62-ой не существуют (идентификатор

хоста 63 - широковещательный адрес). В данном

примере мы будем использовать идентификатор

хоста 36.<a NAME="t045001"></a></small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>в этот раз telnet на IP адрес, а не на имя хоста (hostname)<br>

bsdi % <b>date ; telnet 140.252.13.36 ; date</b><br>

Sat Jan 30 06:46:33 MST 1993<br>

Trying 140.252.13.36 ...<br>

telnet: Unable to connect to remote host : Connection timed out<br>

Sat Jan 30 06:47:49 MST 1993

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; прошло 76

секунд<br>


<br>

bsdi % <b>arp -a </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; проверяем


ARP кэш<br>

? (140.252.13.36) at (incomplete)<br>

</p>

</font><font FACE="Arial">



<p><small>На рисунке 4.5 мы видим вывод tcpdump. </small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>1&nbsp; 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp

who-has 140.252.13.36 tell bsdi<br>

2&nbsp; 5.509069 ( 5.5091)&nbsp; arp who-has 140.252.13.36 tell bsdi<br>

3 29.509745 (24.0007)&nbsp; arp who-has 140.252.13.36 tell bsdi<br>

</p>


</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Рисунок 4.5 ARP запрос на несуществующий хост.</small></p>



<p>&nbsp;</p>



<p><small>Сейчас мы не указываем опцию -e, так как мы

уже знаем, что ARP запрос широковещательный. </small></p>



<p><small>Здесь интересно посмотреть, с какой

частотой рассылаются ARP запросы: 5,5 секунд после

первого запроса и снова через 24 секунды. (Мы

рассмотрим тайм-ауты TCP и алгоритм повторных

передач более подробно в <a HREF="glava21.htm">главе 21</a>.)

Полное время, показанное в выводе tcpdump,

составляет 29,5 секунды. Однако вывод от команды <a NAME="t045011"></a>date перед и после команды <a NAME="t045012"></a>telnet

показывает, что запрос на соединение от Telnet

клиента длился в течении 75 секунд. И

действительно, мы увидим позже, что большинство

BSD реализаций устанавливают ограничение в 75

секунд для завершения запроса на установление TCP

соединения. </small></p>



<p><small>В <a HREF="glava18.htm">главе 18</a>, при рассмотрении

последовательности TCP сегментов, которые

посылаются в процессе установления соединения,

мы увидим, что моменты отправки ARP запросов

полностью совпадают с отправкой сегментов TCP SYN. </small></p>



<p><small>Обратите внимание на то, что в кабеле мы

никогда не увидим TCP сегменты. Все что мы можем

увидеть это ARP запросы. Пока не получен ARP отклик,

TCP сегменты не могут быть отправлены, так как

неизвестен аппаратный адрес назначения. Если

запустить <a NAME="t045013"></a>tcpdump</font> <font FACE="Arial">в

фильтрующем режиме, чтобы увидеть только данные

TCP, вывода не будет вообще. </small></p>

<font size="3"><i><b>



<p>Тайм-аут ARP кэша</p>

</b></i></font>



<p><small>Для записей, вводимых в ARP кэш, обычно

устанавливается тайм-аут. (В разделе <a HREF="#t048000">&quot;Команда

arp&quot;</a> мы увидим, что команда <a NAME="t045014"></a>arp</font> <font FACE="Arial">позволяет системному администратору

поместить в кэш определенную запись, и на нее

тайм-аут распространяться не будет.) Реализации,

произошедшие от Berkeley, обычно установливают

тайм-аут, в 20 минут для завершенной записи и 3

минуты для незавершенной записи. (Мы видели

незавершенную запись в предыдущем примере, когда

заставили отправить ARP запрос на несуществующий

хост.) Эти реализации обычно перестартовывают

20-минутный тайм-аут для записи каждый раз, когда

эта запись используется.</small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">Требования к хостам <a NAME="t045015"></a>Host Requirements RFC говорит, что запись должна

удаляться по тайм-ауту, даже если данная запись

используется, однако большинство реализаций,

произошедших от Berkeley, не делают этого - они

перестартовывают тайм-аут каждый раз, когда

происходит обращение к записи.</font></p>

</font>



<p><small><a NAME="t046000"></a>&nbsp;</small></p>

<font size="3"><u><b>



<p>Уполномоченный агент ARP</p>

</b></u></font>



<p><small>Уполномоченный агент ARP позволяет

маршрутизатору отвечать на ARP запросы в одну

сеть, в то время как запрашиваемый хост находится

в другой сети. С помощью этого средства

происходит обман отправителя, который отправил

ARP запрос, после чего он думает, что маршрутизатор

является хостом назначения, тогда как в

действительности хост назначения находится

&quot;на другой стороне&quot; маршрутизатора.


Маршрутизатор выступает в роли уполномоченного

агента хоста назначения, перекладывая пакеты от

другого хоста. </small></p>



<p><small>Для того чтобы лучше описать работу

уполномоченных агентов ARP, мы рассмотрим пример.

Из рисунка 3.10 видно, что система sun подключена к

двум сетям Ethernet. Однако в действительности это не

так, в чем можно убедиться, если сравнить этот

рисунок с рисунком, который приведен на

внутренней стороне обложки. Между sun и подсетью

140.252.1 находится маршрутизатор, который выступает


в роли уполномоченного агента ARP, при этом все

выглядело так, как будто sun находится в подсети

140.252.1. На рисунке 4.6 показано, что Telebit NetBlazer,

названный netb, находится между подсетью и хостом

sun.<a NAME="t046001"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t4_6.jpg" WIDTH="517" HEIGHT="307"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 4.6 Пример уполномоченного

ARP.</small></p>




<p>&nbsp;</p>



<p><small>Когда какой-либо другой хост в подсети 140.252.1

(скажем, gemini) хочет послать IP датаграмму хосту sun

на адрес 140.252.1.29, gemini сравнивает идентификатор

сети (140.252) и идентификатор подсети (1), и если они

идентичны, отправляет ARP запрос в верхний Ethernet (на

рисунке 4.6) на IP адрес 140.252.1.29. Маршрутизатор netb

распознает этот IP адрес как принадлежащий одному

из dialup хостов и отвечает, отправив аппаратный

адрес этого Ethernet интерфейса в кабель 140.252.1. Хост

gemini</font> <font FACE="Arial">посылает IP датаграмму в netb по

Ethernet, а netb направляет датаграмму в sun по SLIP

каналам с дозвоном (dialup). Это делает его

прозрачным для всех хостов подсети 140.252.1, так как

хост sun действительно находится &quot;позади&quot;

маршрутизатора netb. </small></p>



<p><small>Если мы запустим команду arp на хосте gemini

после общения с хостом sun, то увидим, что оба эти

адреса принадлежат подсети 140.252.1 (netb и sun) и что им

соответствует один аппаратный адрес. Как

правило, это основная причина, по которой

используется уполномоченный агент ARP.</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>gemini % <b>arp -a</b><br>

появится много строк про хосты из подсети 140.252.1<br>

netb (140.252.1.183) at 0:80:ad:3:6a:80<br>

sun (140.252.1.29) at 0:80:ad:3:6a:80<br>

</p>



<p>&nbsp;</p>

</font><font FACE="Arial">



<p><small>Еще одна деталь на рисунке 4.6, которую

необходимо объяснить, это отсутствие IP адреса

под квадратиком, который обозначает

маршрутизатор netb (SLIP канал). Почему на обоих

концах SLIP канала нет IP адреса, как между bsdi и slip? В

разделе <a HREF="glava3.html#t038000">&quot;Команда ifconfig&quot;</a>

главы 3, из вывода команды <a NAME="t046002"></a>ifconfig, мы

заметили, что адрес назначения SLIP канала 140.252.1.183.

NetBlazer не требует наличия IP адресов на каждом

конце SLIP канала. (Это позволяет сэкономить

несколько столь ценных в настоящее время IP

адресов.) Он определяет какой хост посылает пакет

в зависимости от того по какому

последовательному интерфейсу прибыл пакет,

поэтому нет необходимости каждому хосту на SLIP

канале использовать уникальный IP адрес для

своего канала с маршрутизатором. Все dialup хосты

используют адрес 140.252.1.183 в качестве адреса

назначения для своих SLIP каналов. </small></p>



<p><small><a NAME="t046003"></a>Уполномоченный агент ARP

обеспечивает доставку датаграмм к

маршрутизатору sun, однако как это делают другие

хосты из подсети 140.252.13? Для направления

датаграмм в другие хосты должна использоваться

маршрутизация. Где-либо в сети 140.252 должны быть

сделаны записи в таблице маршрутизации, поэтому

все датаграммы, направляющиеся в подсеть 140.252.13

или в указанные хосты этой подсети, будут

направляться на маршрутизатор netb. Этот

маршрутизатор знает, как доставить датаграммы в

их конечный пункт назначения, отправляя их через

маршрутизатор sun. </small></p>



<p><small>Уполномоченный агент ARP также называется <a NAME="t046004"></a>смешанным (promiscuous ARP) или <a NAME="t046005"></a>расщепленным

(ARP hack). Эти имена появились благодаря другому

использованию уполномоченных агентов ARP: они

применялись для того, чтобы спрятать друг от

друга две физические сети между которыми

находился маршрутизатор. В этом случае обе

физические сети использовали один и тот же

идентификатор сети, так как маршрутизатор,

находящийся между ними, был сконфигурирован как

уполномоченный ARP агент, чтобы отвечать на ARP

запросы из одной сети к хостам в другой сети. Эта

техника использовалась в прошлом, чтобы спрятать

группу хостов с более старой версией TCP/IP на

отдельном физическом кабеле. Две причины, по

которым приходилось отделять эти

&quot;устаревшие&quot; хосты, заключались в том, что,

во-первых, они не могли поддерживать разделение

на подсети и, во-вторых, использовали старые

широковещательные адреса (идентификатор хоста

состоял из всех нулевых бит вместо современного

стандарта, при котором идентификатор хоста

состоит из единичных битов). </small></p>

<font size="3"><u><b>



<p><a NAME="t047000"></a>&quot;Беспричинный&quot; ARP </p>

</b></u></font>



<p><small>Другая характеристика ARP, которую стоит

рассмотреть - &quot;беспричинный&quot; ARP (gratuitous ARP). Он

проявляется, когда хост посылает ARP запрос,

основываясь на собственном IP адресе. Обычно это

делается, когда интерфейс конфигурируется во

время загрузки. </small></p>



<p><small>Если мы запустим <a NAME="t047001"></a>tcpdump на хосте sun

при загрузке хоста bsdi, то увидим пакет,

показанный на рисунке 4.7.<a NAME="t047002"></a></small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>1&nbsp; 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0:0:c0:6f:2d:40

ff:ff:ff:ff:ff:ff arp 60: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp

who-has 140.252.13.35 tell 140.252.13.35<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Рисунок 4.7 Пример &quot;беспричинного&quot; ARP.</small></p>



<p>&nbsp;</p>



<p><small>(Мы использовали флаг <a NAME="t047003"></a>-n

программы tcpdump, чтобы напечатать адреса в

цифровом десятичном виде вместо имен хостов.) В

терминах полей ARP запроса, адрес протокола

отправителя и адрес протокола назначения

идентичны: 140.252.13.35 (что соответствует хосту bsdi).

Адрес источника в заголовке Ethernet, 0:0:c0:6f:2d:40 как

показано программой tcpdump, эквивалентен

аппаратному адресу отправителя (из рисунка 4.4). </small></p>



<p><small>&quot;Беспричинный&quot; ARP предоставляет две

характеристики.</small> 



<ol>

  <li><small>Он позволяет хосту определить, существует

    ли другой хост с тем же самым IP адресом. Хост bsdi не

    ожидает отклика на свой запрос, однако если

    отклик принят, на консоли возникает сообщение об

    ошибке &quot;обнаружен дублирующий IP адрес с Ethernet

    адресом: a:b:c:d:e:f&quot;. Это предупреждение

    системному администратору о том, что одна из

    систем неправильно сконфигурирована.</small></li>

  <li><small>Если хост, посылающий &quot;беспричинный&quot; ARP,

    только что изменил свой аппаратный адрес (может

    быть потому, что хост был выключен, удалена

    интерфейсная плата и затем хост был

    перезагружен), этот пакет заставляет другой хост

    на кабеле, который имеет запись в своем кэше для

    старого аппаратного адреса, обновить ARP кэш

    соответствующим образом. Малоизвестный факт о

    протоколе ARP [Plummer 1982] заключается в том, что если

    хост получает ARP запрос для IP адреса, который он

    уже имеет в кэше, содержимое кэша обновляется

    аппаратным адресом отправителя (Ethernet адресом) из

    запроса ARP. Это делается для любого запроса ARP,

    полученного хостом. (Повторим, что ARP запросы

    широковещательные, поэтому такие действия

    осуществляются всеми хостами в сети каждый раз

    при появлении ARP запроса.) <a NAME="t047004"></a>[Bhide, Elnozahy, and

    Morgan 1991] описывает приложения, которые используют

    эту характеристику ARP. Она позволяет запасному

    (backup) файл-серверу занять место вышедшего из

    строя сервера с использованием

    &quot;беспричинного&quot; ARP запроса с запасным

    аппаратным адресом, однако с тем же IP адресом,

    который имел вышедший из строя хост. При этом все

    пакеты, направляемые серверу, вышедшему из строя,

    будут посланы на запасной сервер, а

    пользовательские приложения не будут знать о

    том, что основной сервер вышел из строя.</small></li>

</ol>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">К сожалению, авторы

затем отказались от этого подхода, так как он

зависит от корректности реализации ARP на всех

типах клиентов. Существуют различные типы ARP,

которые не поддерживают эту спецификацию.</font></p>



<p><font color="#0000A0">Наблюдения за всеми системами в

подсети, используемой в этой книге, показывает,

что <a NAME="t047005"></a>SunOS&nbsp;4.1.3 и <a NAME="t047006"></a>4.4BSD

используют &quot;беспричинный&quot; ARP при загрузке, а <a NAME="t047007"></a>SVR4 не поддерживает эту характеристику.</font></p>

</font>



<p><small><a NAME="t048000"></a>&nbsp;</small></p>

<font size="3"><u><b>



<p>Команда arp</p>

</b></u></font>



<p><small>Мы использовали эту команду с флагом <a NAME="t048001"></a>-a, чтобы отобразить все записи ARP кэша.

Существуют и другие опции. </small></p>



<p><small>Суперпользователь может использовать

опцию <a NAME="t048002"></a>-d, чтобы удалить запись из ARP

кэша. (Это было сделано перед запуском некоторых

примеров, чтобы показать изменения ARP.) </small></p>



<p><small>Записи могут быть добавлены с

использованием опции <a NAME="t048003"></a>-s. При

использовании этой опции необходимо указать имя

хоста и Ethernet адрес, IP адрес, соответствующий

имени хоста, и Ethernet адрес добавляются в кэш.

Подобная запись делается на постоянной основе

(она не будет удалена из кэша по тайм-ауту), если

только в конце командной строки не будет

использовано ключевое слово temp. </small></p>



<p><small>Ключевое слово pub</font> <font FACE="Arial">в конце

командной строки с опцией -s приведет к тому, что

система будет функционировать как ARP агент для

этого хоста. Система будет отвечать на ARP запросы

для IP адресов, соответствующих имени хоста, при

этом ответ будет содержать указанный Ethernet адрес.

Если объявленный адрес это адрес самой

отвечающей системы, это означает, что система

работает как уполномоченный агент ARP для

указанного имени хоста.</small></p>

<font size="3"><u><b>




<p><a NAME="t049000"></a>Краткие выводы</p>

</b></u></font>



<p><small>ARP это основной протокол, который

используется практически во всех реализациях

TCP/IP. Обычно его функционирование не зависит от

используемых приложений или воли системного

администратора. <a NAME="t049001"></a>ARP кэш является

фундаментом этой работы. Мы использовали команду

arp, чтобы просмотреть или модифицировать кэш.

Каждая запись в кэше имеет таймер, который

используется для удаления незавершенных или

завершенных записей. Команда arp отображает

модифицированные записи в ARP кэше. </small></p>



<p><small>Мы посмотрели обычное функционирование ARP и

специализированные версии: уполномоченный агент

ARP (когда маршрутизатор отвечает на ARP запросы для

хостов, находящихся на другом интерфейсе

маршрутизатора) и &quot;беспричинный&quot; ARP

(посылающий ARP запросы для своего собственного IP

адреса, обычно во время загрузки).</small></p>

<font size="3"><i><b>



<p>Упражнения</b></i></font></font><font size="1" FACE="Arial"> 



<ol>

  <li></font><font FACE="Arial" size="2">Вернемся к команде, которую

    мы исполнили, чтобы получить вывод, показанный на

    рисунке 4.4. Что произойдет, если после того как мы

    проверили локальный ARP кэш и он оказался пустым,

    мы введем команду</font><font FACE="Courier New" size="2"><p>bsdi % <a NAME="t049002"></a><b>rsh svr4 arp -a</p>

    </b></font><font FACE="Arial" size="2"><p>чтобы проверить, что ARP кэш

    также пуст на хосте назначения? (Эта команда

    исполнит команду arp -a на хосте svr4.)</p>

  </li>

  <li>Опишите тест, который позволит определить,

    корректно ли обрабатывает определенный хост

    &quot;беспричинные&quot; ARP запросы.</li>

  <li>Шаг номер 7 в разделе <a HREF="#t042000">&quot;Пример&quot;</a>

    может занять определенное время (миллисекунды),

    потому что пакет отправлен и ARP ожидает ответа.

    Как Вы думаете, обработает ли ARP несколько

    датаграмм, которые прибыли от IP на тот же адрес

    назначения в течение этого периода времени?</li>

  <li>В конце раздела <a HREF="#t045000">&quot;Примеры ARP&quot;</a> мы

    упомянули, что <a NAME="t049003"></a>RFC Host Requirements и Berkeley

    реализации отличаются с точки зрения обработки

    тайм-аутов для активных записей ARP. Что

    произойдет, если клиент Berkeley постарается

    установить контакт с сервером, который был

    выключен и из него была удалена плата Ethernet?

    Изменится ли что-нибудь, если сервер выдаст

    &quot;беспричинный&quot; ARP запрос при загрузке?</font><font size="1" FACE="Arial"></li>

</ol>

</font>



<p><small><a HREF="index.html"><img SRC="contents.jpg" BORDER="0" WIDTH="94" HEIGHT="20"></a><a HREF="../home.htm"><img SRC="begin.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava5.html"><img SRC="forward.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava3.html"><img SRC="back_b.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a href="index.html"><img SRC="index.jpg" border="0" WIDTH="68" HEIGHT="20"></a></small></p>

<font size="1">



<p>&nbsp;</p>

</font>
</div>
</body>

</html>

