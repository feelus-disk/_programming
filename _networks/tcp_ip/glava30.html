<html>
<head>
<title>Другие приложения TCP/IP</title>
</head>

<body>
<div>


<p><small><a HREF="index.html"><img SRC="contents.jpg" BORDER="0" WIDTH="94" HEIGHT="20"></a><a HREF="../home.htm"><img SRC="begin.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glavaA.html"><img SRC="forward.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava29.html"><img SRC="back_b.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><img SRC="index.jpg" WIDTH="68" HEIGHT="20"></small></p>

<b><font FACE="Arial" SIZE="4">



<p><a NAME="t300000"></a>Глава 30 Другие приложения TCP/IP</p>

</font><font FACE="Arial"><font size="3"><u>



<p><a NAME="t301000"></a>Введение</p>

</u></font></b>



<p><small>В этой главе мы опишем приложения TCP/IP,

которые присутствуют почти во всех реализациях.

Некоторые из них просты и их можно описать

целиком (Finger и Whois), тогда как другие достаточно

сложны (X Window System). Сложные приложения мы

рассмотрим, не вдаваясь в подробности, фокусируя

свое внимание на то, как они используют протоколы

TCP/IP. </small></p>



<p><small>В дополнение, мы приведем обзор некоторых

средств <a NAME="t301001"></a>Internet, которые позволяют

определить ресурсы. Это средства, которые

помогают нам ориентироваться в Internet, искать

отдельные пункты, точное положение которых и

точные имена которых не известны.</small></p>

<font size="3"><u><b>



<p><a NAME="t302000"></a>Протокол Finger</p>

</b></u></font>



<p><small>Протокол Finger возвращает информацию об

одном или нескольких пользователях на указанном

хосте. Это приложение обычно используется, для

того чтобы посмотреть, находится ли конкретный

пользователь в настоящее время в системе, или

чтобы получить имя какого-либо пользователя,

чтобы послать ему почту. RFC 1288 [<a NAME="t302001"></a>Zimmerman

1991] описывает этот протокол. </small></p>



<p><small>Многие узлы не запускают Finger сервер по двум


причинам. Во-первых, ошибки в программировании в

ранних версиях сервера были одной из точек входа <a NAME="t302002"></a>&quot;червяка&quot; в Internet в 1988 году. (RFC 1135 [<a NAME="t302003"></a>Reynolds 1989] и [<a NAME="t302004"></a>Curry 1992] описывают

этого &quot;червяка&quot; более подробно.) Во-вторых,

протокол Finger может предоставить подробную

информацию о пользователях (login имя, телефонные

номера, время последнего логирования и так

далее), а эту информацию большинство

администраторов считают частной. Раздел 3 RFC 1288

детально описывает аспекты секретности,

соответствующие сервису Finger. </small></p>



<p><small>Сервер Finger использует заранее известный

порт 79. Клиент осуществляет активное открытие на

этот порт и отправляет запрос длиной в 1 строку.

Сервер обрабатывает запрос, посылает назад вывод

и закрывает соединение. Запрос и отклик в формате

<a NAME="t302005"></a>NVT ASCII, почти так же как мы видели в

случае FTP и SMTP. </small></p>




<p><small>Обычно большинство пользователей Unix

получают доступ к серверу Finger с использованием

клиента finger(1), однако мы воспользуемся Telnet

клиентом, подсоединимся непосредственно к

серверу и рассмотрим команды, которые выдаются

клиентом (команды длиной в 1 строку). Если запрос

клиента состоит из пустой строки (которая в NVT ASCII

передается как CR, за которой следует LF), это

воспринимается как запрос на информацию о всех

текущих пользователях.</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p><br>

sun % <b>telnet slip finger </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; первые

три строки - вывод Telnet клиента<br>

Trying 140.252.13.65 ...<br>

Connected to slip.<br>

Escape character is '^]'.<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; здесь

вводим RETURN в качестве команды клиента Finger<br>

Login&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tty

&nbsp;&nbsp;&nbsp; Idle&nbsp;&nbsp;&nbsp; Login Time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Office

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Office Phone<br>

rstevens&nbsp;&nbsp;&nbsp; Richard Stevens&nbsp;&nbsp;&nbsp; *c0&nbsp;&nbsp;&nbsp; 45

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Jul 31 09:13<br>

rstevens&nbsp;&nbsp;&nbsp; Richard Stevens&nbsp;&nbsp;&nbsp; *c2&nbsp;&nbsp;&nbsp; 45

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Aug 5 09:41<br>

Connection closed by foreign host.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вывод Telnet

клиента<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Пустые поля с названием офиса и рабочего

телефона взяты из необязательных полей в файле

пользовательских паролей (которые в данном

случае отсутствуют). </small></p>



<p><small>Сервер на своей стороне осуществляет

активное закрытие, при этом сервер возвращает

переменное количество информации, а получение

клиентом метки конца файла оповещает клиента о

том, что вывод завершен. </small></p>



<p><small>Когда в запросе клиента содержится имя

пользователя, сервер выдает информацию только об

этом пользователе. Здесь приведен еще один

пример, вывод Telnet клиента удален:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p><br>

sun % <b>telnet vangogh.cs.berkeley.edu finger<br>

rstevens </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; это

клиент, о котором мы хотим узнать<br>

Login: rstevens

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name:

Richard Stevens<br>

Directory: /a/guest/rstevens

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shell:

/bin/csh<br>

Last login Thu Aug 5 09:55 (PDT) on ttyq2 from sun.tuc.noao.edu<br>

Mail forwarded to: rstevens@noao.edu<br>

No Plan.<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Когда Finger сервис отключен, клиент, в ответ

на активное открытие, получает от сервера RST, так

как никакой из процессов не осуществил пассивное

открытие на порт 79:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="1">



<p></font><font FACE="Courier New" size="2">sun % <b>finger @svr4<br>

</b>[svr4.tuc.noao.edu] connect: Connection refused</font><font FACE="Arial">&nbsp;</p>



<p>&nbsp;</p>



<p><small>Некоторые узлы предоставляют определенный

сервис на порт 79, однако они просто сообщают

информацию, не обращая внимание на клиентские

запросы:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p><br>

sun % <b>finger @att.com</b><br>

[att.com]

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; это

строка вывода от Finger клиента; все остальное от

сервера<br>

------------------------------------------------------------<br>

There are no user accounts on the AT&amp;T Internet gateway.<br>

To send email to an AT&amp;T employee, send email to their name<br>

separated by periods at att.com. If the employee has an email<br>

address registered in the employee database, they will receive<br>

email - otherwise, you'll receive a non-delivery notice.<br>

For example: John.Q.Public@att.com<sup>1</sup><br>

<br>

sun % <b>finger clinton@whitehouse.gov</b><br>

[whitehouse.gov]<br>

<br>

Finger service for arbitrary addresses on whitehouse.gov is not<br>

supported. If you wish to send electronic mail, valid addresses are<br>

&quot;PRESIDENT@WHITEHOUSE.GOV&quot;, and &quot;VICE-PRESIDENT@WHITEHOUSE.GOV&quot;<sup>2</sup>.<br>

</p>

</font><font FACE="Arial">



<p><small>&nbsp;</small></font><font size="1" FACE="Arial"> 



<ol>

  <li></font><font FACE="Arial" size="2">На Internet маршрутизаторе фирмы

    AT&amp;T нет пользовательских бюджетов. Чтобы

    послать электронную почту работникам AT&amp;T,

    отправьте ее на имя работника, отделенного

    точкой от имени att.com</font><font FACE="Futuris,Times New Roman" size="2">.</font><font FACE="Arial" size="2"> Если работник имеет адрес

    электронной почты - он ее получит, иначе Вы

    получите сообщение о недоставке почты. Например,

    John.Q.Public@att.com.</li>

  <li>Сервис Finger не поддерживается для адреса whitehouse.gov</font><font FACE="Futuris,Times New Roman" size="2">.</font><font FACE="Arial"><font size="2">

    Если Вам необходимо послать электронную почту,

    самые подходящие адреса это &quot;PRESIDENT@WHITEHOUSE.GOV&quot;

    и &quot;VICE-PRESIDENT@WHITEHOUSE.GOV&quot;.</font><font size="1"></li>

</ol>

</font>



<p>&nbsp;</p>



<p><small>Существует возможность организовать

брандмауэр (<a NAME="t302006"></a>firewall gateway). Маршрутизатор

между организацией и Internet, который фильтрует

конкретные IP датаграммы. (<a NAME="t302007"></a>[Cheswick and

Bellovin 1994] описывает брандмауэры более подробно.)

Брандмауэр может быть сконфигурирован таким

образом, чтобы отбрасывать входящие датаграммы,

которые содержат TCP сегменты на порт 79. В этом

случае Finger клиент прекратит работу по тайм-ауту

примерно через 75 секунд. </small></p>



<p><small>У Finger сервера и Unix клиента finger существуют

набор опций. Обратитесь к RFC 1288 и к страницам

помощи по finger(1) за более подробной информацией.</small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">RFC 1288 заявляет, что

машины с TCP/IP соединениями, которые предоставляют

сервер Finger, должны отвечать на запрос клиента

содержащий пустую строку, списком всех пунктов,

доступных в настоящий момент. Они должны

отвечать на запрос клиента содержащий имя,

счетчиком или списком доступных пунктов для

этого продукта.</font></p>

</font>



<p><small><a NAME="t303000"></a>&nbsp;</small></p>

<font size="3"><u><b>



<p>Протокол Whois</p>

</b></u></font>



<p><small>Протокол Whois это еще один информационный

сервис. Несмотря на то, что любой узел может

предоставить Whois сервис, наиболее широко

используется <a NAME="t303001"></a>InterNIC, <a NAME="t303002"></a>rs.internic.net.

Этот сервер содержит информацию о всех

зарегистрированных DNS доменах и о большинстве

системных администраторов, которые ответственны

за системы, подключенные к Internet. (Еще один

подобный сервер <a NAME="t303003"></a>nic.ddn.mil содержит

информацию о сети <a NAME="t303004"></a>MILNET.) К сожалению,

не всегда предоставляется полная информация. RFC

954 <a NAME="t303005"></a>[Harrenstein, Stahl, and Feinler 1985]

документирует сервис Whois. </small></p>



<p><small>С точки зрения протокола, сервер Whois

работает с заранее известным портом TCP 43. Он

принимает от клиента запрос на соединение, после

чего клиент отправляет на сервер запрос длиной в

1 строку. Сервер выдает информацию и закрывает

соединение. Запросы и отклики передаются в

формате NVT <a NAME="t303006"></a>ASCII. Он практически

идентичен серверу Finger, за исключением того, что

запросы и отклики содержат разную информацию. </small></p>



<p><small>Широко используемый Unix клиент - программа <a NAME="t303007"></a>whois(1) , однако можно использовать Telnet и

ввести команды самостоятельно. Сначала

отправляется запрос, содержащий знак вопроса, на

что возвращается более подробная информация о

поддерживаемых запросах клиента.</small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">Когда NIC было

переименовано в InterNIC в 1993 году, узел для сервера

Whois переместился с nic.ddn.mil на rs.internic.net. Многие

производители все еще поставляют версии клиента

whois с именем nic.ddn.mil, встроенном вовнутрь. Вам

может потребоваться указать аргумент командной

строки <a NAME="t303008"></a>-h rs.internic.net, чтобы

подсоединиться к нужному серверу.</font></p>




<p><font color="#0000A0">Другой способ - использовать Telnet,

чтобы подсоединиться к rs.internic.net с именем whois.</font></p>

</font>



<p>&nbsp;</p>



<p><small>Воспользуемся Whois сервером, чтобы получить

информацию об авторе. (Весь вывод Telnet клиента

удален.) Первый запрос - поиск всех имен,

совпадающих с шаблоном &quot;stevens.&quot;</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>sun % <b>telnet rs.internic.net whois<br>

stevens </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; это

командная строка, которую мы ввели клиенту<br>

<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; информация

о 25 других &quot;стивенсах&quot;, которую мы

игнорировали<br>

Stevens, W. Richard (WRS28) stevens@kohala.com

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +1 602 297 9416<br>

<br>

The InterNIC Registration Services Host ONLY contains Internet<br>

Information (Networks, ASN's, Domains, and POC's).<br>

Please use the whois server at nic.ddn.mil for MILNET Information.<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Три заглавные буквы, которые стоят перед

цифрами в скобках после имени, (WRS28), это

персональный описатель NIC. Следующий запрос

содержит восклицательный знак и описатель NIC, что

позволяет получить более подробную информацию

об этом человеке.</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p><br>

sun % <b>telnet rs.internic.net whois<br>

!wrs28 </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; запрос

клиента<br>

Stevens, W. Richard (WRS28)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stevens@kohala.com<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Kohala Software<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1202 E. Paseo del Zorro<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tuscon, AZ 85718<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +1 602 297 9416<br>

<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Record last updated on 11-Jan-91.<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Также можно получить дополнительную

информацию о переменных Internet. Например, запрос net

140.252 возвращает информацию о сети класса B 140.252.</small></p>

<font size="3"><i><b>



<p><a NAME="t303009"></a>Белые страницы</p>

</b></i></font>



<p><small>С использованием команды VRFY в SMTP, вместе с

протоколом Finger и протоколом Whois можно определить

положение пользователей в <a NAME="t303010"></a>Internet. Это

напоминает использование белых страниц в

телефонной книге, когда необходимо найти

чей-нибудь телефонный номер. В настоящее время

существуют широко доступные средства, однако

проводятся исследования, призванные улучшить

этот тип сервиса. </small></p>



<p><small><a NAME="t303011"></a>[Schwartz and Tsirigotis 1991] приводит

дополнительную информацию о различных сервисах

белых страниц, которые появляются в Internet. Один из

них <a NAME="t303012"></a>Netfind; к нему можно получить доступ

по Telnet на хосте bruno.cs.colorado.edu или ds.internic.net (имя

пользователя netfind). </small></p>



<p><small>RFC 1309 <a NAME="t303013"></a>[Weider, Reynolds, and Heker 1992]

предоставляет краткое описание службы

директорий <a NAME="t303014"></a>OSI, которая называется <a NAME="t303015"></a>X.500, где приводится сравнение отличие с

текущими технологиями Internet (Finger и Whois).</small></p>

<font size="3"><u><b>



<p><a NAME="t304000"></a>Archie, WAIS, Gopher, Veronica и WWW</p>

</b></u></font>



<p><small>Средства, которые мы описали в двух

предыдущих разделах, - Finger, Whois и сервис белых

страниц предоставляют информацию о

местонахождении персон. Существуют другие

средства, которые позволяют находить файлы и

документы. В следующем разделе дается краткое

описание этих средств. Мы приводим только

краткое описание, потому что рассмотрение в

деталях каждого из них может занять целую книгу.

Новые программы разрабатываются постоянно. <a NAME="t304001"></a>[Obraczka, Danzig, and Li 1993] описывает сервисы

поиска ресурсов в Internet.</small></p>

<font size="3"><i><b>



<p><a NAME="t304002"></a>Archie</p>

</b></i></font>



<p><small>Многое из того, что показано этой книге,

было получено с использованием анонимного FTP.

Проблема заключается в том, чтобы найти FTP узел,

на котором находится необходимая программа.

Иногда мы даже не знаем точное имя файла, однако

знаем какое-либо ключевое слово, которое может

появиться в имени файла. </small></p>



<p><small>Archie предоставляет информацию о тысячах FTP

серверов на бескрайних просторах Internet. Мы можем

получить доступ к этой информации, зайдя на

сервер Archie и осуществив поиск файла, имя которого

содержит указанное регулярное выражение. В ответ

появится список серверов, для которых было

найдено совпадение с именами файлов. Затем мы

используем анонимный FTP, чтобы получить файл. </small></p>



<p><small>Существует много Archie серверов по всему

миру. Стартовая точка - Telnet заход на ds.internic.net, под

именем archie и исполнение команды servers. При этом

будет возвращен список всех Archie серверов и их

положений.</small></p>

<font size="3"><i><b>



<p><a NAME="t304003"></a>WAIS: информационные сервисы

глобальных сетей</p>

</b></i></font>



<p><small>Archie помогает найти положение имен файлов,


содержащих ключевые слова, однако иногда

приходится искать файл или базу данных, ключевое

слово в которой содержится внутри. Таким образом,

осуществляется поиск файла, содержащего

ключевое слово, а не имени файла, содержащего

ключевое слово. </small></p>



<p><small>WAIS знает о сотнях баз данных, которые

содержат информацию по темам, связанным с

компьютерами, и другим общим темам. Чтобы

использовать WAIS, мы выбираем базы данных для

поиска и указываем ключевые слова. Чтобы

попробовать WAIS, попробуйте подсоединиться Telnetом

к quake.think.com с именем пользователя wais.</small></p>

<font size="3"><i><b>



<p><a NAME="t304004"></a>Gopher</p>

</b></i></font>



<p><small>Gopher это меню-ориентированное приложение

для работы с разнообразными сервисами Internet,

таких как <a NAME="t304005"></a>Archie, WAIS и анонимный FTP. Gopher

это одно из наиболее легко используемых средств,

так как его пользовательский интерфейс не

зависит от того, какой сервис используется. </small></p>



<p><small>Чтобы воспользоваться Gopher, подсоединитесь

Telnetом к <a NAME="t304006"></a>is.internic.net с именем

пользователя gopher.</small></p>

<font size="3"><i><b>



<p><a NAME="t304007"></a>Veronica: Very Easy Rodent-Oriented Netwide Index to Computerized

Archives</p>

</b></i></font>



<p><small>Тогда как Archie это индекс анонимных FTP

серверов, Veronica это индекс заголовков пунктов Gopher.

Veronica обычно осуществляет поиск по сотням Gopher

серверов. </small></p>



<p><small>Чтобы получить доступ к Veronica, необходимо

воспользоваться клиентом Gopher. Выберите пункт

меню в Gopher &quot;Beyond InterNIC: Virtual Treasures of the Internet&quot;, а

затем выберите Veronica из следующего меню.</small></p>

<font size="3"><i><b>



<p><a NAME="t304008"></a>WWW: World Wide Web</p>

</b></i></font>



<p><small>World Wide Web позволяет нам просмотреть в

мировом масштабе большой набор сервисов и

документов с использованием средства, которое

называется <a NAME="t304009"></a>гипертекст (hypertext). По мере

того как информация отображается, определенные

ключевые слова подсвечиваются, и мы можем

получить более подробную информацию с

использованием этих ключевых слов. </small></p>



<p><small>Чтобы получить доступ к WWW, подсоединитесь

Telnetом к info.cern.ch.</small></p>

<font size="3"><u><b>



<p><a NAME="t305000"></a>X Window System</p>

</b></u></font>



<p><small><a NAME="t305001"></a>X Window System, или просто X, это

приложение клиент-сервер, которое позволяет

нескольким клиентам (приложениям) использовать

графический дисплей, управляемый сервером.

Сервер это программное обеспечение, которое

управляет дисплеем, клавиатурой и мышкой. Клиент

это программа приложения, которая запущена либо

на том же самом хосте, что и сервер, либо на другом

хосте. В последнем случае обычная форма связи

между клиентом и сервером это TCP, однако могут

быть использованы и другие протоколы, такие как

DECNET. В некоторых случаях сервер это часть

аппаратного обеспечения (X терминал), которая

общается с клиентом на другом хосте. В другом

случае отдельно стоящая рабочая станция, клиент

и сервер находятся на одном и том же хосте и

общаются с помощью коммуникаций между

процессами на этом хосте, без использования

сетевого обеспечения. Однако наиболее

стандартная ситуация, когда клиенты запущены на

том же хосте, что сервер, или когда клиенты

запущены на других хостах. </small></p>



<p><small>X требует надежный, двунаправленный

потоковый протокол, такой как TCP. (X не разработана

для работы с ненадежными протоколами, такими как

UDP.) Общение между клиентом и сервером

осуществляется посредством обмена 8-битовыми

байтами по этому соединению. [<a NAME="t305002"></a>Nye 1992]

приводит формат более чем 150 сообщений, которыми

обмениваются клиент и сервер по TCP соединению. </small></p>



<p><small>В Unix системах, когда X клиент и X сервер

находятся на одном и том же хосте, вместо TCP

обычно используются протоколы <a NAME="t305003"></a>Unix

domain, потому что в этом случае осуществляется

меньше обработки протоколов, нежели при

использовании с TCP. <a NAME="t305004"></a>Протоколы Unix domain

это форма общения между процессами, которая

может быть использована между клиентами и

серверами на одном и том же хосте. Обратитесь к <a HREF="glava2.html#t027001">рисунку 2.4</a>, на котором видно, что

когда TCP используется для общения между двумя

процессами на одном и том же хосте, эти данные

передаются по петле ниже IP уровня, при этом

осуществляется обработка данных и TCP, и UDP. На

рисунке 30.1 показан возможный вариант общения

трех клиентов, использующих один дисплей. Один

клиент на том же самом хосте, что и сервер,

использует Unix domain протоколы. Остальные два

клиента находятся на других хостах и используют

TCP. Один клиент это обычно <a NAME="t305005"></a>оконный

менеджер (window manager), который имеет право

располагать окна на дисплее. Оконный менеджер

позволяет нам передвигать окна по экрану или,

например, менять их размер. </small></p>



<p><small>На первый взгляд термины клиент и сервер не

совсем уместны в данном случае. С такими

приложениями как Telnet и FTP мы считаем, что клиент

это интерактивный пользователь, который сидит за

клавиатурой и дисплеем. Однако в случае X

клавиатура и дисплей принадлежат самому серверу.

Поэтому в данном случае сервер это то, что

предоставляет сервис. Сервис, предоставляемый X,

это доступ к окну, клавиатуре и мышке. В случае

Telnet сервис это терминальный заход на удаленный

хост. В случае FTP сервис это файловая система

сервера. </small></p>



<p><small>X сервер обычно стартует, когда X терминал

или рабочая станция загружаются. Сервер создает

конечную точку TCP и осуществляет пассивное

открытие на порт 6000 + n, где n это номер дисплея

(обычно 0).<a NAME="t305006"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t30_1.jpg" WIDTH="520" HEIGHT="209"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 30.1 Три X клиента,

использующие один дисплей.</small></p>



<p>&nbsp;</p>



<p><small>Большинство Unix серверов также создают <a NAME="t305007"></a>Unix domain сокет с именем /tmp/.X11-unix/Xn, где n

это тот же номер дисплея. </small></p>



<p><small>Когда клиент стартует на другом хосте, он

создает TCP конечную точку и осуществляет

активное открытие на порт 6000 + n сервера. Каждый

клиент имеет свое собственное TCP соединение с

сервером. Уже от сервера будет зависеть, как он

поделит ресурсы между всеми клиентами. Клиент

отправляет по TCP соединению запросы на сервер

(создает окно), сервер посылает обратно отклики, а

также сервер посылает события клиенту (нажатие

кнопки мыши, нажатие клавиш на клавиатуре,

перемещение окна, изменение размера окна и так

далее). </small></p>



<p><small>На рисунке 30.2 повторен рисунок 30.1, где

показаны фазы общения клиента с процессом X

сервера, которые, в свою очередь, обслуживают

окна на дисплее. Здесь не показано, как X сервер

обслуживает клавиатуру и мышь.<a NAME="t305008"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t30_2.jpg" WIDTH="520" HEIGHT="247"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 30.2 Три клиента,

использующие один дисплей.</small></p>



<p>&nbsp;</p>




<p><small>Подобная форма, когда один сервер

обрабатывает несколько клиентов, отличается от

обычного TCP <a NAME="t305009"></a>конкурентного сервера,

который мы описали в разделе <a HREF="glava18.html#t18B000">&quot;Реализация

TCP сервера&quot;</a> главы 18. FTP и Telnet серверы,

например, запускают новый процесс каждый раз,

когда приходит запрос на новое TCP соединение,

поэтому каждый клиент общается со своим

процессом сервера. В случае X, все клиенты,

запущенные на этом же хосте или на другом хосте,

общаются с одним сервером. </small></p>



<p><small>По TCP соединению между X клиентом и его

сервером осуществляется обмен большим

количеством данных. Количество данных зависит от

конкретной реализации приложения. Например, если

мы запустим клиента Xclock, который отображает

текущее время и дату в окне клиента на сервере и

укажем ему обновляться один раз в секунду, X

сообщения посылаются по TCP соединению от клиента

к серверу один раз в секунду. Если мы запустим

эмулятор X терминала, Xterm, каждое нажатие клавиши

будет генерировать 32-байтное X сообщение (72 байта

вместе со стандартными IP и TCP заголовками), и еще

больше X сообщений в обратном направлении с

символами, отраженными эхом. <a NAME="t305010"></a>[Droms and

Dyksen 1990] рассчитывает TCP траффик между различными X

клиентами и одним конкретным сервером.</small></p>

<font size="3"><i><b>



<p><a NAME="t305011"></a>Программа Xscope</p>

</b></i></font>



<p><small>Удобная программа, с помощью которой можно

определить, чем обмениваются X клиент и его

сервер, это Xscope. Она поставляется с большинством

реализаций X Window. Программа находится между

клиентом и сервером, пропуская все данные в обоих

направлениях, при этом отлавливая все запросы

клиента и отклики сервера. На рисунке 30.3

показано, как это происходит.<a NAME="t305012"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t30_3.jpg" WIDTH="520" HEIGHT="282"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 30.3 Использование xscope для

мониторинга X соединения.</small></p>



<p>&nbsp;</p>



<p><small>Во-первых, мы стартовали процесс xscope на том

же самом хосте, где находится сервер, при этом xscope

слушает запросы на TCP соединение приходящие на

порт 6001, а не 6000. Затем мы стартовали клиента на

другом хосте и указали дисплей номер 1, а не 0,

таким образом, клиент подключается к xscope, а не

непосредственно к серверу. Когда запрос на

соединение прибывает от клиента, xscope создает TCP

соединение на реальный порт сервера 6000 и

копирует все между клиентом и сервером, а также

предоставляет читаемое описание запросов и

откликов. Мы запустим xscope на хосте sun, а клиента <a NAME="t305013"></a>xclock на хосте svr4. </small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="1">



<p></font><font FACE="Courier New" size="2">svr4 % <a NAME="t305014"></a><b>DISPLAY=sun:1

xclock -digital -update 5</p>

</b></font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>При этом отображаются время и дата в

цифровом формате</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="1">



<p></font><font FACE="Courier New" size="2">Thu Sep 9 10:32:55 1993</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>в окне на хосте sun. Мы указали обновлять

время один раз каждые 5 секунд. </small></p>



<p><small>Также указана опция -q команды xscope, чтобы

получать минимальный вывод. Доступны различные

уровни отладки, что позволяет просмотреть все

поля в каждом сообщении. Следующий вывод

показывает первые три запроса и отклика.</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p><br>

sun % <b>xscope -q</b><br>

0.00: Client --&gt; 12 bytes<br>

0.02:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 152

bytes &lt;-- X11 Server<br>

0.03: Client --&gt; 48 bytes<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ............REQUEST: CreateGC<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ............REQUEST: GetProperty<br>

0.20:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 396

bytes &lt;-- X11 Server<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ..............REPLY:

GetProperty<br>

0.30: Client --&gt; 8 bytes<br>

0.38: Client --&gt; 20 bytes<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ............REQUEST: InternAtom<br>

0.43:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32

bytes &lt;-- X11 Server<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ..............REPLY:

InternAtom<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Первое сообщение от клиента в момент

времени 0,00 и отклик сервера в момент времени 0,02

это стандартное установление соединения между

клиентом и сервером. Клиент указывает <a NAME="t305015"></a>порядок

следования байтов и версию сервера, которую он

ожидает. Сервер сообщает о себе различную

информацию. </small></p>



<p><small>Следующее сообщение в момент времени 0,03

содержит два запроса от клиента. Первый запрос

создает на сервере графическое окружение, в

котором клиент будет рисовать. Второй получает

свойства от сервера (характеристика RESOURCE_MANAGER).

Свойства обеспечивают общение между клиентами,

обычно между приложением и оконным менеджером.

Отклик от сервера размером 396 байт в момент

времени 0,20 содержит это свойство. </small></p>



<p><small>Следующие два сообщения от клиента в

моменты времени 0,30 и 0,38 имеют форму одного

запроса, который требует вернуть атом. (Каждое

свойство имеет уникальный целый идентификатор,

который называется атом.) В момент времени 0.43

сервер отправляет отклик, содержащий атом. </small></p>



<p><small>Рассматривать этот пример дальше

невозможно без подробного описания того, как

работает система X window system, что не является целью

нашего повествования. В этом примере мы видим,

что перед тем как на дисплее появилось окно,

клиент отправил 12 сегментов, содержащих 1668 байт,

а сервер отправил 10 сегментов, содержащих 1120

байт. Весь процесс занял 3,17 секунды. С этого

момента, каждые 5 секунд, клиент посылает

маленький запрос в среднем по 44 байта, которые

обновляют окно. Это продолжается до тех пор, пока

клиент не будет выключен.</small></p>

<font size="3"><i><b>



<p><a NAME="t305016"></a>LBX: X с низкой шириной полосы</p>

</b></i></font>



<p><small>Кодирование, используемое протоколом X,

оптимально для работы в локальных сетях, где

время, которое тратится на кодирование и

декодирование данных, более важно, нежели

минимизация количества передаваемых данных. При

работе с Ethernet все нормально, однако в случае

медленных последовательных каналов, таких как <a NAME="t305017"></a>SLIP и <a NAME="t305018"></a>PPP (глава 2, разделы <a HREF="glava2.html#t024000">&quot;SLIP: IP по последовательной

линии&quot;</a> и <a HREF="glava2.html#t026000">&quot;PPP: протокол

точка-точка&quot;</a>) возникают проблемы. </small></p>



<p><small>Поэтому был разработан стандарт Low Bandwidth X

(LBX), который использует следующую технику для

уменьшения сетевого траффика: кэширование,

отправку изменений от предыдущих пакетов и

сжатие. Спецификации появились в 1993 году с

реализацией X window system Release 6.</small></p>

<font size="3"><u><b>



<p><a NAME="t306000"></a>Краткие выводы</p>

</b></u></font>



<p><small>Первые два приложения, которые мы

рассмотрели, Finger и Whois, предназначены для

получения информации о пользователях. Клиент Finger

запрашивает сервер, чаще всего для того, чтобы

найти какое-либо имя (например, чтобы отправить

пользователю почту) или для того чтобы

посмотреть, зашел ли кто-либо в систему

терминалом в настоящий момент. Клиент Whois обычно

общается с сервером, запущенным от <a NAME="t306001"></a>InterNIC,

в поисках информации о человеке, организации,

домене или номере сети. </small></p>



<p><small>Другие сервисы, позволяющие более

эффективно работать с ресурсами Internet, это <a NAME="t306002"></a>Archie, WAIS, <a NAME="t306003"></a>Gopher, Veronica и WWW. Они

помогают найти в Internet файлы и документы. В

настоящее время разрабатываются и другие

средства определения ресурсов. </small></p>



<p><small>Эта глава закончена кратким рассмотрением

системы X Window System, еще одного очень

&quot;серьезного&quot; приложения, работающего с TCP/IP.

Мы видели, что X сервер обслуживает несколько

окон на дисплее и обеспечивает общение клиента с

его окном. С помощью программы Xscope мы видели, как

существует возможность поместить еще одну

программу между клиентом и сервером, чтобы

получить информацию о том, с помощью каких

сообщений осуществляется обмен.</small></p>

<font size="3"><i><b>



<p>Упражнения</b></i></font><font size="1"> 



<ol>

  <li></font><font size="2">Используйте Whois, чтобы найти

    владельца сети класса A с идентификатором сети 88.</li>

  <li>Используйте Whois, чтобы найти DNS сервер в домене

    whitehouse.gov. Совпадет ли отклик с ответом, который

    можно получить от системы DNS?</li>

  <li>Как Вы думаете, должен ли быть процесс xscope,

    показанный на рисунке 30.3, запущен на том же самом

    хосте, что и X сервер?</font><font size="1"></li>

</ol>

</font></font>



<p><small><a HREF="index.html"><img SRC="contents.jpg" BORDER="0" WIDTH="94" HEIGHT="20"></a><a HREF="../home.htm"><img SRC="begin.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glavaA.html"><img SRC="forward.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava29.html"><img SRC="back_b.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><img SRC="index.jpg" WIDTH="68" HEIGHT="20"></small></p>

<font size="1">



<p>&nbsp;</p>

</font>
</div>
</body>

</html>

