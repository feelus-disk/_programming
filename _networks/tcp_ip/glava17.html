<html>
<head>
<title>TCP: Transmission Control Protocol</title>
</head>

<body>
<div>
<p><small><a HREF="index.html"><img SRC="contents.jpg" BORDER="0" WIDTH="94" HEIGHT="20"></a><a HREF="../home.htm"><img SRC="begin.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava18.html"><img SRC="forward.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava16.html"><img SRC="back_b.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a href="index.html"><img SRC="index.jpg" border="0" WIDTH="68" HEIGHT="20"></a></small></p>

<font FACE="Arial" SIZE="4">



<p><a NAME="t170000"></a>Глава 17 TCP: Transmission Control Protocol</p>

</font><font FACE="Arial"><font size="3"><u>



<p><b><a NAME="t171000"></a>Введение</p>

</b></u></font>



<p><small>В этой главе описаны сервисы, которые TCP

предоставляет приложениям. Здесь же

рассмотриваются поля TCP заголовка. В следующих

главах мы подробно рассмотрим эти поля и

расскажем, как TCP функционирует. </small></p>



<p><small>Описанию TCP посвящена эта глава, и следующие

семь глав. В <a HREF="glava18.html">главе 18</a> будет

рассказано, как устанавливаются и разрываются TCP

соединения, в <a HREF="glava19.html">главе 19</a> и <a HREF="glava20.html">главе

20</a> мы рассмотрим обычную передачу данных, как в

диалоговом использовании (удаленный заход), так и

передачу файлов. В <a HREF="glava21.html">главе 21</a> мы

подробно рассмотрим, как TCP осуществляет

тайм-ауты и повторные передачи. И в <a HREF="glava22.html">главе

22</a> и <a HREF="glava23.html">главе 23</a> мы рассмотрим

некоторые таймеры TCP. И в заключение, в <a HREF="glava24.html">главе

24</a> мы рассмотрим новые характеристики и

производительность TCP. </small></p>



<p><small>Основная спецификация TCP находится в RFC 793 [<a NAME="t171001"></a>Postel 1981c], однако некоторые ошибки этого

RFC исправлены в требованиях к хостам <a NAME="t171002"></a>Host

Requirements RFC. </small></p>

<font size="3"><u><b>



<p><a NAME="t172000"></a>TCP сервисы</p>

</b></u></font>



<p><small>Несмотря на то, что TCP и UDP используют один и

тот же сетевой уровень (IP), TCP предоставляет

приложениям абсолютно другие сервисы, нежели UDP. <a NAME="t172001"></a>TCP предоставляет основанный на

соединении надежный сервис потока байтов. </small></p>



<p><small>Термин <a NAME="t172002"></a>&quot;основанный на

соединении&quot; (connection-oriented) означает, что два

приложения, использующие TCP (как правило, это

клиент и сервер), должны установить TCP соединение

друг с другом, после чего у них появляется

возможность обмениваться данными. Типичная

аналогия - это набор телефонного номера, ожидание

ответа от удаленного абонента, когда он говорит

&quot;алло&quot;, после чего необходимо сказать, кто

звонит. В <a HREF="glava18.html">главе 18</a> мы рассмотрим, как

устанавливается соединение и как это соединение

разрывается через некоторое время, когда работа

завершена. </small></p>



<p><small>Всегда существуют две конечные точки,

которые общаются друг с другом с помощью TCP

соединения. Концепции, о которых мы говорили в <a HREF="glava12.html">главе 12</a>, широковещательная рассылка

и групповая рассылка, не имеют отношения к TCP. </small></p>



<p><small>TCP обеспечивает свою надежность благодаря

следующему:</small> 



<ul>

  <li><small>Данные от приложения разбиваются на блоки

    определенного размера, которые будут отправлены.

    Это полностью отличается от UDP, в котором каждая

    запись, которую осуществляет приложение,

    генерирует IP датаграмму этого размера. Блок

    информации, который передается от TCP в IP,

    называется <a NAME="t172003"></a>сегментом (segment). (См. <a HREF="glava1.html#t016001">рисунок 1.7</a>.) В разделе <a HREF="glava18.html#t184000">&quot;Максимальный размер

    сегмента&quot;</a> главы 18 мы посмотрим, как TCP

    определяет нужный размер сегмента. </small></li>

  <li><small>Когда TCP посылает сегмент, он устанавливает

    таймер, ожидая, что с удаленного конца придет

    подтверждение на этот сегмент. Если

    подтверждение не получено по истечении времени,

    сегмент передается повторно. В <a HREF="glava21.html">главе

    21</a> мы рассмотрим стратегию TCP, которую он

    реализует для тайм-аутов и повторных передач. </small></li>

  <li><small>Когда TCP принимает данные от удаленной

    стороны соединения, он отправляет подтверждение.

    Это подтверждение не отправляется немедленно, а

    обычно задерживается на доли секунды, что мы

    обсудим в разделе <a HREF="glava19.html#t193000">&quot;Задержанные

    подтверждения&quot;</a> главы 19. </small></li>

  <li><small><a NAME="t172004"></a>TCP осуществляет расчет

    контрольной суммы для своего заголовка и данных.

    Это контрольная сумма, рассчитываемая на концах

    соединения, целью которой является выявить любое

    изменение данных в процессе передачи. Если

    сегмент прибывает с неверной контрольной суммой,

    TCP отбрасывает его и подтверждение не

    генерируется. (Ожидается, что отправитель

    отработает тайм-аут и осуществит повторную

    передачу.) </small></li>

  <li><small>Так как TCP сегменты передаются в виде IP

    датаграмм, а IP датаграммы могут прибывать

    беспорядочно, также беспорядочно могут

    прибывать и TCP сегменты. После получения данных TCP

    может по необходимости изменить их

    последовательность, в результате приложение


    получает данные в правильном порядке. </small></li>

  <li><small>Так как IP датаграмма может быть

    продублирована, принимающий TCP должен

    отбрасывать продублированные данные. </small></li>

  <li><small><a NAME="t172005"></a>TCP осуществляет контроль потока

    данных. Каждая сторона TCP соединения имеет

    определенное пространство буфера. TCP на

    принимающей стороне позволяет удаленной стороне

    посылать данные только в том случае, если

    получатель может поместить их в буфер. Это

    предотвращает от переполнения буферов медленных

    хостов быстрыми хостами.</small></li>

</ul>



<p><small>Между двумя приложениями по TCP соединению

осуществляется обмен потоком 8-битовых байтов.

Автоматически TCP не вставляет записи маркеров.

Это называется <a NAME="t172006"></a>сервисом потока

байтов (byte stream service). Если приложение на одном

конце записало сначала 10 байт, затем 20 байт и

затем еще 50 байт, приложение на другом конце

соединения не может сказать какого размера была

каждая запись. На другом конце эти 80 байт могут

быть считаны, например, за 4 раза по 20 байт за

каждый раз. Один конец соединения помещает поток

байт в TCP, и точно так же идентичный поток байт

появляется на другом конце. </small></p>



<p><small>TCP не интерпретирует содержимое байтов. TCP

понятия не имеет о том, происходит ли обмен

двоичными данными, ASCII символами, EBCDIC символами

или чем-либо еще. Эта интерпретация потока байтов

осуществляется приложениями на каждой стороне

соединения.</small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">Это представление

потока байтов протоколом TCP напоминает

представление файла в операционной системе Unix.

Ядро Unix не интерпретирует байты, которые

приложение читает или записывает - это полностью

зависит от приложений. Ядро Unix не видит разницы

между бинарными файлами и файлами, содержащими

строки текста.</font></p>

</font>



<p><small><a NAME="t173000"></a>&nbsp;</small></p>

<font size="3"><u><b>



<p>Заголовок TCP</p>

</b></u></font>



<p><small>Вспомним, что данные TCP инкапсулируются в IP

датаграммы, как показано на рисунке 17.1.<a NAME="t173002"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t17_1_2.jpg" WIDTH="355" HEIGHT="105"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 17.1 Инкапсуляция TCP данных в

IP датаграмму.</small></p>



<p>&nbsp;</p>



<p><small>На рисунке 17.2 показан формат TCP заголовка.

Обычно его размер составляет 20 байт, если не

присутствуют опции.<a NAME="t173001"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t17_2_2.jpg" WIDTH="531" HEIGHT="315"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 17.2 TCP заголовок.</small></p>



<p>&nbsp;</p>



<p><small>Каждый TCP сегмент содержит <a NAME="t173003"></a>номер

порта (port number) источника и назначения, с помощью

которых идентифицируются отправляющее и

принимающее приложения. Эти два значения вместе

с IP адресом источника и назначения в IP заголовке

уникально идентифицируют каждое соединение. </small></p>



<p><small>Комбинация IP адреса и номера порта иногда

называется <a NAME="t173004"></a>сокетом (socket) . Этот термин

появился в исходной спецификации TCP (RFC 793), а

позднее стал использоваться в качестве имени

программного интерфейса Berkeley (глава 1, раздел <a HREF="glava1.html#t01F000">&quot;Интерфейсы прикладного

программирования&quot;</a>). Эта <a NAME="t173005"></a>пара

сокетов (содержащая IP адрес клиента, номер порта

клиента, IP адрес сервера и номер порта сервера)

указывает две конечные точки, которые уникально

идентифицируют каждое TCP соединение.</small></p>



<p><small><a NAME="t173006"></a>Номер последовательности (sequence

number) идентифицирует байт в потоке данных от

отправляющего TCP к принимающему TCP. Если мы

представим поток байтов, текущий в одном

направлении между двумя приложениями, TCP

нумерует каждый байт номером

последовательности. Номер последовательности

представляет собой 32-битное беззнаковое число,

которое переходит через 0, по достижению значения

2<sup>32 </sup>- 1.</small></font></p>

<font FACE="Arial">



<p><small>При установлении нового соединения,

взводится флаг SYN. Поле номера

последовательности (sequence number field) содержит

исходный номер последовательности (<a NAME="t173007"></a>ISN

- initial sequence number), который выбирается хостом для

данного соединения. Номер последовательности

первого байта данных, который посылается этим

хостом, будет равен ISN плюс один, потому что флаг

SYN занимает собой номер последовательности.

(Подробно мы опишем, как в действительности

устанавливается соединение и как соединение

разрывается, в <a HREF="glava18.html">следующей</a> главе, где

увидим, что флаг FIN также занимает собой номер

последовательности.)</small></p>



<p><small>Так как каждый байт, который участвует в

обмене, пронумерован, <a NAME="t173008"></a>номер

подтверждения (acknowledgment number) это следующий номер

последовательности, который ожидает получить

отправитель подтверждения. Это номер

последовательности плюс 1 последнего успешно

принятого байта данных. Это поле принимается в

рассмотрение, только если флаг ACK (описан ниже)

взведен. </small></p>



<p><small>Отправка ACK не стоит ничего (это означает,

что на подтверждение не тратится сегмент), потому

что 32-битное поле номера подтверждения всегда

является частью заголовка, так же как и флаг ACK. Мы

увидим, что когда соединение установлено, это

поле всегда установлено и флаг ACK всегда взведен.</small></p>



<p><small>TCP предоставляет для прикладного уровня <a NAME="t173009"></a>полнодуплексный сервис. Это означает,

что данные могут передаваться в каждом

направлении независимо от другого направления.

Однако, на каждом конце соединения необходимо

отслеживать номер последовательности данных,

передаваемых в каждом направлении.</small></p>



<p><small><a NAME="t173010"></a>TCP может быть описан как

протокол с изменяющимся окном без селективных

или отрицательных подтверждений. (Изменение

окна, используемое при передаче данных, описано в

разделе <a HREF="glava20.html#t203000">&quot;Изменение размера

окна&quot;</a> главы 20.) Мы сказали, что в TCP нет

селективных подтверждений, потому что номер

подтверждения в TCP заголовке означает, что

отправитель успешно принял, все байты за

исключением этого байта. Таким образом, в

настоящее время не существует возможности

подтвердить отдельно выбранную часть потока

данных. Например, если байты 1-1024 приняты

нормально, а следующий сегмент содержит байты

2049-3072, принимающий не может подтвердить этот

новый сегмент. Все что он может - это послать ACK с

номером подтверждения 1025. Также нет никакого

смысла посылать отрицательные подтверждения на

сегмент. Например, если сегмент с байтами 1025-2048

прибыл, однако была определена ошибка в

контрольной сумме, все что может послать

принимающий TCP это ACK с номером подтверждения

равным 1025. В разделе <a HREF="glava21.html#t217000">&quot;Быстрая

повторная передача и алгоритм быстрого

восстановления&quot;</a> главы 21 мы увидим, как

дублированные подтверждения могут помочь

определить потерю пакетов.</small></p>



<p><small><a NAME="t173011"></a>Длина заголовка (header length)

содержит длину заголовка в 32-битных словах. Это

объясняется тем, что длина поля опций переменная.

С 4-битным полем у TCP есть ограничение на длину

заголовка в 60 байт. Без опций, однако, стандартный

размер составляет 20 байт.</small></p>



<p><small>В TCP заголовке существуют 6 флаговых битов.

Один или несколько из них могут быть установлены

в единицу в одно и то же время. Здесь мы кратко

опишем их использование, а позже опишем каждый

флаг более подробно в соответствующих главах.</small>



<dl>

  <p><small>URG</small></p>

  <dd><small><a NAME="t173013"></a>Указатель срочности (urgent pointer)

    будет рассмотрен в разделе <a HREF="glava20.html#t208000">&quot;Режим

    срочности (Urgent Mode)&quot;</a> главы 20.</small><p><small><a NAME="t173014"></a> </small></p>

  </dd>

  <p><small>ACK</small></p>

  <dd><small>Номер подтверждения необходимо принять в

    рассмотрение (acknowledgment).</small><p><small><a NAME="t173015"></a> </small></p>

  </dd>

  <p><small>PSH</small></p>

  <dd><small>Получатель должен передать эти данные

    приложению как можно скорее (глава 20, раздел <a HREF="glava20.html#t205000">&quot;Флаг PUSH&quot;</a>).</small><p><small><a NAME="t173016"></a> </small></p>

  </dd>

  <p><small>RST</small></p>

  <dd><small>Сбросить соединение (глава 18, раздел <a HREF="glava18.html#t187000">&quot;Сегменты сброса (Reset)&quot;</a>).</small><p><small><a NAME="t173017"></a> </small></p>

  </dd>

  <p><small>SYN</small></p>

  <dd><small>Синхронизирующий номер последовательности

    для установления соединения. Этот следующий

    флаги описаны в <a HREF="glava18.html">главе 18</a>.</small><p><small><a NAME="t173018"></a> </small></p>

  </dd>

  <p><small>FIN</small></p>

  <dd><small>Отправитель заканчивает посылку данных.</small></dd>

</dl>



<p>&nbsp;</p>



<p><small><a NAME="t173019"></a>Контроль потока данных TCP

осуществляется на каждом конце с использованием <a NAME="t173020"></a>размера окна (window size) . Это количество

байт, начинающееся с указанного в поле номера

подтверждения, которое приложение собирается

принять. Это 16-битовое поле ограничивает размер

окна в 65535 байт. В разделе <a HREF="glava24.html#t244000">&quot;Опция

масштабирования окна&quot;</a> главы 24 мы увидим, что

опция масштабирования окна позволяет изменять

это значение, при этом могут быть использованы

окна большего размера.</small></p>



<p><small><a NAME="t173021"></a>Контрольная сумма (checksum)


охватывает собой весь TCP сегмент: TCP заголовок и TCP

данные. Это обязательное поле, которое должно

быть рассчитано и сохранено отправителем, а

затем проверено получателем. Контрольная сумма

TCP рассчитывается так же как контрольная сумма UDP,

с использованием <a NAME="t173022"></a>псевдозаголовка,

как описано в разделе <a HREF="glava11.html#t113000">&quot;Контрольная

сумма UDP&quot;</a> главы 11.</small></p>



<p><small><a NAME="t173023"></a>Указатель срочности (urgent pointer)

действителен только в том случае, если

установлен флаг URG. Этот указатель является

положительным смещением, которое должно быть

прибавлено к полю номера последовательности

сегмента, чтобы получить номер

последовательности последнего байта срочных

данных. Режим срочности TCP это способ, с помощью

которого отправитель передает срочные данные на

удаленный конец. Мы рассмотрим эту

характеристику в разделе <a HREF="glava20.html#t208000">&quot;Режим

срочности (Urgent Mode)&quot;</a> главы 20. </small></p>



<p><small>Наиболее общее поле опций - это опция

максимального размера сегмента (<a NAME="t173024"></a>MSS -

maximum segment size). На каждом конце соединения эта опция

обычно указывается в первом сегменте, с которого

начинается обмен (сегмент с установленным флагом

SYN, который используется для установления

соединения). Она указывает на максимальный

размер сегмента, который может быть принят

отправителем. Мы опишем опцию MSS более подробно в

разделе <a HREF="glava18.html#t184000">&quot;Максимальный размер

сегмента&quot;</a> главы 18, а некоторые другие опции

TCP в <a HREF="glava24.html">главе 24</a>. </small></p>



<p><small>На рисунке 17.2 мы видели, что раздел данных в

TCP сегменте необязателен. В <a HREF="glava18.html">главе 18</a>

мы увидим, что когда устанавливается соединение

или когда соединение разрывается, сегменты

содержат только TCP заголовки с возможными

опциями. Заголовок без данных также

используется, чтобы подтвердить принятые данные,

если в этом направлении не надо передавать

данные. Также существует несколько случаев

тайм-аутов, когда сегмент может быть отправлен

без данных.</small></p>

<font size="3"><u><b>



<p><a NAME="t174000"></a>Краткие выводы</p>

</b></u></font>



<p><small>TCP предоставляет надежный, ориентированный

на соединения, и ориентированный на поток байтов

сервис транспортного уровня. Мы коротко

рассмотрели все поля TCP заголовка, подробное

описание полей приведено в следующих главах.</small></p>



<p><small>TCP строит пакеты из пользовательских

данных, упаковывая их в сегменты, устанавливает

тайм-ауты в тот момент, когда он посылает данные,

подтверждает принятые данные с удаленного конца,

меняет порядок данных, которые пришли

хаотически, отбрасывает продублированные

данные, осуществляет контроль потока данных,

рассчитывает и проверяет контрольную сумму в

конечных точках передачи. </small></p>



<p><small>TCP используется множеством популярных

приложений, таких Telnet, Rlogin, FTP и электронная почта

(SMTP).</small></p>

<font size="3"><i><b>



<p>Упражнения</b></i></font><font size="1"> 



<ol>

  <li></font><font size="2">Мы рассмотрели следующие форматы

    пакетов, каждый из которых имеет контрольную

    сумму в своем заголовке: <a NAME="t174001"></a>IP, <a NAME="t174002"></a>ICMP,

    <a NAME="t174003"></a>IGMP, <a NAME="t174004"></a>UDP и TCP. Для каждого

    опишите, какая часть IP датаграммы покрывается

    контрольной суммой, и где контрольная сумма

    обязательна, а где нет.</li>

  <li>Почему все протоколы Internet, которые мы обсуждали

    (IP, ICMP, IGMP, UDP, TCP), молча отбрасывают пакеты, которые

    прибывают с ошибкой контрольной суммы?</li>

  <li>TCP предоставляет сервис потока байтов, где не

    происходит разграничения записей в процессе

    передачи между отправителем и получателем. Как

    могут приложения осуществить вставку своих

    собственных маркеров записей?</li>

  <li>Почему номера портов источника и назначения

    находятся в начале TCP заголовка?</li>

  <li>Почему TCP заголовок имеет <a NAME="t174005"></a>поле длины

    заголовка, тогда как UDP заголовок (<a HREF="glava11.html#t112001">рисунок

    11.2</a>) не имеет?</font><font size="1"></li>

</ol>

</font></font>



<p><small><a HREF="index.html"><img SRC="contents.jpg" BORDER="0" WIDTH="94" HEIGHT="20"></a><a HREF="../home.htm"><img SRC="begin.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava18.html"><img SRC="forward.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava16.html"><img SRC="back_b.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a href="index.html"><img SRC="index.jpg" border="0" WIDTH="68" HEIGHT="20"></a></small></p>

<font size="1">



<p>&nbsp;</p>

</font>
</div>
</body>

</html>

