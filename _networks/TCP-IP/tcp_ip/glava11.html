<html>
<head>
<title>UDP: User Datagram Protocol</title>
</head>

<body>
<div>


<p><small><a HREF="index.htm"><img SRC="contents.jpg" BORDER="0" WIDTH="94" HEIGHT="20"></a><a HREF="../home.htm"><img SRC="begin.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava12.html"><img SRC="forward.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava10.html"><img SRC="back_b.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a href="index.html"><img SRC="index.jpg" border="0" WIDTH="68" HEIGHT="20"></a></small></p>

<font FACE="Arial" SIZE="4">



<p><a NAME="t110000"></a>Глава 11 UDP: User Datagram Protocol</p>

</font><font FACE="Arial"><font size="3"><u>



<p><b><a NAME="t111000"></a>Введение</p>

</b></u></font>



<p><small><a NAME="t111001"></a>UDP простой, ориентированный на

передачу датаграмм, протокол транспортного

уровня: за один раз процесс выдает одну UDP

датаграмму, в результате чего передается одна IP

датаграмма. Это отличается от

поток-ориентированных протоколов, таких как TCP,

где количество данных, которое выдается

приложением, практически не имеет отношения к

количеству отправленных IP датаграмм. </small></p>



<p><small>На рисунке 11.1 показана инкапсуляция UDP

датаграммы в IP датаграмму.<a NAME="t111002"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t11_1.jpg" WIDTH="316" HEIGHT="105"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 11.1 UDP инкапсуляция.</small></p>



<p>&nbsp;</p>



<p><small>Официальная спецификация UDP приведена в RFC

768 [<a NAME="t111003"></a>Postel 1980]. </small></p>



<p><small>UDP является ненадежным протоколом: он

отправляет датаграммы, которые приложение пишет

в IP уровень, однако не существует гарантии того,

что они достигнут конечного пункта назначения. С

точки зрения надежности может возникнуть

предположение, что стоит избегать использовать

UDP и всегда пользоваться надежными протоколами,

такими как TCP. После того как TCP будет описан в <a HREF="glava17.html">главе 17</a>, мы вернемся к этой теме и

посмотрим, какие типы приложений могут

использовать UDP. </small></p>



<p><small>Приложениям нет необходимости

беспокоиться о размере получившейся в

результате IP датаграммы. Если она по размеру

больше, чем MTU для данной сети (см. главу 2, раздел <a HREF="glava2.html#t028000">&quot;MTU&quot;</a>), IP датаграмма будет

фрагментирована. Это применимо к каждой сети,

через которую пройдет датаграмма по пути от

источника до пункта назначения, кроме первой

сети, к которой подключен посылающий хост. (Мы

определили понятие транспортного MTU в разделе <a HREF="glava2.html#t029000">&quot;Транспортный MTU&quot;</a> главы 2.)

Более подробно IP фрагментация будет рассмотрена

в разделе <a HREF="#t115000">&quot;Фрагментация IP&quot;</a> этой

главы.</small></p>

<font size="3"><u><b>



<p><a NAME="t112000"></a>UDP заголовок </p>

</b></u></font>



<p><small>На рисунке 11.2 показаны поля, присутствующие

в UDP заголовке.<a NAME="t112001"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t11_2.jpg" WIDTH="528" HEIGHT="179"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 11.2 UDP заголовок.</small></p>



<p>&nbsp;</p>



<p><small><a NAME="t112002"></a>Номера портов (port numbers)

указывают на отправляющий и принимающий

процессы. На <a HREF="glava1.html#t017001">рисунке 1.8</a>

показано, что TCP и UDP используют номер порта

назначения для демультиплексирования данных,

поступающих от IP. Так как IP осуществляет

демультиплексирование входящих IP датаграмм для

TCP и UDP (с использованием значения протокола в IP

заголовке), TCP просматривает номера портов TCP, а UDP

- номера портов UDP. Номера портов TCP независимы от

номеров портов UDP. </small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">Несмотря на подобную

независимость, если зарезервированный сервис

предоставляется обоими TCP и UDP, обычно выбирается

один и тот же номер порта для обоих транспортных

уровней. Это сделано для удобства, а не по

требованию протоколов.</font></p>

</font>



<p>&nbsp;</p>



<p><small><a NAME="t112003"></a>Поле длины UDP содержит длину в

байтах UDP заголовка и UDP данных. Минимальное

значение для этого поля составляет 8 байт. (Не

произойдет ничего страшного, если будет

отправлена UDP датаграмма с нулевой длиной

данных.) Параметр UDP длины - избыточный. IP

датаграмма содержит свою полную длину в байтах,

поэтому длина UDP датаграммы это <a NAME="t112004"></a>полная

длина минус длина IP заголовка (которая указана в

поле длины заголовка на <a HREF="glava3.html#t032001">рисунке

3.1</a>).</small></p>

<font size="3"><u><b>



<p><a NAME="t113000"></a>Контрольная сумма UDP</p>

</b></u></font>



<p><small><a NAME="t113001"></a>Контрольная сумма UDP охватывает

UDP заголовок и UDP данные. Вспомним, что

контрольная сумма в IP заголовке охватывает

только IP заголовок - она не охватывает данные,

находящиеся в IP датаграмме. И UDP, и TCP содержат

контрольные суммы в своих заголовках, которые

охватывают как заголовок, так и данные. Для UDP

контрольная сумма необязательна, но для TCP она

обязательна. </small></p>



<p><small>Контрольная сумма UDP рассчитывается точно

так же, как (глава 3, раздел <a HREF="glava3.html#t032000">&quot;IP

заголовок&quot;</a>) контрольная сумма IP заголовка

(сумма 16-битных слов с переполнением), хотя

существуют и отличия. Во-первых, UDP датаграмма

может состоять из нечетного количества байт,

тогда как при расчете контрольной суммы

складываются 16-битные слова. При этом в конец

датаграммы добавляются нулевые байты

заполнения, если это необходимо для расчета

контрольной суммы. (Байты заполнения не

передаются.) </small></p>



<p><small>В UDP и TCP существуют 12-байтовые <a NAME="t113002"></a>псевдозаголовки

(в UDP датаграммах и TCP сегментах) только для

расчета контрольной суммы. Псевдозаголовки

содержат в себе определенные поля из IP заголовка.

Все это сделано для двойной проверки того, что

данные достигли того пункта назначения, которому

предназначались (IP не принимает датаграммы,

которые не адресованы для данного хоста, и не

сможет передать UDP датаграммы, предназначенные

для другого верхнего уровня). На рисунке 11.3

показан <a NAME="t113003"></a>псевдозаголовок и UDP

датаграмма.<a NAME="t113004"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t11_3.jpg" WIDTH="533" HEIGHT="326"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 11.3 Поля, используемые для

расчета контрольной суммы UDP.</small></p>



<p>&nbsp;</p>



<p><small>На этом рисунке мы специально показали

датаграмму с нечетной длиной, в этом случае

требуется дополнительный байт для расчета

контрольной суммы. Обратите внимание на то, что

длина UDP датаграммы, при расчете контрольной

суммы, появляется дважды. </small></p>



<p><small>Если рассчитанная контрольная сумма равна

0, она хранится как все единичные биты (65535), эти

значения эквивалентны в арифметике с

поразрядным дополнением (дополнение единицы)

(ones-complement). Если переданная контрольная сумма

равна 0, это означает, что отправитель не

рассчитал контрольную сумму. </small></p>



<p><small>Если отправитель все же рассчитал

контрольную сумму, а получатель определил

наличие ошибки, UDP датаграмма молча уничтожается,

сообщение об ошибке не генерируется. (То же самое

происходит, если IP уровень обнаружил ошибку в

контрольной сумме IP заголовка.) </small></p>



<p><small><a NAME="t113005"></a>Контрольная сумма UDP

рассчитывается отправителем и проверяется

получателем. Она позволяет определить любые

изменения в UDP заголовке или данных, которые

произошли на пути между отправителем и

получателем. </small></p>



<p><small>Несмотря на то, что для контрольная сумма UDP

- необязательный параметр, она должна

рассчитываться всегда. В конце 1980-х годов

некоторые производители компьютеров стали по

умолчанию отключать расчет контрольной суммы UDP,

чтобы увеличить скорость работы сетевой

файловой системы (NFS - Network File System), которая

использует UDP. Это может быть допустимым в одной

локальной сети, где рассчитывается циклический

избыточный код для фреймов на канальном уровне

(фреймы Ethernet или Token ring), с помощью которого можно

определить повреждение фрейма, когда датаграмма

проходит через маршрутизаторы. Поверите Вы или

нет, но существуют маршрутизаторы, у которых есть

ошибки в программном или аппаратном обеспечении

и которые изменяют биты в датаграммах, которые

они маршрутизируют. Эти ошибки не могут быть

выявлены в UDP датаграммах, если отключена опция

контрольной суммы. Также необходимо отметить,

что некоторые протоколы канального уровня

(например, SLIP) не имеют каких-либо форм расчета

контрольной суммы для данных в канале.</small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">Требования к хостам <a NAME="t113006"></a>Host Requirements RFC требуют, чтобы расчет

контрольной суммы UDP был включен по умолчанию.

Также они требуют, чтобы принятая контрольная

сумма обязательно проверялась, если ее рассчитал

отправитель (в том случае, если принятая

контрольная сумма не нулевая). Некоторые


реализации игнорируют это и проверяют принятую

контрольную сумму в том случае, если включена

опция расчета исходящей контрольной суммы.</font></p>

</font>



<p>&nbsp;</p>

<font size="3"><i><b>



<p>Вывод команды tcpdump</p>

</b></i></font>



<p><small>Довольно сложно определить, включена ли

опция расчета <a NAME="t113007"></a>контрольной суммы UDP на

конкретной системе. Обычно приложение не имеет

доступа к полю контрольной суммы принятого UDP

заголовка. Чтобы решить эту проблему, автор

добавил еще одну опцию к программе <a NAME="t113008"></a>tcpdump,

после чего та стала выдавать полученные

контрольные суммы UDP. Если полученное значение

равно 0, это означает, что отправитель не

рассчитал контрольную сумму. </small></p>



<p><small>На рисунке 11.4 показан вывод к трем системам

и от тех же трех различных систем в нашей сети. Мы

запустили программу <a NAME="t113009"></a>sock (<a HREF="glavaC.html">приложение

С</a>), послав единственную UDP датаграмму с 9

байтами данных на стандартный эхо сервер.<a NAME="t113010"></a></small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>1&nbsp;&nbsp; 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.1900

&gt; gemini.echo: udp 9 (UDP cksum=6e90)<br>

2&nbsp;&nbsp; 0.303755 ( 0.3038)&nbsp;&nbsp;&nbsp;&nbsp; gemini.echo &gt; sun.1900: udp 9

(UDP cksum=0)<br>

<br>

3&nbsp; 17.392480 (17.0887)&nbsp;&nbsp;&nbsp;&nbsp; sun.1904 &gt; aix.echo: udp 9 (UDP

cksum=6e3b)<br>

4&nbsp; 17.614371 ( 0.2219)&nbsp;&nbsp;&nbsp;&nbsp; aix.echo &gt; sun.1904: udp 9 (UDP

cksum=6e3b)<br>

<br>

5&nbsp; 32.092454 (14.4781)&nbsp;&nbsp;&nbsp;&nbsp; sun.1907 &gt; solaris.echo: udp 9 (UDP

cksum=6e74)<br>

6&nbsp; 32.314378 ( 0.2219)&nbsp;&nbsp;&nbsp;&nbsp; solaris.echo &gt; sun.1907: udp 9 (UDP

cksum=6e74)<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Рисунок 11.4 Вывод tcpdump, с помощью которого

можно определить, включена ли опция контрольной

суммы UDP на конкретном хосте.</small></p>



<p>&nbsp;</p>



<p><small>Отсюда мы видим, что у двух из трех систем

опция контрольной суммы UDP включена. </small></p>



<p><small>Также обратите внимание на то, что

исходящая датаграмма имеет такую же контрольную

сумму, как и входящая датаграмма (строки 3 и 4, 5 и 6).

На рисунке&nbsp;11.3, можно заметить, что два IP адреса

поменяны местами, так же, как и два номера порта.

Другие поля в псевдозаголовке и заголовке UDP

остались те же, так как данные были отражены эхом.

Это подтверждает, что контрольная сумма UDP (а в

действительности, и все контрольные суммы в

семействе протоколов TCP/IP) это простая 16-битовая

сумма. С ее помощью невозможно определить ошибку,

которая заключается в перемене мест двух

16-битных значений.</small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">Автор также направил DNS

запрос на каждый из восьми корневых серверов DNS,

описанных в разделе <a HREF="glava14.html#t142000">&quot;Основы

DNS&quot;</a> главы 14. DNS использует UDP, и только на двух

из восьми была включена опция расчета

контрольной суммы UDP!</font></p>

</font>



<p>&nbsp;</p>

<font size="3"><i><b>



<p>Немного статистики</p>

</b></i></font>



<p><small>[<a NAME="t113011"></a>Mogul 1992] предоставляет некоторую

статистическую информацию о появлении <a NAME="t113012"></a>ошибок

контрольных сумм на довольно загруженном NFS

сервере, который работал в течение 40 дней. На

рисунке 11.5 приведены статистические данные.<a NAME="t113013"></a></small></p>



<p>&nbsp;</p>

</font>



<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="616">

  <tr>

    <td WIDTH="17%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small><font FACE="Arial">Уровень</font></small></td>

    <td WIDTH="42%" VALIGN="TOP" BGCOLOR="#ffffff"><font FACE="Arial"><p ALIGN="CENTER"><small>Количество

    ошибок в контрольных суммах</small></font></td>

    <td WIDTH="41%" VALIGN="TOP" BGCOLOR="#ffffff"><font FACE="Arial"><p ALIGN="CENTER"><small>Приблизительное

    количество пакетов</small></font></td>

  </tr>

  <tr>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><small>Ethernet</small></font></td>

    <td WIDTH="42%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>446</small></font></td>

    <td WIDTH="41%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>170.000.000</small></font></td>

  </tr>

  <tr>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><small>IP</small></font></td>

    <td WIDTH="42%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>14</small></font></td>

    <td WIDTH="41%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>170.000.000</small></font></td>

  </tr>

  <tr>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><small>UDP</small></font></td>

    <td WIDTH="42%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>5</small></font></td>

    <td WIDTH="41%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>140.000.000</small></font></td>

  </tr>

  <tr>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><small>TCP</small></font></td>

    <td WIDTH="42%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>350</small></font></td>

    <td WIDTH="41%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>30.000.000</small></font></td>

  </tr>

</table>

<font FACE="Arial">



<p><small>Рисунок 11.5 Статистика поврежденных

пакетов, определенных с использованием

контрольных сумм. </small></p>



<p>&nbsp;</p>



<p><small>В последней колонке приведено

приблизительное количество пакетов, так как и

другие протоколы используют Ethernet и IP уровень.

Например, не все Ethernet фреймы используются IP

датаграммами, ARP также использует Ethernet. Не все IP

датаграммы используются UDP или TCP, так как ICMP

также использует IP. </small></p>



<p><small>Обратите внимание на то, что выявлено

значительно больше ошибок <a NAME="t113014"></a>контрольных

сумм TCP, чем UDP. Это скорее всего вызвано тем, что с

помощью TCP обычно устанавливаются &quot;дальние&quot;

соединения (которые проходят через много

маршрутизаторов, мостов и так далее), тогда как UDP

траффик обычно локальный. </small></p>



<p><small>Поэтому ошибки, приведенные в нижней

строке, не всегда имеют отношение к канальному

уровню (Ethernet, Token ring). При передаче данных следует

всегда включать опцию <a NAME="t113015"></a>контрольную

сумму в оконечных точках. Однако, если

передаваемые данные представляют определенную

ценность, не стоит полностью доверять <a NAME="t113016"></a>контрольным

суммам UDP или TCP, так как это простые контрольные

суммы, и они не гарантируют, что защитят данные от

всех возможных ошибок. </small></p>

<font size="3"><u><b>



<p><a NAME="t114000"></a>Простой пример</p>

</b></u></font>



<p><small>Мы воспользуемся программой sock, чтобы

сгенерировать несколько UDP датаграмм, которые мы

просмотрим с использованием <a NAME="t114001"></a>tcpdump: </small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="1">



<p></font><font FACE="Courier New" size="2">bsdi % <b>sock -v -u -i -n4 svr4 discard<br>

</b>connected on 140.252.13.35.1108 to 140.252.13.34.9<br>

<br>

bsdi % <b>sock -v -u -i -n4 -w0 svr4 discard<br>

</b>connected on 140.252.13.35.1110 to 140.252.13.34.9</font><font FACE="Arial">&nbsp;</p>



<p>&nbsp;</p>



<p><small>В первом случае запуска программы

установлен отладочный режим (<a NAME="t114002"></a>-v), при

этом можно просмотреть номера динамически

назначаемых портов, указан UDP (<a NAME="t114003"></a>-u)

вместо TCP по умолчанию и установлен режим

источника, опция (<a NAME="t114004"></a>-i) , это означает,

что мы будем посылать данные, а не будем читать из

стандартного ввода или писать в стандартный

вывод. Опция <a NAME="t114005"></a>-n4 сообщает о

необходимости выдать 4 датаграммы (вместо того,

чтобы выдавать по умолчанию 1024) на хост

назначения svr4. Сервис discard описан в разделе <a HREF="glava1.html#t01C000">&quot;Стандартные простые сервисы&quot;</a>

главы 1. Мы используем размер вывода по умолчанию

в 1024 байта на одну запись. </small></p>



<p><small>Второй раз мы запустили программу, указав <a NAME="t114006"></a>-w0, при этом будут выдаваться

датаграммы нулевой длины. На рисунке 11.6 показан

вывод команды tcpdump для двух примеров.<a NAME="t114007"></a></small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">




<p>1&nbsp;&nbsp; 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1108

&gt; svr4.discard: udp 1024<br>

2&nbsp;&nbsp; 0.002424 ( 0.0024)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1108 &gt; svr4.discard: udp

1024<br>


3&nbsp;&nbsp; 0.006210 ( 0.0038)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1108 &gt; svr4.discard: udp

1024<br>

4&nbsp;&nbsp; 0.010276 ( 0.0041)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1108 &gt; svr4.discard: udp

1024<br>

<br>

5&nbsp; 41.720114 (41.7098)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1110 &gt; svr4.discard: udp 0<br>

6&nbsp; 41.721072 ( 0.0010)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1110 &gt; svr4.discard: udp 0<br>

7&nbsp; 41.722094 ( 0.0010)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1110 &gt; svr4.discard: udp 0<br>

8&nbsp; 41.723070 ( 0.0010)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1110 &gt; svr4.discard: udp 0<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Рисунок 11.6 Вывод команды tcpdump для случая,

когда UDP датаграммы посылаются в одном

направлении.</small></p>



<p>&nbsp;</p>



<p><small>В выводе показаны четыре датаграммы

размером 1024 байта, за которыми следуют четыре

датаграммы нулевой длинны. Каждая датаграмма

следует за предыдущей с интервалом в несколько

миллисекунд. (Для того чтобы ввести вторую

команду, потребовалась 41 секунда.) </small></p>



<p><small>До того как была отправлена первая

датаграмма, соединения между отправителем и

получателем не существовало. (В <a HREF="glava17.html">главе

17</a>, где рассказывается о TCP, мы покажем, что перед

тем как будет отправлен первый байт данных,

должно быть установлено соединение.) Необходимо

отметить, что получатель не выдает

подтверждение, когда получает данные.

Отправитель, в этом примере, не имеет

представления о том, получены ли данные на

удаленном конце. </small></p>



<p><small>И в завершение, обратите внимание, что номер

порта источника UDP меняется каждый раз при

запуске программы. Сначала порт был 1108, затем 1110.

В разделе <a HREF="glava1.html#t019000">&quot;Номера портов&quot;</a>

главы 1 мы показали, что номера динамически

назначаемых портов, используемых клиентами,

обычно находятся в диапазоне от 1024 до 5000.</small></p>

<font size="3"><u><b>




<p><a NAME="t115000"></a>Фрагментация IP</p>

</b></u></font>



<p><small>Как мы указали в разделе <a HREF="glava2.html#t028000">&quot;MTU&quot;</a>

главы 2, физический сетевой уровень обычно имеет

ограничение максимального размера фрейма,

который может быть передан. Когда IP уровень

получает IP датаграмму, которую необходимо

отправить, он определяет, на какой локальнй

интерфейс отправляется датаграмма (или

маршрутизируется), и запрашивает интерфейс,

чтобы тот сообщил размер своего MTU. IP сравнивает

MTU с размером датаграммы и, если необходимо,

осуществляет фрагментацию. Фрагментация может

быть осуществлена как на отправляющем хосте, так

и на промежуточном маршрутизаторе. </small></p>



<p><small>Когда IP датаграмма фрагментирована, она не

собирается вновь до тех пор, пока не достигнет

конечного пункта назначения. (Для некоторых

других сетевых протоколов процесс повторной

сборки отличается от описанного выше, при этом <a NAME="t115001"></a>повторная сборка осуществляется на

маршрутизаторе следующей пересылки, а не в

конечном пункте назначения.) На уровне IP сборка

осуществляется в конечном пункте назначения. Это

сделано для того, чтобы сделать фрагментацию и

повторную сборку прозрачной для транспортных

уровней (TCP и UDP), хотя это может вести к некоторой

потере производительности. Существует


вероятность, что фрагмент датаграммы будет снова

фрагментирован (возможно даже несколько раз).

Информации, которая содержится в IP заголовке

вполне достаточно для фрагментации и повторной

сборки. </small></p>



<p><small>Вернемся снова к IP заголовку (см. <a HREF="glava3.html#t032001">рисунок 3.1</a>) и рассмотрим, какие

поля используются в процессе фрагментации. <a NAME="t115002"></a>Поле идентификации содержит значение

уникальное для каждой отправленной IP датаграммы.

Это значение копируется в каждый фрагмент

конкретной датаграммы. В поле флагов один бит

означает, что &quot;дальше следуют еще фрагменты&quot;


(more fragments). Этот бит устанавливается в единицу для

каждого фрагмента, кроме последнего. <a NAME="t115003"></a>Поле

смещения фрагмента (fragment offset) содержит смещение

этого фрагмента от начала исходной датаграммы.

Когда датаграмма фрагментируется, <a NAME="t115004"></a>поле

полной длины каждого фрагмента изменяется, так

чтобы соответствовать размеру фрагмента. </small></p>



<p><small>И в заключение, один из битов в поле флагов

называется <a NAME="t115005"></a>&quot;не фрагментировать&quot;

(don't fragment). Если этот бит установлен в единицу, IP не

будет фрагментировать датаграмму. Вместо этого

датаграмма уничтожается, а отправителю

посылается ICMP ошибка <a NAME="t115006"></a>&quot;фрагментация

необходима, однако установлен бит не

фрагментировать&quot; (fragmentation needed but don't fragment bit set).

Мы рассмотрим эту ошибку более подробно в

следующем разделе. </small></p>



<p><small>Когда IP датаграмма фрагментируется, каждый

фрагмент становится пакетом, с собственным IP

заголовком, и маршрутизируется независимо от

других пакетов. Поэтому становится возможным,

что датаграммы прибудет в конечный пункт

назначения в другом порядке, нежели они были

исходно отправлены и фрагментированы. Однако, в IP

заголовке хранится достаточно информации для

того, чтобы датаграмма была собрана корректно. </small></p>



<p><small>Несмотря на то, что процесс фрагментации IP

выглядит довольно прозрачным, существует одна

особенность, которая делает его не всегда

желательным: если один фрагмент потерялся,

датаграмма должна быть целиком <a NAME="t115007"></a>повторно

передана. Это объясняется тем, что IP не имеет

тайм-аутов и не осуществляет повторной передачи -

за это несут ответственность верхние уровни. (TCP

осуществляет тайм-аут и повторную передачу, UDP -

нет. Некоторые UDP приложения осуществляют

тайм-аут и повторную передачу самостоятельно.)

Когда потерялся фрагмент из TCP сегмента, TCP

отработает тайм-аут и повторно передаст TCP

сегмент целиком (IP датаграмма). Не существует

способа повторно передать только один фрагмент

датаграммы. И действительно, если фрагментация

была осуществлена промежуточным

маршрутизатором, а не отправляющей системой,

отправляющая система не сможет знать как

датаграмма была фрагментирована в процессе

передачи. Именно по этой причине (всего одной)

фрагментации стараются избежать. <a NAME="t115008"></a>[Kent

and Mogul 1987] приводят аргументы, которые доказывают

необходимость избегать фрагментации. </small></p>



<p><small>С использованием UDP довольно легко добиться

IP фрагментации. (Позже мы увидим, что TCP старается

избежать фрагментации, и для приложения

практически невозможно заставить TCP отправлять

сегменты, которые нуждаются в фрагментации. То

есть, другими словами, отправить сегмент такого

размера, для которого потребуется фрагментация,

практически невозможно.) Мы воспользуемся

программой <a NAME="t115009"></a>sock, чтобы увеличить

размер датаграммы, с таким расчетом, чтобы была

осуществлена фрагментация. Максимальный размер

данных во фрейме Ethernet составляет 1500 байт (<a HREF="glava2.html#t022001">рисунок 2.1</a>), при этом 1472 байта

предназначены для пользовательских данных, 20

байт отводится под IP заголовок и 8 байт под UDP

заголовок. Запустим программу sock с размером

данных 1471, 1472, 1473 и 1474 байта. Мы ожидаем, что в двух

последних случаях произойдет фрагментация:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="1">



<p></font><font FACE="Courier New" size="2">bsdi % <b>sock -u -i -n1 -w1471 svr4 discard<br>

</b>bsdi % <b>sock -u -i -n1 -w1472 svr4 discard<br>

</b>bsdi % <b>sock -u -i -n1 -w1473 svr4 discard<br>

</b>bsdi % <b>sock -u -i -n1 -w1474 svr4 discard</b></font><font FACE="Arial">&nbsp;</p>



<p>&nbsp;</p>



<p><small>На рисунке 11.7 показан соответствующий

вывод команды <a NAME="t115010"></a>tcpdump.<a NAME="t115011"></a></small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>1&nbsp;&nbsp; 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1112

&gt; svr4.discard: udp 1471<br>

2&nbsp; 21.008303 (21.0083)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1114 &gt;

svr4.discard: udp 1472<br>

<br>

3&nbsp; 50.449704 (29.4414)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1116 &gt;

svr4.discard: udp 1473 (frag 26304:1480@0+)<br>

4&nbsp; 50.450040 ( 0.0003)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi &gt; svr4:

(frag 26304:1@1480)<br>

<br>

5&nbsp; 75.328650 (24.8786)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1118 &gt;

svr4.discard: udp 1474 (frag 26313:1480@0+)<br>

6&nbsp; 75.328982 ( 0.0003)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi &gt; svr4:

(frag 26313:2@1480)<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Рисунок 11.7 Наблюдения за фрагментацией UDP

датаграмм.</small></p>



<p>&nbsp;</p>



<p><small>Первые две UDP датаграммы (строки 1 и 2)

помещаются в Ethernet фреймы и не фрагментируются.

Однако, длина IP датаграммы, в которую необходимо

записать 1473 байта данных, составляет 1501 байт,

поэтому она должна быть фрагментирована (строка 3

и 4). Точно так же, длина датаграммы, в которую

необходимо записать 1474 байта данных, будет

составлять 1502 байта, и она также должна быть

фрагментирована (строки 5 и 6). </small></p>



<p><small>Когда IP датаграмма фрагментирована, tcpdump

выводит дополнительную информацию. Во-первых,

выводится флаг frag 26304 (строки 3 и 4) и флаг frag 26313

(строки 5 и 6), который указывает на значение поля

идентификации в IP заголовке. </small></p>



<p><small>Число 1480 в строке 3 (между двоеточием и


символом @), это размер, за исключением IP

заголовка. Первые фрагменты обеих датаграмм

содержит 1480 байт данных: 8 байт UDP заголовока и 1472

байта пользовательских данных. (Если добавить 20

байт IP заголовка, получится точно размер пакета -

1500 байт.) Второй фрагмент первой датаграммы

(строка 4) содержит 1 байт данных - оставшийся байт

пользовательских данных. Второй фрагмент второй

датаграммы (строка 6) содержит 2 оставшихся байта

пользовательских данных. </small></p>



<p><small>При фрагментации требуется, чтобы порция

данных генерируемых фрагментов (за исключением IP

заголовока) была кратна 8 байтам для всех

фрагментов за исключением последнего. В этом

примере, число 1480 кратно восьми. </small></p>



<p><small>Число, следующее за символом @, это смещение

данных во фрагменте от начала датаграммы. Первый

фрагмент обеих датаграмм начинается с нуля

(строки 3 и 5), а второй фрагмент обеих датаграмм

начинается со смещения в 1480 байт (строки 4 и 6).

Символ плюс, который следует за смещением и

напечатан для первых фрагментов обеих датаграмм,

означает, что в данной датаграмме присутствуют

еще фрагменты. Знак плюс соответствует биту

&quot;дальше следуют еще фрагменты&quot; (more fragments) в

3-битовом поле флагов IP заголовка. Назначение

этого бита заключается в том, чтобы сообщить

принимающему о том, что сборка всех фрагментов

датаграммы полностью завершена. </small></p>



<p><small>И в завершение, обратите внимание на то, что

в строках 4 и 6 (не первые фрагменты) не указан

протокол (UDP), а также порты источника и

назначения. Протокол должен быть напечатан, так

как он находится в IP заголовке, который

копируется в каждый фрагмент. А номера портов

находятся в UDP заголовке, который присутствует

только в первом фрагменте. На рисунке 11.8

показано, что произойдет с третьей датаграммой

(которая содержит 1473 байта пользовательских

данных). Здесь мы видим подтверждение того, что

заголовок любого транспортного уровня

присутствует только в первом фрагменте. </small></p>



<p><small>Хочется обратить внимание на терминологию: <a NAME="t115012"></a>IP датаграмма (IP datagram) это блок, который

передается от одного конца IP уровня к другому

концу IP уровня (перед фрагментацией и после

повторной сборки), тогда как <a NAME="t115013"></a>пакет

(packet) это блок данных, который передается между IP

уровнем и канальным уровнем. Пакет может быть

полной IP датаграммой или всего лишь фрагментом IP

датаграммы.<a NAME="t115014"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t11_8.jpg" WIDTH="531" HEIGHT="223"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 11.8 Пример UDP фрагментации.</small></p>

<font size="3"><u><b>



<p><a NAME="t116000"></a>ICMP ошибки о недоступности

(требуется фрагментация) </p>

</b></u></font>



<p><small>Необходимо обсудить еще одну ICMP ошибку о

недоступности. Она генерируется, когда

маршрутизатор принимает датаграмму, которую

необходимо фрагментировать, однако в IP заголовке

установлен флаг <a NAME="t116001"></a>&quot;не

фрагментировать&quot; (DF). Эта ошибка может быть

использована программой, которой необходимо

определить минимальный MTU в маршруте до пункта

назначения - что называется <a NAME="t116002"></a>механизмом

определения транспортного MTU (path MTU discovery) (глава 2,

раздел <a HREF="glava2.html#t029000">&quot;Транспортный MTU&quot;</a>). </small></p>



<p><small>На рисунке 11.9 показан формат ICMP ошибки о

недоступности для данного случая. Он отличается

от формата, приведенного на <a HREF="glava6.html#t065001">рисунке

6.10</a>, потому что биты 16-31 во втором 32-битном слове

могут содержать MTU следующей пересылки, вместо

того чтобы быть установленными в 0.<a NAME="t116003"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t11_9.jpg" WIDTH="514" HEIGHT="168"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 11.9 ICMP ошибка о

недоступности, когда необходима фрагментация,

однако установлен бит &quot;не фрагментировать&quot;.</small></p>



<p>&nbsp;</p>



<p><small>Если маршрутизатор не поддерживает этот

новый формат ICMP ошибки, MTU следующей пересылки

устанавливается в 0. </small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">Новые требования к

маршрутизаторам <a NAME="t116004"></a>Router Requirements RFC [<a NAME="t116005"></a>Almquist 1993] указывают на то, что

маршрутизатор должен генерировать эту новую

форму, когда выдает ICMP сообщение о недоступности.</font></p>

</font>



<p>&nbsp;</p>

<font size="3"><i><b>



<p>Пример</p>

</b></i></font>



<p><small>Проблема, которую мы обсудим, возникла при

получении ICMP ошибки при попытке определить MTU SLIP

канала с дозвоном между маршрутизатором netb и

хостом sun. Мы знаем MTU этого канала от sun к netb, так

как, во-первых, это указывается при конфигурации

SLIP на хосте sun, во-вторых, мы видели MTU при запуске

команды <a NAME="t116006"></a>netstat в разделе <a HREF="glava3.html#t039000">&quot;Команда netstat&quot;</a> главы 3. А

сейчас мы хотим определить MTU в другом

направлении. (В <a HREF="glava25.html">главе 25</a>

рассказывается как определить MTU с

использованием SNMP.) Для каналов точка-точка нет

необходимости, чтобы MTU был одним и тем же в обоих

направлениях. </small></p>



<p><small>Для определения использована следующая

техника. Мы запустили <a NAME="t116007"></a>ping с хоста <a NAME="t116008"></a>solaris на хост bsdi, увеличивая размер

пакета данных до тех пор, пока к пакетам не была

применена фрагментация. Процесс показан на

рисунке&nbsp;11.10.<a NAME="t116009"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t11_10.jpg" WIDTH="492" HEIGHT="167"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 11.10 Системы, которые были

использованы для определения MTU SLIP канала между

netb и sun.</small></p>



<p>&nbsp;</p>



<p><small>На хосте sun была запущена программа <a NAME="t116010"></a>tcpdump, которая позволила посмотреть, как

осуществляется фрагментация в SLIP канале.

Фрагментация не появлялась и все было отлично до

тех пор, пока размер данных в пакете ping не возрос

от 500 байт до 600. Входящие эхо запросы были видны

(как будто фрагментации не было), однако эхо

отклики исчезли. </small></p>



<p><small>Чтобы лучше разобраться в происходящем,

программа tcpdump также была запущена на bsdi, после

чего стало видно, что отправляется и что

принимается. На рисунке 11.11 показан вывод.<a NAME="t116011"></a></small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>1&nbsp; 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; solaris

&gt; bsdi: icmp: echo request (DF)<br>

2&nbsp; 0.000000 (0.0000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi &gt; solaris: icmp:

echo reply (DF)<br>

3&nbsp; 0.000000 (0.0000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; bsdi: icmp: solaris

unreachable - <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; need

to frag, mtu = 0 (DF)<br>

<br>

4&nbsp; 0.738400 (0.7384)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; solaris &gt; bsdi: icmp:

echo request (DF)<br>

5&nbsp; 0.748800 (0.0104)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi &gt; solaris: icmp:

echo reply (DF)<br>

6&nbsp; 0.748800 (0.0000)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; bsdi: icmp: solaris

unreachable - <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; need

to frag, mtu = 0 (DF)<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Рисунок 11.11 Вывод программы tcpdump от ping на bsdi

от solaris с IP датаграммой размером в 600 байт.</small></p>



<p>&nbsp;</p>



<p><small>Во-первых, выражение (DF) в каждой строке

означает, что в единицу установлен бит &quot;не

фрагментировать&quot; в IP заголовке. Это означает,

что Solaris 2.2 нормально устанавливает этот бит в

единицу, что является частью механизма

определения транспортного MTU. </small></p>



<p><small>Строка 1 указывает, что эхо запрос проходит

через маршрутизатор netb к sun без фрагментации и с

установленным битом DF, поэтому можно сделать

вывод, что критичный размер MTU для SLIP хоста netb еще

не достигнут. </small></p>



<p><small>Также, заметьте из строки номер 2, что DF флаг

копируется в каждый эхо отклик. Как раз это и

вызвало проблему. Эхо отклик того же размера, что

и эхо запрос (чуть больше 600 байт), однако MTU

исходящего SLIP интерфейса хоста sun равен 552. Эхо

отклик должен быть фрагментирован, однако

установлен флаг DF. Это заставляет sun генерировать

ICMP ошибку о недоступности и отправлять ее к bsdi

(где она уничтожается). </small></p>



<p><small>Именно поэтому мы не видели эхо отклики от

solaris. Отклики не проходили через sun. На рисунке 11.12

показан путь прохождения пакетов.<a NAME="t116012"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t11_12.jpg" WIDTH="492" HEIGHT="217"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 11.12 Обмен пакетами для

данного примера.</small></p>



<p>&nbsp;</p>



<p><small>И в завершение, отметим, что выражение mtu=0 в

строках 3 и 6 на рисунке&nbsp;11.11 указывает на то, что

sun не возвращает MTU для исходящего интерфейса в ICMP

сообщении о недоступности, как показано на

рисунке 11.9. (В разделе <a HREF="glava25.html#t259000">&quot;Дополнительные

примеры&quot;</a> главы 25 мы решим эту проблему с

использованием SNMP и убедимся в том, что MTU SLIP

интерфейса netb равен 1500.) </small></p>

<font size="3"><u><b>



<p><a NAME="t117000"></a>Определение транспортного MTU с

использованием Traceroute</p>

</b></u></font>



<p><small>Так как большинство систем не поддерживают

функцию определения транспортного MTU, мы

доработаем программу <a NAME="t117001"></a>traceroute (<a HREF="glava8.html">глава 8</a>) так, чтобы она могла

определять транспортный MTU. Мы отправим пакет с

установленным битом &quot;не фрагментировать&quot;

(don't fragment). Размер первого отправляемого пакета

будет равен MTU исходящего интерфейса. Когда

вернется ICMP ошибка &quot;не могу

фрагментировать&quot; (can't fragment), мы уменьшим размер

пакета. Если маршрутизатор, отправивший ICMP

ошибку, поддерживает новую версию, которая

включает MTU исходящего интерфейса в ICMP сообщение,

мы используем полученное значение; иначе мы

попробуем следующий меньший MTU. Как утверждает RFC

1191 [<a NAME="t117002"></a>Mogul and Deering 1990], существует

ограниченное количество значений MTU, наша

программа имеет таблицу возможных значений и

просто перейдет на следующее меньшее значение. </small></p>



<p><small>Попробуем подобный алгоритм с хоста sun на

хост slip, зная, что SLIP канал имеет MTU равный 296: </small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>sun % <b>traceroute.pmtu slip</b><br>

traceroute to slip (140.252.13.65), 30 hops max<br>

outgoing MTU = 1500<br>

1 bsdi (140.252.13.35)&nbsp; 15 ms&nbsp; 6 ms&nbsp; 6 ms<br>

2 bsdi (140.252.13.35)&nbsp; 6 ms<br>

fragmentation required and DF set, trying new MTU = 1492<br>

fragmentation required and DF set, trying new MTU = 1006<br>

fragmentation required and DF set, trying new MTU = 576<br>

fragmentation required and DF set, trying new MTU = 552<br>

fragmentation required and DF set, trying new MTU = 544<br>

fragmentation required and DF set, trying new MTU = 512<br>

fragmentation required and DF set, trying new MTU = 508<br>

fragmentation required and DF set, trying new MTU = 296<br>

2 slip (140.252.13.65)&nbsp; 377 ms&nbsp; 377 ms&nbsp; 377 ms<br>

</p>



<p>&nbsp;</p>

</font><font FACE="Arial">



<p><small>В этом примере маршрутизатор bsdi не вернул MTU

исходящего интерфейса в ICMP сообщении, поэтому мы

перейдем на следующее меньшее значение MTU. Первая

строка вывода для <a NAME="t117003"></a>TTL равного 2

сообщает имя хоста bsdi, однако это происходит

из-за того, оно было возвращено маршрутизатором в

ICMP ошибке. Последняя строка вывода для TTL равного

2 это как раз то, что мы ожидали. </small></p>



<p><small>Не составляет труда модифицировать ICMP код

на bsdi, чтобы получить MTU исходящего интерфейса. И

если мы сделаем это и вернемся к нашей программе,

то получим следующий вывод: </small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>sun % <b>traceroute.pmtu slip</b><br>

traceroute to slip (140.252.13.65), 30 hops max<br>

outgoing MTU = 1500<br>

1 bsdi (140.252.13.35)&nbsp; 53 ms&nbsp; 6 ms&nbsp; 6 ms<br>

2 bsdi (140.252.13.35)&nbsp; 6 ms<br>

fragmentation required and DF set, next hop MTU = 296<br>

2 slip (140.252.13.65)&nbsp; 377 ms&nbsp; 378 ms&nbsp; 377 ms<br>

</p>



<p>&nbsp;</p>

</font><font FACE="Arial">



<p><small>Здесь нам нет смысла перебирать восемь

различных значений MTU, маршрутизатор сообщил

нужное значение.</small></p>

<font size="3"><i><b>



<p><a NAME="t117004"></a>Мировой Internet</p>

</b></i></font>



<p><small>Модифицированная версия traceroute была

запущена несколько раз на различные хосты по

всему миру. С ее помощью было достигнуто 15 стран

(включая Антарктику), при этом были использованы

различные трансатлантические и

транстихоокеанские каналы. Однако, до того как

сделать это, мы увеличили MTU SLIP канала с дозвоном

между нашей подсетью и маршрутизатором netb

(рисунок 11.12) до 1500, как в Ethernet. </small></p>



<p><small>Из 18 раз, когда была запущена программа,

только в двух случаях траспортный MTU был меньше

чем 1500. Один трансатлантический канал имел MTU

равный 572 (странное значение, которое даже не

приведено в списке в RFC 1191), и маршрутизатор не

вернул ICMP ошибку в новом формате. Еще один канал

между двумя маршрутизаторами в Японии не

обрабатывал фреймы размером 1500 байт, также

маршрутизатор не вернул ICMP ошибку в новом

формате. После того как MTU было уменьшено до 1006,

все заработало. </small></p>



<p><small>Вывод, который мы можем сделать из этих

экспериментов, заключается в том, что

большинство (но не все) глобальных сетей в

настоящее время могут обрабатывать пакеты

больше чем 512 байт. Использование характеристики

поиска транспортного MTU позволяет приложениям

работать значительно продуктивнее, пользуясь

большими MTU.</small></p>

<font size="3"><u><b>



<p><a NAME="t118000"></a>Определение транспортного MTU при

использовании UDP</p>

</b></u></font>



<p><small>Давайте рассмотрим взаимодействие между

приложением, использующим UDP, и механизмом

определения транспортного MTU. Нам необходимо

посмотреть, что произойдет в том случае, когда

приложение отправляет датаграмму, которая

слишком велика для некоторого промежуточного

канала. </small></p>

<font size="3"><i><b>



<p>Пример</p>

</b></i></font>



<p><small>Так как единственная система, которая

поддерживает механизм определения

транспортного MTU, это <a NAME="t118001"></a>Solaris 2.x, мы

используем ее как хост источник, чтобы отправить

датаграмму размером 650 байт на slip. Так как хост slip

находится позади SLIP канала с MTU равным 296, любая UDP

датаграмма больше чем 268 байт (296 - 20 - 8) с

установленным битом &quot;не фрагментировать&quot;

должна вызвать ICMP ошибку &quot;не могу

фрагментировать&quot; с маршрутизатора bsdi. На

рисунке 11.13 показана топология и MTU каналов.<a NAME="t118002"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t11_13.jpg" WIDTH="508" HEIGHT="180"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 11.13 Системы, использованные

для определения транспортного MTU с

использованием UDP.</small></p>



<p>&nbsp;</p>



<p><small>Следующая команда генерирует десять UDP

датаграмм размером 650 байт с интервалом в 5

секунд:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="1">



<p></font><font FACE="Courier New" size="2">solaris % <b>sock -u -i -n10 -w650 -p5 slip

discard</p>

</b></font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>На рисунке 11.14 показан вывод команды <a NAME="t118003"></a>tcpdump. Когда этот пример был запущен,

маршрутизатор bsdi был сконфигурирован таким

образом, чтобы не возвращать MTU следующей

пересылки как часть ICMP ошибки &quot;не могу

фрагментировать&quot;.</small></p>



<p><small>Первая посланная датаграмма с

установленным битом <a NAME="t118004"></a>DF (строка 1)

генерирует ожидаемую ошибку от маршрутизатора

bsdi (строка 2). Что интересно, следующая датаграмма,

также посланная с установленным битом DF (строка

3), генерирует ту же самую ICMP ошибку (строка 4). Мы

ожидали, что эта датаграмма будет послана с

выключенным битом DF.</small></p>



<p><small>В строке 5 IP наконец понял, что датаграммы в

этот пункт назначения не должны посылаться с

установленным битом DF, после чего стал

фрагментировать датаграммы на хосте источнике.

Это поведение отличается от того, что было

показано в ранних примерах, где IP отправлял

датаграммы, которые он получал от UDP, и при этом

маршрутизаторам с более маленькими MTU (bsdi в

данном случае) позволялось осуществлять

фрагментацию.<a NAME="t118005"></a>&nbsp;</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p> 1&nbsp; 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; solaris.38196

&gt; slip.discard: udp 650 (DF)<br>


2&nbsp; 0.004218 (0.0042)&nbsp;&nbsp; bsdi &gt; solaris: icmp: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slip

unreachable - need to frag, mtu = 0 (DF)<br>

<br>

3&nbsp; 4.980528 (4.9763)&nbsp;&nbsp; solaris.38196 &gt; slip.discard: udp 650 (DF)<br>

4&nbsp; 4.984503 (0.0040)&nbsp;&nbsp; bsdi &gt; solaris: icmp: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slip

unreachable - need to frag, mtu = 0 (DF)<br>

<br>

5&nbsp; 9.870407 (4.8859)&nbsp;&nbsp; solaris.38196 &gt; slip.discard: udp 650 (frag

47942:552@0+)<br>

6&nbsp; 9.960056 (0.0896)&nbsp;&nbsp; solaris &gt; slip: (frag 47942:106@552)<br>

<br>

7&nbsp; 14.940338 (4.9803)&nbsp; solaris.38196 &gt; slip.discard: udp 650 (DF)<br>

8&nbsp; 14.944466 (0.0041)&nbsp; bsdi &gt; solaris: icmp: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slip

unreachable - need to frag, mtu = 0 (DF)<br>

<br>

9&nbsp; 19.890015 (4.9455)&nbsp; solaris.38196 &gt; slip.discard: udp 650 (frag

47944:552@0+)<br>

10&nbsp; 19.950463 (0.0604)&nbsp; solaris &gt; slip: (frag 47944:106@552)<br>

<br>

11&nbsp; 24.870401 (4.9199)&nbsp; solaris.38196 &gt; slip.discard: udp 650 (frag

47945:552@0+)<br>

12&nbsp; 24.960038 (0.0896)&nbsp; solaris &gt; slip: (frag 47945:106@552)<br>

<br>

13&nbsp; 29.880182 (4.9201)&nbsp; solaris.38196 &gt; slip.discard: udp 650 (frag

47946:552@0+)<br>

14&nbsp; 29.940498 (0.0603)&nbsp; solaris &gt; slip: (frag 47946:106@552)<br>

<br>

15&nbsp; 34.860607 (4.9201)&nbsp; solaris.38196 &gt; slip.discard: udp 650 (frag

47947:552@0+)<br>

16&nbsp; 34.950051 (0.0894)&nbsp; solaris &gt; slip: (frag 47947:106@552)<br>

<br>

17&nbsp; 39.870216 (4.9202)&nbsp; solaris.38196 &gt; slip.discard: udp 650 (frag

47948:552@0+)<br>

18&nbsp; 39.930443 (0.0602)&nbsp; solaris &gt; slip: (frag 47948:106@552)<br>

<br>

19&nbsp; 44.940485 (5.0100)&nbsp; solaris.38196 &gt; slip.discard: udp 650 (DF)<br>

20&nbsp; 44.944432 (0.0039)&nbsp; bsdi &gt; solaris: icmp: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slip

unreachable - need to frag, mtu = 0 (DF)<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Рисунок 11.14 Определение транспортного MTU с

использованием UDP.</small></p>



<p>&nbsp;</p>



<p><small>Так как ICMP сообщение &quot;не могу

фрагментировать&quot; не содержит MTU следующей

пересылки, это означает, что IP решил что всех

устраивает MTU равный 576. Первый фрагмент (строка 5)

содержит 544 байта UDP данных, 8 байт UDP заголовка и 20

байт IP заголовка, полный размер IP датаграммы

составляет 572 байта. Второй фрагмент (строка 6)

содержит оставшиеся 106 байт UDP данных и 20-байтный

IP заголовок. </small></p>



<p><small>К сожалению, следующая датаграмма, строка 7,

имеет установленный бит DF, поэтому она

отбрасывается bsdi, после чего возвращается ICMP

ошибка. Здесь произошло следующее: истек IP

таймер, который сообщил IP о необходимости

проверить, не увеличился ли транспортный MTU,

путем повторной установки бита DF. Мы увидим, что

это произойдет снова в строках 19 и 20. Сравнивая

времена в строках 7 и 19, где DF бит устанавливается

в единицу, мы видим, что проверка на увеличение

транспортного MTU осуществляется каждые 30 секунд.</small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">Этот 30-секундный таймер

слишком мал. RFC 1191 рекомендует установить

значение таймера в 10 минут. Величину таймера

можно изменить с помощью параметра <a NAME="t118006"></a>ip_ire_pathmtu_interval

(приложение E, раздел <a HREF="glavaE.html#t354000">&quot;Solaris 2.2&quot;</a>).

В <a NAME="t118007"></a>Solaris 2.2 не существует способа

выключить определение транспортного MTU для

одного UDP приложения или для всех UDP приложений.

Оно может быть включено или выключено только для

всей системы в целом с помощью изменения

параметра <a NAME="t118008"></a>ip_path_mtu_discovery. Как мы видим

из данного примера, включение характеристики

определения транспортного MTU, когда UDP приложения

отправляют датаграммы, которые, возможно, будут

фрагментированы, приведет к тому, что датаграмма

может быть отброшена. </font></p>

</font>



<p>&nbsp;</p>



<p><small>Максимальный размер датаграммы,

воспринимаемый IP уровнем на solaris (576 байт),

неверен. На рисунке 11.13 мы видели, что реальный MTU

составляет 296 байт. Это означает, что фрагменты,

генерируемые solaris, снова фрагментируются на bsdi.

На рисунке 11.15 показан вывод <a NAME="t118009"></a>tcpdump,

полученный на хосте назначения (slip) для первой

прибывшей датаграммы (строки 5 и 6 на рисунке 11.14).<a NAME="t118010"></a></small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>1&nbsp; 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; solaris.38196

&gt; slip.discard: udp 650 (frag 47942:272@0+)<br>

2&nbsp; 0.304513 (0.3045)&nbsp;&nbsp;&nbsp;&nbsp; solaris &gt; slip: (frag 47942:272@272+)<br>

3&nbsp; 0.334651 (0.0301)&nbsp;&nbsp;&nbsp;&nbsp; solaris &gt; slip: (frag 47942:8@544+)<br>

4&nbsp; 0.466642 (0.1320)&nbsp;&nbsp;&nbsp;&nbsp; solaris &gt; slip: (frag 47942:106@552)<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Рисунок 11.15 Первая датаграмма, прибывшая на

хост slip от solaris.</small></p>



<p>&nbsp;</p>



<p><small>В этом примере хост solaris не должен

фрагментировать исходящие датаграммы, однако

должен выключить бит DF и позволить

маршрутизатору с меньшим MTU осуществить

фрагментацию. </small></p>



<p><small>Сейчас мы запустим тот же самый пример,

однако изменим поведение маршрутизатора bsdi так,

чтобы тот возвращал MTU следующей пересылки в ICMP

сообщении &quot;не могу фрагментировать&quot;. На

рисунке 11.16 показаны первые шесть строк вывода


tcpdump.<a NAME="t118011"></a></small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>1&nbsp; 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; solaris.37974

&gt; slip.discard: udp 650 (DF)<br>

2&nbsp; 0.004199 (0.0042)&nbsp;&nbsp;&nbsp;&nbsp; bsdi &gt; solaris: icmp: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slip

unreachable - need to frag, mtu = 296 (DF)<br>


<br>

3&nbsp; 4.950193 (4.9460)&nbsp;&nbsp;&nbsp;&nbsp; solaris.37974 &gt; slip.discard: udp 650

(DF)<br>

4&nbsp; 4.954325 (0.0041)&nbsp;&nbsp;&nbsp;&nbsp; bsdi &gt; solaris: icmp: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slip

unreachable - need to frag, mtu = 296 (DF)<br>

<br>

5&nbsp; 9.779855 (4.8255)&nbsp;&nbsp;&nbsp;&nbsp; solaris.37974 &gt; slip.discard: udp 650

(frag 35278:272@0+)<br>

6&nbsp; 9.930018 (0.1502)&nbsp;&nbsp;&nbsp;&nbsp; solaris &gt; slip: (frag 35278:272@272+)<br>

7&nbsp; 9.990170 (0.0602)&nbsp;&nbsp;&nbsp;&nbsp; solaris &gt; slip: (frag 35278:114@544)<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Рисунок 11.16 Определение транспортного MTU с

использованием UDP.</small></p>



<p>&nbsp;</p>



<p><small>И снова мы видим, что две первые датаграммы

отправлены с установленным битом DF, на обе

получены ICMP ошибки. Сейчас в ICMP ошибке

указывается MTU следующей пересылки, который

равен 296. </small></p>



<p><small>В строках 5, 6 и 7 мы видим, что хост источник

осуществляет фрагментацию, как на рисунке 11.14.

Если известен MTU следующей пересылки,

генерируются только три фрагмента, по сравнению

с четырьмя фрагментами, которые генерируются

маршрутизатором bsdi на рисунке 11.15.</small></p>

<font size="3"><u><b>



<p><a NAME="t119000"></a>Взаимодействие между UDP и ARP</p>

</b></u></font>



<p><small>Используя UDP, мы можем рассмотреть очень

интересное взаимодействие между UDP и типичной

реализацией ARP.</small></p>



<p><small>Мы используем программу <a NAME="t119001"></a>sock,

чтобы сгенерировать одну UDP датаграмму с 8192

байтами данных. Мы ожидаем, что в этом случае

будет сгенерировано шесть Ethernet фрагментов (см. <a HREF="#t11D001">упражнение 3</a> главы 11). Также, перед

запуском программы, мы убедимся в том, что ARP кэш

пуст, поэтому перед тем как будет отправлен

первый фрагмент, должен произойти обмен ARP

запросом и откликом.</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>bsdi % <b>arp -a </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; проверяем,

что ARP кэш пуст<br>

bsdi % <b>sock -u -i -n1 -w8192 svr4 discard<br>

</p>

</b></font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Мы ожидаем, что первая датаграмма вызовет

отправку ARP запроса. Следующие пять фрагментов,

которые генерируются IP, ставят перед нами два

вопроса, на которые мы можем ответить, только

воспользовавшись <a NAME="t119002"></a>tcpdump: будут ли

готовы к отправке оставшиеся фрагменты, перед

тем как будет получен ARP отклик, если так, что

будет делать ARP с этими несколькими пакетами

направляемыми на конкретный пункт назначения,

пока ожидается ARP отклик? На рисунке 11.17 показан

вывод программы tcpdump.<a NAME="t119003"></a></small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p> 1&nbsp; 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp

who-has svr4 tell bsdi<br>

2&nbsp; 0.001234 (0.0012)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>

3&nbsp; 0.001941 (0.0007)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>

4&nbsp; 0.002775 (0.0008)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>

5&nbsp; 0.003495 (0.0007)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>

6&nbsp; 0.004319 (0.0008)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp who-has svr4 tell bsdi<br>

7&nbsp; 0.008772 (0.0045)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp reply svr4 is-at

0:0:c0:c2:9b:26<br>


8&nbsp; 0.009911 (0.0011)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp reply svr4 is-at

0:0:c0:c2:9b:26<br>

9&nbsp; 0.011127 (0.0012)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi &gt; svr4: (frag

10863:800@7400)<br>

10&nbsp; 0.011255 (0.0001)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp reply svr4 is-at

0:0:c0:c2:9b:26<br>

11&nbsp; 0.012562 (0.0013)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp reply svr4 is-at

0:0:c0:c2:9b:26<br>

12&nbsp; 0.013458 (0.0009)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp reply svr4 is-at

0:0:c0:c2:9b:26<br>

13&nbsp; 0.014526 (0.0011)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp reply svr4 is-at

0:0:c0:c2:9b:26<br>

14&nbsp; 0.015583 (0.0011)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arp reply svr4 is-at

0:0:c0:c2:9b:26<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Рисунок 11.17 Обмен пакетами при отправке по

Ethernet UDP датаграммы размером 8192 байта.</small></p>



<p>&nbsp;</p>



<p><small>Этот вывод достаточно неожидан. Во-первых,

перед тем как получен первый ARP отклик,

генерируются шесть ARP запросов. Как можно

догадаться, IP быстро генерирует шесть

фрагментов, и для каждого отправляется ARP запрос. </small></p>



<p><small>Затем, когда получен первый ARP отклик

(строка 7), отправляется только последний

фрагмент (строка 9)! Это означает, что первые пять

фрагментов были отброшены. В действительности,

это пример обычного функционирования ARP.

Большинство реализаций держат только последний

пакет, который должен быть отправлен на хост


назначения, пока ожидается ARP отклик. </small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">Требования к хостам <a NAME="t119004"></a>Host Requirements RFC требуют от реализаций,

чтобы они предотвращали <a NAME="t119005"></a>лавинообразную

рассылку ARP запросов (повторная отправка ARP

запросов для одного и того же IP адреса с большой

частотой). Рекомендуемая максимальная частота

составляет один раз в секунду. Здесь мы видим

шесть ARP запросов в течение 4,3 миллисекунды.

Требования к хостам Host Requirements RFC требуют, чтобы ARP

сохранил по крайней мере один пакет, и это должен

быть самый последний пакет. Это как раз то, что мы

видели здесь.</font></p>

</font>



<p>&nbsp;</p>



<p><small>Следующая необъяснимая аномальность

заключается в том, что svr4 отправил назад семь ARP

откликов, а не шесть. </small></p>



<p><small>И последнее, про что хочется сказать, tcpdump

работал еще 5 минут после того, как вернулся

последний ARP отклик, ожидая увидеть, как svr4 пошлет

назад ICMP ошибку <a NAME="t119006"></a>&quot;время истекло в

течение повторной сборки&quot; (time exceeded during reassembly).

ICMP сообщение так и не появилось. (Мы показали

формат этого сообщения на <a HREF="glava8.html#t083001">рисунке

8.2</a>. Поле код, установленное в 1, указывает на то,

что время истекло в течение <a NAME="t119007"></a>повторной

сборки датаграммы.)</small></p>



<p><small>IP уровень должен запустить таймер, когда

появляется первый фрагмент датаграммы. Здесь

&quot;первый&quot; означает первый из прибывших

фрагментов для данной датаграммы, а не просто

первый фрагмент (со <a NAME="t119008"></a>смещением

фрагмента равным 0). Обычное значение тайм-аута

находится в диапазоне от 30 до 60 секунд. Если все

фрагменты для этой датаграммы не прибыли за

время до истечения таймера, все фрагменты

отбрасываются. Если этого не сделать, фрагменты,

которые уже никогда не прибудут (как мы видели в

этом примере), могут вызвать переполнение <a NAME="t119009"></a>приемного буфера. </small></p>



<p><small>Существуют две причины, по которым мы не

увидели ICMP сообщение. Во-первых, большинство

реализаций Berkeley никогда не генерируют эту

ошибку! Эти реализации устанавливают таймер и

отбрасывают все фрагменты, когда таймер истечет,

однако ICMP ошибка не генерируется. Во-вторых,

первый фрагмент - фрагмент со смещением равным 0,

содержащий UDP заголовок, не был принят. (Это был

первый из пяти пакетов, отброшенных ARP.)

Реализация не требует генерировать ICMP ошибку,

если первый фрагмент не был принят. Причина

заключается в том, что приемник ICMP ошибки не

может сказать, который пользовательский процесс

отправил датаграмму, которая была отброшена,

потому что недоступен заголовок транспортного

уровня. А высший уровень (либо TCP приложение, либо

UDP приложение) отработает тайм-аут и повторит

передачу. </small></p>



<p><small>В этом разделе мы использовали IP

фрагментацию, чтобы посмотреть, как

осуществляется взаимодействие между UDP и ARP. Это

взаимодействие можно увидеть, если отправитель

быстро отправит несколько UDP датаграмм. Мы

воспользовались фрагментацией, потому что

пакеты быстро генерируются с помощью IP, что

значительно быстрее, чем генерация нескольких

пакетов пользовательским процессом.</small></p>

<font size="3"><u><b>



<p><a NAME="t11A000"></a>Максимальный размер UDP датаграммы</p>

</b></u></font>



<p><small>Теоретически максимальный размер IP

датаграммы может составлять 65535 байт, что

ограничивается 16-битным полем полной длины в IP

заголовке (см. <a HREF="glava3.html#t032001">рисунок 3.1</a>). При

длине IP заголовка равной 20 байтам и длине UDP

заголовка равной 8 байтам в UDP датаграмме для

пользовательских данных остается максимум 65507

байт. В большинстве реализаций, однако,

используются датаграммы значительно меньшего

размера. </small></p>



<p><small>Обычно играют роль два ограничения.

Во-первых, программа приложение может быть

ограничена программным интерфейсом. <a NAME="t11A001"></a>Сокеты

API (глава 1, раздел <a HREF="glava1.html#t01F000">&quot;Интерфейсы

прикладного программирования&quot;</a>)

предоставляют функцию, которая может быть

вызвана приложением, чтобы установить размер

буферов ввода и вывода. Для UDP сокета этот размер

напрямую связан с максимальным размером UDP

датаграммы, которая может быть прочитана и

записана UDP. В настоящее время большинство систем

предоставляют по умолчанию максимальный размер

UDP датаграммы, которая может быть прочитана или

записана, равный 8192 байтам. (Эта значение

установлено в 8192, потому что именно столько по

умолчанию читается и записывается системой NFS.) </small></p>



<p><small>Следующее ограничение определяется

реализацией ядра TCP/IP. Могут существовать

характеристики реализации (или ошибки), которые

ограничивают размер UDP датаграммы значением

меньшим, чем 65535 байт.</small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">Автор

экспериментировал с различными размерами UDP

датаграмм, используя программу <a NAME="t11A002"></a>sock. С

использованием <a NAME="t11A003"></a>loopback интерфейса под <a NAME="t11A004"></a>SunOS 4.1.3, максимальный размер UDP

датаграммы был 32767 байт. Использовать большее

значение не удавалось. При передаче по Ethernet от <a NAME="t11A005"></a>BSD/386 к SunOS 4.1.3, максимальный размер IP

датаграммы, которую мог принять Sun, составлял 32786

(при этом пользовательских данных было 32758 байт).

С использованием loopback интерфейса в <a NAME="t11A006"></a>Solaris

2.2 максимальный размер IP датаграммы, которая

могла быть отправлена и принята, составлял 65535

байт. При передаче от Solaris 2.2 к <a NAME="t11A007"></a>AIX 3.2.2

удалось передать IP датаграмму максимального

размера в 65535 байт.</font></p>

</font>



<p>&nbsp;</p>




<p><small>В разделе <a HREF="glava3.html#t032000">&quot;IP заголовок&quot;</a>

главы 3 мы упомянули, что хосту необходимо

получать IP датаграммы размером по меньшей мере 576

байт. Большинство приложений UDP разработаны

таким образом, чтобы ограничивать свои

приложения в размере 512 байт данных или меньше,

чтобы уложиться в это ограничение. В разделе <a HREF="glava10.html#t104000">&quot;RIP: протокол обмена информацией

о маршрутизации&quot;</a> главы 10, например, мы

видели, что RIP всегда посылает в датаграмме

меньше чем 512 байт. Это же самое ограничение мы

найдем и в других UDP приложениях: DNS (<a HREF="glava14.html">глава

14</a>), TFTP (<a HREF="glava15.html">глава 15</a>), BOOTP (<a HREF="glava16.html">глава

16</a>) и SNMP (<a HREF="glava25.html">глава 25</a>).</small></p>

<font size="3"><i><b>



<p><a NAME="t11A008"></a>Усечение датаграмм</p>

</b></i></font>



<p><small>Из того что IP может отправлять и принимать

датаграммы определенного размера, не следует,


что принимающее приложение готово прочитать

датаграммы этого размера. Программный интерфейс

UDP позволяет приложениям указывать максимальное

количество байт, которые будут обработаны за

один раз. Что произойдет, если принятая

датаграмма по размеру больше, чем датаграмма,

которую готово принять приложение? </small></p>



<p><small>К сожалению, ответ зависит от программного

интерфейса и реализации.</small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">Традиционные версии

Berkeley сокет API обрезают датаграммы, отбрасывая

любые непоместившиеся данные. Будет ли

приложение поставлено в известность, зависит от

версии. (<a NAME="t11A009"></a>4.3 BSD Reno и более поздние

версии могут уведомить приложение о том, что

датаграмма была обрезана.) <a NAME="t11A010"></a>API сокеты

под <a NAME="t11A011"></a>SVR4 (включая Solaris 2.x) не обрезают

датаграммы. Любые непоместившиеся данные

последовательно считываются. Приложение не

уведомляется о нескольких циклах считывания и

ему будет передана одна UDP датаграмма. TLI API не

отбрасывают данные. Вместо этого возвращается

флаг, указывающий на то, что данных больше, чем

можно считать за один раз, поэтому приложение

начинает последовательно считывать оставшуюся

датаграмму.</font></p>

</font>



<p>&nbsp;</p>



<p><small>Когда мы будем обсуждать TCP, то увидим, что

этот протокол предоставляет последовательные

потоки байт, направляемые в приложение, без

каких-либо ограничений. TCP передает в приложение

данные любого размера, которые требуются для

приложения - причем данные на этом интерфейсе

никогда не теряются. </small></p>

<font size="3"><u><b>



<p><a NAME="t11B000"></a>ICMP ошибка подавления источника</p>

</b></u></font>



<p><small>Воспользовавшись UDP, можно сгенерировать ICMP

ошибку <a NAME="t11B001"></a>&quot;подавление источника&quot;

(source quench). Эта ошибка может быть сгенерирована

системой (маршрутизатором или хостом), когда она

принимает датаграммы быстрее, чем эти датаграммы

могут быть обработаны. Обратите внимание на

выражение &quot;могут быть&quot;. Система не требует

послать подавление источника, даже если буферы

переполнены и датаграммы отбрасываются. </small></p>



<p><small>На рисунке 11.18 показан формат ICMP ошибки

подавления источника. Мы имеем идеальную

возможность сгенерировать подобную ошибку в

нашей тестовой сети. Мы можем посылать

датаграммы с bsdi на маршрутизатор sun по Ethernet,

причем эти датаграммы должны быть

смаршрутизированы через SLIP канал. Так как SLIP

канал примерно в тысячу раз медленнее чем Ethernet,

мы легко можем переполнить буфер. Следующая

команда посылает 100 датаграмм размером 1024 байта с

хоста bsdi через маршрутизатор sun на solaris. Мы

отправляем датаграммы на стандартный discard

сервис, где они будут игнорированы:<a NAME="t11B002"></a></small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="1">



<p></font><font FACE="Courier New" size="2">bsdi % <b>sock -u -i -w1024 -n100 solaris

discard</p>

</b></font><font FACE="Arial">



<p>&nbsp;</p>

</font>



<p ALIGN="CENTER"><small><img SRC="t11_18.jpg" WIDTH="514" HEIGHT="168"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 11.18 ICMP ошибка подавления

источника.</small></p>



<p>&nbsp;</p>



<p><small>На рисунке 11.19 показан вывод команды tcpdump,

соответствующий этой команде.<a NAME="t11B003"></a></small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>&nbsp; 1&nbsp; 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1403 &gt;

solaris.discard: udp 1024<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 26

строк не показано<br>

27&nbsp; 0.10 (0.00)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1403 &gt; solaris.discard: udp 1024<br>

28&nbsp; 0.11 (0.01)&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; bsdi: icmp: source quench<br>

<br>

29&nbsp; 0.11 (0.00)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1403 &gt; solaris.discard: udp 1024<br>

30&nbsp; 0.11 (0.00)&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; bsdi: icmp: source quench<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 142

строки не показано<br>

173&nbsp; 0.71 (0.06)&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1403 &gt; solaris.discard: udp 1024<br>

174&nbsp; 0.71 (0.00)&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; bsdi: icmp: source quench<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Рисунок 11.19 ICMP подавление источника от

маршрутизатора sun.</small></p>



<p>&nbsp;</p>



<p><small>Из этого вывода мы удалили множество строк.

Первые 26 датаграмм приняты без ошибок: мы

показали вывод только для первой. Начиная с 27-й

датаграммы, каждый раз, когда отправляется

датаграмма, мы получаем ошибку подавление

источника. Всего было 26+(74х2)=174 строк вывода. </small></p>



<p><small>Из нашего расчета пропускной способности

последовательной линии, приведенного в разделе <a HREF="glava2.html#t02A000">&quot;Вычисление загруженности

последовательной линии&quot;</a> главы 2, видно, что

на передачу датаграммы размером 1024 байта со

скоростью 9600 бит/сек потребуется больше одной

секунды. (В нашем примере для этого потребуется

больше времени, так как датаграмма размером 20+8+1024

байт будет фрагментирована, потому что MTU SLIP

канала от sun к netb составляет 552 байта.) Однако, из

показателей времени, приведенных на рисунке 11.19,

мы видим, что маршрутизатор sun получил все 100

датаграмм за время меньше чем одна секунда, перед

тем как первая была отправлена в SLIP канал. При

этом понятно, что мы использовали множество его


буферов. </small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">Несмотря на то, что RFC 1009

<a NAME="t11B004"></a>[Braden and Postel 1987] требует, чтобы

маршрутизатор генерировал ошибки подавления

источника, когда переполняются его буферы, новые

требования к маршрутизаторам <a NAME="t11B005"></a>Router

Requirements RFC [<a NAME="t11B006"></a>Almquist 1993] меняют это

положение и говорят, что маршрутизатор не должен

генерировать ошибки подавления источника.</font></p>

</font>



<p>&nbsp;</p>



<p><small>Следующий момент, на который необходимо

обратить внимание в примере, заключается в том,

что программа <a NAME="t11B007"></a>sock никогда не получала

уведомлений о том, что источник подавлен, или

если и получала их, то игнорировала. Это говорит о

том, что реализации BSD обычно игнорируют

полученные сообщения о подавлении источника в

случае использования протокола UDP. (В случае TCP,

при получении уведомления передача данных по

соединению, для которого сгенерировано

подавление источника, замедляется. Мы это

обсудим в разделе <a HREF="glava21.html#t21A000">&quot;ICMP

ошибки&quot;</a> главы 21.) Проблема заключается в том,

что процесс, который сгенерировал данные,

которые, в свою очередь, вызвали подавление

источника, может уже завершиться, когда будет

принято сообщение о подавлении источника. И

действительно, если мы используем программу <a NAME="t11B008"></a>time в Unix, чтобы оценить, как долго

работает программа sock, то узнаем, что она

проработала всего лишь около 0,5 секунды. Однако

на рисунке 11.19 мы видели, что некоторые сообщения

о подавлении источника были получены через 0,71

секунды после отправки первой датаграммы, то

есть уже после того, как процесс прекратил

работу. Что произойдет, если наша программа

выдаст 100 датаграмм и завершится. Не все 100

датаграмм будут посланы - некоторые из них будут

стоять в выходной очереди. </small></p>




<p><small>Этот пример доказывает, что UDP - <a NAME="t11B009"></a>ненадежный

протокол и показывает важность контроля за

потоком данных (flow control). Несмотря на то, что

программа sock успешно выдала в сеть 100 датаграмм,

только 26 достигли пункта назначения. Остальные 74

скорее всего были отброшены промежуточным

маршрутизатором. Если приложение не

поддерживает какую-либо форму уведомлений,

отправитель не знает, принял ли получатель

данные.</small></p>

<font size="3"><u><b>



<p><a NAME="t11C000"></a>Сервер UDP</p>

</b></u></font>



<p><small>Существует несколько особенностей

использования UDP, которые отражаются на

разработке и реализации сервера. Разработка и

реализация клиентов обычно легче, чем реализация

серверов. Именно поэтому здесь мы обсудим

разработку сервера, а не разработку клиента.

Серверы обычно взаимодействуют с операционной

системой, и большинство серверов требуют, чтобы

существовал какой-либо способ, позволяющий

обработать запросы от нескольких клиентов

одновременно. </small></p>



<p><small>Обычно когда клиент стартует, он сразу же

устанавливает соединение с одним сервером.

Сервера, с другой стороны, стартуют и затем

&quot;засыпают&quot;, ожидая прибытия запроса от

клиента. В случае UDP, сервер &quot;просыпается&quot;,

когда прибывает датаграмма от клиента, эта

датаграмма может содержать запрос в какой-либо

форме. </small></p>



<p><small>Мы не будем рассматривать аспекты

программирования клиентов и серверов ([Stevens 1990]

описывает все более подробно), однако рассмотрим

характеристики протокола UDP, которые оказывают

влияние на разработку и реализацию сервера,

использующего UDP. (Мы обсудим подробности TCP

сервера в разделе <a HREF="glava18.html#t18B000">&quot;Реализация

TCP сервера&quot;</a> главы 18.) Некоторые

характеристики мы обсудим в зависимости от

реализаций UDP, которые будут использоваться, а

также рассмотрим характеристики, которые

являются общими для большинства реализаций.</small></p>

<font size="3"><i><b>



<p><a NAME="t11C001"></a>IP адрес клиента и номер порта</p>

</b></i></font>



<p><small>От клиента прибывает UDP датаграмма. IP

заголовок содержит IP адреса источника и

назначения, а UDP заголовок содержит номера портов

UDP источника и назначения. Когда приложение

получает UDP датаграмму, операционная система

должна сообщить ему, кто послал сообщение - IP

адрес источника и номер порта.</small></p>



<p><small>Эта характеристика позволяет одному UDP

серверу обрабатывать несколько клиентов. Каждый

отклик отправляется тому клиенту, который послал

запрос.</small></p>

<font size="3"><i><b>



<p><a NAME="t11C002"></a>IP адрес назначения</p>

</b></i></font>



<p><small>Некоторым приложениям необходимо знать,

кому предназначена датаграмма, то есть IP адрес

назначения. Например, требования к хостам <a NAME="t11C003"></a>Host Requirements RFC определяют, что <a NAME="t11C004"></a>TFTP

сервер должен игнорировать принятые датаграммы,

которые рассылаются на широковещательный адрес.

(Мы опишем широковещательную адресацию в <a HREF="glava12.html">главе 12</a>, а TFTP в <a HREF="glava15.html">главе 15</a>.)</small></p>



<p><small>Это означает, что операционная система

должна передать IP адрес назначения из принятой UDP

датаграммы в приложение. К сожалению, не все

реализации предоставляют эту возможность.</small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0"><a NAME="t11C005"></a>Сокеты API

предоставляют эту возможность с использованием

опции <a NAME="t11C006"></a>IP_RECVDSTADDR. Из систем, которые

описываются в тексте, только <a NAME="t11C007"></a>BSD/386, <a NAME="t11C008"></a>4.4BSD и <a NAME="t11C009"></a>AIX 3.2.2 поддерживают

эту опцию. <a NAME="t11C010"></a>SVR4, <a NAME="t11C011"></a>SunOS 4.x и <a NAME="t11C012"></a>Solaris 2.x не поддерживают.</font></p>

</font>



<p>&nbsp;</p>

<font size="3"><i><b>



<p><a NAME="t11C013"></a>Входная очередь UDP</p>

</b></i></font>



<p><small>В разделе <a HREF="glava1.html#t018000">&quot;Модель

клиент-сервер&quot;</a> главы 1 мы говорили, что


большинство UDP серверов могут обслуживать все

запросы к клиентам с использованием одного UDP

порта (заранее известные порты серверов). </small></p>



<p><small>Обычно размер входной очереди, связанный с

каждым UDP портом, который используется

приложением, ограничен. Это означает, что

запросы, которые прибывают в одно и то же время от

различных клиентов, автоматически ставятся в

очередь UDP. Принятые UDP датаграммы передаются

приложению (когда оно требует следующую

датаграмму) в том порядке, в каком они были

приняты. </small></p>



<p><small>Однако существует вероятность, в случае

если очередь переполнена, что модуль UDP в ядре

отбросит входящие датаграммы. Мы можем

пронаблюдать это с помощью следующего

эксперимента. Стартуем нашу программу sock на

хосте bsdi, запустив таким образом UDP сервер: </small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>bsdi % <b>sock -s -u -v -E -R256 -r256 -P30 6666</b><br>

from 140.252.13.33, to 140.252.13.63: 1111111111

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; от sun на

широковещательный адрес<br>

from 140.252.13.34, to 140.252.13.35: 4444444444444&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; от

svr4 на персональный адрес<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Мы использовали следующие флаги : <a NAME="t11C014"></a>-s,

запускает программу в роли сервера, <a NAME="t11C015"></a>-u

для UDP, <a NAME="t11C016"></a>-v, печатает IP адрес клиента, и <a NAME="t11C017"></a>-E печатает IP адрес назначения (в данном

случае система это позволяет). В дополнение, мы

установили <a NAME="t11C018"></a>приемный буфер UDP для

этого порта в 256 байт (<a NAME="t11C019"></a>-R), вместе с

размером, который может быть прочитан каждым

приложением (<a NAME="t11C020"></a>-r). Флаг <a NAME="t11C021"></a>-P30

сообщает о необходимости подождать 30 секунд

после очистки UDP порта, перед считыванием первой

датаграммы. Это дает нам время стартовать

клиентов на двух других хостах, послать

некоторые датаграммы и посмотреть, как работает

очередь приема.</small></p>



<p><small>После того как сервер стартован и прошла

30-секундная пауза, мы стартуем одного клиента на

хосте sun и посылаем три датаграммы:</small></p>



<p>&nbsp;</p>


</font><font FACE="Courier New" size="2">



<p>sun % <b>sock -u -v 140.252.13.63 6666 </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; на

широковещательный адрес Ethernet<br>

connected on 140.252.13.33.1252 to 140.252.13.63.6666<br>

<b>1111111111 </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11

байт данных (с символом новой строки)<br>

<b>222222222 </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10

байт данных (с символом новой строки)<br>

<b>33333333333 </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12

байт данных (с символом новой строки)<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Адрес назначения это широковещательный

адрес (140.252.13.63). Затем мы стартовали еще одного

клиента на хосте svr4 и послали еще три датаграммы:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p><br>

svr4 % <b>sock -u -v bsdi 6666</b><br>

connected on 0.0.0.0.1042 to 140.252.13.35.6666<br>

<b>4444444444444 </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14

байт данных (с символом новой строки)<br>

<b>555555555555555 </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16

байт данных (с символом новой строки)<br>

<b>66666666 </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9

байт данных (с символом новой строки)<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Первое, на что необходимо обратить внимание

в интерактивном выводе, показанном ранее на bsdi,

что только две датаграммы были приняты

приложением: первая от sun, состоящая из всех

единиц, и первая от svr4, состоящая из всех

четверок. Остальные четыре датаграммы были

отброшены. </small></p>



<p><small>Вывод команды <a NAME="t11C022"></a>tcpdump на рисунке

11.20 показывает, что все шесть датаграмм были

доставлены к хосту назначения. Датаграммы

прибыли от двух клиентов в обратном порядке:

первая от sun, затем от svr4 и так далее. Также мы

можем заметить, что все шесть были доставлены

примерно за 12 секунд, в течение 30-секундного

периода пока сервер &quot;спал&quot;.<a NAME="t11C023"></a></small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p><br>

1&nbsp;&nbsp; 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.1252


&gt; 140.252.13.63.6666: udp 11<br>

2&nbsp;&nbsp; 2.499184 (2.4992)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.1042

&gt; bsdi.6666: udp 14<br>

3&nbsp;&nbsp; 4.959166 (2.4600)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.1252

&gt; 140.252.13.63.6666: udp 10<br>

4&nbsp;&nbsp; 7.607149 (2.6480)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.1042

&gt; bsdi.6666: udp 16<br>

5&nbsp; 10.079059 (2.4719)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun.1252 &gt;

140.252.13.63.6666: udp 12<br>

6&nbsp; 12.415943 (2.3369)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; svr4.1042 &gt;

bsdi.6666: udp 9<br>

</p>

</font><font FACE="Arial">




<p>&nbsp;</p>



<p><small>Рисунок 11.20 Вывод tcpdump для UDP датаграмм,

посланных двумя клиентами.</small></p>



<p>&nbsp;</p>



<p><small>Также необходимо отметить, что c опцией -E

сервер может узнать IP адрес назначения каждой

датаграммы. Сервер может выбирать, что сделать с

первой принятой датаграммой, которая была

отправлена на широковещательный адрес. </small></p>



<p><small>В этом примере необходимо обратить

внимание еще на некоторые особенности. Во-первых,

приложение не сообщило, когда была переполнена

входная очередь. Лишние датаграммы UDP просто

отбросил. Также в выводе tcpdump мы видим, что ничего

не было отправлено клиенту обратно, чтобы

сообщить ему о том, что датаграммы были

отброшены. Не было послано ничего похожего на ICMP

сообщение <a NAME="t11C024"></a>подавления источника,

абсолютно ничего. И в заключение, хочется

отметить, что входная очередь UDP функционирует по

принципу <a NAME="t11C025"></a>FIFO (первый вошел, первый

вышел), тогда как, что мы видели в разделе <a HREF="#t119000">&quot;Взаимодействие между UDP и ARP&quot;</a>

этой главы, входная очередь ARP - <a NAME="t11C026"></a>LIFO

(последний зашел, первый вышел).</small></p>

<font size="3"><i><b>



<p><a NAME="t11C027"></a>Ограничение локального IP адреса</p>

</b></i></font>



<p><small>Большинство UDP серверов используют <a NAME="t11C028"></a>символы подстановки для своих IP

адресов, когда создают конечные точки UDP. Это

означает, что входящая UDP датаграмма,

направляющаяся на порт сервера, будет принята

любым локальным интерфейсом. Например, мы можем

стартовать UDP сервер на порте 7777:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="1">



<p></font><font FACE="Courier New" size="2">sun % <b>sock -u -s 7777</p>

</b></font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Затем мы воспользуемся командой <a NAME="t11C030"></a>netstat,

чтобы посмотреть состояние этой конечной точки:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p><br>

sun % <b>netstat -a -n -f inet</b><br>

Active Internet connections (including servers)<br>

Proto Recv-Q Send-Q&nbsp;&nbsp; Local Address

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Foreign Address

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (state)<br>

udp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0

&nbsp;&nbsp; *.7777

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *.*<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>В этом выводе мы удалили много строк и

оставили только те, которые нам интересны. Флаг <a NAME="t11C031"></a>-a сообщает о всех конечных точках сети.

Флаг <a NAME="t11C032"></a>-n печатает IP адреса в десятичном

представлении, вместо того чтобы использовать DNS

и конвертировать адреса в имена, а также печатает

номера портов вместо имен сервисов. Опция <a NAME="t11C033"></a>-f inet сообщает только о точках TCP и UDP. </small></p>



<p><small>Локальный адрес напечатан как *.7777, где

звездочка означает, что в качестве локального IP

адреса может быть подставлен любой адрес.</small></p>



<p><small>Когда сервер создает свою конечную точку,

он может указать один из локальных IP адресов

хоста, включая один из его широковещательных

адресов в качестве локального IP адреса конечной

точки. При этом входящая UDP датаграмма будет

передана на конечную точку только в том случае,

если IP адрес назначения совпадет с указанным

локальным адресом. С помощью программы sock можно

указать IP адрес перед номером порта, и этот IP

адрес становится локальным IP адресом для

конечной точки. Например,</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="1">



<p></font><font FACE="Courier New" size="2">sun % <b>sock -u -s 140.252.1.29 7777</p>

</b></font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>из датаграмм, прибывающих на SLIP интерфейс,

выбирает датаграммы с адресом 140.252.1.29. Вывод

команды <a NAME="t11C034"></a>netstat будет выглядеть

следующим образом:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p><br>

Proto Recv-Q Send-Q&nbsp;&nbsp; Local Address

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Foreign Address

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (state)<br>

udp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0

&nbsp;&nbsp; 140.252.1.29.7777&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *.*<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Если мы постараемся послать на этот сервер

датаграмму с хоста bsdi, адрес которого 140.252.13.35, по

Ethernet, вернется ICMP ошибка о <a NAME="t11C035"></a>недоступности

порта. Сервер никогда не увидит эту датаграмму.

На рисунке 11.21 это показано более подробно.<a NAME="t11C036"></a></small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p><br>

1&nbsp; 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsdi.1723

&gt; sun.7777: udp 13<br>

2&nbsp; 0.000822 (0.0008)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sun &gt; bsdi: icmp: sun udp port

7777 unreachable<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Рисунок 11.21 Отказ обработки UDP датаграммы,

вызванный несовпадением локального адреса

сервера.</small></p>



<p>&nbsp;</p>



<p><small>Существует возможность запустить другие

сервера для этого же порта, каждый с собственным

локальным IP адресом. Однако, приложение должно

разрешить системе повторно использовать тот же

самый номер порта.</small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">Должна быть указана

опция <a NAME="t11C037"></a>сокета в API <a NAME="t11C038"></a>SO_REUSEADDR.

Это делается нашей программой <a NAME="t11C039"></a>sock с

помощью опции <a NAME="t11C040"></a>-A. </font></p>

</font>



<p>&nbsp;</p>



<p><small>На хосте sun мы можем стартовать пять

различных серверов на одном и том же UDP порте (8888):</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p><br>

sun % <b>sock -u -s 140.252.1.29 8888 </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; для

канала SLIP<br>

sun % <b>sock -u -s -A 140.252.13.33 8888 </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; для Ethernet<br>

sun % <b>sock -u -s -A 127.0.0.1 8888 </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; для

loopback интерфейса<br>

sun % <b>sock -u -s -A 140.252.13.63 8888 </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; для

широковещательных запросов Ethernet<br>

sun % <b>sock -u -s -A 8888 </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; для

всего остального (метасимволы в IP адресе)<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Ожидалось, что первый из серверов будет

запущен с флагом -A, который сообщает системе о

том, что можно повторно использовать тот же самый

номер порта. Вывод команды netstat показывает

следующие пять серверов:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p><br>

Proto Recv-Q Send-Q&nbsp;&nbsp; Local Address

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Foreign Address

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (state)<br>

udp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0

&nbsp;&nbsp; *.8888

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *.*<br>

udp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0

&nbsp;&nbsp; 140.252.13.63.8888&nbsp;&nbsp;&nbsp; *.*<br>

udp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0

&nbsp;&nbsp; 127.0.0.1 8888&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *.*<br>

udp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0

&nbsp;&nbsp; 140.252.13.33 8888&nbsp;&nbsp;&nbsp; *.*<br>

udp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0

&nbsp;&nbsp; 140.252.1.29 8888&nbsp;&nbsp;&nbsp;&nbsp; *.*<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>В этом сценарии только датаграммы,

направляющиеся на адрес 140.252.1.255, будут попадать

на сервер с символами подстановки, используемыми

в качестве локального IP адреса, потому что другие

четыре сервера охватывают все возможные адреса. </small></p>



<p><small>При использовании подстановки IP адресов

используется система приоритетов. Конечная

точка с указанным IP адресом, который совпадает с

IP адресом назначения, всегда будет выбрана

раньше, чем адрес с символами подстановки.

Конечная точка с символами подстановки

используется только в том случае, когда не

найдено совпадение с указанным адресом.</small></p>

<font size="3"><i><b>



<p><a NAME="t11C041"></a>Ограничение внешних IP адресов</p>

</b></i></font>



<p><small>Во всех выводах команды <a NAME="t11C042"></a>netstat,

которую мы показывали ранее, удаленные IP адреса и

удаленные номера портов показаны как *.*. Это

означает, что конечная точка воспримет входящие

UDP датаграммы с любого IP адреса и любого номера

порта. В большинстве реализаций конечным точкам

UDP позволяется ограничивать удаленные адреса. </small></p>



<p><small>Другими словами, конечная точка может

воспринимать только UDP датаграммы от указанного

IP адреса и номера порта. Наша программа sock

использует опцию <a NAME="t11C043"></a>-f, чтобы указать

удаленный IP адрес и номер порта:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="1">



<p></font><font FACE="Courier New" size="2"><font color="#0000A0">sun % <b>sock -u -s -f

140.252.13.35.4444 5555</font></p>

</b></font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>При этом удаленный IP адрес устанавливается

в 140.252.13.35 (наш хост bsdi), а удаленный номер порта в

4444. Заранее-известный порт сервера 5555. Если мы

запустим netstat, то увидим, что локальный IP адрес

также установлен, даже если мы не указывали его

непосредственно:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p><br>

Proto Recv-Q Send-Q&nbsp;&nbsp; Local Address

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Foreign Address

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (state)<br>

udp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0

&nbsp;&nbsp; 140.252.13.33.5555&nbsp;&nbsp;&nbsp; 140.252.13.35.4444<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Это побочный эффект указания удаленного IP

адреса и удаленного номера порта в системах Berkeley:

если локальный IP адрес не был выбран при

установке удаленного адреса, локальный адрес

выбирается автоматически. В качестве локального

IP адреса устанавливается IP адрес интерфейса,

который выбирается с помощью IP маршрутизации для

достижения указанного удаленного IP адреса. И

действительно, в этом примере IP адрес sun для Ethernet,

который подключен к удаленному адресу, это

140.252.13.33. </small></p>



<p><small>На рисунке 11.22 приведены три типа адресов и

портов, которые UDP сервер может установить для

самого себя.<a NAME="t11C044"></a></small></p>



<p>&nbsp;</p>

</font>



<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="715">

  <tr>

    <td WIDTH="20%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small><font FACE="Arial">Локальный

    адрес</font></small></td>

    <td WIDTH="21%" VALIGN="TOP" BGCOLOR="#ffffff"><font FACE="Arial"><p ALIGN="CENTER"><small>Удаленный

    адрес</small></font></td>


    <td WIDTH="59%" VALIGN="TOP" BGCOLOR="#ffffff"><font FACE="Arial"><p ALIGN="CENTER"><small>Описание</small></font></td>

  </tr>

  <tr>

    <td WIDTH="20%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>localIP.lport</small></font></td>

    <td WIDTH="21%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>foreignIP.fport</small></font></td>

    <td WIDTH="59%" VALIGN="TOP"><font FACE="Arial"><small>ограничено одним

    клиентом</small></font></td>

  </tr>

  <tr>

    <td WIDTH="20%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>localIP.lport</small></font></td>

    <td WIDTH="21%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>*.*</small></font></td>

    <td WIDTH="59%" VALIGN="TOP"><font FACE="Arial"><small>ограничено

    датаграммами, прибывающими с одного локального

    интерфейса: localIP</small></font></td>

  </tr>

  <tr>

    <td WIDTH="20%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>*.lport</small></font></td>

    <td WIDTH="21%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>*.*</small></font></td>

    <td WIDTH="59%" VALIGN="TOP"><font FACE="Arial"><small>принимает все

    датаграммы, посланные на lport</small></font></td>

  </tr>

</table>

<font FACE="Arial">



<p><small>Рисунок 11.22 Указание локального и

удаленного IP адресов и номера порта для UDP

сервера.</small></p>



<p>&nbsp;</p>



<p><small>Во всех случаях lport это заранее-известный

порт сервера, а localIP должен быть IP адресом

локального интерфейса. Порядок, в котором

расположены три строки на рисунке 11.22, показывает

тот порядок, в котором UDP модуль старается

определить, на которую локальную конечную точку

принята входящая датаграмма. Наиболее жесткая

связь адреса с портом (первая строка) выбирается

в первую очередь, а менее жесткая (последняя

строка, где и IP адрес, и номер порта указаны в виде

метасимволов) выбирается последней.</small></p>

<font size="3"><i><b>



<p><a NAME="t11C045"></a>Множественный прием на порт</p>

</b></i></font>



<p><small>Несмотря на то, что это не описано в RFC,

большинство реализаций позволяют только одному

приложению в одно и то же время быть связанным с

одним локальным адресом и номером UDP порта. Когда

UDP датаграмма прибывает на хост назначения на

свой IP адрес и номер порта, одна копия

доставляется в единственную конечную точку. IP

адрес конечной точки может быть представлен в

виде символов подстановки, как было показано

ранее.</small></p>



<p><small>Например, в <a NAME="t11C046"></a>SunOS 4.1.3 мы стартовали

один сервер на порт 9999 с локальным IP адресом в

виде символов подстановки: </small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="1">



<p></font><font FACE="Courier New" size="2">sun % <b>sock -u -s 9999</p>

</b></font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Если затем попробовать стартовать еще один

сервер с тем же локальным адресом в виде символов

подстановки и с тем же портом, это не сработает,

даже если мы укажем опцию <a NAME="t11C047"></a>-A:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p>sun % <b>sock -u -s 9999 </b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; так

получиться не должно<br>

can't bind local address: Address already in use<br>

<br>


sun % <b>sock -u -s -A 9999 </b>&nbsp;&nbsp;&nbsp;&nbsp; поэтому мы

указали флаг -A<br>

can't bind local address: Address already in use<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Для систем, которые поддерживают групповую

адресацию (см. <a HREF="glava12.html">главу 12</a>), все обстоит

иначе. Несколько конечных точек могут

использовать один и тот же локальный адрес и

номер UDP порта, однако приложение должно сообщить

API, что это допустимо (флаг -A использует опцию

сокета <a NAME="t11C048"></a>SO_REUSEADDR). </small></p>



<p>&nbsp;</p>

<font size="1">




<p></font><font size="2"><font color="#0000A0"><a NAME="t11C049"></a>4.4BSD,

которая поддерживает групповую адресацию,

требует, чтобы приложение установило другую

опцию сокета (<a NAME="t11C050"></a>SO_REUSEPORT), чтобы

позволить нескольким конечным точкам делить

один и тот же порт. Более того, каждая конечная

точка должна указать эту опцию, включая первую

конечную точку, которая использует этот порт.</font></p>

</font>



<p>&nbsp;</p>



<p><small>Когда UDP датаграмма прибывает на свой IP

адрес назначения, который является

широковещательным или групповым адресом, при

этом с этим IP адресом и номером порта связано

несколько конечных точек, копия входящей

датаграммы направляется каждой конечной точке.

(Локальный IP адрес конечной точки может быть

указан в виде символов подстановки, при этом он

совпадет с любым IP адресом назначения.) Однако,

если у прибывшей IP датаграммы IP адрес назначения

- персональный адрес, только одна копия

датаграммы доставляется в одну конечную точку.

Которая конечная точка получит датаграмму с

персональным адресом, зависит от реализации.</small></p>

<font size="3"><u><b>



<p><a NAME="t11D000"></a>Краткие выводы</p>

</b></u></font>



<p><small>UDP это простой протокол. Официальная

спецификация RFC 768 [<a NAME="t11D014"></a>Postel 1980] состоит

всего лишь из трех страниц. Сервисы, которые он

предоставляет пользовательским процессам,

находящиеся над и позади <a NAME="t11D002"></a>IP, это

номера портов и необязательные контрольные

суммы. Мы использовали UDP, чтобы просмотреть

расчет контрольных сумм и посмотреть, как

осуществляется фрагментация. </small></p>



<p><small>Затем мы рассмотрели ICMP ошибку о

недоступности, которая является частью новой

характеристики определения транспортного MTU (см.

главу 2, раздел <a HREF="glava2.html#t029000">&quot;Транспортный

MTU&quot;</a>). Мы рассмотрели определение

транспортного MTU с использованием Traceroute и UDP.

Также рассмотрен процесс взаимодействия UDP и ARP. </small></p>



<p><small>Мы убедились, что ICMP ошибка подавления

источника может быть послана системой, которая

принимает IP датаграммы быстрее, чем может

обработать. Существует возможность легко

генерировать эти ICMP ошибки с использованием UDP.</small></p>

<font size="3"><i><b>



<p><a NAME="t11D001"></a>Упражнения</b></i></font><font size="1"> 



<ol>

  <li></font><font size="2">В разделе <a HREF="#t115000">&quot;Фрагментация

    IP&quot;</a> этой главы мы вызвали фрагментацию в <a NAME="t11D003"></a>Ethernet, записав UDP датаграмму с размером

    пользовательских данных в 1473 байта. Какой

    наименьший размер пользовательских данных может

    вызвать фрагментацию в Ethernet, если используется <a NAME="t11D004"></a>инкапсуляция IEEE 802 (глава 2, раздел <a HREF="glava2.html#t022000">&quot;Ethernet и IEEE 802 инкапсуляция&quot;</a>)?</li>

  <li>Прочитайте RFC 791 [<a NAME="t11D005"></a>Postel 1981a] и скажите,

    почему все фрагменты кроме последнего должны

    иметь длину кратную 8 байтам.</li>

  <li>Представьте себе Ethernet и UDP датаграмму с 8192

    байтами пользовательских данных. Сколько

    фрагментов будет передано и какова будет длина

    смещения для каждого фрагмента?</li>

  <li>Продолжая предыдущий пример, представьте себе,

    что эти датаграммы затем передаются в SLIP канал с

    MTU равным 552. Вам необходимо помнить, что

    количество данных в каждом фрагменте (все кроме IP

    заголовка) должно быть кратно 8 байтам. Сколько

    фрагментов передано и каковы смещение и длина

    каждого фрагмента?</li>

  <li><a NAME="t11D006"></a>Приложение, использующее UDP,

    посылает датаграмму, которая фрагментирована на

    4 части. Представьте себе, что фрагменты 1 и 2

    достигли своего пункта назначения, тогда как

    фрагменты 3 и 4 были потеряны. Приложение

    отрабатывает тайм-аут, а затем, через 10 секунд,

    повторяет передачу UDP датаграммы. Эта датаграмма

    фрагментируется точно так же, как и при первой

    передаче (то же смещение и та же длина). Теперь

    представьте, что фрагменты 1 и 2 потеряны, однако

    фрагменты 3 и 4 достигли своего пункта назначения.

    <a NAME="t11D007"></a>Таймер повторной сборки на

    принимающем хосте установлен в 60 секунд, поэтому

    когда фрагменты 3 и 4 прибыли на конечный пункт

    назначения, фрагменты 1 и 2 из первой передачи еще

    не были отброшены. Может ли получатель собрать IP

    датаграмму из этих четырех фрагментов?</li>

  <li>Как Вы можете узнать, что фрагменты на рисунке

    11.15 действительно соответствуют строкам 5 и 6 на

    рисунке 11.14?</li>

  <li><a NAME="t11D008"></a>После того как хост gemini работал 33

    дня, программа netstat показала, что 129 IP датаграмм из

    48 миллионов были отброшены из-за несовпадения

    контрольной суммы заголовка, а 20 сегментов из 30

    миллионов сегментов TCP были отброшены из-за


    несовпадения контрольной суммы TCP. Однако,

    примерно из 18 миллионов UDP датаграмм ни одна не

    была отброшена по причине ошибки в контрольной

    сумме UDP. Приведите минимум две причины, почему

    это могло произойти. (Подсказка: см. рисунок 11.4.)</li>

  <li>В нашем описании фрагментации мы ни разу не

    упомянули, что происходит с <a NAME="t11D009"></a>IP опциями

    в IP заголовке - либо они копируются как часть IP

    заголовка в каждый фрагмент, либо остаются

    только в первом фрагменте? Мы описали следующие

    опции: <a NAME="t11D010"></a>запись маршрута (глава 7,

    раздел <a HREF="glava7.html#t073000">&quot;Опция записи IP

    маршрута&quot;</a>), <a NAME="t11D011"></a>временная марка

    (глава 7, раздел <a HREF="glava7.html#t074000">&quot;IP опция

    временной марки&quot;</a>), <a NAME="t11D012"></a>жесткая и

    свободная маршрутизация от источника (глава 8,

    раздел <a HREF="glava8.html#t085000">&quot;Опция IP маршрутизации

    от источника&quot;</a>). Как Вы считаете, как при

    фрагментации обрабатываются эти опции?

    Сопоставьте Ваш ответ с RFC 791.</li>

  <li>На <a HREF="glava1.html#t017001">рисунке 1.8</a> мы сказали, что

    входящие IP датаграммы <a NAME="t11D013"></a>демультиплексируются

    на основе номера порта назначения UDP. Правильно

    ли это?</font><font size="1"></li>

</ol>

</font></font>



<p><small><a HREF="index.html"><img SRC="contents.jpg" BORDER="0" WIDTH="94" HEIGHT="20"></a><a HREF="../home.htm"><img SRC="begin.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava12.html"><img SRC="forward.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava10.html"><img SRC="back_b.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a href="index.html"><img SRC="index.jpg" border="0" WIDTH="68" HEIGHT="20"></a></small></p>

<font size="1">



<p>&nbsp;</p>

</font>
</div>
</body>

</html>

