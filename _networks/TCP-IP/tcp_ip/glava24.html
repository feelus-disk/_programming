<html>
<head>
<title>Будущее TCP и его производительность</title>
</head>

<body>
<div>


<p><small><a HREF="index.html"><img SRC="contents.jpg" BORDER="0" WIDTH="94" HEIGHT="20"></a><a HREF="../home.htm"><img SRC="begin.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava25.html"><img SRC="forward.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava23.html"><img SRC="back_b.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a href="index.html"><img SRC="index.jpg" border="0" WIDTH="68" HEIGHT="20"></a></small></p>

<font FACE="Arial" SIZE="4">



<p><a NAME="t240000"></a>Глава 24 Будущее TCP и его

производительность</p>

</font><font FACE="Arial"><font size="3"><u>



<p><b><a NAME="t241000"></a>Введение</p>

</b></u></font>



<p><small>TCP функционирует уже в течение многих лет и

по SLIP каналам со скоростью 1200 бит в секунду и по


Ethernet. В 80-х и начале 90-х годов Ethernet был основным

типом канального уровня для TCP/IP. Несмотря на то,

что TCP корректно работает на скоростях больших,

чем предоставляемые Ethernet (телефонные линии T3, FDDI

и гигабитные сети, например), на повышенных

скоростях начинают сказываться некоторые

ограничения TCP. </small></p>



<p><small>В этой главе рассматриваются некоторые

предложения посвященные модификациям TCP, которые

позволяют добиться максимальной пропускной

способности на высоких скоростях. Во-первых, мы

рассмотрим механизм определения транспортного

MTU, который мы уже упоминали раньше. Сейчас мы

подробно рассмотрим, как он функционирует с TCP.

Этот алгоритм позволяет TCP использовать MTU больше

чем 536 для соединений по глобальным сетям, что, в

свою очередь, повышает пропускную способность. </small></p>



<p><small>Затем мы рассмотрим каналы с повышенной

пропускной способностью (long fat pipes), сети, имеющие

большую емкость канала зависящую от полосы

пропускания (bandwidth-delay product), и ограничения TCP,

которые становятся существенными для этих сетей.

Здесь описаны две новые опции TCP, используемые

для работы с каналами с повышенной пропускной

способностью (long fat pipes): опция масштабирования

окна (позволяет использовать окна TCP с

максимальным размером больше чем 65535 байт) и

опция временной марки. Опция временной марки

позволяет TCP осуществлять более аккуратный

расчет RTT для сегментов данных, а также

предоставляет защиту от перехода номеров

последовательности через ноль, что может

возникнуть на высоких скоростях. Эти две опции

определены в RFC 1323 <a NAME="t241001"></a>[Jacobson, Braden, and Borman

1992]. </small></p>



<p><small>Также мы рассмотрим T/TCP - модификацию TCP для

транзакций. Режим транзакций это характеристики

коммуникации, при которых на запрос от клиента

приходит отклик от сервера. Основная задача T/TCP

заключается в том, чтобы уменьшить количество

сегментов, которыми обмениваются два участника

соединения, при этом отпадает необходимость в

трехразовом рукопожатии (three-way handshake) и четырех

сегментах, которыми необходимо обменяться, чтобы

закрыть соединение. При этом клиент получает

отклик от сервера через время равное одному RTT

плюс время, необходимое для обработки запроса. </small></p>



<p><small>И самое замечательное в этих новых опциях -

в характеристике определения транспортного MTU,

опции масштабирования окна, опции временной

марки и T/TCP - это то, что они совместимы с уже

существующими реализациями TCP. Новые системы,

которые имеют эти опции, могут общаться с более

ранними системами. За исключением

дополнительных полей в ICMP сообщении, которые

могут быть использованы при определении

транспортного MTU, новые опции должны быть

реализованы только на конечных системах, которые

хотят пользоваться их преимуществами. </small></p>



<p><small>Мы закончим эту главу рассмотрением

публикаций, вышедших в настоящее время и имеющих

отношение к производительности TCP.</small></p>

<font size="3"><u><b>



<p><a NAME="t242000"></a>Определение транспортного MTU</p>

</b></u></font>



<p><small>В разделе <a HREF="glava2.html#t029000">&quot;Транспортный

MTU&quot;</a> главы 2 мы описали концепцию

транспортного MTU (path MTU). Это минимальный MTU в любой

из сетей, по которым проходит маршрут между двумя

хостами. При определении транспортного MTU в IP

заголовке устанавливается бит <a NAME="t242003"></a>&quot;не

фрагментировать&quot; (DF - don't fragment), что позволяет

определить, необходимо ли какому-либо

маршрутизатору на текущем маршруте

фрагментировать IP датаграммы, которые мы

посылаем. В разделе <a HREF="glava11.html#t116000">&quot;ICMP ошибки

о недоступности&quot;</a> главы 11 мы показали <a NAME="t242004"></a>ICMP ошибку о недоступности,

генерируемую маршрутизатором, которому

необходимо перенаправить IP датаграмму с

установленным битом DF, когда MTU меньше чем размер

датаграммы. В разделе <a HREF="glava11.html#t117000">&quot;Определение

транспортного MTU с использованием Traceroute&quot;</a>

главы 11 мы показали версию программы <a NAME="t242005"></a>traceroute,

которая использует этот механизм, чтобы

определить транспортный MTU к пункту назначения. В

разделе <a HREF="glava11.html#t118000">&quot;Определение

транспортного MTU при использовании UDP&quot;</a> главы

11 мы видели, как UDP определял транспортный MTU. В

этом разделе мы просмотрим, как TCP использует

этот механизм. Это описано в RFC 1191 <a NAME="t242006"></a>[Mogul

and Deering 1990].</small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">Из всех систем, которые

используются в этой книге (см. вступление), только

<a NAME="t242007"></a>Solaris 2.x поддерживает определение

транспортного MTU.</font></p>

</font>



<p>&nbsp;</p>



<p><small>Алгоритм определения транспортного MTU TCP

работает следующим образом. Когда соединение

установлено, TCP использует минимальный MTU

исходящего интерфейса или <a NAME="t242008"></a>MSS,

объявленный удаленным концом, в качестве

исходного размера сегмента. Алгоритм

определения транспортного MTU не позволяет TCP

превосходить MSS, объявленный удаленным концом.

Если удаленный конец не указал MSS, то он

устанавливается по умолчанию в значение равное

536. Реализации могут сохранить информацию о

транспортном MTU определенного канала, как мы

говорили в разделе <a HREF="glava21.html#t219000">&quot;Показатели

на маршрут&quot;</a> главы 21. </small></p>



<p><small>После того как выбран исходный размер

сегмента, во всех IP датаграммах, отправляемых TCP

по этому соединению, установливается бит DF. Если

промежуточному маршрутизатору необходимо

фрагментировать датаграмму, в которой

установлен бит DF, он отбрасывает датаграмму и

генерирует ICMP ошибку &quot;не могу

фрагментировать&quot; (can't fragment). Это описано в

разделе <a HREF="glava11.html#t116000">&quot;ICMP ошибки о

недоступности&quot;</a> главы 11. Если принята такая

ICMP ошибка, TCP уменьшает размер сегмента и

повторяет передачу. Если маршрутизатор

сгенерировал новую ICMP ошибку, размер сегмента

может быть установлен в MTU следующей пересылки

минус размеры IP и TCP заголовков. </small></p>



<p><small>Если возвратилась старая ICMP ошибка, должно

быть использовано следующее меньшее значение MTU

(рисунок 2.5). Когда осуществляются повторные

передачи, вызванные этими ICMP ошибками, окно

переполнения не должно изменяться, вместо этого

должен быть использован медленный старт. </small></p>



<p><small><a NAME="t242009"></a>Так как маршруты могут меняться

со временем, по истечении определенного времени

после последнего уменьшения транспортного MTU,

можно попробовать большее значение (до величины

минимального MSS, объявленного удаленным концом,

или MTU исходящего интерфейса). RFC 1191 рекомендует,

чтобы этот временной интервал составлял

примерно 10 минут. (Мы видели в разделе <a HREF="glava11.html#t118000">&quot;Определение транспортного MTU

при использовании UDP&quot;</a> главы 11, что Solaris 2.2

использует для этих целей 30-секундный тайм-аут.) </small></p>



<p><small>Используя обычное для работы в глобальных

сетях значение MSS по умолчанию равное 536, алгоритм

определения транспортного MTU избегает

фрагментации по промежуточным каналам с MTU

меньшим чем 576 (что встречается довольно редко).

Также можно избежать фрагментации в локальных

сетях, когда промежуточный канал (Ethernet) имеет

меньший MTU, чем сеть конечного пункта назначения

(Token ring). В процессе определения транспортного MTU

(при работе в глобальных сетях с MTU большим чем 576),

системы не должны использовать MSS по умолчанию

равный 536 байт для нелокальных пунктов

назначения. Предпочтительней выбирать MSS равный

MTU исходящего интерфейса (естественно, минус

размер IP и TCP заголовков). (В <a HREF="glavaE.html">приложении

Е</a> мы увидим, что большинство реализаций


позволяют системным администраторам изменить

значение MSS принятое по умолчанию.)</small></p>

<font size="3"><i><b>



<p>Пример</p>

</b></i></font>



<p><small>Увидеть, как происходит определение

транспортного MTU, можно в том случае, когда

промежуточный маршрутизатор имеет MTU меньше чем

MTU интерфейсов конечных точек. На рисунке 24.1

показана топология для данного примера.<a NAME="t242010"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t24_1.jpg" WIDTH="508" HEIGHT="170"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 24.1 Топология для примера

транспортного MTU.</small></p>



<p>&nbsp;</p>



<p><small>Мы установим соединение с хоста solaris

(который поддерживает механизм определения

транспортного MTU) на хост slip. Установки идентичны

тем, которые использованы для примера

определения транспортного MTU в случае UDP (рисунок

11.13), однако здесь мы установили MTU интерфейса на

slip равный 552, вместо его обычного значения 296. Это

заставляет slip объявить <a NAME="t242011"></a>MSS равный 512.

Мы оставили MTU = 296 на SLIP канале на bsdi, поэтому TCP

сегменты, размером больше чем 256, должны быть

фрагментированы. Посмотрим, как механизм

определения транспортного MTU на solaris обработает

подобную ситуацию. </small></p>



<p><small>Запустим программу <a NAME="t242012"></a>sock на хосте

solaris и осуществим одну запись величиной 512 байт на

discard сервис хоста slip:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="1">



<p></font><font FACE="Courier New" size="2">solaris % <b>sock -i -n1 -w512 slip discard</p>

</b></font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>На рисунке 24.2 мы показали вывод команды

tcpdump, полученный на SLIP интерфейсе хоста sun. </small></p>



<p><small>Значение MSS в строках 1 и 2 как раз такое, как

и ожидалось. Затем мы видим, что solaris отправил

сегмент размером 512 байт (строка 3), содержащий 512

байт данных и подтверждение на SYN. (Мы видели эту

комбинацию ACK вместе с SYN в первом сегменте данных

в <a HREF="glava18.html#t18C001">упражнении 9</a> главы 18.)<a NAME="t242013"></a></small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p><br>

1&nbsp; 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; solaris.33016

&gt; slip.discard: S 1171660288:1171660288(0) <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win

8760 &lt;mss 1460&gt; (DF)<br>

2&nbsp; 0.101597 (0.1016)&nbsp;&nbsp;&nbsp; slip.discard &gt; solaris.33016: S

137984001:137984001(0) <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack

1171660289 win 4096 <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;mss

512&gt;<br>

3&nbsp; 0.630609 (0.5290)&nbsp;&nbsp;&nbsp; solaris.33016 &gt; slip.discard: P 1:513(512) <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack

1 win 9216 (DF)<br>

4&nbsp; 0.634433 (0.0038)&nbsp;&nbsp;&nbsp; bsdi &gt; solaris: icmp: <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slip

unreachable - need to frag, mtu = 296 (DF)<br>

5&nbsp; 0.660331 (0.0259)&nbsp;&nbsp;&nbsp; solaris.33016 &gt; slip.discard: F 513:513(0) <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack

1 win 9216 (DF)<br>

6&nbsp; 0.752664 (0.0923)&nbsp;&nbsp;&nbsp; slip.discard &gt; solaris.33016: . ack 1 win

4096<br>

7&nbsp; 1.110342 (0.3577)&nbsp;&nbsp;&nbsp; solaris.33016 &gt; slip.discard: P 1:257(256) <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack

1 win 9216 (DF)<br>

8&nbsp; 1.439330 (0.3290)&nbsp;&nbsp;&nbsp; slip.discard &gt; solaris.33016: . ack 257 win

3840<br>

9&nbsp; 1.770154 (0.3308)&nbsp;&nbsp;&nbsp; solaris.33016 &gt; slip.discard:FP

257:513(256) <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack

1 win 9216 (DF)<br>

10&nbsp; 2.095987 (0.3258)&nbsp;&nbsp;&nbsp; slip.discard &gt; solaris.33016: . ack 514

win 3840<br>

11&nbsp; 2.138193 (0.0422)&nbsp;&nbsp;&nbsp; slip.discard &gt; solaris.33016: F 1:1(0) ack


514 win 4096<br>

12&nbsp; 2.310103 (0.1719)&nbsp;&nbsp;&nbsp; solaris.33016 &gt; slip.discard: . ack 2 win

9216 (DF)<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Рисунок 24.2 Вывод команды tcpdump для

определения транспортного MTU.</small></p>



<p>&nbsp;</p>



<p><small>В строке 4 генерируется ICMP ошибка, и мы

видим, что маршрутизатор bsdi генерирует новую ICMP

ошибку, содержащую MTU исходящего интерфейса. </small></p>



<p><small>Так случилось, что перед тем, как эта ошибка

вернулась на хост solaris, был отправлен FIN (строка 5).

Так как slip не получил 512 байт данных, отброшенных

маршрутизатором bsdi, и не ожидает этого номера

последовательности (513), он отправляет ожидаемый

номером последовательности (1) в строке 6. </small></p>



<p><small>В это время ICMP ошибка вернулась на solaris, и

было повторно передано 512 байт данных в двух

сегментах размером 256 байт (строки 7 и 9). Оба

сегмента отправлены с установленным битом DF, так

как дальше за маршрутизатором bsdi может быть еще

один маршрутизатор, у которого MTU еще меньше. </small></p>



<p><small>Была осуществлена довольно долгая передача

(она заняла примерно 15 минут), и после перехода от

исходного размера сегмента равного 512 байт к

сегментам размером 256 байт, solaris уже больше

никогда не пытался отправить сегменты большего

размера.</small></p>

<font size="3"><i><b>



<p><a NAME="t242014"></a>Большие пакеты или маленькие?</p>

</b></i></font>



<p><small>Народная мудрость гласит, что лучше

использовать большие пакеты [<a NAME="t242015"></a>Mogul 1993,

Sec.15.2.8], потому что отправка меньшего количества

больших пакетов &quot;дешевле&quot;, чем отправка

большего количества маленьких пакетов.

(Подразумевается, что пакеты не настолько велики,

чтобы вызвать фрагментацию.) Не все согласны с

этим положением [<a NAME="t242016"></a>Bellovin 1993]. </small></p>



<p><small>Представьте себе следующий пример. Мы

посылаем 8192 байта через четыре маршрутизатора,

каждый из которых подключен к телефонной линии T1

(1544000 бит/сек). Во-первых, мы используем два пакета

размером 4096 байт, как показано на рисунке 24.3.<a NAME="t242001"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t24_3.jpg" WIDTH="403" HEIGHT="136"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 24.3 Отправка двух пакетов

размером 4096 байт через четыре маршрутизатора.</small></p>



<p>&nbsp;</p>



<p><small>Основная проблема заключается в том, что

маршрутизаторы это устройства, которые работают

по принципу &quot;сохранить и перенаправить&quot;. Они

обычно получают входящий пакет целиком,

проверяют на правильность IP заголовок, включая <a NAME="t242017"></a>контрольную сумму IP, принимают решение

о маршрутизации и затем начинают отправку

исходящего пакета. На этом рисунке мы


предположили идеальный случай, когда на

операции, осуществляемые в маршрутизаторе, время

не тратится, (горизонтальные пунктирные линии).

Тем не менее, на отправку всех 8192 байт от R1 до R4

будет истрачено четыре отрезка времени. Время на

каждую пересылку будет составлять</small></p>



<p>&nbsp;</p>



<p><small>[(4096 + 40 байт) x 8 бит/байт]/1544000 бит/сек = 21,4

миллисекунды на пересылку</small></p>



<p>&nbsp;</p>



<p><small>(IP и TCP заголовки составляют 40 байт.) Полное

время, которое тратится на отправку данных,

состоит из количества пакетов плюс количество

пересылок минус один и составляет четыре отрезка

времени или 85,6 миллисекунды. Каждый канал

остается неиспользованным в течение двух

отрезков времени или 42,8 миллисекунды. </small></p>



<p><small>На рисунке 24.4 показано что произойдет, если

мы пошлем 16 пакетов размером 512 байт.<a NAME="t242002"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t24_4.jpg" WIDTH="414" HEIGHT="215"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 24.4 Отправка 16 пакетов

размером 512 байт через четыре маршрутизатора.</small></p>



<p>&nbsp;</p>



<p><small>Это передача займет больше отрезков

времени, однако каждый отрезок короче, так как

отправляются пакеты меньшего размера.</small></p>



<p>&nbsp;</p>



<p><small>[(512 + 40 байт) x 8 бит/байт]/1544000 бит/сек = 2,9

миллисекунды на пересылку</small></p>



<p>&nbsp;</p>



<p><small>Сейчас полное время составляет (18 x 2,9) = 52,2

миллисекунды. Каждый канал снова не занят в

течение двух отрезков времени, что сейчас

составляет 5,8 миллисекунды. </small></p>



<p><small>В этом примере мы игнорировали время,

которое необходимо для того, чтобы вернулось

подтверждение (ACK), также мы проигнорировали

время, необходимое для установления и разрыва

соединения, и не приняли во внимание то, что по

каналам может двигаться и другой траффик. Тем не


менее, расчеты в [<a NAME="t242018"></a>Bellovin 1993] указывают,

что отправка больших пакетов всегда эффективней.

Однако, для различных сетей требуются более

подробные исследования.</small></p>

<font size="3"><u><b>



<p><a NAME="t243000"></a>Каналы с повышенной пропускной

способностью (Long Fat Pipes) </p>

</b></u></font>



<p><small>В разделе <a HREF="glava20.html#t207000">&quot;Пропускная

способность для неинтерактивных данных&quot;</a>

главы 20 мы сказали, что емкость соединения можно

рассчитать следующим образом</small></p>



<p>&nbsp;</p>



<p><small>емкость (бит) = ширина полосы (бит/сек) x время

возврата (сек)</small></p>



<p>&nbsp;</p>



<p><small>и назвали это <a NAME="t243002"></a>емкость канала в

зависимости от полосы пропускания. Иногда эта

величина называется размером канала между двумя

точками. </small></p>



<p><small>Существующие ограничения TCP начинают

влиять на производительность по мере увеличения

емкости каналов. На рисунке 24.5 показаны

некоторые значения для различных типов сетей.<a NAME="t243003"></a></small></p>



<p>&nbsp;</p>

</font>



<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="945">

  <tr>

    <td WIDTH="48%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small><font FACE="Arial">Сеть</font></small></td>

    <td WIDTH="17%" VALIGN="TOP" BGCOLOR="#ffffff"><font FACE="Arial"><p ALIGN="CENTER"><small>Ширина

    полосы (бит/сек)</small></font></td>

    <td WIDTH="18%" VALIGN="TOP" BGCOLOR="#ffffff"><font FACE="Arial"><p ALIGN="CENTER"><small>Время

    возврата (миллисекунды)</small></font></td>

    <td WIDTH="17%" VALIGN="TOP" BGCOLOR="#ffffff"><font FACE="Arial"><p ALIGN="CENTER"><small>Емкость

    канала (байты)</small></font></td>

  </tr>

  <tr>

    <td WIDTH="48%" VALIGN="TOP"><font FACE="Arial"><small>Локальная сеть на

    основе Ethernet</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>10000000</small></font></td>

    <td WIDTH="18%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>3</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>3750</small></font></td>

  </tr>

  <tr>

    <td WIDTH="48%" VALIGN="TOP"><font FACE="Arial"><small>Трансконтинентальный

    канал, телефонная линия T1 </small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>1544000</small></font></td>

    <td WIDTH="18%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>60</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>11580</small></font></td>

  </tr>

  <tr>

    <td WIDTH="48%" VALIGN="TOP"><font FACE="Arial"><small>Спутниковый канал,

    телефонная линия T1</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>1544000</small></font></td>

    <td WIDTH="18%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>500</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>95500</small></font></td>

  </tr>

  <tr>

    <td WIDTH="48%" VALIGN="TOP"><font FACE="Arial"><small>Трансконтинентальный

    канал, телефонная линия T3 </small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>45000000</small></font></td>

    <td WIDTH="18%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>60</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>337500</small></font></td>

  </tr>

  <tr>

    <td WIDTH="48%" VALIGN="TOP"><font FACE="Arial"><small>Трансконтинентальный

    гигабитный канал</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>1000000000</small></font></td>

    <td WIDTH="18%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>60</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>7500000</small></font></td>

  </tr>

</table>

<font FACE="Arial">



<p><small>Рисунок 24.5 Емкость канала для различных

сетей.</small></p>



<p>&nbsp;</p>



<p><small>Мы показали емкость канала в байтах, потому

что именно так эта величина обычно

рассчитывается на каждом конце соединения для

определения размеров буферов и размеров окон. </small></p>



<p><small>Сети с большой емкостью канала называются

сетями с повышенной пропускной способностью (<a NAME="t243004"></a>LFN - long fat networks, произносится как

&quot;elephant(s)&quot;, elephant (англ.) - слон), а TCP соединения,

работающие на LFN, называются <a NAME="t243005"></a>каналами

с повышенной пропускной способностью (long fat pipe).

Возвращаясь назад к рисункам 20.11 и 20.12, можно

сказать, что эти каналы могут быть расширены в

горизонтальном направлении (большие <a NAME="t243006"></a>RTT)

или в вертикальном направлении (большая ширина

полосы передачи) или в обоих направлениях.

Однако, с подобными каналами с повышенной

пропускной способностью возникают некоторые

проблемы.</small> 



<ol>

  <li><small>Размер окна TCP находится в 16-битном поле TCP

    заголовка, ограничивая размер окна величиной

    равной 65535 байт. Как видно из последней колонки на

    рисунке 24.5, существующие сети уже требуют

    большего окна, чем 65535, для достижения

    максимальной пропускной способности. Опция

    масштабирования окна, описанная в разделе <a HREF="#t244000">&quot;Опция масштабирования окна&quot;</a>

    этой главы, решает эту проблему.</small></li>

  <li><small>Пакеты, теряемые в LFN, могут значительно

    уменьшить пропускную способность. Если потерян

    только один сегмент, <a NAME="t243007"></a>алгоритм

    быстрой передачи и быстрого восстановления,

    который мы описали в разделе <a HREF="glava21.html#t217000">&quot;Быстрая

    повторная передача и алгоритм быстрого

    восстановления&quot;</a> главы 21, сделает так, что

    канал не сузится. Однако, даже при использовании

    этого алгоритма, потеря больше чем одного пакета

    внутри окна обычно приводит к тому, что канал

    сужается. (Если канал сузился, снова используется

    медленный старт, что в несколько раз увеличивает

    время возврата, прежде чем канал будет снова

    заполнен.) Чтобы обработать потерю нескольких

    пакетов внутри окна, в RFC 1072 <a NAME="t243008"></a>[Jacobson and

    Braden 1988] было предложено использовать cелективные

    подтверждения (<a NAME="t243009"></a>SACK). Однако, начиная с

    RFC 1323, от использования этой характеристики

    отказались, потому что авторы обнаружили

    несколько технических проблем, которые

    необходимо решить перед включением этой опции в

    TCP.</small></li>

  <li><small>В разделе <a HREF="glava21.html#t214000">&quot;Пример RTT&quot;</a>

    главы 21 мы видели, что большинство TCP реализаций

    измеряют только одно время задержки на окно. Они

    не измеряют <a NAME="t243010"></a>RTT для каждого сегмента.

    Однако для функционирования в LFN требуется

    лучшее измерение RTT. Опция временной марки,

    которая описана в разделе <a HREF="#t245000">&quot;Опция

    временной марки&quot;</a> этой главы, позволяет

    оценить время передачи нескольких сегментов,

    включая повторно переданные. </small></li>

  <li><small>TCP идентифицирует каждый байт данных

    уникальным 32-битным номером последовательности.

    Что произойдет, если сегмент, задержанный в сети,

    появится после того как соединение, которому он

    принадлежал, уже закрыто, и когда установлено

    новое соединение между теми же двумя хостами и

    теми же номерами портов? Во-первых, вспомним, что

    поле <a NAME="t243011"></a>TTL в IP заголовке содержит

    максимальное время жизни любой IP датаграммы - 255

    пересылок или 255 секунд (что кончится первым). В

    разделе <a HREF="glava18.html#t186000">&quot;Диаграмма состояний

    передачи TCP&quot;</a> главы 18 мы определили, что

    максимальное время жизни сегмента (<a NAME="t243012"></a>MSL)

    это параметр, зависящий от реализации и

    используемый для того, чтобы не возникла

    подобная ситуация. Рекомендуемое значение для MSL

    - 2 минуты (при этом <a NAME="t243013"></a>2MSL будет равно 240

    секундам), однако мы видели в разделе <a HREF="glava18.html#t186000">&quot;Диаграмма состояний передачи

    TCP&quot;</a> главы 18, что многие реализации

    устанавливают MSL в 30 секунд. Еще одна проблема с

    номерами последовательности TCP возникает при

    использовании LFN. Так как величина номера

    последовательности ограничена, тот же самый

    номер последовательности будет использован

    повторно после того, как будет передано 4.294.967.296

    байт. Что произойдет, если сегмент, содержащий

    байт с номером последовательности N, будет

    задержан в сети и появится позже, когда

    соединение все еще открыто? Эта проблема

    появится только в том случае, если тот же самый

    номер последовательности N повторно

    используется в течение периода MSL, то есть в том

    случае, если сеть настолько быстрая, что номер

    последовательности успевает повториться за

    время меньшее чем MSL. Для Ethernet необходимо почти 60

    минут, чтобы послать такое количество данных,

    поэтому подобная ситуация не возможна, однако

    время, необходимое на то, чтобы появился номер

    последовательности, который уже существует в

    сети, уменьшается с ростом ширины пропускания

    сети: для телефонных линий T3 (45 Мбит/сек)

    требуются 12 минут, для <a NAME="t243014"></a>FDDI (100 Мбит/сек)

    - 5 минут, а для гигабитных сетей (1000 Мбит/сек) - 34

    секунды. В данном случае проблема не связана с

    емкостью канала, а связана с шириной полосы. В

    разделе <a HREF="#t246000">&quot;PAWS: защита от перехода

    номеров последовательности через ноль&quot;</a> этой

    главы мы описываем способ, с помощью которого

    можно решить эту проблему: алгоритм PAWS (защита от

    перехода номеров последовательности через ноль),

    который использует опцию временной марки TCP.</small></li>

</ol>



<dir>

  <dir>

    <p>&nbsp;</p>

  </dir>

</dir>

<font size="1">



<p></font><font size="2"><font color="#0000A0"><a NAME="t243015"></a>4.4BSD

содержит все опции и алгоритмы, которые мы

описываем в следующих разделах: опцию

масштабирования окна, опцию временной марки и

защиту от перехода номеров последовательности

через ноль. Некоторые производители также

начинают поддерживать эти опции.</font></p>

</font>



<p>&nbsp;</p>

<font size="3"><i><b>



<p><a NAME="t243016"></a>Гигабитные сети</p>

</b></i></font>



<p><small>Положение вещей меняется, когда скорости в

сетях достигают гигабитов. [<a NAME="t243017"></a>Partridge 1994]

описывает гигабитные сети более подробно. Здесь

мы рассмотрим различие между задержкой

(латенсией) и шириной полосы [<a NAME="t243018"></a>Kleinrock

1992]. </small></p>



<p><small>Представьте себе процесс отправки файла

размером 1 миллион байт через Соединенные Штаты,

с предполагаемой латенсией равной 30

миллисекундам. На рисунке 24.6 показаны два

сценария, верхний соответствует использованию

телефонной линии T1 (1544000 бит/сек), а нижний

подразумевает использование сети 1 гигабит/сек.

Время показано по оси ОХ, (отправитель находится

слева, а получатель справа), а емкость показана по

оси OY. Закрашенный прямоугольник на обоих

рисунках - это 1 миллион байт, который необходимо

отправить.<a NAME="t243001"></a></small></p>

</font>



<p ALIGN="CENTER"><small><img SRC="t24_6.jpg" WIDTH="498" HEIGHT="247"></small></p>

<font FACE="Arial">



<p ALIGN="CENTER"><small>Рисунок 24.6 Отправка файла размером

1 Мбайт по сетям с 30-миллисекундной латенсией.</small></p>



<p>&nbsp;</p>




<p><small>На рисунке 24.6 показано состояние обеих

сетей через 30 миллисекунд. В обеих сетях первый

бит данных достиг удаленного конца через 30

миллисекунд (латенсия), однако в случае сети T1

(емкость канала - 5790 байт), 994210 байт все еще

находятся у отправителя, ожидая того, что они

будут отправлены. Емкость гигабитной сети,

составляет 3750000 байт, поэтому файл целиком

занимает всего лишь около 25% канала. Последний

бит файла достигает получателя через 8

миллисекунд после первого бита. </small></p>



<p><small>Полное время передачи файла по сети T1

составляет 5,211 секунды. Если мы увеличить ширину

полосы пропускания, например, с использованием

сети T3 (45000000 бит/сек), полное время уменьшится до

0,208 секунды. Увеличение ширины полосы в 29 раз

уменьшает полное время в 25 раз. </small></p>



<p><small>В случае гигабитной сети полное время,

необходимое на передачу файла, составляет 0,038

секунды: 30-миллисекундная латенсия плюс 8

миллисекунд на реальную передачу файла.

Предположим, мы можем увеличить ширину полосы

пропускания до 2 гигабит/сек, однако в этом случае

мы уменьшим полное время передачи до всего лишь

0,034 секунды: та же самая 30-миллисекундная

латенсия плюс 4 миллисекунды на передачу файла.

Таким образом, удвоение полосы передачи,

уменьшает полное время всего лишь на 10%. В случае

гигабитных скоростей мы уже ограничены

латенсией, а не шириной полосы. </small></p>



<p><small>Латенсия определяется скоростью света, и мы

не можем ее уменьшить (если, конечно, Эйнштейн был

прав). Влияние фиксированной латенсии становится

еще более ощутимым (в отрицательную сторону),

когда мы решаем установить или закрыть

соединение. В случае гигабитных сетей на

некоторые сетевые проблемы приходится взглянуть

с другой точки зрения.</small></p>

<font size="3"><u><b>



<p><a NAME="t244000"></a>Опция масштабирования окна</p>

</b></u></font>



<p><small>Опция масштабирования окна увеличивает

определение окна TCP с 16 до 32 бит. Вместо того чтобы

изменять TCP заголовок, для того чтобы поместить в

него окно большего размера, заголовок все так же

содержит 16-битное значение, а опция определяет

операцию масштабирования этого 16-битного

значения. После чего TCP использует

&quot;реальный&quot; размер окна внутри себя как

32-битное значение. </small></p>



<p><small>Мы видели пример использования этой опции

на рисунке 18.20. 1-байтовый сдвиговый счетчик

находится в диапазоне от 0 (нет масштабирования)

до 14. Максимальное значение равное 14

соответствует окну размером 1.073.725.440 байт (65535 x 2<sup>14</sup>).

</small></p>



<p><small>Эта опция может появиться только в сегменте

SYN; таким образом, коэффициент масштабирования

определяется в каждом направлении при

установлении соединения. Чтобы включить

масштабирование окна, оба конца должны

активизировать опцию в своих сегментах SYN.

Сторона, осуществляющая активное открытие,

посылает опцию в своем SYN, однако сторона,

осуществляющая пассивное открытие, может

послать опцию, только если эта опция установлена

в полученном SYN. Коэффициент масштабирования

может быть различен для каждого направления. </small></p>



<p><small>Если сторона, осуществляющая активное

открытие, устанавливает ненулевой коэффициент

масштабирования, однако не получает опцию

масштабирования окна с удаленного конца, эта

сторона устанавливает свой сдвиговый счетчик

отправки и приема в 0. Таким образом добиваются

совместимости новых систем со старыми, не

поддерживающими эту опцию.</small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">Требования к хостам <a NAME="t244001"></a>Host Requirements RFC требуют, чтобы TCP принимал

эту опцию в любом сегменте. (Единственная заранее

определенная опция, максимальный размер

сегмента, может появиться только в сегментах SYN.)

Также этот документ требует, чтобы TCP игнорировал

любые опции, которые он не понимает. Это легко

осуществимо, так как все новые опции имеют поле

длины (рисунок 18.20).</font></p>

</font>



<p>&nbsp;</p>



<p><small>Представьте, что мы используем опцию

масштабирования окна со сдвиговым счетчиком

равным S для отправки и со сдвиговым счетчиком

равным R для приема. В этом случае каждые 16 бит

объявленного окна, которые мы получаем от

удаленного конца, сдвигаются влево на R бит, чтобы

получить реальный размер объявленного окна.

Каждый раз, когда мы отправляем объявление окна

на удаленный конец, мы берем реальный 32-битный

размер окна, сдвигаем его вправо на S бит,

помещаем получившийся результат (16-битное

значение) в TCP заголовок. </small></p>



<p><small>TCP автоматически выбирает значение

сдвигового счетчика, основываясь на размере

приемного буфера. Размер <a NAME="t244002"></a>приемного

буфера устанавливается системой, однако

приложению дается возможность изменить его. (Мы

обсудили приемный буфер в разделе <a HREF="glava20.html#t204000">&quot;Размер окна&quot;</a> главы 20.)</small></p>

<font size="3"><i><b>



<p>Пример</p>

</b></i></font>



<p><small>Если мы инициируем соединение с

использованием программы <a NAME="t244003"></a>sock с хоста <a NAME="t244004"></a>4.4BSD vangogh.cs.berkeley.edu, то можем увидеть, как

TCP рассчитывает коэффициент масштабирования

окна. Приведенный ниже интерактивный вывод

показывает два последовательных запуска

программы, причем в первом случае

устанавливается приемный буфер размером 128000

байт, а во втором приемный буфер установлен в 220000

байт:</small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p><br>

vangogh % <b>sock -v -R128000 bsdi.tuc.noao.edu echo</b><br>

SO_RCVBUF = 128000<br>

connected on 128.32.130.2.4107 to 140.252.13.35.7<br>

TCP_MAXSEG = 512<br>

<b>hello, world </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим

эту строку<br>

hello, world

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; здесь

она отражена эхом<br>

^<b>D </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим

символ конца файла, чтобы закрыть соединение<br>

<br>

vangogh % <b>sock -v -R220000 bsdi.tuc.noao.edu echo</b><br>

SO_RCVBUF = 220000<br>

connected on 128.32.130.2.4108 to 140.252.13.35.7<br>

TCP_MAXSEG = 512<br>

<b>bye, bye </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим

эту строку<br>

bye, bye

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; здесь

она отражена эхом<br>

^<b>D </b>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; вводим

символ конца файла, чтобы закрыть соединение<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>На рисунке 24.7 показан вывод команды tcpdump для

этих двух соединений. (Мы удалили последние 8

строк для второго соединения, потому что в них

нет ничего нового.)<a NAME="t244007"></a></small></p>



<p>&nbsp;</p>

</font><font FACE="Courier New" size="2">



<p><br>

1&nbsp;&nbsp; 0.0

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vangogh.4107

&gt; bsdi.echo: S 462402561:462402561(0) <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win


65535 <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;mss

512,nop,wscale 1,nop,nop,timestamp 995351 0&gt;<br>

2&nbsp;&nbsp; 0.003078 ( 0.0031)&nbsp;&nbsp;&nbsp; bsdi.echo &gt; vangogh.4107: S

177032705:177032705(0) <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack

462402562 win 4096 &lt;mss 512&gt;<br>

3&nbsp;&nbsp; 0.300255 ( 0.2972)&nbsp;&nbsp;&nbsp; vangogh.4107 &gt; bsdi.echo: . ack 1

win 65535<br>

<br>

4&nbsp; 16.920087 (16.6198)&nbsp;&nbsp;&nbsp; vangogh.4107 &gt; bsdi.echo: P 1:14(13) ack

1 win 65535<br>

5&nbsp; 16.923063 ( 0.0030)&nbsp;&nbsp;&nbsp; bsdi.echo &gt; vangogh.4107: P 1:14(13) ack

14 win 4096<br>

6&nbsp; 17.220114 ( 0.2971)&nbsp;&nbsp;&nbsp; vangogh.4107 &gt; bsdi.echo: . ack 14 win

65535<br>

<br>

7&nbsp; 26.640335 ( 9.4202)&nbsp;&nbsp;&nbsp; vangogh.4107 &gt; bsdi.echo: F 14:14(0) ack

14 win 65535<br>

8&nbsp; 26.642688 ( 0.0024)&nbsp;&nbsp;&nbsp; bsdi.echo &gt; vangogh.4107: . ack 15 win

4096<br>

9&nbsp; 26.643964 ( 0.0013)&nbsp;&nbsp;&nbsp; bsdi.echo &gt; vangogh.4107: F 14:14(0) ack

15 win 4096<br>

10&nbsp; 26.880274 ( 0.2363)&nbsp;&nbsp;&nbsp; vangogh.4107 &gt; bsdi.echo: . ack 15 win

65535<br>

<br>

11&nbsp; 44.400239 (17.5200)&nbsp;&nbsp;&nbsp; vangogh.4108 &gt; bsdi.echo: S

468226561:468226561(0) <br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win

65535 <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;mss

512,nop,wscale 2,nop,nop,timestamp 995440 0&gt;<br>

12&nbsp; 44.403358 ( 0.0031)&nbsp;&nbsp;&nbsp; bsdi.echo &gt; vangogh.4108: S

182792705:182792705(0) <br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ack

468226562 win 4096 &lt;mss 512&gt;<br>

13&nbsp; 44.700027 ( 0.2967)&nbsp;&nbsp;&nbsp; vangogh.4108 &gt; bsdi.echo: . ack 1 win

65535<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; все

остальное для этого соединения удалено<br>

</p>

</font><font FACE="Arial">



<p>&nbsp;</p>



<p><small>Рисунок 24.7 Пример опции масштабирования

окна.</small></p>



<p>&nbsp;</p>



<p><small>В строке 1 vangogh объявляет окно размером 65535 и

указывает опцию масштабирования окна со

сдвиговым счетчиком равным 1. Это объявленное

окно имеет максимально возможное значение,

однако оно меньше чем размер приемного буфера

(128000), потому что поле окна в сегменте SYN никогда

не масштабируется. </small></p>



<p><small>Коэффициент масштабирования равный 1

означает, что vangogh хочет объявить окна размером

до 131070 (65535 x 2<sup>1</sup>). Это соотносимо с размером

приемного буфера (128000). Так как bsdi не отправлял

опцию масштабирования окна в своем SYN (строка 2),

эта опция не используется. Обратите внимание на

то, что vangogh и дальше продолжает использовать

максимально возможный размер окна (65535) для

соединения. </small></p>



<p><small>Для второго соединения vangogh устанавливает

сдвиговый счетчик в значение 2, а это означает,

что он собирается отправить объявления окна

размером до 262140 (65535 x 2<sup>2</sup>), то есть больше чем

размер приемного буфера (220000).</small></p>

<font size="3"><u><b>



<p><a NAME="t245000"></a>Опция временной марки</p>

</b></u></font>



<p><small>Опция временной марки (timestamp) позволяет

отправителю поместить значение временной марки

в каждый сегмент. Получатель возвращает это

значение в подтверждении, что позволяет

отправителю рассчитать <a NAME="t245001"></a>RTT при

получении каждого ACK. (Мы должны сказать &quot;

каждый ACK&quot;, а не &quot;каждый сегмент&quot;, так как TCP

обычно подтверждает несколько сегментов с

помощью одного ACK.) Мы сказали, что большинство

современных реализаций рассчитывают одно RTT на

окно, что вполне достаточно, если окно содержит 8

сегментов. Однако в случае, если окно имеет

большие размеры, требуется лучший расчет RTT.</small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0">Раздел 3.1 в RFC 1323

объясняет причины, по которым требуется лучшая

оценка RTT при больших размерах окна. Обычно RTT

измеряется с помощью сигнала данных (сегмент

данных), с небольшой частотой (один раз на окно).

Когда в окне 8 сегментов, скорость сигналов

составляет одну восьмую скорости данных, что

вполне приемлемо, однако когда в окне 100

сегментов, скорость сигналов составляет 1/100 от

скорости данных. При этом RTT может быть

рассчитано некорректно, что, в свою очередь,

может вызвать повторные передачи, в которых нет

необходимости. Если сегмент потерян, все

становится еще хуже.</font></p>

</font>



<p>&nbsp;</p>



<p><small>На рисунке 18.20 показан формат опции

временной марки. Отправитель помещает 32-битное


значение в первое поле, а получатель отражает его

эхом в поле отклика. TCP заголовки, содержащие эту

опцию, увеличиваются с обычных 20 байт до 32-х. </small></p>



<p><small>Временная марка - монотонно

увеличивающееся значение. Так как получатель

отражает то, что он получает, его не интересуют

конкретные значения временных марок. Эта опция

не требует какой-либо формы <a NAME="t245002"></a>синхронизации

часов между двумя хостами. RFC 1323 рекомендует,

чтобы значение временной марки увеличивалось на

единицу в диапазоне от 1 миллисекунды до 1

секунды.</small></p>



<p>&nbsp;</p>

<font size="1">



<p></font><font size="2"><font color="#0000A0"><a NAME="t245003"></a>4.4BSD

увеличивает временную марку каждые 500

миллисекунд, и эта временная марка сбрасывается

в 0 при перезагрузке.</font></p>



<p>&nbsp;</p>



<p><font color="#0000A0">Обратитесь к рисунку 24.7. Разница


временных марок между сегментом 1 и сегментом 11

составляет 89 промежутков размером по 500

миллисекунд. Что составляет 44,4 секунды.</font></p>

</font>



<p>&nbsp;</p>



<p><small>Эта опция устанавливается при открытии

соединения таким же образом, как и опция

масштабирования окна, которую мы рассмотрели в

предыдущем разделе. Сторона, осуществляющая

активное открытие, устанавливает опцию в своем

SYN. Только если опция получена в SYN с удаленного

конца, она может быть установлена в следующих

сегментах. </small></p>



<p><small>Мы видели, что получающий TCP не должен

подтверждать каждый полученный сегмент данных.

Если получатель отправляет ACK, подтверждающий

два принятых сегмента данных, которая из

принятых временных марок отправляются назад в

поле эха отклика на временную марку? </small></p>



<p><small>Чтобы минимизировать количество состояний,

обрабатываемых на каждом конце, только одно

единственное значение временной марки

используется для каждого соединения. Алгоритм,

по которому выбирается момент, когда необходимо

обновить это значение, довольно прост.</small></p>



<p><small>TCP всегда знает значение временной марки,

которое необходимо послать в следующем ACK

(переменная с именем tsrecent), и номер

последовательности подтверждения последнего ACK,

который был отправлен (переменная с именем lastack).

Номер последовательности это следующий номер

последовательности, который ожидает принять

получатель. Когда прибывает сегмент, содержащий

байт, номер которого хранится в lastack, значение

временной марки из этого сегмента сохраняется в

tsrecent. Когда бы ни была отправлена опция временной

марки, tsrecent отправляется в поле эха отклика

временной марки, а поле номера

последовательности сохраняется в lastack. </small></p>



<p>&nbsp;</p>



<p><small>Этот алгоритм обрабатывает два следующих

случая:</small> 



<ol>

  <li><small>Если подтверждения (<a NAME="t245004"></a>ACK)

    задержаны получателем, значение временной марки,

    возвращаемое эхом, будет соответствовать самому

    раннему подтверждаемому сегменту. Например, если

    прибыло два сегмента содержащие байты 1-1024 и

    1025-2048, оба с опцией временной марки, а получатель

    подтверждает их обоих с ACK 2049, временная марка в ACK

    будет иметь значение из первого сегмента,

    содержащего байты 1-1024. Это делается именно так,

    потому что отправитель должен рассчитать свой

    тайм-аут для повторной передачи, с учетом

    задержанных ACK.</small></li>

  <li><small>Если полученный сегмент принят в своем окне,

    но его номер последовательности не

    соответствует ожидаемому, можно сделать

    предположение, что предыдущий сегмент был

    потерян. Однако когда этот отсутствующий сегмент

    получен, именно его временная марка будет

    отражена эхом, а не временная марка сегмента,

    пришедшего &quot;вне очереди&quot;. Например,

    представьте себе три сегмента, каждый из которых

    содержит 1024 байта, они приняты в следующем

    порядке: сегмент 1 с байтами 1-1024, сегмент 3 с

    байтами 2049-3072 и затем сегмент 2 с байтами 1025-2048.

    Будут отправлены следующие подтверждения: ACK 1025 с

    временной маркой из сегмента 1 (обычный ACK для

    ожидаемых данных), ACK 1025 с временной маркой из

    сегмента 1 (дублированный ACK в ответ на сегмент,

    пришедший &quot;в окне&quot;, но &quot;вне

    последовательности&quot;) и затем ACK 3073 с временной

    маркой из сегмента 2 (но не с последней временной

    маркой из сегмента 3). В подобных случаях RTT может

    быть оценен несколько раз, что все же лучше чем

    неверная оценка RTT. Также, если последний ACK

    содержит временную марку из сегмента 3, он может

    включать в себя время, необходимое для возврата

    дублированного ACK и повторной передачи сегмента

    2, или он может включать в себя время, выделенное

    отправителем на тайм-аут повторной передачи для

    сегмента 2. В обоих случаях отражение эхом


    временной марки из сегмента 3 может повлиять на

    расчет RTT отправителем. </small></li>

</ol>



<p><small>Помимо того, что опция временной марки

позволяет лучше рассчитывать RTT, она также

предоставляет получателю способ избежать

получения старых сегментов и воспринятия их как

части существующих сегментов данных. Это

описывается в следующем разделе.</small></p>

<font size="3"><u><b>



<p><a NAME="t246000"></a>PAWS: защита от перехода номеров

последовательности через ноль</p>

</b></u></font>



<p><small>Представим TCP соединение, использующее

опцию масштабирования окна, с максимально

возможным окном, 1 гигабайт (2<sup>30</sup>). (Самое

большое окно даже меньше чем это, 65535 x 2<sup>14</sup>, а

не 2<sup>16</sup> x 2<sup>14</sup>, однако это не должно влиять

на наши рассуждения.) Также представьте, что

используется опция временной марки, и что

значение временной марки, назначенное

отправителем, увеличивается на единицу для

каждого отправляемого окна. (Это достаточно

устаревший способ. Обычно значение временной

марки увеличивается значительно быстрее.) На

рисунке 24.8 показан поток данных между двумя

хостами, возникающий при передаче 6 гигабайт.

Чтобы избежать большого количества

десятизначных цифр, мы используем запись G, что

означает умножение на 1.073.741.824. Мы также

используем форму записи из <a NAME="t246001"></a>tcpdump, где

J:K означает байты от J до K-1, включая байт K-1.<a NAME="t246002"></a></small></p>



<p>&nbsp;</p>

</font>



<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="9" WIDTH="886">

  <tr>

    <td WIDTH="11%" VALIGN="MIDDLE"><p ALIGN="CENTER"><small><font FACE="Arial">Время</font></small></td>

    <td WIDTH="17%" VALIGN="MIDDLE"><font FACE="Arial"><p ALIGN="CENTER"><small>Отправленные

    байты</small></font></td>

    <td WIDTH="17%" VALIGN="MIDDLE"><font FACE="Arial"><p ALIGN="CENTER"><small>Отправленный

    номер последова-тельности</small></font></td>

    <td WIDTH="15%" VALIGN="MIDDLE"><font FACE="Arial"><p ALIGN="CENTER"><small>Отправлен-ная

    временная марка</small></font></td>

    <td WIDTH="40%" VALIGN="MIDDLE"><font FACE="Arial"><p ALIGN="CENTER"><small>Получение</small></font></td>

  </tr>

  <tr>

    <td WIDTH="11%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>A</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>0G:1G</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>0G:1G</small></font></td>

    <td WIDTH="15%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>1</small></font></td>

    <td WIDTH="40%" VALIGN="TOP"><font FACE="Arial"><small>принято нормально</small></font></td>

  </tr>

  <tr>

    <td WIDTH="11%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>B</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>1G:2G</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>1G:2G</small></font></td>

    <td WIDTH="15%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>2</small></font></td>

    <td WIDTH="40%" VALIGN="TOP"><font FACE="Arial"><small>принято нормально,

    но один сегмент потерян и передан повторно</small></font></td>

  </tr>

  <tr>

    <td WIDTH="11%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>C</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>2G:3G</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>2G:3G</small></font></td>

    <td WIDTH="15%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>3</small></font></td>

    <td WIDTH="40%" VALIGN="TOP"><font FACE="Arial"><small>принято нормально</small></font></td>

  </tr>

  <tr>

    <td WIDTH="11%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>D</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>3G:4G</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>3G:4G</small></font></td>

    <td WIDTH="15%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>4</small></font></td>

    <td WIDTH="40%" VALIGN="TOP"><font FACE="Arial"><small>принято нормально</small></font></td>

  </tr>


  <tr>

    <td WIDTH="11%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>E</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>4G:5G</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>0G:1G</small></font></td>

    <td WIDTH="15%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>5</small></font></td>

    <td WIDTH="40%" VALIGN="TOP"><font FACE="Arial"><small>принято нормально</small></font></td>

  </tr>

  <tr>

    <td WIDTH="11%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>F</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>5G:6G</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>1G:2G</small></font></td>

    <td WIDTH="15%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>6</small></font></td>

    <td WIDTH="40%" VALIGN="TOP"><font FACE="Arial"><small>принято нормально,

    но повторно переданный сегмент появился в сети

    повторно</small></font></td>

  </tr>

</table>

<font FACE="Arial">



<p><small>Рисунок 24.8 Передача 6 гигабайт в шести

1-гигабайтных окнах.</small></p>



<p>&nbsp;</p>



<p><small>32-битный номер последовательности перешел

через ноль между моментами времени D и E. Мы

предположили, что один сегмент потерялся в

момент времени B и был передан повторно. Также мы

предположили, что потерянный сегмент повторно

появился в сети в момент времени F. </small></p>



<p><small>Разница во времени между моментами, когда

сегмент был потерян и появился повторно, меньше

чем <a NAME="t246003"></a>MSL; иначе сегмент должен быть

отброшен каким-либо маршрутизатором по

истечению его <a NAME="t246004"></a>TTL. Как мы упоминали

ранее, такая проблема возникает только на

высокоскоростных соединениях, где старые

сегменты могут повторно появиться и содержать

номер последовательности, который в настоящее

время передается. </small></p>



<p><small>Также мы можем видеть из рисунка 24.8, что

использование временной марки решает эту

проблему. Получатель рассматривает временную

марку как 32-битное расширение к номеру

последовательности. Так как потерянный сегмент,

повторно появившийся в момент времени F, имел

временную марку равную 2, что меньше чем самая

последняя приемлемая временная марка (5 или 6), он

отбрасывается алгоритмом PAWS. </small></p>



<p><small>Алгоритм PAWS не требует какой-либо формы

синхронизации времени между отправителем и

получателем. Все что необходимо получателю это

то, чтобы значение временной марки монотонно

увеличивалось и увеличивалось по крайней мере на

единицу для каждого нового окна.</small></p>

<font size="3"><u><b>



<p><a NAME="t247000"></a>T/TCP: расширение TCP для транзакций</p>

</b></u></font>



<p><small>TCP предоставляет транспортный <a NAME="t247001"></a>сервис

виртуальных каналов (virtual-circuit). Существуют три

определенные фазы в жизни соединения:

установление соединения, передача данных и

разрыв соединения. Приложения, осуществляющие

удаленный терминальный доступ и передачу файлов,

хорошо приспособлены для работы с сервисом

виртуальных каналов. </small></p>



<p><small>Помимо этого существуют приложения,

разработанные для использования сервиса

транзакций. <a NAME="t247002"></a>Транзакция это запрос от

клиента, за которым следует отклик от сервера, со

следующими характеристиками: </small></p>



<p><small>Необходимо избежать лишних действий при

установлении и разрыве соединения. Когда это

возможно, необходимо отправлять один пакет с

запросом и получать один пакет с <a NAME="t247003"></a>откликом.

Латенсия должна быть уменьшена до RTT плюс SPT, где

RTT это время возврата, а SPT это время необходимое

серверу для обработки запроса. Сервер должен

определять дублированные запросы и не повторять

транзакцию, когда прибывает дублированный

запрос. (Другими словами, сервер не обрабатывает

запрос снова. Он должен послать назад

сохраненный отклик, соответствующий запросу.) </small></p>



<p><small>Одно из рассмотренных нами приложение,

использующее этот тип сервиса - система имен

доменов (DNS, <a HREF="glava14.html">глава 14</a>). Надо отметить,

что DNS сервер не осуществляет повторную

обработку дублированных запросов. </small></p>



<p><small>В настоящее время разработчики приложений

имеют выбор: TCP или UDP. TCP предоставляет слишком

много характеристик для транзакций, а UDP - слишком

мало. Обычно приложения строятся с

использованием UDP (чтобы избежать

перегруженности характеристиками свойственной

TCP соединениям), при этом большинство требуемых

характеристик (динамические тайм-ауты и

повторные передачи, избежание переполнения и так

далее) помещаются внутрь приложений, и для

каждого приложения их приходится делать заново. </small></p>



<p><small>Оптимальное решение - это транспортный

уровень, который включает в себя эффективную

обработку транзакций. Протокол транзакций,

который мы описываем в этом разделе, называется

T/TCP. Протокол определен в RFC 1379 [<a NAME="t247004"></a>Braden

1992b] и [Braden 1992c]. </small></p>



<p><small>Для большинства TCP реализаций требуются 7

сегментов, чтобы открыть и закрыть соединение

(см. рисунок 18.13). Здесь добавляются еще три

сегмента: один с запросом, другой с откликом и

подтверждением на запрос и третий с

подтверждением на отклик. Если в сегменты

добавлены дополнительные управляющие биты - а

именно, первый сегмент содержит SYN, запрос

клиента, и FIN - клиенту все кажется, что имеют

место лишние действия, которые выражается в виде

удвоенного значения RTT плюс SPT. (Отправка SYN вместе

с данными и FIN разрешена; сможет ли TCP обработать

подобную ситуацию корректно - это уже другой

вопрос.) </small></p>



<p><small>Еще одна проблема с TCP это состояние <a NAME="t247005"></a>TIME_WAIT, которое требует ожидания в

течение <a NAME="t247006"></a>2MSL. Как показано в <a HREF="glava18.html#t18C001">упражнении 14</a> главы 18, это

ограничивает скорость транзакций между двумя

хостами на величине примерно 268 в секунду. </small></p>



<p><small>Две модификации, необходимые для TCP, чтобы

обрабатывать транзакции, заключаются в том,

чтобы избежать <a NAME="t247007"></a>трехразового

рукопожатия и сократить состояние TIME_WAIT. T/TCP

избегает трехразового рукопожатия с

использованием ускоренного открытия:</small></p>



<p><small>T/TCP назначает каждому соединению номер в

соответствии с 32-битным счетчиком соединений (CC -

connection count), вне зависимости от того,

осуществляется ли активное или пассивное

открытие. Значение CC хоста назначается из общего

счетчика, который увеличивается на единицу при

каждом его использовании. Каждый сегмент между

двумя хостами, использующими T/TCP, включает новую

TCP опцию, которая называется CC. Эта опция имеет

длину 6 байт и содержит 32-битное значение CC

отправителя для соединения. Хост имеет кэш для

каждого хоста, с которым был осуществлен обмен. В

кэше содержится значение CC из последнего

полученного от этого хоста сегмента SYN. Когда

опция CC получена в исходном SYN, получатель

сравнивает значение с сохраненным значением для

этого отправителя. Если полученное CC больше чем

кэшированное CC, SYN новый, и любые данные,

находящиеся в сегменте, передаются принимающему

приложению (серверу). Соединение называется

наполовину синхронизированным. Если полученное

CC не больше чем кэшированное CC, или если

принимающий хост не имеет кэшированного CC для

этого клиента, осуществляется стандартное

трехразовое рукопожатие TCP. SYN, <a NAME="t247008"></a>ACK

сегмент в отклике на первоначальный SYN, отражает

эхом полученное значение CC в другой новой опции,

которая называется CC эхо или CCECHO. С помощью

значения CC в сегментах, не содержащих SYN,

определяются и отбрасываются любые

дублированные сегменты от предыдущих воплощений

того же самого соединения. </small></p>



<p><small>Благодаря ускоренному открытию отпадает

необходимость в трехразовом рукопожатии, за

исключением того случая когда оба, и клиент, и

сервер, вышли из строя и перезагрузились. Однако

мы платим за это тем, что сервер должен помнить

последний полученный CC от каждого клиента. </small></p>



<p><small>Состояние TIME_WAIT становится короче, потому

что расчет задержки TIME_WAIT осуществляется

динамически, на основании измеренного RTT между


двумя хостами. Задержка TIME_WAIT устанавливается в <a NAME="t247009"></a>RTO умноженное на 8 (RTO - значение

тайм-аута повторной передачи, глава 21, раздел <a HREF="glava21.html#t213000">&quot;Определение времени

возврата&quot;</a>). </small></p>



<p><small>С использованием этих характеристик,

минимальная последовательность транзакций

заключается в обмене тремя сегментами:</small></p>



<p><small>От клиента к серверу, осуществляется при

активном открытии: SYN-клиента, данные от клиента

(запрос), FIN-клиента и CC-клиента. TCP сервер,

осуществляющий пассивное открытие, получает эти

сегменты и если CC-клиента больше чем

кэшированный CC для этого клиента, данные клиента

передаются приложению сервера, которое

обрабатывает запрос. От сервера к клиенту:

SYN-сервера, данные сервера (отклик), FIN-сервера,

подтверждение на FIN-клиента, CC-сервера и CCECHO на

CC-клиента. Так как подтверждения TCP - обобщающие,

ACK на FIN-клиента подтверждает SYN-клиента, данные и


FIN. Когда TCP клиент получает этот сегмент, он

передает отклик приложению клиента. От клиента к

серверу: ACK на FIN-сервера, который подтверждает

SYN-сервера, данные и FIN.</small></p>



<p><small>Время отклика клиента на его запрос

составляет RTT плюс SPT. </small></p>



<p><small>В реализации этой TCP опции существует

множество особенностей, которые мы кратко

рассмотрим:</small> 



<ul>

  <li><small>ACK на SYN сервера (второй сегмент) должен быть

    задержан, чтобы позволить отклику передаваться

    вместе с ним. (Обычно ACK на SYN не задерживается.) Он

    не может быть задержан надолго, иначе клиент

    отработает тайм-аут и осуществит повторную

    передачу. </small></li>

  <li><small>Запрос может состоять из нескольких

    сегментов, однако сервер должен предусмотреть

    вариант, когда данные приходят в беспорядке.

    (Обычно, когда данные прибывают перед SYN, они

    отбрасываются и генерируется сброс. В случае T/TCP

    данные, прибывшие в беспорядке, должны быть

    поставлены в очередь.) </small></li>

  <li><small>API должен позволять процессу сервера

    отправлять данные и закрывать соединение с

    помощью одной операции, что позволит FIN во втором

    сегменте передаваться вместе с откликом. (Обычно

    приложение отправляет отклик, что вызывает

    отправку сегменту данных, а затем закрывает

    соединение, отправляя FIN.) </small></li>

  <li><small>Клиент отправляет данные в первом сегменте

    перед получением объявления <a NAME="t247010"></a>MSS от

    сервера. Чтобы не ограничивать клиента значением

    MSS равным 536, MSS для данного хоста должно быть

    кэшировано вместе с его значением CC. </small></li>

  <li><small>Клиент отправляет данные серверу без

    получения объявления окна от сервера. T/TCP

    предоставляет окно по умолчанию равное 4096

    байтам, а также кэширует порог переполнения для

    сервера. </small></li>

  <li><small>В случае минимального обмена тремя

    сегментами может быть измерен только один RTT для

    каждого направления. RTT, измеренный клиентом,

    включает время, необходимое серверу для

    обработки запроса. Это означает, что

    хэшированное значение RTT и его отклонение также

    должны быть кэшированы для сервера; это

    напоминает то, что мы описали в разделе <a HREF="glava21.html#t219000">&quot;Показатели на маршрут&quot;</a>

    главы 21.</small></li>

</ul>



<p><small>Одна из основных особенностей T/TCP

заключается в том, что для его реализации

требуется минимальный набор изменений к

существующему протоколу, что, в свою очередь,

обеспечивает совместимость с более ранними

версиями существующих реализаций. Он также

использует все преимущества существующих

характеристик TCP (динамические тайм-ауты и

повторные передачи, предотвращение переполнения

и так далее), вместо того чтобы заставлять

приложения заботиться об этом. </small></p>



<p><small>Альтернативный протокол транзакций - VMTP,

Versatile Message Transaction Protocol. Он описан в RFC 1045 [<a NAME="t247011"></a>Cheriton

1988]. В отличие от T/TCP, который вносит небольшое

количество расширений в существующий протокол,

VMTP это транспортный уровень в целом, который

использует IP. VMTP занимается определением ошибок,

повторными передачами и предотвращением

дублирования. Он также поддерживает групповые

способы рассылки.</small></p>

<font size="3"><u><b>



<p><a NAME="t248000"></a>Производительность TCP</p>

</b></u></font>



<p><small>Цифры, которые публиковались в середине 80-х

годов, показывали пропускную способность TCP по

Ethernet где-то в районе 100000-200000 байт в секунду. (В

разделе 17.5 [Stevens 1990] приводятся эти цифры.) С того

времени многое изменилось. Современное

аппаратное обеспечение (рабочие станции и

быстрые персональные компьютеры) обеспечивает

передачу 800000 байт в секунду и больше. </small></p>



<p><small>Стоит наверное рассчитать максимальную

теоретически возможную пропускную способность,

которую мы можем получить с TCP на Ethernet 10 Мбит/сек [<a NAME="t248001"></a>Warnock 1991]. На рисунке 24.9 показаны данные,

необходимые для подобного расчета. На этом

рисунке показано полное количество байт,

необходимое при обмене сегментами данных

полного размера, и ACK.<a NAME="t248002"></a></small></p>



<p>&nbsp;</p>

</font>



<table BORDER="1" CELLSPACING="1" BORDERCOLOR="#000000" CELLPADDING="5" WIDTH="732">

  <tr>

    <td WIDTH="60%" VALIGN="TOP" BGCOLOR="#ffffff"><p ALIGN="CENTER"><small><font FACE="Arial">Поле</font></small></td>

    <td WIDTH="17%" VALIGN="TOP" BGCOLOR="#ffffff"><font FACE="Arial"><p ALIGN="CENTER"><small>Количество

    байт данных</small></font></td>

    <td WIDTH="23%" VALIGN="TOP" BGCOLOR="#ffffff"><font FACE="Arial"><p ALIGN="CENTER"><small>Количество

    байт подтверждения</small></font></td>

  </tr>

  <tr>

    <td WIDTH="60%" VALIGN="TOP"><font FACE="Arial"><small>преамбула Ethernet</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>8</small></font></td>

    <td WIDTH="23%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>8</small></font></td>

  </tr>

  <tr>

    <td WIDTH="60%" VALIGN="TOP"><font FACE="Arial"><small>адрес назначения

    Ethernet</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>6</small></font></td>

    <td WIDTH="23%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>6</small></font></td>

  </tr>

  <tr>

    <td WIDTH="60%" VALIGN="TOP"><font FACE="Arial"><small>адрес источника

    Ethernet</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>6</small></font></td>

    <td WIDTH="23%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>6</small></font></td>

  </tr>

  <tr>

    <td WIDTH="60%" VALIGN="TOP"><font FACE="Arial"><small>поле типа Ethernet</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>2</small></font></td>

    <td WIDTH="23%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>2</small></font></td>

  </tr>

  <tr>

    <td WIDTH="60%" VALIGN="TOP"><font FACE="Arial"><small>заголовок IP</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>20</small></font></td>

    <td WIDTH="23%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>20</small></font></td>

  </tr>

  <tr>

    <td WIDTH="60%" VALIGN="TOP"><font FACE="Arial"><small>заголовок TCP</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>20</small></font></td>

    <td WIDTH="23%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>20</small></font></td>

  </tr>

  <tr>

    <td WIDTH="60%" VALIGN="TOP"><font FACE="Arial"><small>пользовательские

    данные</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>1460</small></font></td>

    <td WIDTH="23%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>0</small></font></td>

  </tr>

  <tr>

    <td WIDTH="60%" VALIGN="TOP"><font FACE="Arial"><small>заполнение (до

    минимального размера Ethernet)</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>0</small></font></td>

    <td WIDTH="23%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>6</small></font></td>

  </tr>

  <tr>

    <td WIDTH="60%" VALIGN="TOP"><font FACE="Arial"><small>контрольная сумма

    Ethernet </small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>4</small></font></td>

    <td WIDTH="23%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>4</small></font></td>

  </tr>

  <tr>

    <td WIDTH="60%" VALIGN="TOP"><font FACE="Arial"><small>промежуток между

    пакетами (9,6 микросекунды)</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>12</small></font></td>

    <td WIDTH="23%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>12</small></font></td>

  </tr>

  <tr>

    <td WIDTH="60%" VALIGN="TOP"><font FACE="Arial"><small>всего</small></font></td>

    <td WIDTH="17%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>1538</small></font></td>

    <td WIDTH="23%" VALIGN="TOP"><font FACE="Arial"><p ALIGN="CENTER"><small>84</small></font></td>

  </tr>

</table>

<font FACE="Arial">



<p><small>Рисунок 24.9 Размеры полей для Ethernet при

расчете максимальной теоретически возможной

пропускной способности.</small></p>



<p>&nbsp;</p>



<p><small>Мы должны сделать расчет для всех

составляющих: преамбула, байты заполнения,

которые добавляются к подтверждению, <a NAME="t248003"></a>контрольная

сумма, и минимальный промежуток между пакетами

(9,6 микросекунды, что равно 12 байтам при скорости

10 Мбит/сек). </small></p>



<p><small>Во-первых, мы предположим, что отправитель

передает два полноразмерных сегмента данных,

после чего получатель отправляет ACK на эти два

сегмента. Максимальная пропускная (throughput)

способность (для пользовательских данных) будет

равна </small></p>




<p>&nbsp;</p>



<p><small>throughput = [(2 x 1460 байт)/(2 x 1538 + 84 байта)] x [(10.000.000

бит/сек)/(8 бит/байт)] = 1.155.063 байт/сек</small></p>



<p>&nbsp;</p>



<p><small>Если окно TCP открыто на его максимальный

размер (65535, опция масштабирования окна не

используется), это позволяет отправить окно

размером в 44 сегмента, каждый из которых размером

1460 байт. Если получатель отправляет ACK на каждый

22-й сегмент, расчет будет следующим</small></p>



<p>&nbsp;</p>



<p><small>throughput = [(22 x 1460 байт)/(22 x 1538 + 84 байта)] x [(10.000.000

бит/сек)/(8 бит/байт)] = 1.183.667 байт/сек</small></p>



<p>&nbsp;</p>




<p><small>Это теоретический предел, при расчете

которого сделаны некоторые допущения: не

произойдет коллизии (столкновения) между ACK,

отправленным получателем, и одним из сегментов

отправителя; отправитель может передать два

сегмента с минимальным промежутком Ethernet; и

получатель может сгенерировать ACK внутри

минимального промежутка Ethernet. Несмотря на

оптимизм, который так и пышет из этих цифр, [<a NAME="t248004"></a>Warnock 1991] приводит измеренную скорость

равную 1.075.000 байт/сек по Ethernet, со стандартной

многопользовательской рабочей станцией (быстрая

рабочая станция), что составляет примерно 90% от

теоретического значения. </small></p>



<p><small>Что касается более быстрых сетей, таких как <a NAME="t248005"></a>FDDI (100 Мбит/сек), [<a NAME="t248006"></a>Schryver 1993]

рассказывает, что три поставщика

демонстрировали TCP поверх FDDI со скоростью в

диапазоне от 80 до 98 Мбит/сек. В случае, когда

доступна большая ширина полосы пропускания, [<a NAME="t248007"></a>Borman 1992] сообщает, что было получено до

781 Мбит/сек между двумя компьютерами Cray Y-MP по

каналу <a NAME="t248008"></a>HIPPI 800 Мбит/сек, и 907 Мбит/сек

между двумя процессами с использованием <a NAME="t248009"></a>loopback интерфейса на компьютере Cray Y-MP. </small></p>



<p><small>Следующие практические ограничения

применимы для всех реальных сценариев [Borman 1991].</small>



<ol>

  <li><small>Вы не можете запустить что-либо быстрее, чем

    скорость самого медленного канала.</small></li>

  <li><small>Вы не можете двигаться быстрее, чем ширина

    пропускания памяти в самой медленной машине.

    Здесь подразумевается, что ваша реализация

    обрабатывает данные за один раз. Если нет (то

    есть, ваша реализация делает один шаг, чтобы

    скопировать их из пространства пользователя в

    ядро, затем еще один, чтобы рассчитать TCP

    контрольную сумму), у вас все будет работать еще

    медленнее. [<a NAME="t248010"></a>Dalton et al. 1993] описывает

    способы улучшения производительности

    стандартной Berkeley реализации, когда количество

    шагов было уменьшено до одного копирования. <a NAME="t248011"></a>[Partridge and Pink 1993] применяет то же

    улучшение <a NAME="t248012"></a>&quot;копирование и

    контрольная сумма&quot; для UDP, вместе с улучшением

    производительности, что повышает

    производительность UDP примерно на 30%.</small></li>

  <li><small>Вы не можете двигаться быстрее, чем размер

    окна, предложенный получателем, поделенный на

    время возврата. (<a NAME="t248013"></a>Это наше уравнение

    емкости канала, где размер окна используется как

    емкость канала и используется для расчета ширины

    полосы.) Если мы используем максимальный

    коэффициент масштабирования окна равный 14 из

    раздела <a HREF="#t244000">&quot;Опция масштабирования

    окна&quot;</a>, то получим размер окна равный 1,073

    Гбайта; эта величина, поделенная на RTT, будет

    являться пределом ширины полосы пропускания.</small></li>

</ol>



<p><small>Смысл всех приведенных выше цифр

заключается в том, что реальный верхний предел

того, насколько быстро может работать TCP,

определяется размером TCP окна и скоростью света.

В заключение, можно, ссылаясь на <a NAME="t248014"></a>[Partridge

and Pink 1993], заявить, что большинство проблем с

производительностью протокола заключается в

основном в реализациях, а не во внутренних или

наследуемых ограничениях самого протокола.</small></p>

<font size="3"><u><b>



<p><a NAME="t249000"></a>Краткие выводы</p>

</b></u></font>



<p><small>В этой главе рассмотрено пять новых

характеристик TCP: определение транспортного MTU,

опция масштабирования окна, опция временной

марки, защита от перехода через 0 номера

последовательности и улучшенная обработка

транзакций с использованием TCP. Мы видели, что три

средние опции требуются для оптимальной

производительности в каналах с повышенной

пропускной способностью - в сетях с большой

емкостью. </small></p>



<p><small>Определение транспортного MTU позволяет TCP

использовать окна больше, чем окно по умолчанию

равное 536, для нелокальных соединений, когда

транспортный MTU больше. Это может улучшить

производительность. </small></p>



<p><small>Опция масштабирования окна воспринимает

максимальный размер TCP окна от 65535 байт до сверх 1

гигабайта. Опция временной марки позволяет

аккуратно засечь время для нескольких сегментов

и также позволяет получателю предоставить

защиту против перехода номера

последовательности через 0 (PAWS). Это очень важно

для высокоскоростных соединений. Эти новые опции

TCP обсуждаются хостами при установлении

соединения и игнорируются более старыми

системами, которые не понимают их, позволяя более

новым системам нормально функционировать с

более старыми системами. </small></p>



<p><small>Расширение TCP для транзакций, T/TCP, позволяет

ограничить общение клиент-сервер запрос-отклик

всего тремя сегментами. Это позволяет избежать

трехразового рукопожатия и уменьшить

продолжительность состояния <a NAME="t249001"></a>TIME_WAIT с

помощью кэширования небольшого количества

информации для каждого хоста, с которым

установлено соединение. При этом флаги SYN и FIN

передаются в сегментах данных. </small></p>



<p><small>Мы завершили главу рассмотрением

производительности TCP, так как до сих пор

существует огромное количество &quot;фольклора&quot;,

который далек от истины, о том, как может и

насколько быстро должен работать TCP. Для хорошо

настроенных и отлаженных реализаций, которые

используют более новые характеристики,

описанные в этой главе, производительность TCP

ограничивается только максимальным окном

размером в 1 гигабайт и скоростью света (то есть,

временем возврата).</small></p>

<font size="3"><i><b>



<p>Упражнения</b></i></font><font size="1"> 



<ol>

  <li></font><font size="2">Что означает, если система

    отправляет первоначальный сегмент SYN с

    коэффициентом масштабирования окна равным 0?</li>

  <li>Если хост bsdi на рисунке 24.7 поддерживает опцию

    масштабирования окна, какое ожидаемое значение

    16-битного поля размера окна в TCP заголовке от

    хоста vangogh в сегменте 3? Точно так же, если опция

    используется на втором соединении на этом

    рисунке, какое будет объявленное окно в сегменте

    13?</li>

  <li>Вместо фиксированного коэффициента

    масштабирования окна, который используется при

    установлении соединения, может ли опция

    масштабирования окна быть определена, а затем

    изменен коэффициент масштабирования?</li>

  <li>При какой скорости передачи данных переход

    через 0 номера последовательности станет

    реальной проблемой, в том случае, если <a NAME="t249002"></a>MSL

    равно 2 минутам?</li>

  <li>PAWS разработан для того, чтобы работать только с

    одним соединением. Какие модификации должны быть

    сделаны для TCP, чтобы использовать PAWS как замену

    для ожидания <a NAME="t249003"></a>2MSL (состояние TIME_WAIT)?</li>

  <li>В примере в конце раздела <a HREF="#t244000">&quot;Опция

    масштабирования окна&quot;</a>, почему программа <a NAME="t249004"></a>sock выдала размер <a NAME="t249005"></a>приемного

    буфера перед следующей строкой (с IP адресами и

    номерами портов)?</li>


  <li>Повторите расчет пропускной способности из

    раздела <a HREF="#t248000">&quot;Производительность TCP&quot;</a>,

    представив себе, что <a NAME="t249006"></a>MSS равно 1024.</li>

  <li>Как опция временной марки влияет на <a NAME="t249007"></a>алгоритм

    Карна (глава 21, раздел <a HREF="glava21.html#t213000">&quot;Определение

    времени возврата&quot;</a>)?</li>

  <li>Если TCP отправляет данные с сегментом SYN, который

    сгенерирован при активном открытии (без

    использования расширений, которые мы описали в

    разделе <a HREF="#t247000">&quot;T/TCP: расширение TCP для

    транзакций&quot;</a>), что получающий TCP будет делать

    с данными?</li>

  <li>В разделе <a HREF="#t247000">&quot;T/TCP: расширение TCP для

    транзакций&quot;</a> мы сказали, что без расширения

    T/TCP, даже если активное открытие посылается с

    данными и FIN, задержка для клиента при получении

    отклика от сервера будет все еще удвоенное RTT

    плюс SPT. Покажите сегменты, с помощью которых это

    можно рассчитать.</li>

  <li>Сделайте повторно <a HREF="glava18.html#t18C001">упражнение 14</a>

    главы 18, представив себе, что поддерживается

    расширение T/TCP и что минимальное <a NAME="t249008"></a>RTO,

    поддерживаемое Berkeley системами, равно половине

    секунды.</li>

  <li>Если мы применили T/TCP и рассчитали время

    транзакции между двумя хостами, с чем мы можем

    это сравнить, чтобы определить его

    эффективность?</font><font size="1"></li>

</ol>

</font></font>



<p><small><a HREF="index.html"><img SRC="contents.jpg" BORDER="0" WIDTH="94" HEIGHT="20"></a><a HREF="../home.htm"><img SRC="begin.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava25.html"><img SRC="forward.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a HREF="glava23.html"><img SRC="back_b.jpg" BORDER="0" WIDTH="68" HEIGHT="20"></a><a href="index.html"><img SRC="index.jpg" border="0" WIDTH="68" HEIGHT="20"></a></small></p>

<font size="1">



<p>&nbsp;</p>

</font>
</div>
</body>

</html>

